<!DOCTYPE html>
<html>

<head>
	<title>LuaJIT</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="stylesheet" href="../../css/global.css">
</head>

<body>
	
<header>
  <a href="../../index.html"><img src="../../img/logo.png" width="55"></a><br>ChronCache	
</header>
	
<nav>
	<hr>
  <p><a href="../../blog.html">архив</a> <tt>|</tt> <a href="../../help.html">помощь</a> <tt>|</tt> <a href="/1Q9LVNLD1ghusGxpiwjYnVjPsxD5xGTGc7/donate/index.html">донат</a></p>
	<hr>
</nav>

<article>
	
<acide><p>Это резервная страница от 09.04.2019 <tt>(17.12.2020)</tt> / <a href="/1BLoGBTid3NhGu8ts3fAfHJprnbrH3wfTV/?Post:44">оригинал</a></p></acide>

<section>
	<h1>LuaJIT</h1>
	<p><b>LuaJIT</b> написан гением. Mike Pall практически на коленке реализовал трассирующий JIT-компилятор, который в тестах производительности либо рвёт, либо идёт ноздря в ноздрю с продуктом крутой гигантской корпорации — <b>V8</b>. Я думаю, сравнивать реализации JS и Lua вполне уместно, поскольку оба имеют очень похожую систему типов, набор фич и область применения. JIT-компилятор при генерации кода у обоих языков решает примерно одни и те же задачи.</p>
	<p>В отдельных случаях скорость исполнения кода в LuaJIT приближается к скорости кода на Си, скомпилированного без оптимизаций. Под «приближается» я имею в виду: отстаёт всего в несколько раз, а не на два порядка, как это обычно. И это динамически типизированный скриптовый язык.</p>
	<p>Никакие Перлы, Руби, Питоны и PHP и близко не лежали. Питоновский <b>pypy</b> умеет только жрать память и тормозить после стольких человеко-лет разработки. Про ванильный <b>python</b> в разговоре о производительности вспоминать вообще неприлично.</p>
	<p>Только одна вещь меня расстраивает в LuaJIT — это Lua. Почти всё можно простить языку, но адресация массивов с единицы — такого прощать нельзя.</p>
	<p>Очень хочется взять сорцы LuaJIT и перепилить их под компиляцию JavaScript. Можно будет встраивать этот интерпретатор JS даже в утюги, и такой утюг будет летать. Это будет бомба, котаны!</p>
	<p>Не знаю, доберусь когда-нибудь ли я до этого, но руки чешутся очень. Напишите в комментариях, если у вас тоже. Может быть, совместно что-то выгорит.</p>
</section>	
	
<hr><p>Комментарии:</p>
	
<section class="com">
	<div>
		<p><b>balancer73:</b> <tt>(Oct 13, 2018)</tt><br><em>Никакие Перлы, Руби, Питоны и PHP и близко не лежали</em><br>Ну, если сравнивать на работе с объектами, то с Си++ без оптимизаций имеет такие же результаты PyPy. Всего вдвое хуже себя показывает HHVM. PHP7 и JRuby хуже в 5 раз, но это всё равно не на два порядка :)<br><u>https://github.com/Balancer/benchmarks-fib-obj/wiki/Результат-теста:-i3-2.2ГГц</u><br><em>Почти всё можно простить языку, но адресация массивов с единицы — такого прощать нельзя.</em><br>А это мне как раз почти всегда без разницы :D<br><em>Напишите в комментариях, если у вас тоже. Может быть, совместно что-то выгорит.</em><br>Я старый фортер. И у меня в планах только очередной Форт под Arduino :)</p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(Oct 13, 2018)</tt><br><em><b>balancer73:</b> https://github.com/Balancer/benchmarks...</em><br>Ооо! Вещь! :)</p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(Oct 13, 2018)</tt><br><em><b>balancer73:</b> Большинство синтетических тестов различных языков, их реализаций и сред исполнения ориентируются на «числодробительные» возможности. В то время, как сегодня, при программировании широкого спектра задач, чаще требуется высокая скорость работы с объектами и быстрое выделение и освобождение памяти.</em><br>Интересный подход. Я гонял тесты как раз числодробилок + вызов-возврат из функций. Поскольку трассировщик LuaJIT работает через границы функций (насколько я это понимаю), ему такой код оптимизировать плёвое дело.</p>
		<p>Надо будет с объектами поэкспериментировать.</p>
	</div>
	<div>
		<p><b>balancer73:</b> <tt>(Oct 13, 2018)</tt><br><em><b>geekless:</b> Ооо! Вещь! :)</em><br>Только у левого уха с корнем вылетел винт с креплением. Так, что крышку невозможно нормально открыть/закрыть. Долго валялся без дела, весной узнал рецепт заклейки суперклеем (цианоакрилатным) с содой, залил это ухо. Немного держалось, хотел уже дочке выделить для учёбы, но сейчас снова стало трещать и отходить :) И разъём питания страшно разболтался. Просто заряжать аккумулятор или просто работать хватает, а вот если работать и заряжать — раскаляется так, что пальцы обжигает. Ну и HDD начал бедблоками сыпаться, но там всё равно основная работа с SSD. В остальном — всё ок :)</p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(Oct 13, 2018)</tt><br><em><b>balancer73:</b></em><br>У моего на рамке идет сквозная трещина от левой петли вверх до экрана. Сама петля тоже не в порядке, люфтит. Всё жду, когда развалится, но пока тьфу-тьфу... USB-порты и разъем питания разболтались, но пока держатся. Буквально на днях сдохла ЛКМ тачпада, вот это самое обидное.</p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(Oct 13, 2018)</tt><br><em><b>balancer73:</b></em><br>Про два порядка я прогнал.</p>
		<p>Посмотрел старые результаты для числодробилки.<br><code>gcc -O0</code> vs <code>luajit</code> — разница менее чем в 2 раза.<br><code>gcc -O0</code> vs <code>pypy</code> — разница в 5-10 раз. Но памяти на простых программах он жрет в 10 раз больше простого питона.<br><code>gcc -O0</code> vs <code>python[23]</code> — разница в 50 раз.</p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(Oct 13, 2018)</tt><br><em><b>balancer73:</b></em></p>
		<p><span class="code"><code>Fib = {}
Fib.__index = Fib

function Fib:new(n)
    local f = {}
    setmetatable(f,Fib)
    f.n = n
    return f
end

function Fib:value()
    if self.n &lt;= 2 then
        return 1
    end
    return Fib:new(self.n - 1):value() + Fib:new(self.n - 2):value()
end

print(Fib:new(34):value());</code></span></p>
		<p><span class="code"><code>class Fib:
    def __init__(self, n):
        self.n = n

    def value(self):
        if(self.n &lt;= 2):
            return 1

        f1 = Fib(self.n - 1)
        f2 = Fib(self.n - 2)

        return f1.value() + f2.value()

print (Fib(34).value())</code></span></p>
		<p>На объектном алгоритме pypy обходит luajit:</p>
		<p><span class="code"><code>=> gcc-O0   fib-obj   0.55 s,   1904 KB,   2138555203 Refs
=> gcc-O2   fib-obj   0.45 s,   1904 KB,   1967468608 Refs
=> luajit   fib-obj   3.48 s,   2544 KB,  12255245901 Refs
=> pypy     fib-obj   1.14 s,  74992 KB,   2045327223 Refs
=> python2  fib-obj  12.47 s,   6952 KB,  41252628352 Refs
=> python3  fib-obj  13.37 s,   8008 KB,  47365407786 Refs
=> tcc      fib-obj   0.55 s,   1896 KB,   2144279192 Refs</code></span></p>
		<p>Интересно. По числу ref-ов видно, что luajit не смог оптимизировать код с объектами до уровня Си. А pypy — смог. Что-то я в сомнениях по этим числам. Если pypy выполнил даже меньше инструкций CPU, чем профиль gcc-O0, как он мог так сильно отстать от сишного кода.</p>
		<p>Вот тест, где было наоборот, luajit оптимизировался, а pypy — нет:</p>
		<p><span class="code"><code>=> gcc-O0  fib  0.08 s,   1488 KB,   194099889 Refs
=> gcc-O2  fib  0.02 s,   1488 KB,    71132501 Refs
=> luajit  fib  0.11 s,   2164 KB,   379322913 Refs
=> pypy    fib  0.63 s,  62508 KB,  1375890604 Refs</code></span></p>
		<p>Но результаты это еще с каким-то старым pypy. Надо будет повторить на новой версии.</p>
	</div>
	<div>
		<p><b>hugeping:</b> <tt>(Oct 20, 2018)</tt><br><em>Только одна вещь меня расстраивает в LuaJIT — это Lua.</em><br>Не могу молчать. :) Lua прекрасен! Спорить не буду, ибо если ты не видишь его красоты, что тут можно доказывать? :)</p>
		<p>Красота, простота, скорость... Это всё про Lua.</p>
	</div>
	<div>
		<p><b>hugeping:</b> <tt>(Oct 20, 2018)</tt><br>Хотя у меня тоже есть предубеждения. Одно из них, это принудительное форматирование (как в python). И табы в виде spaces.<br>Мое твёрдое убеждение - табы должны быть табами (код 8), а форматирование не должно быть частью языка. Правда, в итоге я все-таки заценил питон и го и даже пользовался ими :)</p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(Oct 23, 2018)</tt><br><em><b>hugeping:</b> ... Lua прекрасен!..</em><br>Прекрасен-то он прекрасен, но одна единственная вещь его портит, примерно как ложка дерьма в бочке мёда.</p>
		<p>Это всё равно что выпустить дорогой, красивый, быстрый, нафаршированный опциями автомобиль, но поменять в нём газ и тормоз местами.<br><em><b>hugeping:</b> ... Мое твёрдое убеждение - табы должны быть табами...</em><br>Табы удобны в идеальном мире, где все пользуются табами и делают это правильно. А в реальном по-всякому бывает. Но в целом согласен.</p>
	</div>
	<div>
		<p><b>cocaineninja:</b> <tt>(Dec 03, 2018)</tt><br>Тебе настолько не нравится адресовать массивы с 1? Целая куча языков так делает же, особенно те которые в науку пытаются.</p>
	</div>
	<div>
		<p><b>dzmitrylahoda:</b> <tt>(Dec 25, 2018)</tt><br>вызывает Cи быстрее чем Си <u>https://github.com/dyu/ffi-overhead</u>. Julia тоже видно гении делали. Я думаю C# тоже скоро будет гениален.</p>
	</div>
	<div>
		<p><b>90210:</b> <tt>(Aug 05, 2020)</tt><br>Ой-ой. Ну зачем же так гнат ьволну, уважаемый. cpython, numba -- догоняют си, причём вполне статически. А по сложности языка go делает Луну и пыхтон вообще как стоячих.</p>
	</div>
	<div>
		<p><b>csk:</b> <tt>(Oct 31, 2020)</tt><br><em><b>cocaineninja:</b> Тебе настолько не нравится адресовать массивы с 1...</em><br>Десятичное мышление 1234567890<br>Двоичное мышление 0123456789<br>Со школы математику учат в десятичной системе и только в 8-10 классах дают основы информатики и двоичное мышление.<br>Существует ещё шестнадцатиричное 0123456789abcdef.<br>Существует ещё и восьмиричное, но его мало где используют.</p>
	</div>
</section>
	
<p class="dr">Oct 13, 2018 / Geekless.Blog</p>
	
</article>		
		
</body>
</html>