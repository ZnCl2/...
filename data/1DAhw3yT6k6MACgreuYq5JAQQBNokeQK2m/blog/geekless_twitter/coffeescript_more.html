<!DOCTYPE html>
<html>

<head>
	<title>Снова про Coffee Script</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="stylesheet" href="../../css/global.css">
</head>

<body>
	
<header>
  <a href="../../index.html"><img src="../../img/logo.png" width="55"></a><br>ChronCache	
</header>
	
<nav>
	<hr>
  <p><a href="../../blog.html">архив</a> <tt>|</tt> <a href="../../help.html">помощь</a> <tt>|</tt> <a href="/1Q9LVNLD1ghusGxpiwjYnVjPsxD5xGTGc7/donate/index.html">донат</a></p>
	<hr>
</nav>

<article>
	
<acide><p>Это резервная страница от 07.05.2019 / <a href="/1ysjnZzsz5YYXhTNBxELnY4ftz42QupMg/?Post:18">оригинал</a></p></acide>

<section>
	<h1>Снова про Coffee Script</h1>
	<p>И я снова <b>про это.</b></p>
	<p>После нескольких дней интенсивного кодинга на Coffee Script могу поделиться впечатлениями.</p>
	<p>Всё-таки, пусть язык ничего нового из себя не представляет в техническом плане (кого в наше время Javascript-ом удивишь?), но стилистически имеет ненулевую ценность. Если исходить из того, что текст программы мы воспринимаем не только по отдельному слову, но в целом как какой-то «узор» на экране, и из этого узора мозг выхватывает какие-то опорные элементы, то Coffee Script образует довольно гармоничный и лёгкий узор.</p>
	<p>В то же время, эксплиситные концы блоков действительно облегчили бы чтение в местах наподобие следующих, где в конце метода мы сдвигаемся сразу на 4 отступа:</p>
	<div class="code">
		<code>runStatusCheck: (img) ->
    data = @getAttachedData(img)
    data.statusCheckRequired = false
    url = img.src

    corsRequester.checkSiteAvailable(url, {parseUrl: true})
    .then (res) =>
        data.siteAvailable = res

    corsRequester.requestSiteAndContentJson(url)
    .then (res) =>
        if typeof(res) == "string"
            data.siteAvailable = true
            data.contentJsonAvailable = true
            try
                json = JSON.parse(res)
                path = (json.inner_path ? "").replace(/\/?content\.json$/, "")
                parsedUrl = corsRequester.parseUrl(url)
                fileName = (parsedUrl.innerPath ? "").removePrefix(path).removePrefix("/")
                if json["files"][fileName] || json["files_optional"][fileName]
                    data.fileInList = true
                else
                    data.fileInList = false
            catch
                data.fileInList = false

reloadImage: (img) ->
    data = @getAttachedData(img)
    if data.retries > @max_retries
        return
    data.retries += 1
    src = img.src
    @log("Reloading image [#{data.retries}]: #{src}")
    img.src = ""
    img.src = src
    @runStatusCheck(img)</code>
	</div>
	<p>Или вот тут, с длиннющим return-ом, начинающимся в середине кода:</p>
	<div class="code">
		<code>checkSiteAvailable: (siteAddress, options = {}) =>
    if options.parseUrl
        parsedUrl = @parseUrl(siteAddress)
        if not parsedUrl
            return $.Deferred.reject()
        siteAddress = parsedUrl.siteAddress

    if @siteRequest[siteAddress] and @siteRequest[siteAddress].state() == "resolved"
        return @siteRequest[siteAddress]

    if siteAddress == @thisSiteAddress
        return $.Deferred().resolve(true)

    return $.Deferred().resolve()
    .then () =>
        $.Deferred (d) => # Check the permission
            Page.cmd "siteInfo", {}, (siteInfo) =>
                @thisSiteAddress = siteInfo.address
                if siteAddress == @thisSiteAddress
                    d.resolve(true)
                else if "Cors:#{siteAddress}" in siteInfo.settings.permissions
                    # We have the permission, check if site wasn't deleted
                    Page.cmd "fileGet", ["cors-#{siteAddress}/content.json", false, "text", 0], (res) =>
                        if typeof(res) == "string"
                            Page.log "Cors: #{siteAddress}: available"
                            d.resolve(true) # Available
                        else
                            Page.log "Cors: #{siteAddress}: we have permission, but the site is unavailable"
                            d.resolve(false) # Deleted
                else # No permission
                    Page.log "Cors: #{siteAddress}: no permission"
                    d.resolve(false)
    .promise()</code>
	</div>
	<p>Я специально даю методы целиком, чтобы был виден весь контекст. Вот еще сложный для чтения пример, здесь в форматирование отступами вклинивается форматирование открывающими/закрывающими элементами, и на двух пустых строках гладкость чтения сбивается:</p>
	<div class="code">
		<code>pageSettingsMain: ->
    return @queryBuildLog().then (buildlog) =>
        title = "Blog Settings"
        body = """
            * [Left Bar](?Settings:LeftBar)
            * [Footer](?Settings:Footer)
            * [Tags](?Settings:Tags)
            * [Editor](?Settings:Editor)

        """
        if buildlog
            body += """
                &lt;p class='hrboldline'>&lt;/p>
                * [BuildLog](?/Settings:BuildLog)
            """
        @applyAuxPostData(title, body)</code>
	</div>
	<p>Тут еще надо упомянуть, что мой любимый редактор не обновлялся несколько лет, и в нём нет поддержки синтаксиса Coffee Script, а самому сделать для редактора файл-описание мне всё еще лениво. Так что я сейчас пишу код без подсветки синтаксиса, как в доисторические времена.</p>
	<p>Однако код достаточно легко пишется и читается. Поначалу визуально-смысловая мешанина: вроде как визуальный стиль Питона с примочками Руби, но при этом ты пишешь на Javascript. Ну, к этому достаточно быстро привыкаешь.</p>
	<p>Про преимущества Coffee Script над Javascript. Я нашел одно маленькое и частное, и наверное для большинства кодеров незаметное, но для меня это прямо круто. У меня нереально пригорало от необходимости писать эти бесконечные <code>function () { return</code> на каждый чих. Пока пишешь код, где много коллбеков, складывается такое впечатление, что половина кода состоит просто из этих чертовых <code>function</code> и <code>return</code>. <i>А где, блядь, сам код-то?</i></p>
	<p>Честно говоря, я не слежу за нововведениями Javascript. Там вроде сейчас частично пофиксили эту проблему?</p>
	<p>Но вот что в Coffee одна стрелочка <code>-></code> заменяет кучу бесполезных букв — это снижение баттхерта на 80 пунктов по стобалльной шкале. По сравнению с этим вышеперечисленные недостатки Coffee добавляют всего пунктов 20-25.</p>
	<p>То есть в целом, всё сводится к моему всегдашнему мнению о дизайне языков:</p>
	<p>«Хорошо, когда в языке есть возможность использовать мало синтаксиса. Но плохо, когда язык беальтернативно принуждает использовать мало синтаксиса.»</p>
	<p>P.S. И всё-таки я предпочел бы писать на чем-то более похожем на Ruby.<br>С <code>end</code>-скобочками и <code>{}</code>-скобочками.</p>
</section>
	
<hr><p>Комментарии:</p>
	
<section class="com">
	<div>
		<p><b>x86128:</b> <tt>(May 10, 2018)</tt><br>Я раньше тоже думал что Python это верх лаконичности пока не увидел Ruby, а точнее Crystal. На Nim немного писал, но Crystal лучше на мой взгляд.</p>
		<p>Но есть еще REBOL и Red-lang, которые тоже заслуживают внимания, особенно REBOL как первый язык для Internet приложений, жалко что его автор забросил и в свое время не открыл код. Постепенно я думаю все языки придут к виду REBOL для разработки приложений уровня пользователя.</p>
	</div>
	<div>
		<p><b>x86128:</b> <tt>(May 10, 2018)</tt><br>Красиво выглядит CoffeeScript, поскольку я больше всего писал на Python мне как-то он ближе :D<br>Попробую что-нибудь написать на нем.... наверное экспорт твитов из твиттера для начала.</p>
	</div>
	<div>
		<p><b>balancer73:</b> <tt>(May 10, 2018)</tt><br><em><b>x86128:</b> Я раньше тоже думал что Python это верх лаконичности пока не увидел Ruby</em><br>Perl всё равно лаконичнее :D</p>
		<p>Одна беда — лаконичность языка с какого-то момента часто обратно пропорциональна читаемости. Поэтому Perl (и во много — Ruby) — write-only языки :) Впрочем, как и Java и JavaScript — с другой. Там перекос в другую сторону.</p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(May 10, 2018)</tt><br><em><b>balancer73:</b> Поэтому Perl (и во много — Ruby) — write-only языки...</em><br>Любопытно, что именно в Ruby даёт write-only эффект, на твой взгляд.</p>
		<p>По моему мнению, таких вещей три:</p>
		<ol>
			<li><a href="http://ruby.wikia.com/wiki/Special_variable" target="_blank">Perl-like special variables</a>. Вроде как, в современном коде почти не используются.
			<li>Злоупотребление последовательностями коллбеков при обработке enumerable данных. Язык прямо таки подталкивает зафигачить последовательности .map{}-ов, .reduce{}-ов и прочих .select{}-ов, типа, мы тут в функциональном стиле пишем чуть ли всю программу. Потом такой код практически невозможно читать. На JS можно писать в том же стиле, но обычно что-то останавливает (то ли здравый смысл , то ли длина ключевых слов <code>function</code> и <code>return</code>), а на Ruby — нет.
			<li>Постпозитивные управляющие инструкции. Сначала хочется писать лаконичном стиле всякие <code>return if</code> и <code>next unless</code>, а потом обнаруживаешь, что для понимания кода приходится читать каждую строку с середины.
		</ol>
		<p>Если всем этим не злоупотреблять, язык хорошо читабелен.</p>
	</div>
	<div>
		<p><b>x86128:</b> <tt>(May 10, 2018)</tt><br><em><b>geekless:</b> Язык прямо таки подталкивает зафигачить последовательности .map{}-ов, .reduce{}-ов и прочих .select{}-ов...</em><br>Самое страшное, что такой код невозможно отлаживать в пошаговом режиме. Именно это и не дает повсеместного распространения ФП-языков. Хотя многие их "полезности" перетекают в императивные языки.</p>
	</div>
	<div>
		<p><b>gitcenter:</b> <tt>(May 10, 2018)</tt><br><em>Но вот что в Coffee одна стрелочка -> заменяет кучу бесполезных букв...</em><br>А в JavaScript одна стрелочка <code>=></code> xD</p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(May 10, 2018)</tt><br><em><b>gitcenter:</b> А в JavaScript одна стрелочка => xD</em><br><code>=></code> в кофе тоже есть, семантика разная. <code>=></code> связывает this лексически, а <code>-></code> нет.</p>
		<p>Когда я активно кодил на JS, коротких лямбд там не было. Зато в то же время я кодил и на Ruby, и вот после Ruby жаваскрипт был реально боль.</p>
	</div>
	<div>
		<p><b>gitcenter:</b> <tt>(May 10, 2018)</tt><br><em><b>geekless:</b> => в кофе тоже есть, семантика разная...</em><br>На вкус и цвет все фломастеры разные. Пытался когда-то что-то делать на Ruby, мозг сломал от обилия спецсимволов.</p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(May 10, 2018)</tt><br><em><b>gitcenter:</b> ... мозг сломал от обилия спецсимволов</em><br>Попробовал сообразить, какие там есть спецсимволы, которых нет в JS. Вспомнил только $ и @ для доступа к глобальным переменным и к членам класса.</p>
		<p>Наверное, это были <a href="http://ruby.wikia.com/wiki/Special_variable" target="_blank">эти спецсимволы</a>?</p>
	</div>
	<div>
		<p><b>balancer73:</b> <tt>(May 11, 2018)</tt><br><em><b>geekless:</b> Если всем этим не злоупотреблять, язык хорошо читабелен</em><br>Если не злоупотреблять, то <i>любой</i> язык (ну, кроме, может, Брейнфака и Уайтспейса :)) хорошо читабелен. Но человек слаб. И если язык позволяет писать грязно, то люди чаще всего так и пишут :)</p>
	</div>
	<div>
		<p><b>balancer73:</b> <tt>(May 11, 2018)</tt><br><em><b>x86128:</b> Самое страшное, что такой код невозможно отлаживать в пошаговом режиме</em><br>ИМХО, сильно зависит от концепции программирования. Например, Форт, в принципе, позволяет отлаживать код пошагово. Но этим почти никто никогда не пользуется. Т.е. один из принципов <i>Thinking Forth</i> — использование очень коротких слов (так там называются синтаксические элементы — процедуры, функции, литералы, операторы и т.п.), состоящих из 7±2 составляющих слов. И такие слова очень просто отлаживать в интерактивном режиме. Подал на вход параметры, посмотрел результат. В итоге скорость разработки, по сравнению с ровесниками Форта без спец. IDE возрастала на порядок :) И надёжность получалась очень высокой, так как хорошим тоном считалось не использовать глобальные переменные, а всё передавать в параметрах.</p>
	</div>
	<div>
		<p><b>balancer73:</b> <tt>(May 11, 2018)</tt><br><em><b>geekless:</b> ... после Ruby жаваскрипт был реально боль</em><br>ИМХО, JS боль после почти любого языка :D Я тут второй день по основной работе активно на низкоуровневом JS фронтенд пилю, задолбался крутить в циклах массивы, клонировать объекты и т.п. :)</p>
	</div>
	<div>
		<p><b>balancer73:</b> <tt>(May 11, 2018)</tt><br><em><b>gitcenter:</b> ... мозг сломал от обилия спецсимволов</em><br>Вот я тоже с некоторых пор очень настороженно стал относиться к языкам с закорючками :) Хотя лет 25 назад был фанатом. Но длительная поддержка кода с такими языками становится болью, очень легко что-то зевнуть.</p>
		<p>Но я на Ruby хотя бы ничего не пишу, не считая мелких правок. Вот на чём пишу и что иногда вводит в состояние изумления в плохом смысле слова — это Lua :D Вот тут немного концентрата на русском — <u>http://ndtimofeev.github.io/ru/posts/2014-06-18-about-lua.html</u></p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(May 11, 2018)</tt><br><em><b>balancer73:</b> Вот на чём пишу и что иногда вводит в состояние изумления в плохом смысле слова — это Lua...</em><br>Оооо, я мечтаю, что кто-то подымет знамя luajit и сделает таки язык который:</p>
		<ol>
			<li>Как и luajit, до сих пор рвёт виртуальные машины JS на тестах.
			<li>Имеет адекватную семантику, а не вот это вот, на чем мы пишем.
		</ol>
	</div>
	<div>
		<p><b>x86128:</b> <tt>(May 11, 2018)</tt><br><em><b>balancer73:</b> ИМХО, JS боль после почти любого языка</em><br>Это точно :)<br><em><b>balancer73:</b> ... Форт, в принципе, позволяет отлаживать код пошагово</em><br>Хоть я на форте дальше "хэлло ворлд" не заходил, но смотрел его внутренности (реализацию на FPGA :D ). Поэтому там пошагово отлаживать можно. Если в одной функции беда, то портится стэк и программа ведет себя дальше не предсказуемо. Несомненный плюс это компактность кода, но согласитесь чужой код там нечитаемый. И если вдруг рефакторинг, то там этот ребус разгадывать крайне нудно.</p>
		<p>Цепочку map -> filter -> reduce пошагово не отладишь, я вот что имел ввиду, это в любом языке так.</p>
	</div>
	<div>
		<p><b>balancer73:</b> <tt>(May 12, 2018)</tt><br><em><b>x86128:</b> Поэтому там пошагово отлаживать можно</em><br>Так и я пишу, что можно :) Но на практике с таким никогда не сталкивался. Ибо при обычных паттернах программирования оно не нужно. Слова в 5-9 других слов легко «отлаживаются в уме» :)<br><em>Если в одной функции беда, то портится стэк и программа ведет себя дальше не предсказуемо</em><br>Да. Но вероятность того, что после тестирования одного небольшого слова окажется, что оно в каких-то условиях не работает, очень мала.<br><em>но согласитесь чужой код там нечитаемый</em><br>Если это «Thinkig Forth», то не просто читаемый, а самодокументируемый :)<br><em>И если вдруг рефакторинг, то там этот ребус разгадывать крайне нудно</em><br>И рефакторинг обычно выражается в простом переносе строк из одного файла в другой :D Это же кто-то из Форт-монстров (то ли Мур, то ли Броуди) сказал, что в редакторе настоящего программиста должна отсутствовать функция копирования текста :)<br><em>Цепочку map -> filter -> reduce пошагово не отладишь...</em><br>В любом языке можно сделать пошаговую отладку, они же все в итоге на императивных CPU работают :) Но, конечно, функциональные языки отлаживать пошагово намного сложнее.</p>
	</div>
	<div>
		<p><b>x86128:</b> <tt>(May 12, 2018)</tt><br><em><b>balancer73:</b> Так и я пишу, что можно...</em><br>Я так понял на форте Вы много писали, где то видел на форуме что движок (или часть) игры написана на форте? И как оно? Какие профиты были?</p>
	</div>
	<div>
		<p><b>balancer73:</b> <tt>(May 12, 2018)</tt><br><em><b>x86128:</b> Я так понял на форте Вы много писали</em><br>В основном — в середине 1990-х :)<br><em>где то видел на форуме что движок (или часть) игры написана на форте?</em><br>В MMORPG Lineage II в нашей версии сервера скриптописание было на Форте. Я под это дело реализовал Java-версию, JBForth.<br><em>И как оно? Какие профиты были?</em><br>Там главной причиной, по которой я вспомнил про Форт, было внутриигровое скриптописание. Т.е. часто возникала задача прямо внутри программы клиента в чате набросать или поправить какой-то скрипт. А это — исключительно одна строка текста :) Форт тут оказался просто незаменим. Ну а потом он много где в том проекте в качестве скриптового использовался, удобным инструментом оказался.</p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(May 12, 2018)</tt><br><em><b>balancer73:</b> Форт тут оказался просто незаменим...</em><br>Форт интересный инструмент. Теоретически, можно отдельные специализированные "языки", образуемые форт-библиотеками, реализовать как высокопроизводительную VM и получить прозрачный переход от максимальной гибкости настоящего Форта к максимальной скорости отдельного подмножества. Примерно как сделан переход от JS к asm.js - если реализация не умеет оптимизировать это подмножество, она просто исполняет его как есть.</p>
		<p>Я пытался что-то подобное сделать с Io, но не осилил допилить даже прототип. Io требует глубокого анализа семантики программы.на уровне jit-компилятора.</p>
	</div>
</section>
	
<p class="dr">May 10, 2018 / Geekless.Twitter</p>
	
</article>		
		
</body>
</html>