<!DOCTYPE html>
<html>

<head>
	<title>Significant whitespace и границы блоков</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="stylesheet" href="../../css/global.css">
</head>

<body>
	
<header>
  <a href="../../index.html"><img src="../../img/logo.png" width="55"></a><br>ChronCache	
</header>
	
<nav>
	<hr>
  <p><a href="../../blog.html">архив</a> <tt>|</tt> <a href="../../help.html">помощь</a> <tt>|</tt> <a href="/1Q9LVNLD1ghusGxpiwjYnVjPsxD5xGTGc7/donate/index.html">донат</a></p>
	<hr>
</nav>

<article>
	
<acide><p>Это резервная страница от 22.03.2020 / <a href="/1ysjnZzsz5YYXhTNBxELnY4ftz42QupMg/?Post:16">оригинал</a></p></acide>

<section>
	<h1>Significant whitespace и границы блоков</h1>
	<p>Еще что касается Питона и его языков-подражателей.</p>
	<p>Одна из неотъемлемых проблем написания и чтения кода — это проблема конца блока. Когда есть много вложенных конструкций, бывает сложно уследить, не съехали ли отступы, и какой фрагмент к какому уровню вложенности относится. Частным и неприятным случаем этой проблемы является проблема <a href="https://en.wikipedia.org/wiki/Dangling_else" target="_blank">dangling else</a>.</p>
	<p>Да, можно сколько угодно кукарекать, что в хорошем коде не должно быть глубоких уровней вложенности, и что код должен быть побит на процедуры, укладывающиеся в одну экранную страницу. Но, во-первых, <i>хороший код</i> и <i>реальный код</i> зачастую понятия исключающие друг друга, и, во-вторых, мозг человек — такая глючная машина, что умудряется запутаться даже и в простом коде. Так что мало придумать правила ненаступания на грабли, надо еще и дизайн граблей сделать более безопасным для человека.</p>
	<p>У меня есть игрушечный недопиленный компилятор недопиленного языка, сделанный на основе <a href="http://www.avhohlov.narod.ru/p9800ru.htm" target="_blank">игрушечного языка Андрея Хохлова</a>. Не помню, публиковал ли я где-либо сорцы. Одна из первых фич, которые я добавил в язык, когда взялся за переделку кода Андрея — опциональная уточняющая нотация в конце блока. Вот пример куска кода, где закрываются несколько блоков подряд:</p>
	<div class="code">
		<code>                                return i;
                        end:if
                end:if
                inc i;
        end:while

        return OPERATOR_INVALID;
end:function</code>
	</div>
	<p>Всё понятно, не так ли? Теперь попробуем стереть нотацию и посмотрим еще раз:</p>
	<div class="code">
		<code>                                return i;
                        end
                end
                inc i;
        end

        return OPERATOR_INVALID;
end</code>
	</div>
	<p>Стало определённо хуже. Чтобы понять, что происходит, надо листать текст вверх, и чем объемнее там код, тем больше шансов, что мы визуально сопоставим начало и конец блока с ошибкой.</p>
	<p>А теперь запишем это в античеловеческой significant whitespace нотации. Э. Мда:</p>
	<div class="code">
		<code>                                return i
                inc i
        return OPERATOR_INVALID</code>
	</div>
	<p>Уточнения <code>:if</code>, <code>:while</code> и т.п. являются опциональными в моём языке. Если они указаны, компилятор проверит их и выдаст ошибку, если обнаружит несоответствие. Если не указаны — будет работать без дополнительных проверок.</p>
	<p>Оригинальный код Андрея содержал огромные уровни вложенности инструкций. Код частично унаследован еще со времён DOS, где нужно было экономить каждый байт программисты выживали как могли. Передо мной стояла задача отрефакторить его с разбивкой по модулям и процедурам. Чтобы понять, где в коде что начинается и заканчивается, я использовал описанную фичу. Я ставил нотацию в подозрительном месте и смотрел, компилируется ли результат. Для выполнения этого рефакторинга это оказалась действительно киллер-фича.</p>
	<p>Пока я работал над кодом, я настолько привык к этой возможности, что мне её теперь не хватает во всех остальных языках. На Си или JS я часто ставлю end-примечания в комментариях, к сожалению, трансляторы этих языков не умеют проверять соответствие закрывающей скобки блока и комментария.</p>
	<p>Я уверен, что принцип «код работает именно так как выглядит» является необходимым для создания высококачественного софта с минимумом ошибок. С этих позиций код без эксплиситных концов блока и код а-ля <code>eat food for food in foods when food isnt 'chocolate'</code> — лютый, беспросветный северный лис.</p>
	<p>Что касается расширенной нотации конца блока, это не моё изобретение. Аналогичный синтаксис применялся еще в Ada, языке предназначенном для военных разработок. Если не ошибаюсь, там он являлся обязательным для некоторых синтаксических конструкций. (Или всё же не обязательным? Ничерта не помню уже.) Эти люди знали толк в написании надежного кода. :)</p>
</section>	
	
<hr><p>Комментарии:</p>
	
<section class="com">
	<div>
		<p><b>gitcenter:</b> <tt>(May 06, 2018)</tt><br>Вы изобрели BASIC :) Но возможность полезная, согласен.</p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(May 06, 2018)</tt><br><em><b>gitcenter:</b> Вы изобрели BASIC...</em><br>Когда я на BASIC-ке часто писал, там еще было <code>GOTO</code> со всех сторон. :)<br>Точно, ведь <code>end if</code>-ы потом появились, помню их из макросов на VBA. Имхо, совершенно разумное решение.</p>
	</div>
	<div>
		<p><b>deepstrelok:</b> <tt>(May 06, 2018)</tt><br>Можно же использовать emacs с модом для python(или прочих) или иные ide, где вся вложенность видна легко. Мне как-то наоборот ближе без дополнительных указаний ; Все-таки мы люди, а не компиляторы.</p>
	</div>
	<div>
		<p><b>geekless:</b> <tt>(May 06, 2018)</tt><br><em><b>deepstrelok:</b> Можно же использовать emacs с модом...</em><br>Всё-таки мне кажется, в дизайн языка не должно быть заложено, что для правки кода требуется специальный редактор.</p>
		<p>Хорошо, когда язык позволяет писать лаконично, но плохо, когда он не позволяет писать максимально многословно, с максимальным недоверием к себе. Во многих языках заметно это стремление автора: либо сделать всё лаконично, либо наоборот, сделать всё максимально «по-армейски». Существует ли золотая середина?</p>
		<p>Например, в Питоне автор решил экономить на блоках, в Руби автор решил экономить строчки за счёт многоярусных замыканий: <code>.select{|foo| блабла}.map {|bar| блаблабла}.inject(хрен){|вам, понять| что тут написано}</code></p>
		<p>Обе фичи достаточно удобные, но они не универсальные. Но если Руби не принуждает лепить весь код в нечитабельную массу, можно писать и многословнее, то в Питоне лаконичные отступы — одна из ключевых фич языка.</p>
		<p>Я за гибкость в выборе уровня лаконичности самим разработчиком. Условно говоря, чтобы на языке можно было переключаться с питон-стиля на ada-стиль, в зависимости от правил оформления, принятых в проекте. Таких мейнстримных языков нет, к сожалению.<br><em>Все-таки мы люди, а не компиляторы</em><br>При чтении незнакомого кода мы еще и компиляторы, аналоговые и ненадёжные. :)</p>
	</div>
	<div>
		<p><b>x86128:</b> <tt>(May 07, 2018)</tt><br>Хорошая статья. Думаю можно и на хабр положить :)</p>
		<p>Посмотрите еще в сторону таких языков как REBOL и Red, лучше всего на rossetacode</p>
		<p>Минималистичней некуда, но при этом читаемо. В отличие от примера с "северным лисом" :D</p>
	</div>
	<div>
		<p><b>x86128:</b> <tt>(May 07, 2018)</tt><br><em><b>geekless:</b> Хорошо, когда язык позволяет писать лаконично, но плохо, когда он не позволяет писать максимально многословно...</em><br>В том же Red и REBOL это сделано как расширение языка. Так называемые DSL - для каждого уровня разработки свой (Red/System для системных задач (типа управления памятью или вычисления MD5, либо высшие - управляюще-скриптовые)<br>При этом синтаксическая база остается таже, но появляются доп. уточняющие конструкции.</p>
	</div>
</section>
	
<p class="dr">May 06, 2018 / Geekless.Twitter</p>
	
</article>		
		
</body>
</html>