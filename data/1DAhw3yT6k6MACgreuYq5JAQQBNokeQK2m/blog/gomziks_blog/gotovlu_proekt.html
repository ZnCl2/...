<!DOCTYPE html>
<html>

<head>
	<title>Как я готовлю свой проект</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="stylesheet" href="../../css/global.css">
</head>

<body>
	
<header>
  <a href="../../index.html"><img src="../../img/logo.png" width="55"></a><br>ChronCache	
</header>
	
<nav>
	<hr>
  <p><a href="../../blog.html">архив</a> <tt>|</tt> <a href="../../help.html">помощь</a> <tt>|</tt> <a href="/1Q9LVNLD1ghusGxpiwjYnVjPsxD5xGTGc7/donate/index.html">донат</a></p>
	<hr>
</nav>

<article>
	
<acide><p>Это резервная страница от 28.02.2019 <tt>(13.11.2020)</tt> / <a href="/1CpGZyfbUBBV5uXUoY653wVoqZFRojbEzd/?Post:5">оригинал</a></p></acide>

<section>
	<h1>Как я готовлю свой проект</h1>
	<p><i>Статья получилась заметно больше, чем я ожидал, поэтому ждите второй части</i></p>
	<p>Если вы читали предыдущий пост, потом заглянули в мой GitHub и у вас остались вопросы о том, как это все работает, то наверное вам стоит заглянуть под кат.</p>
	<p>Представленный способ в принципе работает для любых проектов, но я упомяну также и ZeroNet-specific вещи.</p>
	<p>Итак, заводим проект.</p>
	<p>Первое, что я настоятельно рекомендую это использовать unix-like системы. Это может быть любой дистрибутив Linux, MacOS, FreeBSD (чем черт не шутит, но не проверял ничего) или даже виртуалка с Linux в Windows (необязательно целиком вести проект там, но там стоит его собирать).</p>
	<p>Второе - это таки завести отдельную директорию под проект. Начитавших всяких там доков можно подумать, что создал директорию под будущий сайт с помощью zeronet.py и там и работать. Однако это не удобно даже банально в силу того, что директория с сайтом - это человеконечитаемая абракадабра.</p>
	<p>Отдельная директория также позволит нам более удобно работать с тем же git-ом и т.п.</p>
	<p>Нам также нужны node.js и npm</p>
	<p>Node.js, если кто не знает, это интерпретатор JavaScript, основанный на базе движка V8, который в свою очередь был разработан в Google (если конечно ничего не поменялось). Npm это менеджер пакетов для того самого node.js (для python'истов - это местный pip).</p>
	<p>Итак, у нас есть отдельная директория, пустая. Пусть называется она hello_zero. У нас установлена node.js вместе с npm. Берем в руки терминал (какая ж разработка без него) заходим в hello_zero и начинаем строить скелет нашего проекта. Инициализируйте git (mercurial, etc.) репозиторий, если нужно. Далее нам нужен файл, в который будут записываться зависимости нашего проекта. Для этого наберем </p>
	<code>$ npm init</code>
	<p>Нас спросят пару вопросов. Обычно я не заморачиваюсь и отвечаю по-дефолту. Скажем так, более подробная информация нужна, если вы делаете какую-то библиотеку, которую будете шарить в сообщество. А так как у нас проект, можно не загоняться.</p>
	<p>Далее. Если вы еще не знаете, что такое Webpack, requirejs, browserify, срочно узнайте. Рекомендую Webpack (<a href="https://webpack.github.io/" target="_blank">оффсайт</a>, он как смесь browserify и require.js. Собрал в себе все самое лучшее от обоих. Нужно оно нам, чтобы собирать из аккуратно структурированных js-файлов (которые даже совсем не обязательно написаны на js), кашу в одном файле, как это принято делать, чтобы не нагружать браузер лишними запросам.</p>
	<p>Ставим:</p>
	<code>npm install webpack --save</code>
	<p>Флаг <code>--save</code> говорит, чтобы npm сохранил данную зависимость (и ее версию) в сгенерированный на прошлом шаге package.json</p>
	<p>После установки у нас в корне проекта появляется директория node_modules. Там на текущий момент хранится только что установленный webpack. Смело добавляем эту директорию в .gitignore (или что там у нас используется). Чуть позже мы настроим webpack и посмотрим, как это все дело заставить работать.</p>
	<p>Настало время определиться с непосредственно структурой проекта. Если это ZeroNet сайт или какое либо другое HTML\JS\CSS only приложение, то советую вам тут же, в корне создать файл <code>index.html</code>, а так же директорию <code>assets</code>. Если с index.html все понятно, то пожалуй поясню, для чего нужна директория assets. Туда я обычно складываю js скрипты и любую другую статику так, как мне удобно, структурировано. Также все эти js'ы не обязательно должны быть js'ами. Они вполне могут быть CoffeeScript'ами или чем там еще люди балуются. Webpack при правильной настройке все скушает, все переварит и выплюнет нам готовый для браузера js скрипт.</p>
	<p>В папке assets создайте index.js, оставьте его пустым. Это будет точкой входа. Не пугайтесь, я сейчас все объясню.</p>
	<p>index.html мы можем заполнить довольно стандартно</p>
	<div class="code">
		<code>&lt;!DOCTYPE html>
&lt;html>
&lt;head>&lt;/head>
&lt;body>
  &lt;script src="js/all.js">&lt;/script>
&lt;/body>
&lt;/html></code>
	</div>
	<p>Тут все просто, кроме того, что мы ссылаемся на не существующий скрипт js/all.js</p>
	<p>Пока несуществующий.</p>
	<p>Далее мы создадим начальный конфиг для webpack. Создаем в корне файл webpack.config.js со следующим содержимым</p>
	<div class="code">
		<code>module.exports = {
  entry: {
    all: './assets/index.js'
  },
  output: {
    path: './js/',
    filename: '[name].js'
  },
  resolve: {
    modulesDirectories: [
      'assets',
      'node_modules'
    ]
  }
}</code>
	</div>
	<p>В целом, о том, что означают те или иные настройки, вы можете прочитать <a href="https://webpack.github.io/docs/configuration.html" target="_blank">на одной из страниц документации webpack</a>. Я коротко пройдусь по этим настройкам.</p>
	<p>Я привык называть собранные webpack'ом скрипты - <i>бандлами (bundle)</i>. Так вот, в <code>entry</code> мы говорим webpack'у о том, какие бандлы у нас есть (all) и откуда он, так сказать, начинается. webpack во время сборки начнет осматривать этот файл, найдет все импорты и обработает.</p>
	<p>В <code>output</code> мы конфигурируем то, куда именно будут складываться наши выходные файлы и какой формат имени они будут иметь. Т.е. наш бандл all после обработки webpack'ом соберется в файл с названием all.js и будет находится в папке js (т.е. js/all.js относително нашей корневой папки проекта). А это именно тот файл, который мы указали в нашем html файле.</p>
	<p>Параметр <code>resolve</code> я использую исключительно для удобства. Стандартный способ webpack запросить какой либо модуль - это написать <code>require('путь/до/модуля.js')</code>. Иногда это очень не удобно и получается что-то вроде <code>require('../../../../models/products/fixed_price.js')</code>. Жутко да? Поэтому я сообщаю webpack'у, как искать модули, если он увидел что-то вроде <code>require('util/mymodule.js')</code>. В данном конкретном случае он сначала поищет в папке assets файл util/mymodule.js, если там не найдет, начнет искать в node_modules. node_modules мы оставляем (так оно работает по-умолчанию) для того, чтобы можно было установить например jquery с помощью npm, и обращаться к нему весьма простым</p>
	<code>var $ = require('jquery');</code>
	<p>Я тут все распинаюсь да распинаюсь. А казалось бы, зачем все так сложно? Зачем мне выпендривться с какими-то webpack'ами, можно ж по старинке, подключить себе на страницу несколько скриптов, да и обращаться к ним через <code>window.$</code> или какая там у вас библиотека.</p>
	<p>Отвечаю:</p>
	<ol>
		<li>Наш код в итоге соберется в один файл, что уменьшает количество запросов на сервер (не совсем справедливо для zeronet, но все равно приятно)
		<li>Мы могли бы подключить какую-то библиотеку, о которой потом забыли. Решили изменить код и так уж получилось, что эта библиотека не используется больше нигде. Но тем не менее, она продолжает скачиваться нашему посетителю. В случае с webpack'ом мы получаем явное указание зависимостей, которые просто не попадут в итоговый бандл, если они больше не используются. Все счастливы
		<li>У нас появляется две особые возможности. Первая - использовать библиотеки, написанные для node.js в браузере (разуметеся, если у них нет какой-то особой работы с файловой системой, процессом и другими штуками, которые в браузере отсутствуют). Вторая - мы теперь можем использовать разные препроцессоры кода, будь то coffeescript или babel (ES6, об этом далее). Так же, если углубиться в доки, можно научиться делать код разбитый на куски, и куски подгружать тогда, когда они действительно нужны (это несколько бесполезно в рамках ZeroNet, по крайней мере пока один файл не занимает очень много мегабайт)
		<li>Если совсем постараться, то мы сможем писать unit-тесты на наш код, который не взаимодействует с DOM-деревом и прочими browser-specific штуками. А это уже много!
		<li>Ваш window свободен, там теперь не хранятся куча всяких jQuery, underscore и прочих имен, т.к. все это добро работает в замыкании
		<li>Вы можете подключить свою итоговую сборку с помощью async аттрибута и не думать о том, в каком порядке у вас загрузятся все ваши библиотеки.
	</ol>
	<p>Ну хватит уже разговаривать, давайте посмотрим, что получилось!</p>
	<p>Как запускать: просто идем в корень проекта, если вы еще не там, и выполняем</p>
	<code>$ ./node_modules/bin/webpack</code>
	<p>Webpack немного подумав выдаст вам несколько строк текста. Если вы видите только зеленый текст - все хорошо. Можно смотреть файл js/all.js хотя там должно быть пусто (или пару строк webpack'овского рантайма, это все вам стоит изучить самостоятельно)</p>
	<p>Открыв index.html, зайдя в developer tools мы видим, что никаких 404 не произошло, но это скучно довольно.</p>
	<p>Давайте попробуем подключить к нашему проекту препроцессор babel, который поможет нам писать с использованием синтаксиса ES6. Ознакомится с синтаксисом и с самим babel можно на официальной странице <a href="https://babeljs.io/docs/learn-es2015/" target="_blank">BabelJS</a></p>
	<p>В целом инструкции по установке вы можете найти <a href="https://babeljs.io/docs/setup/#webpack" target="_blank">здесь</a>, но раз уж я взялся вас учить, то будем идти до конца. Следите за руками</p>
	<code>$ npm install babel-core babel-loader babel-preset-es2015 babel-polyfill --save</code>
	<p>Да, тут несколько много всего, больше чем на оф. сайте.</p>
	<p>Пакет babel-core - обеспечивает базовую функциональность. Подробнее читайте сами, ибо я в подробности уже не уходил.</p>
	<p>Пакет babel-loader - специальный пакет для webpack, который позволяет последнему загружать ES6 код и правильно его обрабатывать.</p>
	<p>Вообще для webpack есть множество разных loader'ов, но я боюсь я скоро из-за этой статьи привышу стандартную квоту.</p>
	<p>Пакет babel-preset-es2015 насколько я понял, babel более универсальная штука, чем просто дать вам возможность писать на ES6, и непосредственно ES6 находится в отдельном пакете. Нужно копать, чтобы до конца понимать</p>
	<p>Пакет babel-polyfill. ES6 привносит довольно много всяких штук, которые не поддерживаются даже самыми современными браузерами. Данный пакет поможет исправить эти недостатки и создаст в экосистеме браузера все необходимое для работы. Конкретный пример Symbols.</p>
	<p>Фух. Едем дальше. ES6 на этом у нас магическим образом не появится. Нам нужно:</p>
	<ul>
		<li>Сконфигурировать вебпак<br>Добавьте строки, чтобы получилось так
	</ul>
	<div class="code">
		<code>module.exports = {
entry: {
  all: './assets/index.js'
},
output: {
  path: './js/',
  filename: '[name].js'
},
module: {
  loaders: [
    {test: /\.js$/, exclude: /node_modules/, loader: 'babel'},
  ]
},
resolve: {
  modulesDirectories: [
    'assets',
    'node_modules'
  ]
}
}```
Намекну, что речь про параметр `module` с внутренним массивом `loaders`. Тут мы указали, что любой js файл, кроме тех, что лежат внутри node_modules (чаще всего они не ES6 совместимы) нужно обрабатывать babel-loader'ом</code>
	</div>
	<ul>
		<li>Сказать babel'у, какой preset использовать.<br>Создаем в корне проекта .babelrc с следующим содержимым<br><code>{ "presets": ["es2015"] }</code>
	</ul>
	<p>После этого мы можем писать с использованием ES6. Давайте перейдем в ранее созданный assets/index.js и напишем что-то с использованием нового синтаксиса. Можно попробовать вот такое</p>
	<div class="code">
		<code>import 'babel-polyfill' // См. выше. Дополняем возможности браузера

function iteritems(obj) {
  return {
    [Symbol.iterator]: function*() {
      for (let key in obj) {
        let value = obj[key]
        yield [key, value]
      }
    }
  }
}

let obj = {
  keyA: 'valueA',
  keyB: 'valueB'
}

for (let [key, value] of iteritems(obj)) {
  console.log(key, value)
}</code>
	</div>
	<p>Демонстрирует сразу несколько возможностей и обычных изменений в ES6 по сравнению с ES5. Тут и генераторы, и итераторы, и Symbols, и новое объявление переменных. Показательно.</p>
	<p>Теперь запуск</p>
	<code>$ ./node_modules/.bin/webpack</code>
	<p>И открываем в браузере. В консоли должно быть что-то вроде</p>
	<div class="code"><code>keyA valueA<br>keyB valueB</code></div>
	<p>Я помоему действительно не расчитал количество букв и видимо придется дробить на две статьи. В следующей мы рассмотрим, что такое Vue.js что такое Vuex, как это все собрать вместе. А сейчас еще пару вещей</p>
	<code>$ ./node_modules/.bin/webpack -wd</code>
	<p>Запустит webpack в виде продолжительного процесса, который будет следить за любым изменением в любом файле, который входит в bundle и сразу собирать новую версию этого бандла. И это будет быстро! Дополнительно генерирует map файлы, чтобы быстро можно было ориентироваться в коде во время выполнения. Полезно для дебага.</p>
	<code>$ ./node_modules/.bin/webpack -p</code>
	<p>Выведет вам большое желтое полотно. Не пугайтесь, все хорошо. Webpack изготовил нам "продакшен" версию, минифицированную и обфусцированную на столько, на сколько он смог.</p>
	<p>Иииии...</p>
	<h3>Домашнее задание</h3>
	<p>Или что еще почитать на тему.</p>
	<p>Как я уже говорил, штудируем</p>
	<ul>
		<li><a href="https://webpack.github.io/" target="_blank">Webpack</a>
		<li><a href="https://babeljs.io/docs/learn-es2015/" target="_blank">BabelJS</a>
		<li><a href="http://blog.madewithlove.be/post/webpack-your-bags/" target="_blank">Неплохая статья на английском</a>
	</ul>
	<p>Ну и если интересно, всегда можете написать мне сюда или на почту (ссылка слева).</p>
	<p>Спасибо за внимание, извините за МНОГАБУКАВ</p>
</section>	
	
<hr><p>Комментарии:</p>
	
<section class="com">
	<div>
		<p><b>sthetz:</b> <tt>(Feb 15, 2016)</tt><br>Отличная статья. Как раз только что дописал свой движок борды с нуля на ES6 по твоему совету, использовал Babel.</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 15, 2016)</tt><br><em><b>sthetz:</b> Отличная статья...</em><br>Как же я рад, что кому-то это пригодилось. :)</p>
	</div>
	<div>
		<p><b>leinariys:</b> <tt>(Mar 05, 2016)</tt><br>Норм статья)</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Mar 06, 2016)</tt><br><em><b>leinariys:</b> Норм статья)</em><br>Пожалуйста :)</p>
	</div>
	<div>
		<p><b>alexum:</b> <tt>(Sep 14, 2019)</tt><br>Так, ну тут около Веба пока. Спасибо</p>
	</div>
</section>
	
<p class="dr">Feb 13, 2016 / GomZik's Blog</p>
	
</article>		
		
</body>
</html>