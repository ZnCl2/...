<!DOCTYPE html>
<html>

<head>
	<title>Как я готовлю свой проект</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="stylesheet" href="../../css/global.css">
</head>

<body>
	
<header>
  <a href="../../index.html"><img src="../../img/logo.png" width="55"></a><br>ChronCache	
</header>
	
<nav>
	<hr>
  <p><a href="../../blog.html">архив</a> <tt>|</tt> <a href="../../help.html">помощь</a> <tt>|</tt> <a href="/1Q9LVNLD1ghusGxpiwjYnVjPsxD5xGTGc7/donate/index.html">донат</a></p>
	<hr>
</nav>

<article>
	
<acide><p>Это резервная страница от 28.02.2019 / <a href="/1CpGZyfbUBBV5uXUoY653wVoqZFRojbEzd/?Post:7">оригинал</a></p></acide>

<section>
	<h1>Как я готовлю свой проект. Часть 2.</h1>
	<p><i>Первая часть тут, чуть ниже, но для ленивых - вот: <a href="/blog.gomzik.bit/?Post:5">Как я готовлю свой проект</a></i></p>
	<p>Сегодня мы поговорим про то, как к нашему добру подключить Vue.js</p>
	<p>Но для начала поговорим о том, что такое <a href="http://vuejs.org/" target="_blank">Vue.js</a>. Точнее скорее мы поговорим о том, что такое Vue.js моими глазами.</p>
	<p>Как я уже упоминал, я в первую очередь python-developer, который занимается в основном web'ом. Ну и по долгу службы приходится часто работать с JavaScript. Я прошел положенные <a href="https://ru.wikipedia.org/wiki/Кюблер-Росс,_Элизабет#.D0.9F.D1.8F.D1.82.D1.8C_.D1.81.D1.82.D0.B0.D0.B4.D0.B8.D0.B9_.D0.BF.D1.80.D0.B8.D0.BD.D1.8F.D1.82.D0.B8.D1.8F_.D1.81.D0.BC.D0.B5.D1.80.D1.82.D0.B8" target="_blank">пять стадий</a> до тех пор, пока не смог его даже полюбить. Так вот, пика этой любви я достиг познакомившись с Vue.js.</p>
	<p>Однако, как и все (ну или действительно очень многие), я начинал с jQuery, спаггети-кода, колбэчного ада и вот этого вот всего. Если вы как раз на этой стадии, то думаю вам стоит вдумчиво дочитать эту статью до конца.</p>
	<p>В конце концов, после очередной задачи на работе, я понял, что мне это все порядком надоело, код стал очень тяжело модифицируем, искать причину бага тоже становилось все тяжелее и тяжелее. Я тогда только впервые услышал про <a href="https://facebook.github.io/react/" target="_blank">React.js</a> да и он относительно недавно появился и только начинал вызывать бурление масс. С мыслью о том, что люди живут как-то проще, что им не нужно программировать пошагово, как из одного состояния перейти в другое, причем когда их штук 5 и все они друг в друга могут переходить между собой я обратился за помощью к другим командам в компании, где были именно специалисты frontend разработки.</p>
	<p>Передо мной стояла задача - облегчить жизнь себе и своим коллегам, а так же уметь работать (на тот момент еще) с IE7+. И да, мне очень подкупал на тот момент React. Выслушав мою боль и мои требования, ребята почти хором сказали: "Тебе нужен <a href="http://knockoutjs.com/" target="_blank">knockout.js</a>".</p>
	<p>И вот знаете - мне понравилось! Писать код стало заметно проще. Заметно проще стало и понимать, что происходит не так. Были разве что пару неочевидных моментов в этом knockout'е, да и то, если вдумчиво читать (а с моим английским это иногда бывает трудно) то это будет на поверхности (или почти). Ну вот из-за всяких мелких нюансов я и начал поглядывать на то, что еще в мире JS существует.</p>
	<p>Ну и как-то ненароком наткнулся я на Vue.js. Совершенно случайно. Листая какую-то связанную статью на хабре. В комментариях. Тогда оно еще было версии 0.12 или что-то около того. Потыкав на дому я понял, что мне оно нравится, однако требование к браузерам в виде IE9+ не позволило мне его попробовать в реальных проектах. Так оно и осталось в загашнике того, что я хочу обязательно попробовать.</p>
	<p>Релизнулась версия 1.0 и я понял, что дальше тянуть нельзя. Работу я уже сменил, требования к браузерам стали не такими жестокими. Да и сама MS их всех разом решила похоронить. К сожалению на новой работе я уже успел начать проект, в котором взял уже знакомый мне knockout.js, так что версию 1.0 изучать мне пришлось снова на дому. Особых конкретных отличий я не заметил, но вспомнил, что это то, с чем я хочу работать.</p>
	<p>Если коротко, то Vue.js для меня выглядит некоторым компромиссом между knockout.js (с его нюансами для поддержки старых браузеров) и React (который не нравится довольно многим за то, что пропагандирует шаблоны прямо в JS коде). У Vue.js хоть и не самое большое, но очень толковое сообщество, а автор библиотеки настолько радеет за свое детище, что понаписал дополнительных утилит к ней на все случаи жизни. И черт возьми, это просто прекрасно.</p>
	<p>Вы можете использовать Vue.js и по старинке, подключив его скриптом к вашему документу, и с помощью ES6, и с помощью ES5, и есть адаптеры к webpack, которые позволяют держать компоненты в удобном, структурированном виде, и подсветка синтаксиса для популярных редакторов имеется (там есть особый формат, который идеально подходит для компонентной структуре, как по мне)</p>
	<p>Получилось какое-то очень большое предисловие, но надеюсь я еще не успел вас утомить, ведь мы еще ничего полезного не сделали!</p>
	<p>Ну так давайте же наконец попробуем этот ваш Vue.js! Итак, надеюсь вы все еще в директории с нашим проектом из прошлой статьи, а если нет, то уверен, вы быстро туда придете. Ставим Vue.js</p>
	<code>$ npm install vue --save</code>
	<p>Но одной библиотеки нам пожалуй мало. Раз уж мы решили использовать всю мощь Webpack, то ставим сюда же рядом <a href="https://vuejs.github.io/vue-loader/" target="_blank">vue-loader</a>. С ним есть некоторая трудность, ему нужно еще куча всего, чтобы работать правильно. Вот полная команда</p>
	<code>$ npm install vue-loader vue-html-loader css-loader vue-style-loader babel-plugin-transform-runtime babel-runtime@5 --save</code>
	<p>babel-runtime умышленно используется 5-ой версии (<a href="https://github.com/vuejs/vue-loader/issues/96#issuecomment-162910917" target="_blank">объяснение</a>).</p>
	<p>Ну вот такие вот зависимости. Скорее всего автор просто очень радеет за гибкость и за то, чтобы многое можно было при желании заменить на что-то другое. Например, если мы будем для каскадных стилей использовать какой-то препроцессор (например stylus), нам достаточно будет установить его</p>
	<code>npm install stylus stylus-loader --save</code>
	<p>и... Ну в общем сами все увидите, а то сложно объяснять, непонятно что.</p>
	<p>Так же мне нравится идея, которую продвигает facebook рядом со своим React.js про паттерн <a href="https://facebook.github.io/flux/" target="_blank">flux</a>. Довольно удачная идея, которая получила одну из реализаций от автора библиотеки Vue.js, и называется <a href="http://vuex.vuejs.org/en/index.html" target="_blank">Vuex</a>. Нам она тоже понадобиться для демонстрации.</p>
	<code>$ npm install vuex --save</code>
	<p>Итак, давайте же уже писать код!</p>
	<p>Нам нужна небольшая правка в нашем webpack.config.js</p>
	<div class="code">
		<code>module.exports = {
  //...
  module: {
    loaders: [
      {test: /\.js$/, exclude: /node_modules/, loader: 'babel'},
      {test: /\.vue$/, loader: 'vue'}
    ]
  }
}</code>
	</div>
	<p>Говорим webpack'у, что файлы, которые оканчиваются на .vue мы должны грузить с помощью специального лоадера vue-loader.</p>
	<p>Зачем же мы все это делаем. Сейчас маленький примерчик и я начну объясняться. Очистим все, кроме самой первой строчки (напомню, это <code>import 'babel-polyfill'</code>) в нашем файле assets/index.js. Создадим файл assets/App.vue</p>
	<p>Тут вы немного сейчас удивитесь. Пишем туда следующее</p>
	<div class="code">
		<code>&lt;script>
import MyButton from 'components/Button.vue'
import MyCounter from 'components/Counter.vue'
import store from 'store.js'

export default {
  computed: {
    counter() {
      return store.state.counter
    }
  },

  methods: {
    buttonClicked() {
      store.actions.increment()
    }
  },

  components: {
    MyButton, MyCounter
  }
}
&lt;/script>

&lt;template>
  &lt;div class="app">
    &lt;my-button @button-click="buttonClicked">Click me!&lt;/my-button>
    &lt;my-counter :counter="counter">&lt;/my-counter>
  &lt;/div>
&lt;/template>

&lt;style lang="stylus">
  body, html
    margin 0
    padding 0
&lt;/style>

&lt;style lang="stylus" scoped>
.app
  padding 10px
  border 1px solid black
&lt;/style></code>
	</div>
	<p>Тут мы объявили компонент в рекомендуемом для Vue.js стиле. Здесь одновременно все вместе, что удобно для компонента и в то же время раздельно (а не как в React.js)</p>
	<p>Сначала мы объявляем секцию <code>&#60;script /></code> в которой размещаем наш ES6 скрипт<sup>1) 2)</sup> компонента. Ниже идет секция <code>&#60;template /></code> в котором мы пишем html разметку, связанную с этим компонентом.</p>
	<p>Еще ниже мы видим почему-то две секции <code>&#60;style /></code>. Я просто для себя вывел такое правило, что в самом корневом компоненте (App в данном случае) я объявлю глобальные стили, которые накладываются на весь документ, и рядом объявлю стили локальные, которые работают только для этого компонента. За то, каким именно стиль является отвечает атрибут <code>scoped</code>. Его действие мы особенно хорошо заметим чуть позже.</p>
	<p>Так же внимательный читатель мог увидеть атрибут <code>lang</code> со значением <code>stylus</code>. Это собственно про то, что я говорил. Нравится вам какой-то другой язык, вы можете использовать его. Тоже самое касается и <code>&#60;template /></code>, и <code>&#60;script /></code>. Можно подставить туда CoffeeScript вполне спокойно (раз уж тут его любят, грех обойти :) ), сделав <code>lang="coffee"</code> (не забудьте установить пакеты <code>coffe coffe-loader</code>)</p>
	<p>Посмотрим на секцию <code>&#60;script /></code> внимательнее. Мы воспользовались предлагаемым автором Vue.js "синтаксическим сахаром" по объявлению компонента. Мы не импортируем библиотеку Vue.js явно и ни от чего не наследуемся. Однако экспортируемый объект должен быть определенной структуры. Подробнее читайте в документации, ссылки я собрал в конце статьи.</p>
	<p>Первым делом мы импортируем наши компоненты (которые мы пока еще не создали, ну да ладно), а так же, по идее flux, мы импортируем наш единый store (о нем тоже чуть позже).</p>
	<p>Пользуясь сахаром ES6 мы просто перечисляем в атрибуте <code>components</code> объекта наши компоненты.</p>
	<p>Так же мы объявляем одно вычисляемое свойство (оно будет изменятся вместе с изменением нашего глобального состояния) и один метод (он же хэндлер).</p>
	<p>В целом довольно просто.</p>
	<p>Следом очередь за <code>&#60;template /></code>. Тут тоже есть несколько особенностей. Во-первых, мы вставляем наши компоненты используя немного модифицированное имя этого самого компонента. Во вторых, возле некоторых атрибутов мы видим странные символы <code>@</code> и <code>:</code>. Это такие сокращения, которые нам предоставляет Vue.js. Первый используется, чтобы подписаться на события дочернего компонента, а второй, чтобы "прокинуть" свойство из родительского контекста. В данном случае мы прокидываем наше вычисляемое свойство <code>counter</code>.</p>
	<p>В целом тут вроде и все. Я приведу код components/Button.vue и components/Counter.vue без комментариев, так как там все даже проще, чем здесь.</p>
	<p class="center">assets/components/Counter.vue</p>
	<div class="code">
		<code>&lt;script>
  export default {
    props: ['counter']
  }
&lt;/script>

&lt;template>
  &lt;p>{{ counter }}&lt;/p>
&lt;/template>

&lt;style lang="stylus" scoped>
  p
    font-weight bolder
&lt;/style></code>
	</div>
	<p class="center">assets/components/Button.vue</p>
	<div class="code">
		<code>&lt;script>
  export default {
    methods: {
      buttonClicked() {
        this.$dispatch('button-click')
      }
    }
  }
&lt;/script>

&lt;template>
  &lt;button @click="buttonClicked">
    &lt;slot>&lt;/slot>
  &lt;/button>
&lt;/template>

&lt;style lang="stylus" scoped>
  button
    padding 5px
    border-radius 4px
&lt;/style></code>
	</div>
	<p>Хотя нет, есть три вещи, на которых стоит остановиться. Во-первых, обратите внимание, как мы бесцеремонно навешиваем стили на теги. Этого конечно даже вместе с Vue.js делать не очень-то стоит, но сделано это нарочно, для демонстрации возможности <code>scoped</code>. Дело в том, что после обработки webpack'ом, мы получим стили следующего вида</p>
	<div class="code"><code>button[_v-123124] {<br>}</code></div>
	<p>а в html у нас будет красоваться не просто <code>&#60;button /></code>, а <code>&#60;button _v-123124></code></p>
	<p>Таким образом достигается изоляция стилей. Данный стиль не будет действовать ни на одну родительскую кнопку. Однако прошу заметить, что на дочерние кнопки (даже если они в других компонентах) это действовать будет.</p>
	<p>Следующая маленькая вещь, на которую я обращу ваше внимание - это атрибут <code>props</code> у Counter.vue. Если посмотреть еще разок на код App.vue, то вы увидите, что мы передаем свойство, которое не похоже на обычное DOM-свойство. Так вот чтобы его получить, компонент должен сказать, что он принимает это свойство.</p>
	<p>И на последок: магический тег <code>&#60;slot /></code> - используется для того, чтобы вставлять контент, так сказать, сверху. Если мы снова вернемся к коду App.vue, то увидим, что в template в теге <code>&#60;my-button /></code> внутри мы написали Click me! Так вот этот самый контент и вставляется на место тега <code>&#60;slot /></code>.</p>
	<p>Знаю, вы уже утомились, но тут осталось три маленькие детали. Во-первых - магический store.js. Привожу его код</p>
	<p class="center">assets/store.js</p>
	<div class="code">
		<code>import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

const store = new Vuex.Store({
  state: {
    counter: 0
  },

  actions: {
    increment(store) {
      store.dispatch('INCREMENT')
    }
  },

  mutations: {
    INCREMENT(state) {
      state.counter += 1
    }
  }
})

export default store</code>
	</div>
	<p>Одновременно простой и не совсем. Тут мы используем Vuex, реализацию идеи flux от автора библиотеки Vue.js. В общем и целом это обычный объект, только построен он на геттерах и сеттерах и оттого "излучает" события всем подписчикам, коим и является наш App.vue (вспомните вычисляемое свойство). У него также есть особая структура, о которой подробнее вы прочитаете в доках.</p>
	<p>Теперь нам нужно все это как-то запустить в нашем assets/index.js</p>
	<div class="code">
		<code>import 'babel-polyfill'

import Vue from 'vue'
import App from 'App.vue'

const app = new Vue({
  el: 'body',
  components: {
    App
  }
})</code>
	</div>
	<p>Всего в пару строк мы создаем наш Vue application, говорим, к какому элементу DOM-дерева мы привязываемся и так же говорим о том, что у нас единственный компонент - App. Также нам нужно немного подправить index.html, чтобы довести это все до рабочего состояния.</p>
	<p>Внутрь <code>&#60;body /></code> вставляем простой тег <code>&#60;app>&#60;/app></code> чтобы получилось так</p>
	<div class="code">
		<code>&lt;!DOCTYPE html>
&lt;html>
&lt;head>
&lt;/head>
&lt;body>
  &lt;app>&lt;/app>
  &lt;script src="js/all.js">&lt;/script>
&lt;/body>
&lt;/html></code>
	</div>
	<p>Не забываем запустить</p>
	<code>./node_modules/.bin/webpack</code>
	<p>И можем смело открывать index.html в нашем браузере. Обязательно выполните просьбу кнопки и пожмякайте на нее.</p>
	<h2>Литература на дом</h2>
	<ol>
		<li><a href="http://vuejs.org/" target="_blank">официальный сайт Vue.js</a>, там вы найдете действительно хорошую документацию
		<li><a href="https://vuejs.github.io/vue-loader/index.html" target="_blank">документация по vue-loader</a>
		<li><a href="http://vuex.vuejs.org/en/index.html" target="_blank">документация по Vuex</a>
		<li><a href="https://egghead.io/lessons/javascript-redux-the-single-immutable-state-tree?series=getting-started-with-redux" target="_blank">видео уроки по Redux</a> - еще одна имплементация идеи flux, откровенно говоря я так и не посмотрел, но сообщество рекомендует.
	</ol>
	<h2>В качестве послесловия</h2>
	<p>Снова большая статья. Надеюсь вам будет относительно легко ее переварить. Хотя я понимаю, что техническая часть статьи получилась несколько сумбурной и наверняка оставил у вас множество вопросов, но это сделано и нарочно, и нет. Во-первых, если я буду застревать на каждом моменте, это будет долго, скучно (особенно если человек уже скилловый), да и наверное выйдет за рамки всех возможных квот. Да и времени на это наверное убить нужно много. Во-вторых - призываю вас читать документацию, тем более, что она очень хорошая и простая, со всякими там Getting started и прочими туториалами. Ну и в третьих - я всегда рад пообщаться по поводу каких-то конкретных проблем, поэтому смело пишите мне на почту (ссылка слева есть), сюда в комментарии или заходите в наш уютный <a href="/1Apr5ba6u9Nz6eFASmFrefGvyBKkM76QgE">Ru-ZeroTalk</a>. Я там регулярно обитаю и подписан на все темы и комментарии.</p><p>Спасибо за потраченное время!</p>
	<h3>Что-то похожее на сноски</h3>
	<p><sup>1)</sup> У меня после версии 1.0 как-то даже не получилось воспользоваться ES5 синтаксисом, именно по этому я попробовал ES6 (хоть и относился к нему скептически) и больше стараюсь с ним не расставаться.<br><sup>2)</sup> я не знаю, почему сноски не работают, в подсказке написано, что должно.</p>
</section>	
	
<hr><p>Комментарии:</p>
	
<section class="com">
	<div>
		<p><b>nippletwister:</b> <tt>(Feb 16, 2016)</tt><br>Работает?</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br><em><b>nippletwister:</b> Работает?</em><br>да</p>
	</div>
	<div>
		<p><b>wrewolf:</b> <tt>(Feb 16, 2016)</tt><br>Офигеть, сайт из 1 кнопки на 36 мегабайт )))<br>А что из этого нужно в продакшене?</p>
	</div>
	<div>
		<p><b>wrewolf:</b> <tt>(Feb 16, 2016)</tt><br>Мне как человеку увидевшему такой js в первый раз, не хватает мануала по сборке проекта сразу в продакшен папку, что бы руками все не копировать (ну или даже написать необходимое скриптом, все равно криво)</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br><em><b>wrewolf:</b> ... не хватает мануала по сборке проекта сразу в продакшен папку...</em><br>ZeroNet специфику опишу в следующей статье. На текущий момент вас интересует только index.html и директория js. В целом zeronet позволяет добавлять исключения, какие файлы не должны участвовать в раздаче. Можно и банальным скриптом решить проблему, который запустит</p>
		<p><span class="code"><code>./node_modules/.bin/webpack -p<br>cp index.html js &#60;path to zeronet site> -R</code></span></p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br><em><b>wrewolf:</b> ... не хватает мануала по сборке проекта сразу в продакшен папку...</em><br>В целом тут ситуация такая, как и с компилированными языками. У вас есть сорцы и либы, которые потом превращаются в <del>бинарники</del> обфусцированный код, который у нужно доставить клиенту.</p>
	</div>
	<div>
		<p><b>wrewolf:</b> <tt>(Feb 16, 2016)</tt><br>ну в случае со сборкой обычно это делается в соседнем каталоге и получается разделение бинарников и исходников</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br><em><b>wrewolf:</b> ... обычно это делается в соседнем каталоге...</em><br>Обычно это делается автоматически по коммиту :)</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br><em><b>wrewolf:</b> ... обычно это делается в соседнем каталоге...</em><br>Вебпак полностью настраивается. Там можно указать, откуда брать и куда ложить. Прочитай первую часть еще раз, попробуй сделать как тебе удобнее, расскажи мне, может мне так больше понравится</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br><em><b>wrewolf:</b> ... обычно это делается в соседнем каталоге...</em><br>Ну и конечно же спрашивай, я помогу</p>
	</div>
	<div>
		<p><b>wrewolf:</b> <tt>(Feb 16, 2016)</tt><br><em><b>gomzik:</b> Вебпак полностью настраивается...</em><br>то есть можно собирать в "соседний" каталог</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br><em><b>wrewolf:</b> то есть можно собирать в "соседний" каталог</em><br>Ну да. Видится мне это как-то так</p>
		<p><span class="code"><code>+-src<br>|---index.js<br>|---App.vue<br>|---+components<br>|---|---Button.vue<br>+-build<br>|---index.html<br>|-webpack.config.json</code></span></p>
		<p>Ну или что-то в этом духе. Не знаю, как тебе удобнее будет</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br>Надеюсь достаточно наглядно</p>
	</div>
	<div>
		<p><b>wrewolf:</b> <tt>(Feb 16, 2016)</tt><br>типа того, а еще вариант с гит, папка то исключена и в продакшене просто не делать npm install, а js css уже собранны</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br>Только учти, что index.html никак никем не обрабатывается, т.е. он должен быть сразу на нужном месте или какой-то отдельный скрипт, который его туда скопирует. Еще можно посмотреть в сторону таких сборщиков как gulp, но это уже как по мне как-то перебор, иметь две билд системы в одном проекте. Вероятно для этого также придумали какой-то специальный лоадер для вебпака или еще чего...</p>
	</div>
	<div>
		<p><b>wrewolf:</b> <tt>(Feb 16, 2016)</tt><br><em><b>gomzik:</b> Только учти, что index.html...</em><br>это я понимаю</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br><em><b>wrewolf:</b> типа того, а еще вариант с гит...</em><br>Ну опять же, это этап сборки, а не работы в продакшене. Типа сначала происходит процесс сборки, где и будет <code>npm install; webpack -p</code> пакуется это все в какой-то пакет (да хоть зип) и этот пакет уже выливается в продакшен и раскладывается в те места, где их ждет тот же nginx</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br>В общем случае как-то так</p>
	</div>
	<div>
		<p><b>wrewolf:</b> <tt>(Feb 16, 2016)</tt><br><em><b>gomzik:</b> Ну опять же, это этап сборки...</em><br>ну вот как раз я и имею в виду упрощение выкладки. т.е. грубо webpack -wd отладка. а git pre-commit script webpack -p, тогда преобразует и положит в коммит продакшен версию</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br><em><b>wrewolf:</b> ну вот как раз я и имею в виду...</em><br>Можно конечно и так, я просто считаю, что держать автоматически с генерированные файлы в VCS несколько не правильно и все. Мои личные предрассудки. Но вижу, что мысль ты уловил.</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br><em><b>wrewolf:</b> ну вот как раз я и имею в виду...</em><br>Из опыта говорю. Когда работает много людей над проектом, тебе просто надоедает резолвить эти файлы как конфликты. Да, там всего то достаточно сгенерить по новой и добавить их в коммит, но даже это надоедает после n-го раза</p>
	</div>
	<div>
		<p><b>wrewolf:</b> <tt>(Feb 16, 2016)</tt><br><em><b>gomzik:</b> Из опыта говорю...</em><br>да, ты прав. это скорее в after pull скрипт класть, генерацию верных ассетов.<br>до этого я только с самописными движками на пхп работал, там все ассерты были в виде отдельных файлов, максимум минификатор стоял, который сам при запросе определял есть ли собранная копия и если нужно собирал ее.</p>
	</div>
	<div>
		<p><b>gomzik:</b> <tt>(Feb 16, 2016)</tt><br><em><b>wrewolf:</b> да, ты прав...</em><br>Ну вот и разобрались. Замечательно как.</p>
		<p>В целом хочу сказать, что сейчас все тулы для фронтенда "находятся" в node.js, его чураться в современном девелопменте - значит быть слепым. Так что вот.</p>
	</div>
</section>
	
<p class="dr">Feb 16, 2016 / GomZik's Blog</p>
	
</article>		
		
</body>
</html>