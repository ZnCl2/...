{
	"title": "编程狗的博客",
	"description": "Linux和Java爱好者",
	"links": "",
	"next_post_id": 21,
	"demo": false,
	"modified": 1486882415,
	"post": [
		{
			"post_id": 20,
			"title": "博客通告：我对自己博客的评论限额已满，调整后自己无法回复评论",
			"date_published": 1486804067.37,
			"body": "这是一个由签名问题导致的错误，本文描述如何找到的bug并且写一点对zeroblog如何工作的看法。\n\n---\n\n## 问题描述\n\n~~估计这是一个zeronet的bug，暂时没有时间去调试，~~现在的症状是自己没办法在自己的博客上使用评论功能了 :( 不过别人可以来评论。\n\n## 解决过程\n\n更新，debug了一下，找到了自己无法评论的原因，并且修正。\n\n发布评论的时候会报下面的一个错误：\n```json\n{'to': 4, 'cmd': 'response', 'error': 'File invalid'}\n```\n这是在文件发布的时候报出来的，\n```coffeescript\n            @cmd \"sitePublish\", {\"inner_path\": inner_path}, (res) =>\n                if res == \"ok\"\n                    cb(true)\n                else\n                    cb(res)\n\n```\n这个res不`ok`,报了一个错误：\n```javascript\n{ error: \"Content publish failed.\" }\n```\n前端在给后端发请求的时候报了这个错误，因此这个错误肯定是后端报的，因此开始翻python源码，发现这个错误来自于Ui/UiWebsocket.py:\n\n```python\n    def doSitePublish(self, site, inner_path):\n        def cbProgress(published, limit):\n            progress = int(float(published) / limit * 100)\n            self.cmd(\"progress\", [\n                \"publish\",\n                _[\"Content published to {0}/{1} peers.\"].format(published, limit),\n                progress\n            ])\n        diffs = site.content_manager.getDiffs(inner_path)\n        back = site.publish(limit=5, inner_path=inner_path, diffs=diffs, cb_progress=cbProgress)\n        if back == 0:  # Failed to publish to anyone\n            self.cmd(\"progress\", [\"publish\", _[\"Content publish failed.\"], -100])\n        else:\n            cbProgress(back, back)\n        return back\n```\n这个函数被Ui/UiRequest.py调用，又被Ui/UiServer.py调用，发现消息被UiServer通过Site.SiteManager给发送出去，发送过程如下：\n```python\n            for retry in range(2):\n                try:\n                    with gevent.Timeout(timeout, False):\n                        result = peer.request(\"update\", {\n                            \"site\": self.address,\n                            \"inner_path\": inner_path,\n                            \"body\": body,\n                            \"diffs\": diffs,\n                            \"peer\": (my_ip, my_port)\n                        })\n                    if result:\n                        break\n                except Exception, err: \n                    self.log.error(\"Publish error: %s\" % Debug.formatException(err))\n                    result = {\"exception\": Debug.formatException(err)}\n\n```\n这个意思是多发几次，不成功就报错。看来错误原因不出在publish的环节上，那么应该是对方不接收这么发送的文件了。\n\nSite.downloadContent函数在下载之前要验证content.json ,\n\n```python\n                diff_success = False\n                diff_actions = diffs.get(file_relative_path)\n                if diff_actions and self.bad_files.get(file_inner_path):\n                    try:\n                        new_file = Diff.patch(self.storage.open(file_inner_path, \"rb\"), diff_actions)\n                        new_file.seek(0)\n                        diff_success = self.content_manager.verifyFile(file_inner_path, new_file)\n                        if diff_success:\n                            self.log.debug(\"Patched successfully: %s\" % file_inner_path)\n                            new_file.seek(0)\n                            self.storage.write(file_inner_path, new_file)\n                            self.onFileDone(file_inner_path)\n                    except Exception, err:\n                        self.log.debug(\"Failed to patch %s: %s\" % (file_inner_path, err))\n                        diff_success = False\n\n                if not diff_success:\n                    # Start download and dont wait for finish, return the event\n                    res = self.needFile(file_inner_path, blocking=False, update=self.bad_files.get(file_inner_path), peer=peer)\n                    if res is not True and res is not False:  # Need downloading and file is allowed\n                        file_threads.append(res)  # Append evt\n\n\n```\n\n## 问题原因\n看了一下自己的content.json，原来是没有签名成功，为啥没前面成功呢？因为只签名了content.json而没有签名data/users/content.json,真是坑爹啊！\n现在只要更新下网站就可以同步评论内容了。\n\n## 结束\n\n稍微总结下zeroblog的工作模式：zeroblog前端整个是由一个html嵌套iframe的，iframe给外面的html进行信息交互，最后信息被发到python后端。python后端把信息发给远端的peers，接收远端peers的response或处理request。有时间再进一步研究zeronet源码，写一篇源码分析的文章。",
			"tags": "博客通告,bug"
		},
		{
			"post_id": 19,
			"title": "如何让博客动起来:编程语言javascript",
			"date_published": 1486389513.674,
			"body": "<font size='6'>编</font>程语言javascript不仅仅停留在样式与内容的层面上，它让样式与内容动起来。所谓动起来，就是以某种方式展现样式与内容，至于哪种方式，完全交给了作者。本文不可能教给你所有的javascript语法甚至连基本的语法也很难叙述完，本文只是一个javascript入门。\n\n---\n\n## 什么是javascript？\n\n\njavascript是一种编程语言，但编程语言又是什么呢？\n\n先来个事例，点击下面：\n\n<button onclick='clickButton()' >请点击按钮 </button>\n<p id='buttonText'  ></p>\n<script>\nfunction clickButton(){\n       var data = '按钮一旦被点击，就会调用一个函数，这个函数再把这句话显示出来。同时这个函数把这句话变成蓝色。';\n\tdocument.getElementById(\"buttonText\").innerHTML = data;\n\t\n\tdocument.getElementById(\"buttonText\").style.color = \"blue\";\n\t\n}\n</script>\n\n\n下面是源码，源码有注释：\n\n```javascript\n<button onclick='clickButton()'> 请点击按钮 </button> <!--这一行对应一个按钮-->\n<p id='buttonText'  ></p>  <!--这一行用来显示内容，默认显示空-->\n\n <!--这一段就是javascript-->\n<script>\nfunction clickButton(){\n\tvar data = '按钮一旦被点击，就会调用一个函数，这个函数再把这句话显示出来。同时这个函数把这句话变成蓝色。'; //这一行定义数据\n\tdocument.getElementById(\"buttonText\").innerHTML = data;//这一行把id=buttonText的html填上内容\n\tdocument.getElementById(\"buttonText\").style.color = \"blue\";//这一行改变id=buttonText的html的样式\n}\n</script>\n\n```\n上面的事例是javascript`处理数据`的一个过程。然而编程语言还做些其他的事情。核心有三，\n\n* 我们给它数据\n* 它处理数据\n* 它把处理完的数据交给我们\n\n这三步中，第一步和第三步就是一个数据传输的过程，对程序来说就是**读和写**。由于经常和外界交互，这是一个**不纯粹**的过程。而第二步处理数据，没有和外界的交互，是一个**纯粹**的过程。\n\n从外界**读取数据**，然后**处理数据**，最后**写入数据**，就是程序。人写程序，就是编程。\n\n简单讲，javascript就是能用来`处理数据`（内容与形式）的编程语言。\n\n\n\n## 如何编写javascript？\n\n\n由于javascript本身只具有`处理数据`的功能，而没有`读取数据`和`写入数据`的功能，学习javascript自然简单了不少。\n\n\n\n下面是编写javascript的一个例子：\n\n```javascript\n//定义add函数\nvar add = function (value1,value2){\n\tvar result=value1+value2;\n\treturn result;\n}\n//执行add函数\nvar res1 = add(1,2);\nvar res2 = add(20,14);\n\n//打印结果\nconsole.log(\"------------------add函数的结果----------------\");\nconsole.log(res1);\nconsole.log(res2);\nconsole.log(\"---------------------------------------------\");\n```\n<script>\n\n//定义add函数\nvar add = function (value1,value2){\n\tvar result=value1+value2;\n\treturn result;\n}\n//执行add函数\nvar res1 = add(1,2);\nvar res2 = add(20,14);\n\n//打印结果\nconsole.log(\"------------------add函数的结果----------------\");\nconsole.log(res1);\nconsole.log(res2);\nconsole.log(\"---------------------------------------------\");\n\n</script>\n\n上面的程序在本问加载的过程中就执行了，请点击`f12`（有些电脑要点击`fn`+`f12`），选择`console`或者`控制台`查找`add函数的结果`那句话，查看程序执行结果。\n\n### javascript语法\n\n下面讲解一下上面程序用到的语法。\n\n\n\n**var定义变量或函数**\n\n`var` 后面跟着变量名或者函数的名字，一旦定义了一个变量或者函数的名字，就可以用这个变量或名字了。\n\n**变量**\n\n变量就是一个`值`，值可以是一个`数字`，`字符串`，`数组`等，比如：\n\n```javascript\nvar num1 = 1000;//数字\nvar num2= 55.66;//数字\nvar str1 = \"hello\";//字符串\nvar str2 = \"字符串\";//字符串\nvar arr1 = [1,2,3,4];//数组\nvar arr2 = [\"字符串1\",\"字符串2\"];//数组\n```\n\n关于javascript支持的更多变量请见[这里](http://www.w3schools.com/js/js_datatypes.asp)。\n\n\n**函数**\n\n函数就像一个黑盒子，你给它**传入值**，它**处理值**，最后它**返回值**（就是把值输出出来）。`add`函数的传入值有两个，`value1`和`value2`。在函数的大括号里面，`add`函数把两个值`相加`处理，得到结果`result`，用`return`语法把处理结果返回出去。\n\n所谓返回出去，就是执行函数的时候，把函数本身替换成函数执行的结果。\n\n比如`var res1 = add(1,2)`，`add(1,2)`就是执行函数，执行函数的结果是`3`,表达式就变成了 `var res1 = 3`，于是，`res1`的结果是3。（请打开控制台查看）。\n\n\n**判断**\n\nif是如果的意思，else是否则的意思。比如：\n\n```javascript\nconsole.log(\"----------关于判断----------\");\nvar num = 100;\nif(num>99){\n\tconsole.log(\"进入if\");\n}else{\n\tconsole.log(\"进入else\");\n}\nconsole.log(\"---------------------------\");\n```\n<script>\nconsole.log(\"----------关于判断----------\");\nvar num = 100;\nif(num>99){\n\tconsole.log(\"进入if\");\n}else{\n\tconsole.log(\"进入else\");\n}\nconsole.log(\"---------------------------\");\n</script>\n\n请打开控制台查看结果。\n\n关于判断，更多请看[这里](http://www.w3schools.com/js/js_if_else.asp)。\n\n**循环**\n\n所谓循环，就是不停干某事。 比如：\n\n```javascript\nconsole.log(\"-----------关于循环------------\");\nvar count = 0;\nwhile(count < 10){\n\tcount=count+1;\n\tconsole.log(\"循环一次:\"+count);\n}\nconsole.log(\"------------------------------\");\n```\n\n<script>\nconsole.log(\"-----------关于循环-------------\");\nvar count = 0;\nwhile(count < 10){\n\tcount=count+1;\n\tconsole.log(\"循环一次:\"+count);\n}\nconsole.log(\"------------------------------\");\n</script>\n\n打开控制台，能看到`循环一次`被打印了10次。\n\n`while`的语法是while后面写上一个条件，条件后面跟着要做的事情，如果条件满足，就再做一遍，否则停止做。比如本例while后面的条件是count<10,刚开始count为0,因此满足这个条件，然后执行大括号里面的内容，count把自己加1,又赋值给count，打印“循环一次”，然后又重新判断条件count<10是否满足，以此类推直到最终不再满足条件，while循环停止。\n\n关于循环，更多请看[for循环](http://www.w3schools.com/js/js_loop_for.asp)和[while循环](http://www.w3schools.com/js/js_loop_while.asp)。\n\n\n**console.log**\n\nconsole.log是一个函数（这个函数不属于原生javascript，而属于外界提供的数据读写相关的函数），传入值放在括号里面，处理数据的过程就是打印数据，没有返回值。\n\n\n**推荐资源**\n\n学习javascript语法对学好javascript很重要，关于javascript语法更多可参见[w3chool-js](http://www.w3schools.com/js/default.asp)。请读者多加练习。\n\n### 其他\n\n关于javascipt，不仅仅是语法而已，下面暂提几点，考虑到本文的入门性质，就不展开了。\n\n- javascript面向对象编程\n- javascript函数式编程\n- javascript异常和错误\n- javascript事件\n- javascript操作DOM和BOM\n- javascript处理json\n- javascript处理表单\n\n\n## 为什么学习javascript？\n\n如果html是一片叶子，那么javascript就是一阵风，风吹叶纷飞。javascript作为编程语言，用来处理html，目的就是让html像风中的叶子动起来。这就是为什么要学习javascript。\n\n\n## 结束\n\n本文仅简单介绍了javascript，并没有示例如何用javascript操作html，做到动起来的效果，这一部分将放到附录。\n\n",
			"tags": "js,编程"
		},
		{
			"post_id": 17,
			"title": "[博客通告]：给ZeroBlog增加阅读量,标签,搜索功能,其他优化",
			"date_published": 1483435264.301,
			"body": "元旦期间，给ZeroBlog增加了`阅读量`，`标签`和`搜索`功能，稍微美化界面并更改了布局。\n\n我是在`coffeescript`代码的基础上增加了这些功能。大家可以点开[首页](http://127.0.0.1:43110/1Ld63vNnfm5SEUTbsYxB7XGo7kHQVUGghU/)体验一下。在体验之前，注意以下，**否则可能看不到更新的效果**，\n\n* 请把右上角的那个0拖住往左拽，点击`更新（Update）`点击`重建（Rebuild）`和`重载（Reload）`。这是因为我对ZeroBlog做了大量改动，如果不更新可能看不到最新效果，我给数据库添加了新的表，更改了表结构，如果不重载或着重建也可能看不到最新的效果。不过请放心，这个动作**不会影响**你自己ZeroNet。更新可能很漫长，请耐心等待。\n\n---\n\n* 如果你发现任何bug，可以在评论区反馈给我，或给我发[ZeroMail](http://127.0.0.1:43110/Mail.ZeroNetwork.bit/?to=programdog)。先行谢过。\n\n* 匿名评论功能一直没有实现。\n\n下面说一下我实现以上功能的思路，等我把代码整理一下，再开源到Github。\n\n## 阅读量\n\n这个比较简单，只需要分析被点击的链接，并记录下来，然后展示到标题下面即可。\n\n## 搜索\n\n搜索功能的实现依赖于本地数据库，最粗暴的方法，直接用select **like**匹配关键词。返回的结果后根据匹配程度打分，权重分别为\n\n```\n标签>标题>文本内容>阅读次数\n```\n\n最后根据打分结果排序并且展示。\n\n## 标签\n\n标签的实现方式依赖于`搜索`，每个标签只需要加上href的值：`?Search:keyword`,比如点击下面链接搜索**linux**标签\n\n[linux标签](http://127.0.0.1:43110/1Ld63vNnfm5SEUTbsYxB7XGo7kHQVUGghU/?Search:linux)\n\n## 其他优化\n\n* 评论回复默认【不引用】回复对象的全部内容，而是以【@用户名】的方式回复。点击被@的人可以跳到该评论。\n* 浏览器窗口变小后窗口文字自动调整，便于小窗口阅读。\n\n",
			"tags": "博客通告"
		},
		{
			"post_id": 6,
			"title": "如何用zeronet优雅地写博客",
			"date_published": 1483195097.896,
			"body": "\n\n大家都知道ZeroNet的抗封锁的好处，但是很多站长也在抱怨ZeroNet写blog的时候遇到了不少麻烦。比如，ZeroNet支持在程序员看来很火的markdown语法，但似乎仅仅对程序员是个好事。**考虑到授之于渔更好一点，本系列不会罗列操作步骤，而是重在理解。**我将介绍一些在ZeroNet入门的知识，帮助大家度过这个槛。本系列有三篇:\n\n\n1.[写作方式的革命:markdown与html](http://127.0.0.1:43110/1Ld63vNnfm5SEUTbsYxB7XGo7kHQVUGghU/?Post:4:)\n2.[让博文五彩缤纷:css入门](http://127.0.0.1:43110/1Ld63vNnfm5SEUTbsYxB7XGo7kHQVUGghU/?Post:5:)\n3.[如何让博客动起来:编程语言javascript](http://127.0.0.1:43110/1Ld63vNnfm5SEUTbsYxB7XGo7kHQVUGghU/?Post:19:)\n附录：\n1.如何让博客美观大方：html布局简介\n2.如何让博客美观大方：css进阶\n3.如何让博客动起来:编程语言javascript操作html\n4.如何让博客动起来:编程语言coffeescript\n\n\n关于本专题更加深入的部分，有时间另开系列。",
			"tags": "html,js,css,markdown,编程"
		},
		{
			"post_id": 5,
			"title": "让博文五彩缤纷:css入门",
			"date_published": 1482677672,
			"body": "\n\n\n\n\n<font size=7>色</font>彩是迷人眼的，虽然色彩背后的内容才能真正打动人心。不过，好的色彩依然重要。上一篇讲到，我们用html修饰内容从而使内容五彩缤纷，我们可以给内容添加众多属性，使其更加异彩纷呈。但是在标签里面添加的属性及其属性组合是没办法复用的。比如我们给所有的链接添加绿色，如本博客所示，有多少链接就得写多少个`color='green'`。不过**css**却可以根据html标签的属性，批量应用属性，五彩斑斓，唾手可得。\n\n---\n\n\n<a href=#here>点击跳回</a>\n<div id='totop'></div>\n\n## 什么是css？\n\n**css**是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言。也就是说，**css是专门用来修饰内容的**。\n\n\n我们先考察一下html的这个效果。\n\n```html\n<font size=1>1号</font>\n<font size=3>3号</font>\n<font size=5>5号</font>\n<font size=7>7号</font>\n<font size=9>9号</font>\n<font size=9>11号</font>\n```\n<div style='background-color:grey'>\n<font size=1>1号</font>\n<font size=3>3号</font>\n<font size=5>5号</font>\n<font size=7>7号</font>\n<font size=9>9号</font>\n<font size=9>11号</font>\n</div>\n\n请仔细观察，size分别为1,3,5,7,9,11号字体，但是显示的效果却字体是1到7依次变大，7,9,11号字体一样大？为什么？\n\n原因很简单，`font`标签只接受1~6号字体，不接受其他号字体，如果号大于6,则都按照6号计算。`font`的`size`属性是内置的，自然而然，不可能穷举无限大字体。\n\n我们引入`px`的概念。`px`意为像素，就是差不多毫米大的小点，比如现在笔记本的屏幕大小可能是`1024x768`,就是说屏幕横着有1024个点，竖着有768个点。每个小点被赋予的颜色，从而把屏幕渲染的五彩缤纷。\n\n如果让字体变大，只需要让字体多占用几个`px`就可以了。\n\n```html\n<font style='font-size:100px'>100px</font>\n```\n<div style='background-color:grey'>\n<font style='font-size:100px'>100px</font>\n</div>\n\n读者可以体会到，100px有多大。\n\n**`style`属性就是的`css`**。\n\n\n## 如何使用css？\n\n`style`可以直接作为一个属性修饰html，如前所示。也可以*脱离*html标签，这是css的优势所在。\n\n### 一个简单的例子\n\n```html\n<style>\np{\n    font-size: 100px;\n}\n</style>\n\n<p>脱离html标签使用css</p>\n<p>即使是第二个自然段也会被修饰</p>\n不在p标签使用范围内的不会被修饰\n\n\n```\n\n<a href='simple.html' target='_black'>查看效果</a>\n\n### id和class\n\n#### id\n\n问题来了，如果我仅仅想修饰特定的标签，而不是所有标签怎么办？这个时候你可以给你的标签一个标志`id`，然后在css里面\"定制\"样式。\n\n```html\n\n<style>\n#showred{\n    color:red;\n}\n#showgreen{\n    color:green;\n}\n\n</style>\n\n<div id='showred'>\n里面全部是红色\n</div>\n<div id='showgreen'>\n里面全部是绿色\n</div>\n<div >\n里面全部是默认的颜色\n</div>\n```\n\n<a href='id.html' target='_black'>查看效果</a>\n\ncss中用`#`号加上`id`名字代表被修饰的`id`。\n\n#### 利用id跳到文章顶部\n\n`id`在html中指一个特定并且唯一位置，也就是说，在一个html页面中，不允许有两个`id`(如果多余一个id，可能只有一个id起作用)。\n\n这样，id就可以被用来指定html中的一个特定的位置，比如你可以点击下面的链接跳到文章顶部。\n\n<a href=#totop>点击跳到文章顶部</a>\n<div id='here'></div>\n\n在文章顶部有一个点击跳回的按钮，可以跳回来。\n\n#### class\n\n`id`只能标记html标签的一处。但是如果想同时标记多处，就可以用`class`属性。\n\n\n```html\n\n<style>\n.showred{\n    color:red;\n}\n.showgreen{\n    color:green;\n}\n\n</style>\n\n\n\n<div class='showred'>\n里面全部是红色1\n</div>\n<div class='showred'>\n里面全部是红色2\n</div>\n<div class='showgreen'>\n里面全部是绿色\n</div>\n<div >\n里面全部是默认的颜色\n</div>\n```\n\n<a href='class.html' target='_black'>查看效果</a>\n\ncss中用`.`号加上`class`名字代表被修饰的`class`。\n\n`class`在html中被标记的标签上起作用，也就是说，在一个html页面中，允许有多个`class`。\n\n#### 利用class动态添加属性\n\n我们可以利用class**动态地**给html添加属性。思路是这样的，提前写好一个属性，比如字体显示蓝色，通过一个事件，比如点击某按钮或链接，给字体加上这个class，这样字体就**动态地**变成蓝色。\n\n\n```html\n<style>\n\t.blue {\n\t\tcolor:blue;\n\t}\n\t .tored{\n        color:red;\n    }\n\n</style>\n<div id='thetarget' style='background-color:gray'>\n\t这里是目标文字，就要变色。\n</div>\n<script>\n    function toblue(){\n        document.getElementById(\"thetarget\").className='toblue';\n    }\n    function tored(){\n        document.getElementById(\"thetarget\").className='tored';\n    }\n\n</script>\n\n<button onclick=\"toblue()\">to blue</button>\n<button onclick=\"tored()\">to red</button>\n\n```\n<a href='sysclass.html' target='_black'>查看效果</a>\n\n这里用了一点js，不过没关系，这非常简单，后面会讲解js。\n\n\n更加深入的css知识放到附录或者评论区，或请访问[w3shool](http://www.w3schools.com)。\n\n## 为什么使用css？\n\n* 优点一： 内容和形式剥离。在操作html标签的时候不用关心样式，这样就可以给页面更改样式而不用动html。这是word所很难办到的。\n* 优点二：批量添加形式。`class`的使用促成这一点，这导致了结合js可以创造出不仅丰富而且动态的页面。\n* 优点三：格式单一，便于程序处理。和html一样，这是他们共有的优点。\n\n## 结束\n\n本文简单介绍了css的核心`id`和`class`，掌握了这些学习css就很容易了。接下来我们要学习js，制造点动态的效果。\n\n",
			"tags": "css,编程"
		},
		{
			"post_id": 4,
			"title": "写作方式的革命：markdown与html",
			"tags": "markdown,html,编程",
			"date_published": 1482498914,
			"body": "\n\n<font size='100'>想</font>必大多数读者都用过微软的**Office Word**,**Word**和纯文本的区别在于Word可以赋予文本以形态，让文字拥有格式，还可以把文字和图片视频穿插，从而图文并茂。然而这一切只需要托托拽拽就可以了。比较著名的网页博客比如**wordpress**都提供了类似于**Word**的编辑器，但是为什么ZeroNet没有呢？这是因为已经有了**更加漂亮更加简单更加稳定的**的编辑器**html与markdown**了。\n\n---\n\n## 什么是html？\n\n\n简而言之,[html](http://www.w3schools.com/html/html_intro.asp)是一种标记性语言，设计目的和**Word**一样，是用来展示图文。只不过html多用在**网页浏览器**里，**Word**都用在日常办公。html在css和js的帮助下可以做出极其绚丽的画面。你看到的本页面就是用html写出来的。\n\n\n## 如何使用html？\n\n\nhtml的语法相当简单，你只需要画上15分钟就可以掌握要领，写出还算不错的界面。当然考虑到本文目的是教读者如何修改或者写少量的html，下面边举例子边讲解。读者可以自己在自己的博客上边看边练。\n\n\n### 标签和样式\n\n\n最简单的html就是用一对尖括号包着被修饰的文字。如下所示,\n\n```html\n<p>html的最简单的形式</p>\n```\n\n上面用字母**p**代表段落的意思。因此被修饰的文字就是一个自然段，不同段落之间会自动加上行间距。\n\n```html\n<p>ZeroNet是自由的网。</p>\n<p>ZeroNet是无法被封锁的网。</p>\n<p>ZeroNet是真正的互联网。</p>\n```\n\n显示如下：\n\n<div style='background-color:grey'>\n<p>ZeroNet是自由的网。</p>\n<p>ZeroNet是无法被封锁的网。</p>\n<p>ZeroNet是真正的互联网。</p>\n</div>\n\n标签不会被显示，文字用来被显示。**因此标签的作用是修饰，内容的作用是被显示。**\n\n下面再举一个把内容变成粉红色的标签,\n\n```html\n<font color='pink'>html就是用尖括号包裹被修饰的文字。</font>\n```\n\n显示如下：\n\n<div style='background-color:grey'>\n<font color='pink'>html就是用尖括号包裹被修饰的文字。</font>\n</div>\n\n\n一对html标签上可以加上**属性**<font color='red'>color='pink'</font>修饰，使内容样式改变。\n\n一对标签上可以加多个**属性**，比如,\n\n```html\n<font color='pink' size='6'>一对标签多个属性</font>\n<a href=\"http://www.w3schools.com\" alt=\"W3School\" target='_black' > 查询更多html标签请到w3schools </a>\n```\n\n显示效果如下,\n\n<div style='background-color:grey'>\n<font color='pink' size='6'>一对标签多个属性</font>\n<a href=\"http://www.w3schools.com\" alt=\"W3School\" target='_black' > 查询更多html标签请到w3schools </a>\n</div>\n\n\n更多的例子将会放到附录或者评论区。\n\n\n## 什么是markdown？\n\nmarkdown因为html而生，是一个更容易书写的html中间语言。虽然html可以非常简单的赋予内容以形式，但是内容之间标签过多反而使内容支离破碎。读者可以看下面的html，是本文html的一部分,\n\n```html\n<h1 id=\"-markdown-html\">写作方式的革命：markdown与html</h1>\n<p><font size=\"100\">想</font>必大多数读者都用过微软的<strong>Office Word</strong>,<strong>Word</strong>和纯文本的区别在于Word可以赋予文本以形态，让文字拥有格式，还可以把文字和图片视频穿插，从而图文并茂。然而这一切只需要托托拽拽就可以了。比较著名的网页博客比如<strong>wordpress</strong>都提供了类似于<strong>Word</strong>的编辑器，但是为什么ZeroNet没有呢？这是因为已经有了<strong>更加漂亮更加简单更加稳定的</strong>的编辑器<strong>html与markdown</strong>了。</p>\n<h2 id=\"-html-\">什么是html？</h2>\n<p>简而言之,<a href=\"http://www.w3schools.com/html/html_intro.asp\">html</a>是一种标记性语言，设计目的和<strong>Word</strong>一样，是用来展示图文。只不过html多用在<strong>网页浏览器</strong>里，<strong>Word</strong>都用在日常办公。html在css和js的帮助下可以做出极其绚丽的画面。你看到的本页面就是用html写出来的。</p>\n```\n\n想必写着很不舒服吧。不过上面的文字可以由下面的文字翻译而来，翻译过程是自动的。\n\n```markdown\n# 写作方式的革命：markdown与html\n\n<font size='100'>想</font>必大多数读者都用过微软的**Office Word**,**Word**和纯文本的区别在于Word可以赋予文本以形态，让文字拥有格式，还可以把文字和图片视频穿插，从而图文并茂。然而这一切只需要托托拽拽就可以了。比较著名的网页博客比如**wordpress**都提供了类似于**Word**的编辑器，但是为什么ZeroNet没有呢？这是因为已经有了**更加漂亮更加简单更加稳定的**的编辑器**html与markdown**了。\n\n\n## 什么是html？\n\n\n简而言之,[html](http://www.w3schools.com/html/html_intro.asp)是一种标记性语言，设计目的和**Word**一样，是用来展示图文。只不过html多用在**网页浏览器**里，**Word**都用在日常办公。html在css和js的帮助下可以做出极其绚丽的画面。你看到的本页面就是用html写出来的。\n```\n\n这个语言就是markdown。\n\nmarkdown极其接近自然语言，只需要几个特殊的符号就可以赋予内容以形式，上面markdown里面嵌入的font标签说明，markdown支持html嵌入。\n\n## 如何使用markdown？\n\nmarkdown依然沿袭那一条简单的定律，用标签修饰内容。\n\n不过markdown里面的标签不是规律的成对，但是记住常用的几个标签就足以有一个漂亮的格式。\n\n### 标题\n\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n...\n以此类推\n```\n\n**#**号就代表标题级别，是一种修饰符号，可以使字体变大，如本文题目:\n\n```markdown\n# 写作方式的革命：markdown与html\n## 写作方式的革命：markdown与html\n### 写作方式的革命：markdown与html\n```\n显示效果,\n\n<div style='background-color:grey ' >\n<h1>写作方式的革命：markdown与html</h1>\n<h2>写作方式的革命：markdown与html</h2>\n<h3>写作方式的革命：markdown与html</h3>\n</div>\n\n\n### 链接和图片\n\nhtml中用a标签修饰链接，markdown这样修饰链接:\n\n```markdown\n[显示的名字](https://www.google.com \"鼠标放上去的提示（可选）\")\n```\n\n显示效果,\n\n<div style='background-color:grey ' style='color:pink'>\n\n[显示的名字](https://www.google.com \"鼠标放上去的提示（可选）\")\n\n</div>\n\n\n\n显示图片的方式和显示链接相似:\n\n```markdown\n![图片未加载前显示的名字](https://upload.wikimedia.org/wikipedia/commons/e/ec/Terrier_mixed-breed_dog.jpg  \"鼠标放上去的提示（可选）\")\n```\n\n\n![dog](https://upload.wikimedia.org/wikipedia/commons/e/ec/Terrier_mixed-breed_dog.jpg  \"dog\")\n\n\n\n### 文字修饰\n\n文字修饰就是对特定的字进行修饰，比如,\n\n```markdown\n*斜体*\n**加粗**\n`标记`\n```\n\n显示效果,\n<div style='background-color:grey ' >\n\n*斜体*\n**加粗**\n`标记`\n\n</div>\n\n\n\n### 区块\n\n本文被嵌套代码的区域就是一个区块,比如,\n\n\n<div style='background-color:#F9EDCC ' >\n\n\\```\nhtml的语法相当简单，你只需要画上15分钟就可以掌握要领，写出还算不错的界面。当然考虑到本文目的是教读者如何修改或者写少量的html，下面边举例子边讲解。读者可以自己在自己的博客上边看边练。\n\\```\n\n</div>\n\n显示效果,\n\n```\nhtml的语法相当简单，你只需要画上15分钟就可以掌握要领，写出还算不错的界面。当然考虑到本文目的是教读者如何修改或者写少量的html，下面边举例子边讲解。读者可以自己在自己的博客上边看边练。\n```\n\n\n### 表格\n\n用markdown显示表格也很简单。\n\n```markdown\n| 标题1| 标题1 | 标题1 |\n| -------| ------ | ------- |\n| html | word | mardkown |\n| 写作方式的革命| zeronet | 抗封锁 |\n```\n\n显示效果,\n\n| 标题 1| 标题1 | 标题1 |\n| -------| ------ | ------- |\n| html | word | mardkown |\n| 写作方式的革命| zeronet | 抗封锁 |\n\n\n每一竖列之间用`|`号隔开，标题和内容之间用`| -------| ------ | ------- |`隔开，这里的`-`可以是任意个。\n\n\n更多内容参见[Github](https://guides.github.com/features/mastering-markdown/)。\n\n\n## 为什么使用html和markdown？\n\n知道了html和markdown是什么和如何简单使用，下面讲一讲为什么使用它们？\n\n### html的优点\n\n* **优点一:**结构简单。html的核心就是用尖括号包裹被修饰的内容，相比word是实现机制要简单的多（docx格式的word内容放在xml里面，但你还是很难离开office写一个word文件）。其结构简单就便于书写和解析。\n* **优点二:**灵活性大。虽然html结构很简单，但是html可以组合出很复杂的页面。即使复杂的结构，修改起来也非常简单。\n* **优点三:**因为其简单灵活，很容易用程序批量操作。现在前端技术有了很大进步，做出很漂亮的界面甚至不需要亲自改动html，大多数工作都是通过其他编程语言(如js)组合html完成。\n* **优点四：**跨平台性。html可以在任何支持网页浏览器的地方运行，自然决定了html到处可以展示。相比来说word却更加局限于windows，word在apple，linux和安卓系统上，微软的word显得很不给力。\n\n正是html的这些优点使html大为流行。当今html已经不仅仅生存在网页浏览器中，它被运用到其他方面，比如正在通过markdown来侵蚀word的地位。\n\n### 用html和markdown写博客的优势\n\n至于写博客，为什么要用html和markdown呢？除了其简单美观之外，更重要的是它们可以和编程语言如js结合，实现很复杂的样式，进行批量操作，甚至可以做出动态的文字效果。这一点通过后面文章的介绍才可以显现。\n\n## 结束\n\n本文介绍html和markdown就到这里。当然markdown除了简单美观外，还更容易存储（相比word这个二进制文件），容易跟踪变化（见git），样式稳定等。markdown是提高书写效率的极其被推荐的工具。\n\n生活在网络时代，网络上大多数工具包括word在内都是程序员发明的，既然程序员要发明这个生产工具，并且在用这个工具用的不亦乐乎（讽刺的是，貌似程序员发明了word却不太喜欢用word），自然有其原因，今天这篇文章就是在讲述原因——这些工具确实好用。除此之外还说明不停制造生产工具的程序员是有产阶级，既然如此，也肯定不傻。\n\n\n\n"
		},
		{
			"post_id": 3,
			"title": "[Linux Net]:3 如何用wireshark和tcpdump抓包 ",
			"date_published": 1482248872.653,
			"tags": "抓包,linux,编程",
			"body": "<font size=100>网</font>络管理员都应掌握抓包的技能，学会用**wireshark**或**tcpdump**调试网络错误。要学习Linux网络，务必多动手抓包，本章意在教你如何抓包。\n\n\n![黑客帝国字幕雨](https://images1-focus-opensocial.googleusercontent.com/gadgets/proxy?container=focus&resize_w=400&refresh=31536000&url=https%3A%2F%2Fi.ytimg.com%2Fvi%2FTInfxe7c7yA%2Fmaxresdefault.jpg  \"黑客帝国字幕雨\")\n\n\n---\n\n## 3.1. wireshark\n\n### 3.1.1. 安装wireshark\n\ndebian系列（包括Debian，Mint，Xubuntu等），\n\n```bash\nroot@debian8:~$ apt-get install wireshark\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\n... (output truncated)\n```\nRHEL系列（包括CentOS，Fedora等），\n\n```bash\n[root@centos7 ~]$ yum install wireshark\nLoaded plugins: fastestmirror\nLoading mirror speeds from cached hostfile\n... (output truncated)\n```\n\n### 3.1.2. 选择网口\n\n第一次打开**wireshark**之时，先选择一个网口进行抓包。如下图所示，\n\n![选择wireshark的网口](http://linux-training.be/networking/images/wireshark_capture_interfaces.png  \"选择wireshark的网口\")\n\n如果发现没有网口可供选择，请尝试**root**权限操作，可尝试**sudo wireshark**。\n\n你也可以用**tcpdump**及其他工具抓包，然后用**wireshark**分析抓包结果。\n\n### 3.1.3. 减小包缓存大小\n\n网络抓包可能短时间内产生数千个数据包，占用大量磁盘。可以采用隔离网络的方式减小抓包文件大小。如通过建立虚拟网卡过滤控制抓包流量。\n\n如果你在自己家里面学习抓包，可以关掉电脑其他程序，关掉其他联网设备，如平板手机等，从而减小抓包流量。\n\n当然，更重要的是学会过滤数据包，这正是本章要讲的。\n\n### 3.1.4. 过滤ping数据包\n\n下面是我启动抓包软件后执行了3次**ping**命令（无须root权限）。\n\n```bash\nroot@debian7:~# ping -c2 ns1.paul.local\nPING ns1.paul.local (10.104.33.30) 56(84) bytes of data.\n64 bytes from 10.104.33.30: icmp_req=1 ttl=64 time=0.010 ms\n64 bytes from 10.104.33.30: icmp_req=2 ttl=64 time=0.023 ms\n\n--- ns1.paul.local ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1001ms\nrtt min/avg/max/mdev = 0.010/0.016/0.023/0.007 ms\nroot@debian7:~# ping -c3 linux-training.be\nPING linux-training.be (188.93.155.87) 56(84) bytes of data.\n64 bytes from antares.ginsys.net (188.93.155.87): icmp_req=1 ttl=56 time=15.6 ms\n64 bytes from antares.ginsys.net (188.93.155.87): icmp_req=2 ttl=56 time=17.8 ms\n64 bytes from antares.ginsys.net (188.93.155.87): icmp_req=3 ttl=56 time=14.7 ms\n\n--- linux-training.be ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2003ms\nrtt min/avg/max/mdev = 14.756/16.110/17.881/1.309 ms\nroot@debian7:~# ping -c1 centos7.paul.local\nPING centos7.paul.local (10.104.33.31) 56(84) bytes of data.\n64 bytes from 10.104.33.31: icmp_req=1 ttl=64 time=0.590 ms\n\n--- centos7.paul.local ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.590/0.590/0.590/0.000 ms\n```\n\n总共抓到200多个包（看起来很混乱），但是尝试在filter上输入icmp协议，然后按**apply（或回车）**键，则与ping相关数据包清晰可见。\n\n![wireshark过滤icmp协议](http://linux-training.be/networking/images/wireshark_ping.png   \"wireshark过滤icmp协议\")\n\n\n### 3.1.5. 过滤ping和dns数据包\n\n抓包配置不变，只改变filter，就能同时抓取**dns**和**icmp**数据包。\n\n在**filter**输入**dns or icmp**，注意不是**dns and icmp**，不存在既是dns又是icmp的数据包。\n\n![wireshark过滤icmp或dns数据包](http://linux-training.be/networking/images/wireshark_icmpordns.png  \"wireshark过滤icmp或dns数据包\")\n\n上图中包25和26的来源和目的地都是ip 10.104.33.30,这是因为我的dns服务器和客户端都在同一台电脑上。\n\n包31和32的情况也一样。\n\n### 3.1.6. 过滤特定ip\n\n下图示例如何同时查看**dns**和一个特定ip的数据包。在**filter**输入**ip.addr==10.104.33.30 and dns**。关键词**and**表示两个条件都满足。\n\n![wireshark过滤包:and的用法](http://linux-training.be/networking/images/wireshark_ipanddns.png  \"wireshark过滤包:and的用法\")\n\n包93是**linux-training.be**的dns查询请求，包98是dns服务器的回复。那么包93到包98之间的数据包是什么呢？请先思考一下再继续阅读（尝试猜测答案然后验证猜测会很有好处）。\n\n### 3.1.7. 过滤桢（frame）\n\n更漂亮的做法是按照桢（frame）而非包（packet）来分析（因为我们在模型的第二层）抓包结果。可以用**frame.number**关键词过滤。\n\n![wireshark通过桢过滤](http://linux-training.be/networking/images/wireshark_framenumber.png  \"wireshark通过桢过滤\")\n\n### 3.1.8. 查看包详情\n\n打开折叠按钮可以看到包详情。\n\n图中我选中了我笔记本电脑的来源地址。\n\n![查看包详情](http://linux-training.be/networking/images/wireshark_source_mac.png  \"查看包详情\")\n\n注意，当在同一个网口上抓包的时候，上面的例子没有问题。但是如果用诸如**tcpdump -i any**这样的命令，在所有的网卡上同时进行抓包的时候，有可能出现[Linux cooked](https://wiki.wireshark.org/SLL) 现象（即得到一些假的或者不完整的数据）。\n\n![Linux coocked 现象](http://linux-training.be/networking/images/wireshark_cooked.png  \"Linux coocked 现象\")\n\n\n### 3.1.9. 过滤其他的包例子\n\n下图是用**or**连接两个协议的例子，过滤**arp**或**bootp（或dhcp）**的包。\n\n![wireshark过滤arp或bootp](http://linux-training.be/networking/images/wireshark_arp_bootp.png  \"wireshark过滤arp或bootp\")\n\n下面是如何过滤dns和ip地址的例子。\n\n![wireshark过滤带有特定ip的dns](http://linux-training.be/networking/images/wireshark_dns_ipaddress.png  \"wireshark过滤带有特定ip的dns\")\n\n## 3.2. tcpdump\n\n可以用tcpdump进行命令行抓包。下面举个例子。\n\n用**tcpdump host $ip**抓取特定ip的所有流量。\n\n```bash\nroot@ubuntu910:~# tcpdump host 192.168.1.38\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n```\n\n用**tcpdump tcp port $port**抓取端口22的流量。\n\n```bash\nroot@deb503:~# tcpdump tcp port 22\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth1, link-type EN10MB (Ethernet), capture size 96 bytes\n14:22:20.716313 IP deb503.local.37973 > rhel53.local.ssh: P 666050963:66605\n14:22:20.719936 IP rhel53.local.ssh > deb503.local.37973: P 1:49(48) ack 48\n14:22:20.720922 IP rhel53.local.ssh > deb503.local.37973: P 49:113(64) ack \n14:22:20.721321 IP rhel53.local.ssh > deb503.local.37973: P 113:161(48) ack\n14:22:20.721820 IP deb503.local.37973 > rhel53.local.ssh: . ack 161 win 200\n14:22:20.722492 IP rhel53.local.ssh > deb503.local.37973: P 161:225(64) ack\n14:22:20.760602 IP deb503.local.37973 > rhel53.local.ssh: . ack 225 win 200\n14:22:23.108106 IP deb503.local.54424 > ubuntu910.local.ssh: P 467252637:46\n14:22:23.116804 IP ubuntu910.local.ssh > deb503.local.54424: P 1:81(80) ack\n14:22:23.116844 IP deb503.local.54424 > ubuntu910.local.ssh: . ack 81 win 2\n^C\n10 packets captured\n10 packets received by filter\n0 packets dropped by kernel\n```\n加**-w**参数即**tcpdump -w $filename**保存抓包的结果到文件。\n\n```bash\nroot@ubuntu910:~# tcpdump -w sshdump.tcpdump tcp port 22\ntcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n^C\n17 packets captured\n17 packets received by filter\n0 packets dropped by kernel\n```\n用**tcpdump -r $filename**查看刚刚保存的文件。\n\n```bash\nroot@ubuntu910:~# tcpdump -r sshdump.tcpdump\n```\n```\n注：也可用wireshark查看\n```\n\n更多例子请参考**tcpdump**手册。\n\n## 3.3. 练习：网络抓包\n\n1.安装wireshark到你的电脑（不是安装到虚拟机）。\n\n2.ping另一台计算机。\n\n3.对网络抓包。\n\n4.用wireshark过滤，查看ping的数据包。\n\n5.ping一个域名（如www.linux-training.be）并抓dns数据包。请问：抓包结果显示，dns服务器是多少？dns协议是走的tcp还是udp？\n\n6.找一个能登陆的网站，用用户名**paul**和密码**hunter2**登陆，并抓包。然后查看相关的抓包结果。\n\n## 3.4. 答案：网络抓包\n\n\n1.安装wireshark到你的电脑（不是安装到虚拟机）。\n\n```bash\nDebian/Ubuntu: aptitude install wireshark\n```\n```bash\nRed Hat/Mandriva/Fedora: yum install wireshark\n```\n\n2.ping另一台计算机。\n\n```bash\nping $ip_address\n```\n\n3.对网络抓包。\n\n```bash\n(sudo) wireshark\n# 然后选择一个网口\n```\n4.用wireshark过滤，查看ping的数据包。\n\n```\n在filter输入 'icmp' (没有逗号) 然后点击 'apply'或回车\n```\n\n5.ping一个域名（如www.linux-training.be）并抓dns数据包。请问：抓包结果显示，dns服务器是多少？dns协议是走的tcp还是udp？\n\n```bash\n# 首先开始抓包\n# 然后过滤dns包\n# 然后ping\nroot@ubuntu910:~# ping www.linux-training.be\nPING www.linux-training.be (88.151.243.8) 56(84) bytes of data.\n64 bytes from fosfor.openminds.be (88.151.243.8): icmp_seq=1 ttl=58 time=14.9 ms\n64 bytes from fosfor.openminds.be (88.151.243.8): icmp_seq=2 ttl=58 time=16.0 ms\n^C\n--- www.linux-training.be ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1002ms\nrtt min/avg/max/mdev = 14.984/15.539/16.095/0.569 ms\n```\n\n下面是结果：\n\n![wireshark抓取dns](http://linux-training.be/networking/images/wireshark_dns_sniff.png  \"wireshark抓取dns\")\n\n上面结果显示dns走了udp协议。\n\n\n6.找一个能登陆的网站，用用户名**paul**和密码**hunter2**登陆，并抓包。然后查看相关的抓包结果。\n\n**本题请躬行:)**\n\n\n<hr/>\n## 版权声明\n\nCopyright 2016-2016 Program Dog\n\nPermission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled 'GNU Free Documentation License'.\n\n---\n\n-----\n\n\n注：\n\n1.本文由[Program Dog](https://program-dog.blogspot.com)翻译自 [http://linux-training.be](http://linux-training.be) \n\n2.本文原始链接：[https://program-dog.blogspot.com/2016/12/linux-net-char03-network-sniffing.html](https://program-dog.blogspot.com/2016/12/linux-net-char03-network-sniffing.html)\n\n<hr/>\n"
		},
		{
			"post_id": 2,
			"title": "[Linux Net]:2 如何配置Linux网卡 ",
			"tags": "网卡,linux,编程",
			"date_published": 1482248282.611,
			"body": "<font size='6'>这</font>一章介绍Linux下如何配置网卡上网。\n\n\n![网口](https://images1-focus-opensocial.googleusercontent.com/gadgets/proxy?container=focus&resize_w=400&refresh=31536000&url=https%3a%2f%2fupload.wikimedia.org%2fwikipedia%2fcommons%2f1%2f11%2fEthernet_Connection.jpg  \"网口\")\n\n\n---\n\n\n## 2.1 有或没有界面\n\n近年来的linux发行版一般都提供了图形界面的网络配置工具。一些人抱怨同时混用界面和命令行进行网卡配置会导致混乱。但是，一些界面应用，尤其是**Network Manager**（或称[Wicd](https://en.wikipedia.org/wiki/Wicd)）**和[yast](https://en.wikipedia.org/wiki/YaST) 可以做到同时兼容界面配置和命令行配置。\n\n由于本教程的目标读者是运维，因此本书的很多Linux命令行需要管理员权限。\n\n本章仅讨论命令行下的网卡配置。\n\n不幸的是Linux下没有统一的命令，也没有完全相同的/etc配置。因此我们仅仅讨论两个比较大的发行版。\n\n我们先讨论Debian系列（或Ubuntu或Mint），再讨论RHEL（或Centos或Fedora）系列。\n\n## 2.2. Debian网卡配置\n\n### 2.2.1. /etc/network/interfaces\n\n文件**/etc/network/interfaces**是debian上网卡的核心配置文件。\n\n#### dhcp 客户端\n\n下面是我电脑上的dhcp和eth0(第一块网卡）的配置。\n\n```bash\npaul@debian8:~$ cat /etc/network/interfaces\n# This file describes the network interfaces available on your system\n# and how to activate them. For more information, see interfaces(5).\n\n# The loopback network interface\nauto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n```\n\n客户端最好采用dhcp方式分配ip，但是服务端一般需要固定ip。\n\n#### 固定 ip\n\n下面是/etc/network/interfaces 的固定ip配置。\n\n```\nroot@debian7~# cat /etc/network/interfaces\nauto lo\niface lo inet loopback\n\nauto  eth0\niface eth0 inet static\naddress   10.42.189.198\nbroadcast 10.42.189.207\nnetmask   255.255.255.240\ngateway   10.42.189.193\n```\n\n上面的配置表明你不仅仅可以对该配置文件配置ip。还可以配置网关，子网掩码等，详情参见**interfaces(5)**。\n\n## 2.2.2. /sbin/ifdown\n\n强烈建议在配置网卡之前先关闭网口，可以用**ifdown**命令关闭网口。\n\n用该命令关闭一个配有固定ip的网口时，如果没有报错则无消息提示。但是**ifconfig**会发现该网口已经消失。\n\n```bash\nroot@ubu1104srv:~# ifdown eth0\nroot@ubu1104srv:~# ifconfig\nlo   Link encap:Local Loopback \n     inet addr:127.0.0.1  Mask:255.0.0.0\n     inet6 addr: ::1/128 Scope:Host\n     UP LOOPBACK RUNNING  MTU:16436  Metric:1\n     RX packets:106 errors:0 dropped:0 overruns:0 frame:0\n     TX packets:106 errors:0 dropped:0 overruns:0 carrier:0\n     collisions:0 txqueuelen:0 \n     RX bytes:11162 (11.1 KB)  TX bytes:11162 (11.1 KB)\n```\n\n关闭的网口就不能联网了。\n\n## 2.2.3. /sbin/ifup\n\n下面是通过**ifup**开启eth0，展示dhcp的示例。\n\n```bash\nroot@ubu1010srv:/etc/network# ifup eth0\nInternet Systems Consortium DHCP Client V3.1.3\nCopyright 2004-2009 Internet Systems Consortium.\nAll rights reserved.\nFor info, please visit https://www.isc.org/software/dhcp/\nListening on LPF/eth0/08:00:27:cd:7f:fc\nSending on\nLPF/eth0/08:00:27:cd:7f:fc\nSending on\nSocket/fallback\nDHCPREQUEST of 192.168.1.34 on eth0 to 255.255.255.255 port 67\nDHCPNAK from 192.168.33.100\nDHCPDISCOVER on eth0 to 255.255.255.255 port 67 interval 3\nDHCPOFFER of 192.168.33.77 from 192.168.33.100\nDHCPREQUEST of 192.168.33.77 on eth0 to 255.255.255.255 port 67\nDHCPACK of 192.168.33.77 from 192.168.33.100\nbound to 192.168.33.77 -- renewal in 95 seconds.\nssh stop/waiting\nssh start/running, process 1301\nroot@ubu1010srv:/etc/network#\n```\n\n```todo\n注：貌似例子有点陈旧。 #todo 更新ifdown 和 ifup示例。\n```\n关于**dhcp**，本书在接下来不同章节都会讲到。\n\n\n## 2.3. RHEL 网卡配置\n\n```todo\n## todo 装台RHEL的机器再翻译\n```\n\n## 2.4. ifconfig\n\n**/sbin/ifconfig**命令不带参数将会列出当前活跃的网口，包含wire和lo网口。下面是不带ip的**eth0**。\n\n```bash\nroot@ubu1010:~# ifconfig \neth0 Link encap:Ethernet  HWaddr 00:26:bb:5d:2e:52 \n     UP BROADCAST MULTICAST  MTU:1500  Metric:1\n     RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n     TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n     collisions:0 txqueuelen:1000 \n     RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n     Interrupt:43 Base address:0xe000 \n\neth1 Link encap:Ethernet  HWaddr 00:26:bb:12:7a:5e \n     inet addr:192.168.1.30  Bcast:192.168.1.255  Mask:255.255.255.0\n     inet6 addr: fe80::226:bbff:fe12:7a5e/64 Scope:Link\n     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n     RX packets:11141791 errors:202 dropped:0 overruns:0 frame:11580126\n     TX packets:6473056 errors:3860 dropped:0 overruns:0 carrier:0\n     collisions:0 txqueuelen:1000 \n     RX bytes:3476531617 (3.4 GB)  TX bytes:2114919475 (2.1 GB)\n     Interrupt:23 \n\nlo   Link encap:Local Loopback \n     inet addr:127.0.0.1  Mask:255.0.0.0\n     inet6 addr: ::1/128 Scope:Host\n     UP LOOPBACK RUNNING  MTU:16436  Metric:1\n     RX packets:2879 errors:0 dropped:0 overruns:0 frame:0\n     TX packets:2879 errors:0 dropped:0 overruns:0 carrier:0\n     collisions:0 txqueuelen:0 \n     RX bytes:486510 (486.5 KB)  TX bytes:486510 (486.5 KB)\n```\n\n**ifconfig**查看特定网口信息。\n\n```bash\n[root@rhel6 ~]# ifconfig eth0\neth0 Link encap:Ethernet  HWaddr 08:00:27:DD:0D:5C  \n     inet addr:192.168.1.99  Bcast:192.168.1.255  Mask:255.255.255.0\n     inet6 addr: fe80::a00:27ff:fedd:d5c/64 Scope:Link\n     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n     RX packets:2969 errors:0 dropped:0 overruns:0 frame:0\n     TX packets:1918 errors:0 dropped:0 overruns:0 carrier:0\n     collisions:0 txqueuelen:1000 \n     RX bytes:335942 (328.0 KiB)  TX bytes:190157 (185.7 KiB)\n```\n\n普通用户调用**/sbin**下的命令的时候，得用全路径，下面是debian下的调用结果。\n\n```bash\npaul@debian5:~$ /sbin/ifconfig eth3\neth3 Link encap:Ethernet  HWaddr 08:00:27:ab:67:30 \n     inet addr:192.168.1.29  Bcast:192.168.1.255  Mask:255.255.255.0\n     inet6 addr: fe80::a00:27ff:feab:6730/64 Scope:Link\n     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n     RX packets:27155 errors:0 dropped:0 overruns:0 frame:0\n     TX packets:30527 errors:0 dropped:0 overruns:0 carrier:0\n     collisions:0 txqueuelen:1000 \n     RX bytes:13095386 (12.4 MiB)  TX bytes:25767221 (24.5 MiB)\n```\n\n```bash\n注：译者亲试普通用户调用ifconfig命令不需要全路径。测试系统是Ubuntu 16.04。\n```\n\n## 2.4.1. 通过ifconfig开启和关闭网口\n\n也可以通过**ifconfig**开关网口，和ifconfig eth0 up 和 ifup eth0不同之处在于ifconfig会读取内存中的网卡配置重新激活网卡，而ifup却重新读取配置文件，然后开启网卡。\n\n```bash\n[root@rhel6 ~]# ifconfig eth0 down\n[root@rhel6 ~]# ifconfig eth0 up\n[root@rhel6 ~]# ifconfig eth0\neth0 Link encap:Ethernet  HWaddr 08:00:27:DD:0D:5C\n     inet addr:192.168.1.99  Bcast:192.168.1.255  Mask:255.255.255.0\n     inet6 addr: fe80::a00:27ff:fedd:d5c/64 Scope:Link\n     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n     RX packets:2995 errors:0 dropped:0 overruns:0 frame:0\n     TX packets:1927 errors:0 dropped:0 overruns:0 carrier:0\n     collisions:0 txqueuelen:1000 \n     RX bytes:339030 (331.0 KiB)  TX bytes:191583 (187.0 KiB)\n```\n\n## 2.4.2. 通过ifconfig更改ip地址\n\n临时更改ip地址，本ip地址在重启网卡或重启系统之前有效。\n\n```bash\n[root@rhel6 ~]# ifconfig eth0 | grep 192\n     inet addr:192.168.1.99  Bcast:192.168.1.255  Mask:255.255.255.0\n[root@rhel6 ~]# ifconfig eth0 192.168.33.42 netmask 255.255.0.0\n[root@rhel6 ~]# ifconfig eth0 | grep 192\n     inet addr:192.168.33.42  Bcast:192.168.255.255  Mask:255.255.0.0\n[root@rhel6 ~]# ifdown eth0 && ifup eth0\n[root@rhel6 ~]# ifconfig eth0 | grep 192\n     inet addr:192.168.1.99  Bcast:192.168.1.255  Mask:255.255.255.0\n```\n\n## 2.4.3. 通过ifconfig设置mac地址\n\n你可以通过ifconfig临时更改的mac地址（注：只是临时改变软件中的mac地址，硬件mac地址没有被改变）。\n\n```bash\n[root@rhel6 ~]# ifconfig eth0 | grep HWaddr\neth0 Link encap:Ethernet  HWaddr 08:00:27:DD:0D:5C \n[root@rhel6 ~]# ifconfig eth0 hw ether 00:42:42:42:42:42\n[root@rhel6 ~]# ifconfig eth0 | grep HWaddr\neth0 Link encap:Ethernet  HWaddr 00:42:42:42:42:42\n```\n\n\n## 2.5. ip命令\n\n有的系统上没有**ifconfig**命令，**ip**命令可以取而代之。\n\n**RHEL 7**上查看ip地址，如下命令。\n\n```bash\n[root@rhel71 ~]# ip a\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000\n    link/ether 08:00:27:89:22:33 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.1.135/24 brd 192.168.1.255 scope global dynamic enp0s3\n       valid_lft 6173sec preferred_lft 6173sec\n    inet6 fe80::a00:27ff:fe89:2233/64 scope link\n       valid_lft forever preferred_lft forever\n[root@rhel71 ~]#\n```\n\n```fix\n注：在Debian上同样适用。\n```\n\n\n\n## 2.6. dhclient命令\n\n一般桌面Linux系统都提供dhclient命令。这个命令可以从dhcp服务端自动获取网口配置。如果你的网口配置了dhcp或者bootp，当你执行/sbin/ifup命令的时候，dhclient会自动启动。\n\n## 2.7. hostname\n\n每个主机都有一个hostname，通常用于DNS解析。\n\n下面是**Red Hat/Fedora**上的hostname配置。\n\n```bash\n[root@rhel6 ~]# grep HOSTNAME /etc/sysconfig/network\nHOSTNAME=rhel6\n[root@rhel6 ~]# hostname\nrhel6\n```\n\n**RHEL7/CentOS7**的hostname的标准配置文件是**/etc/hostname**。\n\n```bash\n[root@rhel71 ~]# cat /etc/hostname\nrhel71.linux-training.be\n[root@rhel71 ~]#\n```\n\nUbuntu/Debian上用**/etc/hostname**配置主机名。\n\n```bash\npaul@debian8:~$ cat /etc/hostname\nserver42\npaul@debian8:~$ hostname\nserver42\n```\n\n任何主机你都可以通过命令hostname临时更改主机名。\n\n```bash\n[root@rhel6 ~]# hostname server42\n[root@rhel6 ~]# hostname\nserver42\n``\n\n任何Linux都可以通过**sysctl**查看和设置主机名。\n\n``bash\n[root@rhel6 ~]# sysctl kernel.hostname\nkernel.hostname = server42\n[root@rhel6 ~]# sysctl kernel.hostname=rhel6\nkernel.hostname = rhel6\n[root@rhel6 ~]# sysctl kernel.hostname\nkernel.hostname = rhel6\n[root@rhel6 ~]# hostname\nrhel6\n```\n\n## 2.8. arp\n\nip到mac的过程由网络模型第二层broadcast的**arp**协议完成。用**arp 工具** 查看 **arp 表**，命令如下。\n\n```bash\nroot@barry:~# arp -a\n? (192.168.1.191) at 00:0C:29:3B:15:80 [ether] on eth1\nagapi (192.168.1.73) at 00:03:BA:09:7F:D2 [ether] on eth1\nanya (192.168.1.1) at 00:12:01:E2:87:FB [ether] on eth1\nfaith (192.168.1.41) at 00:0E:7F:41:0D:EB [ether] on eth1\nkiss (192.168.1.49) at 00:D0:E0:91:79:95 [ether] on eth1\nlaika (192.168.1.40) at 00:90:F5:4E:AE:17 [ether] on eth1\npasha (192.168.1.71) at 00:03:BA:02:C3:82 [ether] on eth1\nshaka (192.168.1.72) at 00:03:BA:09:7C:F9 [ether] on eth1\nroot@barry:~#\n```\n\n```\nAnya 是 Cisco 防火墙, \nfaith 是 laser 打印机, \nkiss 是 Kiss DP600, \nlaika 是 laptop \nAgapi, Shaka and Pasha 是 SPARC 服务. \n带问号的是 虚拟机中的Red Hat Enterprise Linux \n```\n用**arp -d**删除一条arp。\n\n```bash\n[root@rhel6 ~]# arp\nAddress             HWtype  HWaddress           Flags Mask       Iface\nubu1010             ether   00:26:bb:12:7a:5e   C                eth0\nanya                ether   00:02:cf:aa:68:f0   C                eth0\n[root@rhel6 ~]# arp -d anya\n[root@rhel6 ~]# arp\nAddress             HWtype  HWaddress           Flags Mask       Iface\nubu1010             ether   00:26:bb:12:7a:5e   C                eth0\nanya                        (incomplete)                         eth0\n[root@rhel6 ~]# ping anya\nPING anya (192.168.1.1) 56(84) bytes of data.\n64 bytes from anya (192.168.1.1): icmp_seq=1 ttl=254 time=10.2 ms\n...\n[root@rhel6 ~]# arp\nAddress             HWtype  HWaddress           Flags Mask       Iface\nubu1010             ether   00:26:bb:12:7a:5e   C                eth0\nanya                ether   00:02:cf:aa:68:f0   C                eth0\n```\n\n\n## 2.9. route 命令\n\n通过/sbin/route查看本地路由表（netstat -r也可以）。\n\n```bash\nroot@RHEL4b ~]# netstat -r\nKernel IP routing table\nDestination     Gateway   Genmask         Flags   MSS Window  irtt Iface\n192.168.1.0     *         255.255.255.0   U         0 0          0 eth0\n[root@RHEL4b ~]# route\nKernel IP routing table\nDestination     Gateway   Genmask         Flags Metric Ref    Use Iface\n192.168.1.0     *         255.255.255.0   U     0      0        0 eth0\n[root@RHEL4b ~]#\n```\n\n上面现实本计算机没有配置gateway，通过**route add default gw**添加**默认 gateway**到最低端。\n\n除非配置/etc下面的文件，否则本gateway会在重启之后失效。\n\n\n## 2.10. ping\n\nping另一台主机，能ping通就说明网路是通的。\n\n```bash\n[root@RHEL4b ~]# ping 192.168.1.5\nPING 192.168.1.5 (192.168.1.5) 56(84) bytes of data.\n64 bytes from 192.168.1.5: icmp_seq=0 ttl=64 time=1004 ms\n64 bytes from 192.168.1.5: icmp_seq=1 ttl=64 time=1.19 ms\n64 bytes from 192.168.1.5: icmp_seq=2 ttl=64 time=0.494 ms\n64 bytes from 192.168.1.5: icmp_seq=3 ttl=64 time=0.419 ms\n\n--- 192.168.1.5 ping statistics ---\n4 packets transmitted, 4 received, 0% packet loss, time 3009ms\nrtt min/avg/max/mdev = 0.419/251.574/1004.186/434.520 ms, pipe 2\n[root@RHEL4b ~]#\n```\n\n## 2.11. ethtool（可选读）\n\n要查看或配置网卡，可用**etholl**。查看结果依网传输口性能而定。下面是一个自协商带宽示例。\n\n```bash\nroot@laika:~# ethtool eth0\nSettings for eth0:\n\tSupported ports: [ TP ]\n\tSupported link modes:   10baseT/Half 10baseT/Full \n\t                        100baseT/Half 100baseT/Full \n\t                        1000baseT/Full \n\tSupports auto-negotiation: Yes\n\tAdvertised link modes:  10baseT/Half 10baseT/Full \n\t                        100baseT/Half 100baseT/Full \n\t                        1000baseT/Full \n\tAdvertised auto-negotiation: Yes\n\tSpeed: 1000Mb/s\n\tDuplex: Full\n\tPort: Twisted Pair\n\tPHYAD: 0\n\tTransceiver: internal\n\tAuto-negotiation: on\n\tSupports Wake-on: pumbg\n\tWake-on: g\n\tCurrent message level: 0x00000033 (51)\n\tLink detected: yes\n```\n下面这个例子表面如何用ethtool在带宽1000Mbit和100Mbit中来回切换。注意有的时候带宽可能会自己漲回1000Mbit。\n\n```bash\nroot@laika:~# ethtool eth0 | grep Speed\n\tSpeed: 1000Mb/s\nroot@laika:~# ethtool -s eth0 speed 100\nroot@laika:~# ethtool eth0 | grep Speed\n\tSpeed: 100Mb/s\nroot@laika:~# ethtool -s eth0 speed 1000\nroot@laika:~# ethtool eth0 | grep Speed\n\tSpeed: 1000Mb/s\n```\n\n\n## 2.12. 练习：网卡配置\n\n1.查看**dhclient**是否在运行。\n\n2.查看当前ip。\n\n3.查看ip的配置文件。\n\n4.根据本书网卡配置，更改dhcp，配置固定ip。注意ip不要配置冲突。\n\n5.上一题中，你是否配置gateway，如果没有，请配置。\n\n6.检查你的gateway。\n\n7.检查是否可以连通网关。\n\n8.更改mac地址的最后一个数字。\n\n9.http，pop3,ssh，telnet，nntp，ftp 这些协议用到哪些端口？\n\n10.解释为什么email和web用tcp而不用udp？\n\n11.查看hostname。\n\n12.现在你的电脑正在和哪些ip建立连接？\n\n\n\n<hr/>\n## 版权声明\n\nCopyright 2016-2016 Program Dog\n\nPermission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled 'GNU Free Documentation License'.\n\n---\n\n\n-----\n\n\n注：\n\n1.本文由[Program Dog](https://program-dog.blogspot.com)翻译自 [http://linux-training.be](http://linux-training.be) \n\n2.本文原始链接：[https://program-dog.blogspot.com/2016/12/linux-net-char02-interface-configuration.html](https://program-dog.blogspot.com/2016/12/linux-net-char02-interface-configuration.html)\n\n<hr/>"
		},
		{
			"post_id": 1,
			"title": "[Linux Net]:1 学习Linux网络编程应该了解的基础简介 ",
			"date_published": 1433033779,
			"tags": "linux,编程",
			"body": "网络分层结果是计算机网络工作的基础，此模型简单灵活却强大。本文将介绍这一模型。\n\n![网络分层](https://images1-focus-opensocial.googleusercontent.com/gadgets/proxy?container=focus&resize_w=400&refresh=31536000&url=https%3a%2f%2fwww.w3.org%2fPeople%2fFrystyk%2fthesis%2ftcposi.gif)\n\n---\n\n\n\n\n\n这一章并非直入linux网络主题，而是先介绍一些后面会用到的基本的网络概念。\n\n## 1.1. 网络分层\n\n### 1.1.1. 7层OSI模型\n\n说到协议分层，就不得不提osi的7层（应用层，表示层，会话层，传输层，网络层，数据链路层，物理层）网络模型。我们主要讨论2层和3层，次要提及其他层。原因是2，3层对理解网络很重要。至少你应该知道系统管理员常说的“2层设备”或“3层广播”是什么意思。\n\n### 1.1.2 4层DoD模型\n\nDoD（或者说是tcp/ip）模型只有4层。其网络接口层对应OSI的1,2层（物理层和数据链路层），其网络互联层对于OSI的网络层，其传输层（tcp，udp）对应OSI的第4层传输层，其应用层对于OSI的5,6,7层。\n\n下图是ISO和DoD对应表，以及协议举例和设备举例。\n\n![分层协议图](http://linux-training.be/networking/images/networklayers.png  \"分层协议图\")\n\n### 1.1.3. 物理层简介\n\n物理层在第1层，主要是关于电压，电信号和物理链接的。一些网络依然在用[同轴电缆](https://zh.wikipedia.org/wiki/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86)，不过更多的网络已经开始用[双绞线](https://zh.wikipedia.org/wiki/%E5%8F%8C%E7%BB%9E%E7%BA%BF)了。\n\n中继器和集线器属于物理层。但物理层之上的软件是没办法“感觉到”他们的存在的。因为他们唯一的作用就是放大电缆中的电信号。Passive hubs are multiport amplifiers that amplify an incoming electrical signal on all other connections. Active hubs do this by reading and retransmitting bits, without interpreting any meaning in those bits.\n\nNetwork technologies like csma/cd and token ring are defined on this layer.\n\n关于第一层，这本书我们就介绍这点。\n\n### 1.1.4.  数据链路层简介\n\n第2层数据链路层是关于帧的。帧自带循环冗余检查（cyclic redundancy check）。在这一层的以太网（802.3）中，每一块网卡都可以通过一个48bit的mac地址（media access control address）唯一确定。\n\n关于这一层的桥接器和交换器（bridges and switches）。桥接器要比物理层的集线器（hub）更高级，因为桥接器是基于mac地址的。另外交换器也是，它也可以识别mac地址。\n\n关于这一层，这本书将会讨论命令**arp**和**ifconfig**。\n\n### 1.1.5. 网络层简介\n\n第3层是关于ip数据包的。这一层分配给每一个主机一个唯一的32bit的ip地址。但是ip协议并非这一层唯一的协议。除此之外还有icmp，igmp，ipv6等协议。全部协议见文件 [/etc/protocols](file:///etc/protocols \"点击查看\")。\n\n这一层的路由（routers）和第3层的交换器都可以识别ip地址。\n\n在tcp/ip协议里面这次层通常指的是网络层。\n\n### 1.1.6. 传输层简介\n\n我们讨论的第4层的tcp和udp协议在DoD中叫做传输层（host-to-host）。\n\n\n### 1.1.7. 第5,6,7层\n\ntcp/ip的应用层对应了这一层的5,6,7层。讨论它们之间的细节已经超出本书范围。\n\n### 1.1.8. 本书中的网络分层\n\n本书的分层基于wireshark中的**帧里的协议（Protocols in Frame）**。比如嗅探一个dhcp数据包，观察下面的嗅探的结果。\n\n```\n[Protocols in Frame: eth:ip:udp:bootp]\n```\n根据嗅探ntp（网络时间协议）数据包的结果，我们推测ntp和bootp在同一层。\n\n```\n[Protocols in Frame: eth:ip:udp:ntp]\n```\n嗅探arp的结果显示其和ip在同一层。\n\n```\n[Protocols in Frame: eth:arp]\n```\n\n下面是wireshark的常用协议列表（部分）。\n\n![wireshark协议表（部分）](http://linux-training.be/networking/images/networkprotocols.png  \"wireshark协议表（部分）\")\n\n## 1.2. 单播，广播，多播，任播\n\n### 1.2.1. 单播\n\n单播意指一台计算机对另一台计算机通信。一般一台计算机可以有多个单播对象。\n\n![单播](http://linux-training.be/networking/images/unicast.png  \"单播\")\n\n### 1.2.2. 多播\n\n多播意指一台计算机对一组计算机通信。\n\n\n![多播](http://linux-training.be/networking/images/multicast.png  \"多播\")\n\n有一些多播的例子如Realplayer（.sdp文件）和 ripv2(一种路由协议）。\n\n### 1.2.3. 广播\n\n广播意指一台计算机对所有计算机通信。\n\n![广播](http://linux-training.be/networking/images/broadcast.png  \"广播\")\n\n典型的例子是BBC广播。一般，广播在局域网中会被限制。\n\n注意，2层中的广播和3层中的广播是不一样的。2层中的广播被同一网段所接收（不能跨越路由），但是3层广播被同一ip子网所接受。\n\n### 1.2.4. 任播\n\n根域名服务器用的就是任播。任播是计算机找到立它最近的组进行通信。\n\n![任播](http://linux-training.be/networking/images/anycast.png  \"任播\")\n\n\n感谢维基百科的匿名志愿者提供的图片。\n\n## 1.3.  lan,wan和man\n\n**lan**用在局域网而**wan**用在广域网。其用处不同源于计算机之间的距离不同而非计算机数量不同。一些协议如**atm**为**wan**而设计，而一些协议如**以太网（ethernet）**为lan而设计。\n\n### 1.3.1. lan\n\n**lan（Local Area Network）**就是局域网。它可以是一个房间，或一层楼，甚至建筑大楼。只要计算机距离足够近就可以组成一个lan。你也可以把lan定义成所有通过以太网连接的计算机的集合体。\n\n一个lan可以包含多个小的lan。下图是多个小lan组成的一个大lan的拓补图。\n\n![lan](http://linux-training.be/networking/images/LAN_en.jpg  \"lan\")\n\n\n### 1.3.2. man\n\n**man（Metropolitan Area Network）**即城域网，意指连接lan和wan的并且同处一个建筑，或社区或城市的网络。man可利用**fddi**或**以太网**或其他协议进行通信。\n\n### 1.3.3. wan\n\n**wan（Wide Area Network）** 是连接远程计算机的网络。这些计算机通常通过租用线路互相连接。wan不采用以太网协议而采用像fddi, frame relay, ATM or X.25之类的协议互相连接。\n\n下图示意了一个办公场所通过[桢中继（Frame Relay）](https://zh.wikipedia.org/wiki/%E5%B8%A7%E4%B8%AD%E7%BB%A7)连接到总部。\n\n![man](http://linux-training.be/networking/images/WAN.png  \"man\")\n\n**wan**有时也指大型网络，如互联网。\n\n[思科（Cisco）](https://zh.wikipedia.org/wiki/%E6%80%9D%E7%A7%91%E7%B3%BB%E7%BB%9F)以他们的在**wan**方面的技术而闻名于世。他们成功地制造了路由，并通过**wan协议**把非常多的**lan**连接在了一起。\n\n\n### 1.3.4. pan-wpan\n\n家庭网络称之为**pan（Personal Area Network）**。wifi环境称之为**wpan**。\n\n## 1.4. internet-intranet-extranet\n\n互联网（internet）就是由很多不同的网络通过tcp/ip协议栈互相连接而成的公网。\n\n互联网起源于[arpanet](https://zh.wikipedia.org/wiki/ARPANET)。而arpanet于1969年被发明，当时仅有4台计算机相连。1971年第一封电子邮件成功通过arpanet发送。1973年时，75%的网络传输用于电子邮件。同在1973年，**ftp**被发明，网络连接到了欧洲（挪威和英国）。2009年互联网覆盖了25%的人口。2011年，据估计英文网页占比下降到25% 。\n\n**内联网（intranet）**是tcp/ip私网。内联网和互联网使用相同的协议，只不过内联网只对组织内部人员开放。\n\n**外联网（extranet）**类似于**内联网**，只不过**外联网**还允许一些外部组织（如合伙人，客户端，技术提供者等）访问。\n\n\n\n## 1.5. tcp/ip\n\n### 1.5.1. tcp/ip的历史\n\ntcp/ip协议栈的研发始于1960s的美国国防部。80年代，很多商业公司开发了自己的协议栈。比如IBM开发了sna，Novell开发了ipx/spx，微软开发了netbeui，Apple开发了appletalk。但这些协议基本上都没有活到90年代。到了90年代末，几乎所有的计算机都在使用tcp/ip协议。\n\n鄙以为，tcp/ip之所以能活下来是因为其开放性，因为任何人都可以免费参与开发和使用这一套协议。\n\n### 1.5.2. rfc（征求意见稿）\n\n这些网络协议被rfc所定义。一份征求意见稿描述一个网络协议的全部工作细节。1986年以来，**IETF（互联网工程任务组）**一直是rfc的核心发布组织。\n\nrfc官方网站是[http://www.rfc-editor.org](http://www.rfc-editor.org)。这个网站包含了所有的rfc的文本内容。例如rfc2132(定义了dhcp和bootp）的内容在这[http://www.rfc-editor.org/rfc/rfc2132.txt](http://www.rfc-editor.org/rfc/rfc2132.txt)。\n\n\n### 1.5.3. 协议举例\n\ntcp协议建立的连接是可靠的，udp协议建立的连接是不可靠的但是速度快。ping协议用icmp探测错误信息，igmp则是多播分布协议。\n\nip头可见的协议列表见文件[/etc/protocols](file:///etc/protocols \"点击查看\")。\n\n```bash\npaul@debian5:~$ grep tcp /etc/protocols\ntcp      6      TCP      # transmission control protocol\n```\n\n### 1.5.4. 服务举例\n\n网卡被唯一的mac地址所确定，主机被ip地址所确定，应用被端口（port）所确定。\n\n常见的应用层协议服务如smtp，http，ssh，telnet和ftp都有固定的端口号。端口号列表见[/etc/services](file:///etc/services \"点击查看\")。\n\n```bash\npaul@ubu1010:~$ grep ssh /etc/services\nssh   22/tcp   # SSH Remote Login Protocol\nssh   22/udp\n```\n\n\n<hr/>\n# 版权声明\n\nCopyright 2016-2016 Program Dog\n\nPermission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled 'GNU Free Documentation License'.\n\n---\n\n\n\n-----\n\n\n注：\n\n1.本文由[Program Dog](https://program-dog.blogspot.com)翻译自 [http://linux-training.be](http://linux-training.be) \n\n2.本文原始链接：[https://program-dog.blogspot.com/2016/11/linux-net-char01-general-networking.html](https://program-dog.blogspot.com/2016/11/linux-net-char01-general-networking.html)\n\n<hr/>\n"
		}
	],
	"info": "本站为<font size='6'>镜像站</font>，访问[主站](http://127.0.0.1:43111/1Ld63vNnfm5SEUTbsYxB7XGo7kHQVUGghU/?Home)",
	"recommended": "<h3>推荐阅读：</h3>\n[如何用zeronet优雅的写博客](http://127.0.0.1:43110/1Ld63vNnfm5SEUTbsYxB7XGo7kHQVUGghU/?Post:6:%E5%A6%82%E4%BD%95%E7%94%A8zeronet%E4%BC%98%E9%9B%85%E5%9C%B0%E5%86%99%E5%8D%9A%E5%AE%A2)"
}