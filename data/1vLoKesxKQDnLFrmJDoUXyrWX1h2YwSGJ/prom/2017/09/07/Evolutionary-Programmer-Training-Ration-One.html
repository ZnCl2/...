<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>(Genetic Programmer in less than 150 lines of C) Evolutionary Programmer Training: Teaching One - LiberIT Blog</title>
  <link rel="stylesheet" href="/1vLoKesxKQDnLFrmJDoUXyrWX1h2YwSGJ/css/main.css">
  <!--   Syntax highlighting is only needed for posts -->
  
  <link rel="stylesheet" href="/1vLoKesxKQDnLFrmJDoUXyrWX1h2YwSGJ/css/syntax-highlighter.css">
  
  <link href="//fonts.googleapis.com/css?family=Space+Mono|Work+Sans:700" rel="stylesheet">

</head>
<body>

<input type="checkbox" id="hamburger" name="hamburger">
<label id="label-ham" for="hamburger"></label>
<div class="menu-container">
  <div class="menu"></div>
  <div class="links">
      <a href="/1vLoKesxKQDnLFrmJDoUXyrWX1h2YwSGJ/"><i class="fa fa-home"></i>&nbsp;Home</a>
      <a href="/1vLoKesxKQDnLFrmJDoUXyrWX1h2YwSGJ/about/"><i class="fa fa-user"></i>&nbsp;About</a>
      <a href="/1vLoKesxKQDnLFrmJDoUXyrWX1h2YwSGJ/hme_c/"><i class="fa fa-user"></i>&nbsp;Magic
        Spells</a>
      <a href="/1vLoKesxKQDnLFrmJDoUXyrWX1h2YwSGJ/archive/"><i class="fa fa-file-zip-o"></i>&nbsp;Archive</a>
      <a href="/1vLoKesxKQDnLFrmJDoUXyrWX1h2YwSGJ/contact/"><i class="fa fa-address-book-o"></i>&nbsp;Contact</a>
      <a href="https://github.com/sharu725/krishna"><i class="fa fa-code-fork"></i>&nbsp;Project</a>
  </div>
</div>

<div class="content">
<header>
     <a href="/1vLoKesxKQDnLFrmJDoUXyrWX1h2YwSGJ/"><h1 class="site-title">LiberIT Blog</h1></a>
</header>
  <div class="post-title">
    
    <div class="title">
        <h2>(Genetic Programmer in less than 150 lines of C) Evolutionary Programmer Training: Teaching One</h2>
        
        <span>
            <time datetime="">
                   September 07, 2017
            </time>
        </span>
        
    </div>
</div>


<p>I couldn’t find a simple genetic programmer tutorial on the Internet, so I
loosely followed one on <a href="https://www.electricmonk.nl/docs/evolutionary_algorithm/evolutionary_algorithm.html">Evolutionary Algorithms
</a>
to make this post.</p>

<h3 id="seductive-concept">Seductive Concept</h3>
<p>The seductive concept behind establishing an evolutionary programmer is that it
can in principle do a lot of computer programming for you. All you have to do is
provide it with inputs, outputs and some functions and then it will fill in the
algorithm.</p>

<p>Why C you ask? Because it has the best OpenCL integration, and Evolutionary
Programming is embarrassingly parallelizable, so is pliant to highly parallel
processors.</p>

<h3 id="brief-glance">Brief Glance</h3>

<p>At a brief glance, we can look at the main function:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>int main() {
#define TRAINING_SERIES_LONG 3
  const uint16_t training_series_long = TRAINING_SERIES_LONG;
  const uint16_t training_series[TRAINING_SERIES_LONG][2] = {
      {'1', '2'}, {'2', '3'}, {'3', '4'}}; // return input
  uint16_t program_output[TRAINING_SERIES_LONG] = {0};
</code></pre>
</div>
<p>Here the training series has been established,
each input is paired with an output.  Can have very large training sets, though
generally 3 is a minimum. Two for evolving and one for testing.</p>

<p>You’ll note also there is a program_output variable, it will be used as local
memory for one of the function calls, to avoid dynamic allotment each time.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#define CEREMONY_LONG 3
  const uint16_t ceremony_long = CEREMONY_LONG;
  const v16us ceremony[CEREMONY_LONG] = {
      {plus_WORD}, {return_WORD}, {invert_WORD}};
</code></pre>
</div>
<p>Here the ceremonies or available functions have been established, using
constants from pyashWords.h.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#define POPULATION_LONG 16
  const uint16_t population_long = POPULATION_LONG;
  v16us population[POPULATION_LONG] = {0};
  uint16_t population_health[POPULATION_LONG] = {0};
</code></pre>
</div>
<p>Here the population has been alloted, each person is a program and fits in a
vector of sixteen, sixteen bit values (a Pyash Tablet).  Later on can have
larger populations, but for teaching one, it should be sufficient.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  uint16_t champion_iteration = 0;
  uint16_t champion_health = 0;
</code></pre>
</div>
<p>Allotment for the champion program.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  population_establish(ceremony_long, ceremony, population_long, population);
</code></pre>
</div>
<p>Here the population is established, by making some random programs and filling
in the population allotment.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>population_quiz(population_long, population, training_series_long,
                  training_series, program_output, population_health);
</code></pre>
</div>
<p>This is the most computation intensive part, where the population is quized, by
giving it the input, finding the output, and then checking how many that program
got correct.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  champion_choose(population_long, population_health, &amp;champion_iteration,
                  &amp;champion_health);
</code></pre>
</div>
<p>This is a simple ceremony that finds the fittest program.</p>

<p>Typically at this point, if the champion_health is not maximum_health, then we
would be going through additional population modification steps, but we’ll leave
that for teaching two.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  printf("0x%X is champion, %d is health\n", population[champion_iteration].s0,
         champion_health);

  return 0;
}
</code></pre>
</div>
<p>Here we declare the champion and finish successfully.
For the rest of the article will look at the inner ceremonies more deeply.</p>

<h4 id="health-assessment">Health Assessment</h4>
<p>The original tutorial started with a fitness function, so did I.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void health_assess(const uint16_t training_series_long,
                   const uint16_t training_series[][2],
                   const uint16_t *program_output, uint16_t *health) {
  assert(training_series_long &gt; 0);
  assert(training_series != NULL);
  assert(program_output != NULL);
  assert(health != NULL);
  uint16_t iteration = 0;
  uint16_t health_collector = 0;
  for (iteration = 0; iteration &lt; training_series_long; ++iteration) {
    if (training_series[iteration][1] == program_output[iteration]) {
      ++health_collector;
    }
  }
  *health = health_collector;
}
</code></pre>
</div>

<p>It is a skeleton  simply returns the number of results that it got correct.
Later on we’ll include partials.</p>

<h4 id="population-establish">Population Establish</h4>
<p>We need to have an initial population of programs.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>void population_establish(const uint16_t ceremony_long, const v16us *ceremony,
                          const uint16_t population_long, v16us *population) {
  uint16_t iteration = 0;
  srand(5);
  for (iteration = 0; iteration &lt; population_long; ++iteration) {
    population[iteration] = ceremony[rand() % 3];
  }
}
</code></pre>
</div>
<p>Here the population is comprised of persons performing a single ceremony.  Later
on we could have them doing multiple and more complicated ceremonies.</p>

<h4 id="program-interpret">Program Interpret</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>void program_interpret(const v16us program, const uint16_t input,
                       uint16_t *output) {
  uint16_t activity = program.s0;
  assert(activity != 0);
  switch (activity) {
  case plus_WORD:
    *output = input + 1;
    break;
  case return_WORD:
    *output = input;
    break;
  case invert_WORD:
    *output = ~input;
    break;
  default:
    assert(1 == 0);
  }
}

</code></pre>
</div>
<p>The program interpreter is where there is the most room for growth. Ideally it
would be Turing complete, support multiple input arguments and have named
functions.</p>

<p>It will be the largest part of the OpenCL kernel.</p>

<h4 id="program-quiz-and-population-quiz">Program Quiz and Population Quiz</h4>
<div class="highlighter-rouge"><pre class="highlight"><code>void program_quiz(const uint16_t training_series_long,
                  const uint16_t training_series[][2], const v16us program,
                  uint16_t *output) {
  assert(output != NULL);
  uint16_t iteration = 0;
  uint16_t program_output = 0;
  for (iteration = 0; iteration &lt; training_series_long; ++iteration) {
    program_interpret(program, training_series[iteration][0], &amp;program_output);
    output[iteration] = program_output;
  }
}
</code></pre>
</div>

<p>This quizzes a single program, by running it through all the inputs, and getting
the outputs.  It would be possible to use this  as an OpenCL kernel, however it
would be inefficient unless you have many thousands of inputs and outputs.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void population_quiz(const uint16_t population_long, const v16us *population,
                     const uint16_t training_series_long,
                     const uint16_t training_series[][2],
                     /*local*/ uint16_t *program_output,
                     uint16_t *population_health) {
  assert(population != NULL);
  assert(training_series != NULL);
  assert(population_health != NULL);
  uint16_t iteration = 0;
  v16us program = {0};
  uint16_t health = 0;
  for (iteration = 0; iteration &lt; population_long; ++iteration) {
    program = population[iteration];
    program_quiz(training_series_long, training_series, program,
                 program_output);
    health_assess(training_series_long, training_series, program_output,
                  &amp;health);
    population_health[iteration] = health;
  }
}
</code></pre>
</div>
<p>This ceremony quizzes each program and returns their health.</p>

<p>For an OpenCL implementation it would be feeding a parallel_program_quiz
ceremony that accepts as input the training_series, a list of programs and a
program_output array large enough to fit all the outputs.</p>

<p>Within parallel_program_quiz each worker would then select a point in the
training_series and a program to interpret. After it finishes interpreting the
program it would write the output to it’s program_output point. It would then go
onto the next training_series and program that hadn’t been done yet, until they
are all finished.</p>

<h4 id="champion_choose">champion_choose</h4>
<div class="highlighter-rouge"><pre class="highlight"><code>void champion_choose(const uint16_t population_long,
                     const uint16_t *population_health,
                     uint16_t *champion_iteration, uint16_t *champion_health) {
  assert(champion_health != NULL);
  assert(champion_iteration != NULL);
  assert(population_health != NULL);
  uint16_t iteration = 0;
  uint16_t fittest_health = 0;
  uint16_t fittest_iteration = 0; // expand to array for multiple fittest
  uint16_t health = 0;
  for (iteration = 0; iteration &lt; population_long; ++iteration) {
    health = population_health[iteration];
    if (health &gt; fittest_health) {
      fittest_iteration = iteration;
      fittest_health = health;
    }
  }
  *champion_iteration = fittest_iteration;
  *champion_health = fittest_health;
}
</code></pre>
</div>
<p>This is a simple ceremony that chooses the fittest individual based on the most
health.</p>

<p>And that’s it!</p>

<h2 id="all-program-code">All Program Code</h2>

<p>For the working program code you can Git copy it from
<a href="https://gitlab.com/liberit/lwonprom">gitlab</a> and
<a href="/1LwonpedFh54k36SMVJ7i98GdPHL5uGkZ/">zeronet</a></p>


  
<!--    <footer>
      Made with <span style="color: palevioletred">❤</span> by <a href="http://webjeda.com">webjeda</a>
</footer>-->
</div>
  <!-- Calling Fontawesome at the end to avoid delay in loading --> 
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<!-- Google Analytics Tracking code -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', '', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>
