{
	"title": "r3df0x Blog",
	"description": "贴一些自己使用的文章",
	"links": "- [Source code](https://github.com/HelloZeroNet)",
	"next_post_id": 23,
	"demo": false,
	"modified": 1468936027,
	"post": [
		{
			"post_id": 22,
			"title": "系统管理员安全",
			"date_published": 1468934992.403,
			"body": "本文从系统管理员的角度讨论安全问题.系统管理员是管理系统的人:启动\n系统,停止系统运行,安装新软件,增加新用户,删除老用户,以及完成保持系统发\n展和运行的日常事务工作.\n1.安全管理\n  安全管理主要分为四个方面:\n  (1)防止未授权存取:这是计算机安全最重要的问题:未被使用系统的人进入系\n     统.用户意识,良好的口令管理(由系统管理员和用户双方配合),登录活动\n     记录和报告,用户和网络活动的周期检查,这些都是防止未授权存取的关键.\n  (2)防止泄密:这也是计算机安全的一个重要问题.防止已授权或未授权的用户\n     相互存取相互的重要信息.文件系统查帐,su登录和报告,用户意识,加密都\n     是防止泄密的关键.\n  (3)防止用户拒绝系统的管理:这一方面的安全应由操作系统来完成.一个系统\n     不应被一个有意试图使用过多资源的用户损害.不幸的是,UNIX不能很好地\n     限制用户对资源的使用,一个用户能够使用文件系统的整个磁盘空间,而\n     UNIX基本不能阻止用户这样做.系统管理员最好用PS命令,记帐程序df和du\n     周期地检查系统.查出过多占用CUP的进程和大量占用磁盘的文件.\n  (4)防止丢失系统的完整性:这一安全方面与一个好系统管理员的实际工作(例\n     如:周期地备份文件系统,系统崩溃后运行fsck检查,修复文件系统,当有新\n     用户时,检测该用户是否可能使系统崩溃的软件)和保持一个可靠的操作系\n     统有关(即用户不能经常性地使系统崩溃).\n  本文其余部分主要涉及前两个问题,第三个问题在\"安全查帐\"一节讨论.\n2.超级用户\n    一些系统管理命令只能由超级用户运行.超级用户拥有其他用户所没有的特\n权,超级用户不管文件存取许可方式如何,都可以读,写任何文件,运行任何程序.\n系统管理员通常使用命令: /bin/su 或以 root 进入系统从而成为超级用户.在\n后面文章中以#表示应敲入必须由超级用户运行的命令,用$表示应敲入由所有其\n他用户运行的命令.\n3.文件系统安全\n  (1)UNIX文件系统概述\n      UNIX文件系统是UNIX系统的心脏部分,提供了层次结构的目录和文件.文\n  件系统将磁盘空间划分为每1024个字节一组,称为块(block)(也有用512字节\n  为一块的,如:SCO XENIX).编号从0到整个磁盘的最大块数.\n      全部块可划分为四个部分,块0称为引导块,文件系统不用该块;块1称为专\n  用块,专用块含有许多信息,其中有磁盘大小和全部块的其它两部分的大小.从\n  块2开始是i节点表,i节点表中含有i节点,表的块数是可变的,后面将做讨论.\n  i节点表之后是空闲存储块(数据存储块),可用于存放文件内容.\n      文件的逻辑结构和物理结构是十分不同的,逻辑结构是用户敲入cat命令\n  后所看到的文件,用户可得到表示文件内容的字符流.物理结构是文件实际上\n  如何存放在磁盘上的存储格式.用户认为自己的文件是边疆的字符流,但实际\n  上文件可能并不是以边疆的方式存放在磁盘上的,长于一块的文件通常将分散\n  地存放在盘上.然而当用户存取文件时,UNIX文件系统将以正确的顺序取各块,\n  给用户提供文件的逻辑结构.\n      当然,在UNIX系统的某处一定会有一个表,告诉文件系统如何将物理结构\n  转换为逻辑结构.这就涉及到i节点了.i节点是一个64字节长的表,含有有关一\n  个文件的信息,其中有文件大小,文件所有者,文件存取许可方式,以及文件为\n  普通文件,目录文件还是特别文件等.在i节点中最重要的一项是磁盘地址表.\n  该表中有13个块号.前10个块号是文件前10块的存放地址.这10个块号能给出\n  一个至多10块长的文件的逻辑结构,文件将以块号在磁盘地址表中出现的顺序\n  依次取相应的块.\n      当文件长于10块时又怎样呢?磁盘地址表中的第十一项给出一个块号,这\n  个块号指出的块中含有256个块号,至此,这种方法满足了至多长于266块的文\n  件(272,384字节).如果文件大于266块,磁盘地址表的第十二项给出一个块号,\n  这个块号指出的块中含有256个块号,这256个块号的每一个块号又指出一块,\n  块中含256个块号,这些块号才用于取文件的内容.磁盘地址中和第十三项索引\n  寻址方式与第十二项类似,只是多一级间接索引.\n      这样,在UNIX系统中,文件的最大长度是16,842,762块,即17,246,988,288\n  字节,有幸是是UNIX系统对文件的最大长度(一般为1到2M字节)加了更实际的\n  限制,使用户不会无意中建立一个用完整个磁盘窨所有块的文件.\n      文件系统将文件名转换为i节点的方法实际上相当简单.一个目录实际上\n  是一个含有目录表的文件:对于目录中的每个文件,在目录表中有一个入口项,\n  入口项中含有文件名和与文件相应的i节点号.当用户敲入cat xxx时,文件系\n  统就在当前目录表中查找名为xxx的入口项,得到与文件xxx相应的i节点号,然\n  后开始取含有文件xxx的内容的块.\n  (2)设备文件\n      UNIX系统与边在本系统上的各种设备之间的通讯,通过特别文件来实现,\n  就程序而言,磁盘是文件,MODEM是文件,甚至内存也是文件.所有连接到系统上\n  的设备都在/dev目录中有一个文件与其对应.当在这些文件上执行I/O操作时,\n  由UNIX系统将I/O操作转换成实际设备的动作.例如,文件/dev/mem是系统的内\n  存,如果cat这个文件,实际上是在终端显示系统的内存.为了安全起见,这个文\n  件对普通用户是不可读的.因为在任一给定时间,内存区可能含有用户登录口\n  令或运行程序的口令,某部分文件的编辑缓冲区,缓冲区可能含有用ed -x命令\n  解密后的文本,以及用户不愿让其他人存取的种种信息.\n      在/dev中的文件通常称为设备文件,用ls /dev命令可以看看系统中的一\n  些设备:\n      acuo    呼叫自动拨号器\n      console 系统控制台\n      dsknn   块方式操作磁盘分区\n      kmem    核心内存\n      mem     内存\n      lp      打印机\n      mto     块方式操作磁带\n      rdsknn  流方式操作的磁盘分区\n      rmto    流方式操作的磁带\n      swap    交换区\n      syscon  系统终端\n      ttynn   终端口\n      x25     网络端口\n      等等\n  (3)/etc/mknod命令\n      用于建立设备文件.只有root能使用这个命令建立设备文件.其参数是文\n  件名,字母c或b分别代表字符特别文件或块特别文件,主设备号,次设备号.块\n  特别文件是像磁带,磁盘这样一些以块为单位存取数据的设备.字符特别文件\n  是如像终端,打印机,MODEM,或者其它任何与系统通讯时,一次传输一个字符的\n  设备,包括模仿对磁盘进行字符方式存取的磁盘驱动器.主设备号指定了系统\n  子程序(设备驱动程序),当在设备上执行I/O时,系统将调用这个驱动程序.调\n  用设备驱动程序时,次设备号将传递给该驱动程序(次设备规定具体的磁盘驱\n  动器,带驱动器,信号线编号,或磁盘分区).每种类型的设备一般都有自己的设\n  备驱动程序.\n      文件系统将主设备号和次设备号存放在i节点中的磁盘地址表内,所以没\n  有磁盘空间分配给设备文件(除i节点本身占用的磁盘区外).当程序试图在设\n  备文件上执行I/O操作时,系统识别出该文件是一个特别文件,并调用由主设备\n  号指定的设备驱动程序,次设备号作为调用设备驱动程序的参数.\n  (4)安全考虑\n      将设备处理成文件,使得UNIX程序独立于设备,即程序不必一定要了解正\n  使用的设备的任何特性,存取设备也不需要记录长度,块大小,传输速度,网络\n  协议等这样一些信息,所有烦人的细节由设备驱动程序去关心考虑,要存取设\n  备,程序只须打开设备文件,然后作为普通的UNIX文件来使用.\n      从安全的观点来看这样处理很好,因为任何设备上进行的I/O操作只经过\n  了少量的渠道(即设备文件).用户不能直接地存取设备.所以如果正确地设置\n  了磁盘分区的存取许可,用户就只能通过UNIX文件系统存取磁盘.文件系统有\n  内部安全机制(文件许可).不幸的是,如果磁盘分区设备得不正确,任何用户都\n  能够写一个程序读磁盘分区中的每个文件,作法很简单:读一i节点,然后以磁\n  盘地址表中块号出现的顺序,依次读这些块号指出的存有文件内容的块.故除\n  了root以外,决不要使盘分区对任何人可写.因为所有者,文件存取许可方式这\n  样一些信息存放于i节点中,任何人只要具有已安装分区的写许可,就能设置任\n  何文件的SUID许可,而不管文件的所有者是谁,也不必用chmod()命令,还可避\n  过系统建立的安全检查.\n      以上所述对内存文件mem,kmem和对换文件swap也是一样的.这些文件含有\n  用户信息,一个\"耐心\"的程序可以将用户信息提取出来.\n      要避免磁盘分区(以及其它设备)可读可写,应当在建立设备文件前先用\n  umask命令设置文件建立屏蔽值.\n      一般情况下,UNIX系统上的终端口对任何人都是可写的,从而使用户可以\n  用write命令发送信息.虽然write命令易引起安全方面的问题,但大多数用户\n  觉得用write得到其他用户的信息很方便,所以系统将终端设备的存取许可设\n  置成对所有用户可写.\n      /dev目录应当是755存取许可方式,且属root所有.\n      不允许除root外的任何用户读或写盘分区的原则有一例外,即一些程序\n  (通常是数据库系统)要求对磁盘分区直接存取,解决这个问题的经验的盘分区\n  应当由这种程序专用(不安装文件系统),而且应当告知使用这种程序的用户,\n  文件安全保护将由程序自己而不是UNIX文件系统完成.\n  (5)find命令\n      find命令用于搜索目录树,并对目录树上的所有文件执行某种操作,参数\n  是目录名表(指出从哪些起点开始搜索),还可给出一个或多个选项,规定对每\n  个文件执行什么操作.\n      find . -print 将列出当前工作目录下的目录树的每一个文件.\n      find / -user bob -print 将列出在系统中可找到的属于bob用户的所有\n           文件.\n      find /usr/bob -perm 666 -print 将列出/usr/bob目录树下所有存取许\n           可为666的文件.若将666改为-666则将列出所有具有包含了666在内\n           的存取许可方式的文件(如777).\n      find /usr/bob -type b -print 将列出/usr/bob目录树下所有块特别文\n           件(c为字符特别文件).\n      find / -user root -perm -4000 -exec ls -l {} \\; 是一个较复杂一\n           点的命令,-exec COMMAND \\;允许对所找到的每个文件运行指定的\n           命令COMMAND.若COMMAND中含有{},则{}将由find所找到的文件名替\n           换.COMMAND必须以\\;结束.\n      以上举例介绍find的用法,各选项可组合使用以达到更强的功能.\n  (6)secure程序\n      系统管理员应当做一个程序以定期检查系统中的各个系统文件,包括检查\n  设备文件和SUID,SGID程序,尤其要注意检查SUID,SGID程序,检查/etc/passwd\n  和/etc/group文件,寻找久未登录的户头和校验各重要文件是否被修改.\n  (源程序清单将在今后发表)\n  (7)ncheck命令\n      用于检查文件系统,只用一个磁盘分区名作为参数,将列出i节点号及相应\n  的文件名.i节点相同的文件为建链文件.\n      注意:所列出的清单文件名与mount命令的第一个域相同的文件名前部分\n  将不会列出来.因为是做文件系统内部的检查,ncheck并不知道文件系统安装\n  点以上部分的目录.\n      也可用此命令来搜索文件系统中所有的SUID和SGID程序和设备文件,使用\n  -s选项来完成此项功能.\n  (8)安装和拆卸文件系统\n      UNIX文件系统是可安装的,这意味着每个文件系统可以连接到整个目录树\n  的任意节点上(根目录总是被安装上的).安装文件系统的目录称为安装点.\n      /etc/mount命令用于安装文件系统,用这条命令可将文件系统安装在现有\n  目录结构的任意处.\n      安装文件系统时,安装点的文件和目录都是不可存取的,因此未安装文件\n  系统时,不要将文件存入安装点目录.文件系统安装后,安装点的存取许可方式\n  和所有者将改变为所安装的文件根目录的许可方式和所有者.\n      安装文件系统时要小心:安装点的属性会改变!还要注意新建的文件,除非\n  新文件系统是由标准文件建立的,系统标准文件会设置适当的存取许可方式,\n  否则新文件系统的存取许可将是777!\n      可用-r选项将文件系统安装成只读文件系统.需要写保护的带驱动器和磁\n  盘应当以这种方式来安装.\n      不带任何参数的/etc/mount可获得系统中所安装的文件系统的有关信息.\n  包括:文件系统被安装的安装点目录,对应/dev中的哪个设备,只读或可读写,\n  安装时间和日期等.\n      从安全的观点来讲,可安装系统的危险来自用户可能请求系统管理员为其\n  安装用户自己的文件系统.如果安装了用户的文件系统,则应在允许用户存取\n  文件系统前,先扫描用户的文件系统,搜索SUID/SGID程序和设备文件.在除了\n  root外任何人不能执行的目录中安装文件系统,用find命令或secure列出可疑\n  文件,删除不属用户所有的文件的SUID/SGID许可.\n      用户的文件系统用完后,可用umount命令卸下文件系统.并将安装点目录\n  的所有者改回root,存取许可改为755.\n  (9)系统目录和文件\n      UNIX系统中有许多文件不允许用户写,如:/bin,/usr/bin,/usr/lbin,\n  /etc/passwd,/usr/lib/crontab,/unix,/etc/rc,/etc/inittab这样一些文件\n  和目录(大多数的系统目录),可写的目录允许移动文件,会引起安全问题.\n      系统管理员应经常检查系统文件和目录的许可权限和所有者.可做一个程\n  序根据系统提供的规则文件(在/etc/permlist文件中)所描述的文件所有者和\n  许可权规则检查各文件.\n  (源程序清单将在今后发表)\n      注意:如果系统的安全管理不好,或系统是新安装的,其安全程序不够高,\n  可以用make方式在安全强的系统上运行上述程序,将许可规则文件拷贝到新系\n  统来,再以设置方式在新系统上运行上述程序,就可提高本系统的安全程序.但\n  要记住,两个系统必须运行相同的UNIX系统版本.\n4.作为root运行的程序\n    在UNIX系统中,有些程序由系统作为root进程运行.这些程序并不总是具有\nSUID许可,因为其不少程序仅由root运行,系统管理员需要清楚这些程序做什么,\n以及这些程序还将运行其它什么程序.\n  (1)启动系统\n      当某些UNIX系统(如SCO UNIX/XENIX)启动时,是以被称为单用户的方式运\n  行,在这种方式中普通用户不能登录,唯有的进程是init,swapper,以及一些由\n  系统管理员从控制台运行的进程.UNIX系统的单用户方式启动,使系统管理员\n  能在允许普通用户登录以前,先检查系统操作,确保系统一切正常,当系统处于\n  单用户方式时,控制台作为超级用户,命令揭示是\"#\",有些UNIX系统不要确认\n  超级用户口令就认可控制台是root,给出#提示符.这就可能成为一个安全问题.\n  (2)init进程\n      UNIX系统总是以某种方式或称为某种级运行,系统有若干种运行级,这些\n  运行级由init进程控制.\n      UNIX系统启动时以单用户方式运行,也叫1级或S级.\n      对于其他用户登录进入系统,UNIX有一种多用户运行方式,也叫2级.\n      init进程控制系统运行级,它读入文件/etc/inittab,该文件详细地规定\n  了哪些进程在哪一级运行.当root敲入init n(数字),系统就进入n级.init读\n  该文件以确定终止哪些进程,启动哪些进程.\n      有效的运行级的数值是从0到6与s.\n      注意:由init建立的进程以UID为0运行(root)从/etc/inittab运行的程序\n  也作为root运行,所以系统管理员要确保自己知道/etc/inittab中的程序做什\n  么工作,确保这些程序以及这些程序所在的目录直到/和/etc/inittab除root\n  外无人可写.\n  (3)进入多用户\n      当UNIX系统进入多用户方式时,将寝化一系列事件,接着开始执行gettys,\n  允许其他用户登录进入系统.如果再看看/etc/inittab文件,会看到gettys定\n  义在运行级2,至少三个shell程序/etc/brc,/etc/bcheckrc,/etc/rc*也定义\n  在运行级2.这些程序都在gettys启动前运行.\n      这些shell程序作为root运行,也不能仅对root可写还应当检查shell程序\n  运行的命令,因为这些命令也将作为root运行.\n  (4)shutdown命令\n      用shutdown命令关系统,shutdown shell程序发送警告通知所有用户离开\n  系统,在\"给定的期限时间\"到了后,就终止进程,拆卸文件系统,进入单用户方\n  式或关机状态.一旦进入单用户方式,所有的gettys停止运行,用户再不能登录.\n  进入关机状态后可将系统关电.\n      shutdown仅能由作为root登录的用户从系统控制台上运行.所以任何的\n  shutdown运行的命令仅能对root可写.\n  (5)系统V的cron程序\n      cron在UNIX系统是多用户方式时运行,根据规定的时间安排执行指定的命\n  令,每隔一分钟检查一次文件/usr/lib/crontab,寻找是否有应当运行的程序?\n  如果找到要运行的程序,就运行该程序,否则睡眠等待一分钟.\n      实际的/usr/lib/crontab用于根据全天的规则时间表运行程序,也可在夜\n  晚运行白天不愿运行怕降低其他用户速度的程序.通常由cron运行的程序是如\n  记帐,存文件这样的程序.cron一般在系统进入多用户后由/etc/rc启动,当\n  shutdown运行killall命令时便终止运行.由cron运行的程序作为root,所以应\n  当注意放什么程序在crontab中,还要确保/usr/lib/crontab和该表中列出的\n  任何程序对任何人不可写.\n      如果用户需要由cron执行一个程序,系统管理员可用su命令在crontab表\n  中建立一个入口,使用户的程序不能获得root的权限.\n  (6)系统V版本2之后的cron程序\n      在系统V版本2中,cron被修改成允许用户建立自己的crontab入口,\n  /usr/lib/crontab文件不再存在,由目录/usr/spool/cron/crontabs中的文件\n  代替.这些文件的格式与crontab相同,但每个文件与系统中的一个用户对应,\n  并以某用户的名义由cron运行.\n      如果想限制能建立crontab的用户,可在文件/usr/lib/cron/cron.allow\n  文件中列出允许运行crontab命令的用户.任何未列于该文件的用户不能运行\n  crontab.反之,若更愿意列出不允许运行crontab命令的用户,则可将他们列入\n  /usr/lib/cron/cron.deny文件中,未列于该文件的其他用户将被允许建立\n  crontab.\n      注意:若两个文件都存在,系统将使用cron.allow,忽略cron.deny.如果两\n  个文件都不存在,则只有root可运行crontab.所以,若要允许系统中的所有用\n  户都可运行crontab命令,应当建立一个空的cron.deny文件,如果cron.allow\n  也存在,则删除该文件.\n      这个版本的cron命令的安全程度比前一个高,因为用户只能看自己的\n  crontab,系统管理员也不必担心其他用户的程序是否会作为root运行,由于允\n  许每个系统登录用户有自己的crontab,也简化了对程序必须由cron运行,但不\n  必作为root运行的系统程序的处理.\n      必须确保root的crontab文件仅对root可写,并且该文件所在的目录及所\n  有的父目录也仅对root可写.\n  (7)/etc/profile\n      每当用户(包括root在内)登录时,由shell执行/etc/profile文件,应确保\n  这个文件以及从这个文件运行的程序和命令都仅对root可写.\n5./etc/passwd文件\n    /etc/passwd文件是UNIX安全的关键文件之一.该文件用于用户登录时校验\n用户的口令,当然应当仅对root可写.文件中每行的一般格式为:\n    LOGNAME:PASSWORD:UID:GID:USERINFO:HOME:SHELL\n    每行的头两项是登录名和加密后的口令,后面的两个数是UID和GID,接着的\n一项是系统管理员想写入的有关该用户的任何信息,最后两项是两个路径名:\n一个是分配给用户的HOME目录,第二个是用户登录后将执行的shell(若为空格则\n缺省为/bin/sh).\n  (1)口令时效\n      /etc/passwd文件的格式使系统管理员能要求用户定期地改变他们的口令.\n  在口令文件中可以看到,有些加密后的口令有逗号,逗号后有几个字符和一个\n  冒号.如:\n      steve:xyDfccTrt180x,M.y8:0:0:admin:/:/bin/sh\n      restrict:pomJk109Jky41,.1:0:0:admin:/:/bin/sh\n      pat:xmotTVoyumjls:0:0:admin:/:/bin/sh\n      可以看到,steve的口令逗号后有4个字符,restrict有2个,pat没有逗号.\n      逗号后第一个字符是口令有效期的最大周数,第二个字符决定了用户再次\n  修改口信之前,原口令应使用的最小周数(这就防止了用户改了新口令后立刻\n  又改回成老口令).其余字符表明口令最新修改时间.\n      要能读懂口令中逗号后的信息,必须首先知道如何用passwd_esc计数,计\n  数的方法是: .=0  /=1  0-9=2-11  A-Z=12-37  a-z=38-63\n      系统管理员必须将前两个字符放进/etc/passwd文件,以要求用户定期的\n  修改口令,另外两个字符当用户修改口令时,由passwd命令填入.\n      注意:若想让用户修改口令,可在最后一次口令被修改时,放两个\".\",则下\n  一次用户登录时将被要求修改自己的口令.\n      有两种特殊情况:\n      . 最大周数(第一个字符)小于最小周数(第二个字符),则不允许用户修改\n        口令,仅超级用户可以修改用户的口令.\n      . 第一个字符和第二个字符都是\".\",这时用户下次登录时被要求修改口\n        令,修改口令后,passwd命令将\".\"删除,此后再不会要求用户修改口令.\n  (2)UID和GID\n      /etc/passwd中UID信息很重要,系统使用UID而不是登录名区别用户.一般\n  来说,用户的UID应当是独一无二的,其他用户不应当有相同的UID数值.根据惯\n  例,从0到99的UID保留用作系统用户的UID(root,bin,uucp等).\n      如果在/etc/passwd文件中有两个不同的入口项有相同的UID,则这两个用\n  户对相互的文件具有相同的存取权限.\n6./etc/group文件\n    /etc/group文件含有关于小组的信息,/etc/passwd中的每个GID在本文件中\n应当有相应的入口项,入口项中列出了小组名和小组中的用户.这样可方便地了\n解每个小组的用户,否则必须根据GID在/etc/passwd文件中从头至尾地寻找同组\n用户.\n    /etc/group文件对小组的许可权限的控制并不是必要的,因为系统用UID,GID\n(取自/etc/passwd)决定文件存取权限,即使/etc/group文件不存在于系统中,具\n有相同的GID用户也可以小组的存取许可权限共享文件.\n    小组就像登录用户一样可以有口令.如果/etc/group文件入口项的第二个域\n为非空,则将被认为是加密口令,newgrp命令将要求用户给出口令,然后将口令加\n密,再与该域的加密口令比较.\n    给小组建立口令一般不是个好作法.第一,如果小组内共享文件,若有某人猜\n着小组口令,则该组的所有用户的文件就可能泄漏;其次,管理小组口令很费事,\n因为对于小组没有类似的passwd命令.可用/usr/lib/makekey生成一个口令写入\n/etc/group.\n    以下情况必须建立新组:\n    (1)可能要增加新用户,该用户不属于任何一个现有的小组.\n    (2)有的用户可能时常需要独自为一个小组.\n    (3)有的用户可能有一个SGID程序,需要独自为一个小组.\n    (4)有时可能要安装运行SGID的软件系统,该软件系统需要建立一个新组.\n    要增加一个新组,必须编辑该文件,为新组加一个入口项.\n    由于用户登录时,系统从/etc/passwd文件中取GID,而不是从/etc/group中\n取GID,所以group文件和口令文件应当具有一致性.对于一个用户的小组,UID和\nGID应当是相同的.多用户小组的GID应当不同于任何用户的UID,一般为5位数,这\n样在查看/etc/passwd文件时,就可根据5位数据的GID识别多用户小组,这将减少\n增加新组,新用户时可能产生的混淆.\n7.增加,删除,移走用户\n  (1)增加用户\n      增加用户有三个过程:\n      . 在/etc/passwd文件中写入新用户的入口项.\n      . 为新登录用户建立一个HOME目录.\n      . 在/etc/group中为新用户增加一个入口项.\n      在/etc/passwd文件中写入新的入口项时,口令部分可先设置为NOLOGIN,\n  以免有人做为此新用户登录.在修改文件前,应mkdir /etc/ptmp,以免他人同\n  时修改此文件.新用户一般独立为一个新组,GID号与UID号相同(除非他要加入\n  目前已存在的一个新组),UID号必须和其他人不同,HOME目录一般设置在/usr\n  或/home目录下建立一个以用户登录名为名称的目录做为其主目录.\n  (2)删除用户\n      删除用户与加用户的工作正好相反,首先在/etc/passwd和/etc/group文\n  件中删除用户的入口项,然后删除用户的HOME目录和所有文件.\n      rm -r /usr/loginname 删除整个目录树.\n      如果用户在/usr/spool/cron/crontabs中有crontab文件,也应当删除.\n  (3)将用户移到另一个系统\n      这是一个复杂的问题,不只是拷贝用户的文件和用户在/etc/passwd文件\n  中的入口项.首先一个问题是用户的UID和GID可能已经用于另一个系统,若是\n  出现这种情况,必须给要移的用户分配另外的UID和GID,如果改变了用户的UID\n  和GID,则必须搜索该用户的全部文件,将文件的原UID和GID改成新的UID和GID.\n  用find命令可以完成这一修改:\n      find . -user olduid -exec chown newuid {} \\;\n      find . -group oldgid -exec chgrp newgid {} \\;\n      也许还要为用户移走其它一些文件:\n      /usr/mail/user和/usr/spool/cron/crontabs/user.\n      如果用户从一个不是本系统管理员的系统移来,则应对该用户的目录结构\n  运行程序来检查.一个不安全系统的用户,可能有与该用户其它文件存在一起\n  的SUID/SGID程序,而这个SUID/SGID程序属于另一个用户.在这种情况下,如果\n  用cpio或tar命令将用户的目录结构拷贝到本系统,SUID/SGID程序也将会拷贝\n  到本系统而没有任何警告信息.应当在允许用户使用新系统以前先删除这种文\n  件的SUID/SGID许可.总之,始终坚持检查所移用户的文件总是更安全些.也可\n  以用su命令进入用户的户头,再拷贝用户文件,这样文件的所有者就是该用户,\n  而不是root.\n8.安全检查\n    像find和secure这样的程序称为检查程序,它们搜索文件系统,寻找出SUID/\nSGID文件,设备文件,任何人可写的系统文件,设有口令的登录用户,具有相同UID\n/GID的用户等等.\n  (1)记帐\n      UNIX记帐软件包可用作安全检查工具,除最后登录时间的记录外,记帐系\n  统还能保存全天运行的所有进程的完整记录,对于一个进程所存贮的信息包括\n  UID,命令名,进程开始执行与结束的时间,CPU时间和实际消耗的时间,该进程\n  是否是root进程,这将有助于系统管理员了解系统中的用户在干什么.acctcom\n  命令可以列出一天的帐目表.有明,系统中有多个记帐数据文件,记帐信息保存\n  在文件/usr/adm/pacct*中,/usr/adm/pacct是当前记录文件,/usr/adm/pacctn\n  是以前的记帐文件(n为整型数).若有若干个记帐文件要查看,可在acctcom命\n  令中指定文件名: acctcom /usr/adm/pacct? /usr/adm/pacct\n      要检查的问题的其中之一是:在acctcom的输出中查找一个用户过多的登\n  录过程,若有,则说明可能有人一遍遍地尝试登录,猜测口令,企图非法进入系\n  统.此外,还应查看root进程,除了系统管理员用su命令从终端进入root,系统\n  启动,系统停止时间,以及由init(通常init只启动getty,login,登录shell),\n  cron启动的进程和具有root SUID许可的命令外,不应当有任何root进程.\n      由记帐系统也可获得有关每个用户的CPU利用率,运行的进程数等统计数\n  据.\n  (2)其它检查命令\n      *du:报告在层次目录结构(当前工作目录或指定目录起)中各目录占用的\n          磁盘块数.可用于检查用户对文件系统的使用情况.\n      *df:报告整个文件系统当前的空间使用情况.可用于合理调整磁盘空间的\n          使用和管理.\n      *ps:检查当前系统中正在运行的所有进程.对于用了大量CPU时间的进程,\n          同时运行了许多进程的用户,运行了很长时间但用了很少CPU时间的\n          用户进程应当深入检查.还可以查出运行了一个无限制循环的后台进\n          程的用户,未注销户头就关终端的用户(一般发生在直接连线的终端).\n      *who:可以告诉系统管理员系统中工作的进展情况等等许多信息,检查用\n          户的登录时间,登录终端.\n      *su:每当用户试图使用su命令进入系统用户时,命令将在/usr/adm/sulog\n          文件中写一条信息,若该文件记录了大量试图用su进入root的无效操\n          作信息,则表明了可能有人企图破译root口令.\n      *login:在一些系统中,login程序记录了无效的登录企图(若本系统的\n          login程序不做这项工作而系统中有login源程序,则应修改login).\n          每天总有少量的无效登录,若无效登录的次数突然增加了两倍,则表\n          明可能有人企图通过猜测登录名和口令,非法进入系统.\n      这里最重要的一点是:系统管理没越熟悉自己的用户和用户的工作习惯,\n  就越能快速发现系统中任何不寻常的事件,而不寻常的事件意味着系统已被人\n  窃密.\n\n  (3)安全检查程序的问题\n      关于以上的检查方法的一个警告,若有诱骗,则这些方法中没有几个能防\n  诱骗.如find命令,如果碰到路径名长于256个字符的文件或含有多于200个文\n  件的目录,将放弃处理该文件或目录,用户就有可能利用建立多层目录结构或\n  大目录隐藏SUID程序,使其逃避检查(但find命令会给出一个错误信息,系统管\n  理员应手工检查这些目录和文件).也可用ncheck命令搜索文件系统,但它没有\n  find命令指定搜索哪种文件的功能.\n      如果定期存取.profile文件,则检查久未登录用户的方法就不奏效了.而\n  用户用su命令时,除非用参数-,否则su不读用户的.profile.\n      有三种方法可寻找久未登录的帐户:\n      . UNIX记帐系统在文件/usr/adm/acct/sum/login中为每个用户保留了最\n        后一次登录日期.用这个文件的好处是,该文件由系统维护,所以可完全\n        肯定登录日期是准确的.缺点是必须在系统上运行记帐程序以更新\n        loginlog文件,如果在清晨(午夜后)运行记帐程序,一天的登录日期可\n        能就被清除了.\n      . /etc/passwd文件中的口令时效域将能告诉系统管理员,用户的口令是\n        否过期了,若过期,则意味着自过期以来,户头再未被用过.这一方法的\n        好处在于系统记录了久未用的户头,检查过程简单,且不需要记帐系统\n        所需要的磁盘资源,缺点是也许系统管理员不想在系统上设置口令时效,\n        而且这一方法仅在口令的最大有效期(只有几周)才是准确的.\n      . 系统管理员可以写一个程序,每天(和重新引导系统时)扫描/etc/wtmp,\n        自己保留下用户最后登录时间记录,这一方法的好处是不需要记帐程序,\n        并且时间准确,缺点是要自己写程序.\n      以上任何方法都可和/usr/adm/sulog文件结合起来,查出由login或su登\n  录户头的最后登录时间.\n      如果有人存心破坏系统安全,第一件要做的事就是寻找检查程序.破坏者\n  将修改检查程序,使其不能报告任何异常事件,也可能停止系统记帐,删除记帐\n  文件,使系统管理员不能发现破坏者干了些什么.\n  (4)系统泄密后怎么办?\n      发现有人已经破坏了系统安全的时候,这时系统管理员首先应做的是面对\n  肇事用户.如果该用户所做的事不是蓄意的,而且公司没有关于\"破坏安全\"的\n  规章,也未造成损坏,则系统管理员只需清理系统,并留心该用户一段时间.如\n  果该用户造成了某些损坏,则应当报告有关人士,并且应尽可能地将系统恢复\n  到原来的状态.\n      如果肇事者是非授权用户,那就得做最坏的假设了:肇事者已设法成为root\n  且本系统的文件和程序已经泄密了.系统管理员应当想法查出谁是肇事者,他\n  造成了什么损坏?还应当对整个文件做一次全面的检查,并不只是检查SUID和\n  SGID,设备文件.如果系统安全被一个敌对的用户破坏了,应当采用下面的步骤:\n      . 关系统,然后重新引导,不要进入多用户方式,进入单用户方式.\n      . 安装含有本系统原始UNIX版本的带和软盘.\n      . 将/bin,/usr/bin,/etc,/usr/lib中的文件拷贝到一个暂存目录中.\n      . 将暂存目录中所有文件的校验和(用原始版本的sum程序拷贝做校验和,\n        不要用/bin中的suM程序做)与系统中所有对就的文件的校验和进行比\n        较,如果有任何差别,要查清差别产生的原因.如果两个校验和不同,是\n        由于安装了新版本的程序,确认一相是否的确是安装了新版本程序.如\n        果不能找出校验和不同的原因,用暂存目录中的命令替换系统中的原有\n        命令.\n      . 在确认系统中的命令还未被窜改之前,不要用系统中原命令.用暂存目\n        录中的shell,并将PATH设置为仅在暂存目录中搜索命令.\n      . 根据暂存目录中所有系统命令的存取许可,检查系统中所有命令的存取\n        许可.\n      . 检查所有系统目录的存取许可,如果用了perms,检查permlist文件是否\n        被窜改过.\n      . 如果系统UNIX(/unix)的校验和不同于原版的校验和,并且系统管理员\n        从未修改过核心,则应当认为,一个非法者\"很能干\",从暂存缓冲区重新\n        装入系统.系统管理员可以从逐步增加的文件系统备份中恢复用户的文\n        件,但是在检查备份中的\"有趣\"文件之前,不能做文件恢复.\n      . 改变系统中的所有口令,通知用户他们的口令已改变,应找系统管理员\n        得到新口令.\n      . 当用户来要新口令时,告诉用户发生了一次安全事故,他们应查看自己\n        的文件和目录是否潜伏着危害(如SUID文件,特洛依木马,任何人可写的\n        目录),并报告系统管理员任何异乎寻常的情况.\n      . 设法查清安全破坏是如何发生的?如果没有肇事者说明,这也许是不可\n        能弄清的.如果能发现肇事者如何进入系统,设法堵住这个安全漏洞.\n      第一次安装UNIX系统时,可以将shell,sum命令,所有文件的校验和存放在\n  安全的介质上(带,软盘,硬盘和任何可以卸下并锁焉起来的介质).于是不必再\n  从原版系统带上重新装入文件,可以安装备份介质,装入shell和sum,将存在带\n  上的校验和与系统中文件的校验和进行比较.系统管理员也许想自己写一个计\n  算校验和的程序,破坏者将不能知道该程序的算法,如果将该程序及校验和保\n  存在带上,这一方法的保密问题就减小到一个物理的安全问题,即只需将带锁\n  起来.\n9.加限制的环境\n  (1)加限制的shell(rsh)\n      该shell几乎与普通的shell相同,但是该shell的设计能限制一个用户的\n  能力,不允许用户有某些标准shell所允许的行为:\n      . 不能改变工作目录(cd).\n      . 不能改变PATH或SHELL shell变量.\n      . 不能使用含有\"/\"的命令名.\n      . 不能重定向输出(>和>>).\n      . 不能用exec执行程序.\n      用户在登录时,招待.profile文件后系统就强加上了这些限制,如果用户\n  在.profile文件正被解释时按了BREAK键或DELETE键,该用户将被注销.\n      这些简单的限制,使用写受限制用户的.profile文件的系统管理员可以对\n  用户能使用什么命令,进行完全的控制.\n      应当注意:系统V加限制的shell实际上不是很安全,在敌对的用户时不要\n  用.系统V版本2以后的版本中加限制的shell更安全些.但若允许受限制的用户\n  使用某些命令(如env,cp,ln),用户将能逃避加限制的shell,进入非限制的\n  shell.\n  (2)用chroot()限制用户\n      如果的确想限制一个用户,可用chroot()子程序为用户建立一个完全隔离\n  的环境,改变了进程对根目录的概念,因此可用于将一个用户封在整个文件系\n  统的某一层目录结构中,使用户无法用cd命令转出该层目录结构,不能存取文\n  件系统中其余部分的任何文件.这种限制方式比加限制的shell好得多.用户使\n  用的命令应由系统管理员在新的root目录中建立一个bin目录,并建立用户可\n  用命令的链到系统的/bin目录中相应命令文件上(若在不同的文件系统则应拷\n  贝命令文件).\n      还应建立新的passwd文件,保留系统登录户头(为了使ls -l正确地报告与\n  受限制的子文件系统中的文件相关的正确登录名)和用户帐户,但系统帐户的\n  口令改为NOLOGIN以使受限制的用户不能取得系统登录的真实口令,使\"破密\"\n  程序的任何企图成为泡影.\n      utmp文件是who所需要的,该文件含有系统中已登录用户的列表.\n      新的/etc/profile文件也不是建链文件,以便受限制的用户可以执行不同\n  的启动命令.\n      /dev目录中的终端设备文件被链接到新的/dev目录下,因为命令who产生\n  输出时要查看这些文件.\n      在系统V及以后的UNIX版本中,login命令有chroot()的功能.如果口令文\n  件中用户入口项的登录shell域(最后一个域)是*,login将调用chroot()把用\n  户的根目录设置成为口令文件中用户入口项登录目录域指定的目录.然后再调\n  用exec()执行login,新的login将在新子系统文件中执行该用户的登录.\n      chroot()并不是把root封锁在一个子文件系统中,所以给受限制用户用的\n  命令时应加以考虑,具有root的SUID许可的程序可能会给予用户root的能力.\n  应当将这种可能减低到最小程度,交给用户使用的命令应当取自清除了SUID陷\n  井的系统命令.链接文件可减少磁盘占用区,但要记住,当与敌对用户打交道时\n  链接到chroot目录结构(尤其是命令)的系统文件是很危险的.\n      如果建立一个像这样的限制环境,应确保对安装到新的/bin的每条命令都\n  做过测试,有些程序可能有系统管理员未曾想到的出乎意料的执行结果.为了\n  使这些命令能运行,还得在加限制的子文件系统中加服务目录或文件如:/tmp,\n  /etc/termcap,/usr/lib/terminfo,/dev/mem,/dev/kmem,/dev/swap,用户所\n  登录的/dev中的tty文件以及/unix.\n      有些程序在子文件系统中运行时不会很好,如果将假脱机程序和网络命令\n  拷贝到加限制的子文件系统中,并放在为两条命令专建的目录层结构下,它们\n  可能也运行不了.\n10.小系统安全\n    任何足够小,运行于办公室的UNIX系统就是小系统.这类小系统也包括所有\n台式UNIX机器.根据安全观点,使小系统很特别而值得特别的有以下几点:\n    . 小系统的用户比大系统的用户少,通常是很小一组用户,使系统管理员能\n      熟悉每个人,安全问题可以直接地面对面处理.\n    . 由于小UNIX系统管理更简单,可能只需要一个系统管理员,因而维护系统\n      安全的责任只有一个人担负.\n    . 如果既是用户又是系统管理员,将不能花大量时间考虑系统安全.\n    . 如果自己拥有系统并且是系统管理员,就可能有权直接将违反规的用户从\n      系统中删除,而没有几个大系统的管理员能有这种权利.\n    . 如果自己是系统的唯一用户,则将既是用户又是管理员,维护系统安全的\n      任务就很简单了,只须确保系统中所有登录户头的口令是好的.\n    . 如果不能将系统锁起来,就把敏感的数据存放在软盘上,把软盘锁起来.\n    . 即使系统中有若干个用户,但如果系统的终端之产是有线连接,并且用户\n      们保持门上锁,则系统也将是安全的,至少在本组用户内是安全的.\n    . 小系统通常有可移动的介质(软盘),可用mount命令将其安装到系统上,提\n      供一种安全的方法让用户自己在系统上安装软盘,否则系统管理员要一天\n      到晚地干这些琐碎的安装盘事务.允许用户安装软盘的通常做法是给用户\n      一个SUID程序,该程序基本完成与系统管理员安装用户软盘同样的操作,\n      首先检查软盘上有无SUID/SGID/设备文件,若发现任何奇怪的文件,则拒\n      绝安装该软盘.\n    . 当小系统开电源后,系统一般在从硬盘引导以前,先试图从软盘引导.这就\n      意味着计算机将首先试图从软盘装入程序,若软盘不在驱动器中,系统将\n      从硬盘装入UNIX内核.软盘几乎可以含有任何程序,包括在控制台启动\n      root shell的UNIX系统版本.如果破坏者有一把螺丝起子和有关系统内部\n      的一些知识,则即便系统有被认为防止安全事故发生的特殊\"微码\"口令,\n      也可能被诱骗去从软盘引导.\n    . 即使小系统晚上不锁,凡从不将个人的或秘密的信息存放在大系统上的人\n      他们不可能认识所有系统上的用户),也不会想把这样的信息存放在小系\n      统上.\n    . 小系统的系统管理员在使用UNIX系统方面常不如大系统管理员?芯?,而\n      安全地管理系统需要一定的使用系统的知识.\n11.物理安全\n    对于运行任何操作系统的小型或大型计算机,物理安全都是一个要考虑的重\n要问题,物理安全包括:锁上放置计算机的屋子,报警系统,警卫,所有安置在不能\n上锁的地方的通讯设施,包括有线通讯线,电话线,局域网,远程网,应答MODEM,钥\n匙或信用卡识别设备,给用户的口令和钥匙分配,任何前置通讯设施的加密装置,\n文件保护,备份或恢复方案(称为安全保险方案,用作应付偶然的或蓄意的数据或\n计算设备被破坏的情况),上锁的输出仃,上锁的废物箱和碎纸机.\n    物理安全中所饮食的总考虑应是:在安全方案上所付出的代价不应当多于值\n得保护的(硬件或软件的)价值.\n    下面着重讨论保护用户的各种通讯线.对于任何可在不上锁的地方存取的系\n统,通讯是特别严重的安全薄弱环节.当允许用户通过挂到地方电话公司的拨号\nMODEM存取系统时,系统的安全程度就将大大地削弱,有电话和MODEM的任何人就\n可能非法进入该系统.应当避免这一情况,要确保MODEM的电话号码不被列于电话\n薄上,并且最好将电话号码放在不同于本公司普通电话号码所在的交换机上.总\n之,不要假设没人知道自己的拨入号码!大多数家庭计算机都能编程用一个MODEM\n整天地依次调用拨号码,记录下连接上其它MODEM的号码.如果可能,安装一个局\n域PBX,使得对外界的拨号产生一秒钟的拨号蜂音,并且必须输入一个与MODEM相\n关联的扩展号码.\n12.用户意识\n    UNIX系统管理员的职责之一是保证用户安全.这其中一部分工作是由用户的\n管理部门来完成,但是作为系统管理员,有责任发现和报告系统的安全问题,因为\n系统管理员负责系统的运行.\n    避免系统安全事故的方法是预防性的,当用户登录时,其shell在给出提示前\n先执行/etc/profile文件,要确保该文件中的PATH指定最后搜索当前工作目录,\n这样将减少用户能运行特洛依木马的机会.\n    将文件建立屏蔽值的设置放在该文件中也是很合适的,可将其值设置成至少\n将防止用户无意中建立任何人都能写的文件(022/026).要小心选择此值,如果限\n制太严,则用户会在自己的.profile中重新调用umask以抵制系统管理员的意愿,\n如果用户大量使用小组权限共享文件,系统管理员就一要设置限制小组存取权限\n的屏蔽值.系统管理员必须建立系统安全和用户的\"痛苦量\"间的平衡(痛苦量是\n安全限制引起的愤怒的函数).定期地用grep命令查看用户.profile文件中的\numask,可了解系统安全限制是否超过了用户痛苦极限.\n    系统管理员可每星期随机抽选一个用户,将该用户的安全检查结果(用户的\n登录情况简报,SUID/SGID文件列表等)发送给他的管理部门和他本人.主要有四\n个目的:\n    . 大多数用户会收到至少有一个文件检查情况的邮件,这将引起用户考虑安\n      全问题(虽然并不意味着用户们会采取加强安全的行动).\n    . 有大量可写文件的用户,将一星期得到一次邮件,直到他们取消可写文件\n      的写许可为止.冗长的烦人的邮件信息也许足以促使这些用户采取措施,\n      删除文件的写许可.\n    . 邮件将列出用户的SUID程序,引起用户注意自己有SUID程序,使用户知道\n      是否有不是自己建立的SUID程序.\n    . 送安全检查表可供用户管理自己的文件,并使用户知道对文件的管理关系\n      到数据安全.如果系统管理员打算这样做,应事先让用户知道,以便他们了\n      解安全检查邮件的目的.\n    发送邮件是让用户具有安全意识,不要抱怨发送邮件.\n    管理意识是提高安全性的另一个重要因素.如果用户的管理部门对安全要求\n不强烈,系统管理员可能也忘记强化安全规则.最好让管理部门建立一套每个人\n都必须遵守的安全标准,如果系统管理员在此基础上再建立自己的安全规则,就\n强化了安全.管理有助于加强用户意识,让用户明确,信息是有价值的资产.\n    系统管理员应当使安全保护方法对用户尽可能地简单,提供一些提高安全的\n工具,如:公布锁终端的lock程序,让用户自己运行secure程序,将pwexp(检查用\n户口令信息的程序)放入/etc/profile中,使用户知道自己的口令时间.多教给用\n户一些关于系统安全的知识,确保用户知道自己的许可权限和umask命令的设置\n值.如果注意到用户在做蠢事,就给他们一些应当怎样做才对的提示.用户知道的\n关于安全的知识越多,系统管理员在保护用户利益方面做的事就越少.\n13.系统管理员意识\n  (1)保持系统管理员个人的登录安全\n      若系统管理员的登录口令泄密了,则窃密者离窃取root只有一步之遥了,\n  因为系统管理员经常作为root运行,窃密者非法进入到系统管理员的户头后,\n  将用特洛依木马替换系统管理员的某些程序,系统管理员将作为root运行这些\n  已被替换的程序.正是因为这个原因,在UNIX系统中,管理员的户头最常受到攻\n  击.即使su命令通常要在任何都不可读的文件中记录所有想成为root的企图,\n  还可用记帐数据或ps命令识别运行su命令的用户.也是如此,系统管理员作为\n  root运行程序时应当特别小心,因为最微小的疏忽也可能\"沉船\".下列一些指\n  导规则可使系统管理员驾驶一艘\"坚固的船\":\n    . 不要作为root或以自己的登录户头运行其他用户的程序,首先用su命令进\n      入用户的户头.\n    . 决不要把当前?ぷ髂柯寂旁赑ATH路径表的前边,那样实际是招引特洛依木\n      马.当系统管理员用su命令进入root时,他的PATH将会改变,就让PATH保持\n      这样,以避免特洛依木马的侵入.\n    . 敲入/bin/su执行su命令.若有su源码,将其改成必须用全路径名运行(即\n      su要确认argv[0]的头一个字符是\"/\"才运行).随着时间的推移,用户和管\n      理员将养成敲/bin/su的习惯.\n    . 不要未注销户头就离开终端,特别是作为root用户时更不能这样.当系统\n      管理员作为root用户时,命令提示符是\"#\",这个提示符对某些人来说可能\n      是个红灯标志.\n    . 不允许root在除控制台外的任何终端登录(这是login的编译时的选项),\n      如果没有login源码,就将登录名root改成别的名,使破坏者不能在root登\n      录名下猜测各种可能的口令,从而非法进入root的户头.\n    . 经常改变root的口令.\n    . 确认su命令记下的想运行su企图的记录/usr/adm/sulog,该记录文件的许\n      可方式是600,并属root所有.这是非法者喜欢选择来替换成特洛依木马的\n      文件.\n    . 不要让某人作为root运行,即使是几分钟,即使是系统管理员在一旁注视\n      着也不行!\n  (2)保持系统安全\n    . 考虑系统中一些关键的薄弱环节:\n      a. 系统是否有MODEM?电话号码是否公布?\n      b. 系统是否连接到?还有什么系统也连接到该网络?\n      c. 系统管理员是否使用未知来处或来处不可靠的程序?\n      d. 系统管理员是否将重要信息放在系统中?\n      e. 系统的用户是熟悉系统的使用还是新手?\n      f. 用户是否很重视关心安全?\n      g. 用户的管理部门是否重视安全?\n    . 保持系统文件安全的完整性.检查所有系统文件的存取许可,任何具有\n      SUID许可的程序都是非法者想偷换的选择对象.\n    . 要特别注意设备文件的存取许可.\n    . 要审查用户目录中具有系统ID/系统小组的SUID/SGID许可的文件.\n    . 在未检查用户的文件系统的SUID/SGID程序和设备文件之前,不要安装用\n      户的文件系统.\n    . 将磁盘的备份存放在安全的地方.\n    . 设置口令时效,如果能存取UNIX的源码,将加密口令和信息移到仅对root\n      可读的文件中,并修改系统的口令处理子程序.这样可增加口令的安全.修\n      改passwd,使passwd能删去口令打头和末尾的数字,然后根据spell词典和\n      /etc/passwd中用户的个人信息,检查用户的新口令,也检查用户新口令中\n      子串等于登录名的情况.如果新口令是spell词典中的单词,或/etc/passwd\n      中的入口项的某项值,或是登录名的子串,passwd将不允许用户改变口令.\n    . 记录本系统的用户及其授权使用的系统.\n    . 查出久未使用的登录户头,并取消该户头.\n    . 确保没有无口令的登录户头.\n    . 启动记帐系统.\n    . 查出不寻常的系统使用情况,如大量的占用磁盘,大量的使用CPU时间,大\n      量的进程,大量的使用su的企图,大量无效的登录,大量的到某一系统的网\n      络传输,奇怪的uucp请求.\n    . 修改shell,使其等待了一定时间而无任务时终止运行.\n    . 修改login,使其打印出用户登录的最后时间,三次无效登录后,将通讯线\n      挂起,以便系统管理员能检查出是否有人试图非法进入系统.确保login不\n      让root在除控制台外的任何地方登录.\n    . 修改su,使得只有root能以过期口令通过su进入某一户头.\n    . 当安装来源不可靠的软件时,要检查源码和makefile文件,查看特殊的子\n      程序调用或命令.\n    . 即使是安装来源可靠的软件,也要检查是否有SUID(SGID)程序,确认这些\n      许可的确是必要的.如果可能,不要让这些程序具有系统ID(或组)的SUID\n      (SGID)许可,而应该建立一个新用户(或给)供该软件运行.\n    . 如果系统在办公室中,门应上锁,将重要数据保存在软盘上或带上,并锁起\n      来.\n    . 将secure,perms和任何其它做安全检查的shell程序存取许可置为仅执行,\n      更好的是将这些shell程序存于可拆卸的介质上.\n    . 记住,只要系统有任何人都可调用的拨号线,系统就不可能真正的安全.系\n      统管理员可以很好地防止系统受到偶然的破坏.但是那些有耐心,有计划,\n      知道自己在干什么的破坏者,对系统直接的有预谋的攻击却常常能成功.\n    . 如果系统管理员认为系统已经泄密,则应当设法查出肇事者.若肇事者是\n      本系统的用户,与用户的管理部门联系,并检查该用户的文件,查找任何可\n      疑的文件,然后对该用户的登录小心地监督几个星期.如果肇事者不是本\n      系统的用户,可让本公司采取合法的措施,并要求所有的用户改变口令,让\n      用户知道出了安全事故,用户们应当检查自己的文件是否有被窜改的迹象.\n      如果系统管理员认为系统软件已被更改了,就应当从原版系统带(或;软盘\n      )上重装入所有系统软件,保持系统安全比道歉更好.\n--------------------------------------------------------------------\n标  题: 程序员安全\n    UNIX系统为程序员提供了许多子程序,这些子程序可存取各种安全属性.有\n些是信息子程序,返回文件属性,实际的和有效的UID,GID等信息.有些子程序可\n改变文件属性.UID,GID等有些处理口令文件和小组文件,还有些完成加密和解密.\n    本文主要讨论有关系统子程序,标准C库子程序的安全,如何写安全的C程序\n并从root的角度介绍程序设计(仅能被root调用的子程序).\n1.系统子程序\n  (1)I/O子程序\n    *creat():建立一个新文件或重写一个暂存文件.\n             需要两个参数:文件名和存取许可值(8进制方式).如:\n     creat(\"/usr/pat/read_write\",0666)  /* 建立存取许可方式为0666的文件 */\n     调用此子程序的进程必须要有建立的文件的所在目录的写和执行许可,置\n     给creat()的许可方式变量将被umask()设置的文件建立屏蔽值所修改,新\n     文件的所有者和小组由有效的UID和GID决定.\n     返回值为新建文件的文件描述符.\n    *fstat():见后面的stat().\n    *open():在C程序内部打开文件.\n            需要两个参数:文件路径名和打开方式(I,O,I&O).\n     如果调用此子程序的进程没有对于要打开的文件的正确存取许可(包括文\n     件路径上所有目录分量的搜索许可),将会引起执行失败.\n     如果此子程序被调用?ゴ蚩淮嬖诘奈募?,除非设置了O_CREAT标志,调用\n     将不成功.此时,新文件的存取许可作为第三个参数(可被用户的umask修\n     改).\n     当文件被进程打开后再改变该文件或该文件所在目录的存取许可,不影响\n     对该文件的I/O操作.\n    *read():从已由open()打开并用作输入的文件中读信息.\n     它并不关心该文件的存取许可.一旦文件作为输入打开,即可从该文件中读\n     取信息.\n    *write():输出信息到已由open()打开并用作输出的文件中.同read()一样\n     它也不关心该文件的存取许可.\n  (2)进程控制\n    *exec()族:包括execl(),execv(),execle(),execve(),execlp()和execvp()\n              可将一可执行模快拷贝到调用进程占有的存贮空间.正被调用进\n              程执行的程序将不复存在,新程序取代其位置.\n     这是UNIX系统中一个程序被执行的唯一方式:用将执行的程序复盖原有的\n     程序.\n     安全注意事项:\n       . 实际的和有效的UID和GID传递给由exec()调入的不具有SUID和SGID许\n         可的程序.\n       . 如果由exec()调入的程序有SUID和SGID许可,则有效的UID和GID将设\n         置给该程序的所有者或小组.\n       . 文件建立屏蔽值将传递给新程序.\n       . 除设了对exec()关闭标志的文件外,所有打开的文件都传递给新程序.\n         用fcntl()子程序可设置对exec()的关闭标志.\n    *fork():用来建立新进程.其建立的子进程是与调用fork()的进程(父进程)\n            完全相同的拷贝(除了进程号外)\n     安全注意事项:\n       . 子进程将继承父进程的实际和有效的UID和GID.\n       . 子进程继承文件方式建立屏蔽值.\n       . 所有打开的文件传给子进程.\n    *signal():允许进程处理可能发生的意外事件和中断.\n              需要两个参数:信号编号和信号发生时要调用的子程序.\n     信号编号定义在signal.h中.\n     信号发生时要调用的子程序可由用户编写,也可用系统给的值,如:SIG_IGN\n     则信号将被忽略,SIG_DFL则信号将按系统的缺省方式处理.\n     如许多与安全有关的程序禁止终端发中断信息(BREAK和DELETE),以免自己\n     被用户终端终止运行.\n     有些信号使UNIX系统的产生进程的核心转储(进程接收到信号时所占内存\n     的内容,有时含有重要信息),此系统子程序可用于禁止核心转储.\n  (3)文件属性\n    *access():检测指定文件的存取能力是否符合指定的存取类型.\n              需要两个参数:文件名和要检测的存取类型(整数).\n     存取类型定义如下:\n       0: 检查文件是否存在\n       1: 检查是否可执行(搜索)\n       2: 检查是否可写\n       3: 检查是否可写和执行\n       4: 检查是否可读\n       5: 检查是否可读和执行\n       6: 检查是否可读可写可执行\n       这些数字的意义和chmod命令中规定许可方式的数字意义相同.\n     此子程序使用实际的UID和GID检测文件的存取能力(一般有效的UID和GID\n     用于检查文件存取能力).\n     返回值: 0:许可  -1:不许可.\n    *chmod():将指定文件或目录的存取许可方式改成新的许可方式.\n             需要两个参数:文件名和新的存取许可方式.\n    *chown():同时改变指定文件的所有者和小组的UID和GID.(与chown命令不\n             同).\n     由于此子程序同时改变文件的所有者和小组,故必须取消所操作文件的SUID\n     和SGID许可,以防止用户建立SUID和SGID程序,然后运行chown()去获得别\n     人的权限.\n    *stat():返回文件的状态(属性).\n            需要两个参数:文件路径名和一个结构指针,指向状态信息的存放\n            的位置.\n     结构定义如下:\n       st_mode:   文件类型和存取许可方式\n       st_ino:    I节点号\n       st_dev:    文件所在设备的ID\n       st_rdev:   特别文件的ID\n       st_nlink:  文件链接数\n       st_uid:    文件所有者的UID\n       st_gid:    文件小组的GID\n       st_size:   按字节计数的文件大小\n       st_atime:  最后存取时间(读)\n       st_mtime:  最后修改时间(写)和最后状态的改变\n       st_ctime:  最后的状态修改时间\n     返回值: 0:成功    1:失败\n    *umask():将调用进程及其子进程的文件建立屏蔽值设置为指定的存取许可.\n             需要一个参数: 新的文件建立屏值.\n  (4)UID和GID的处理\n    *getuid():返回进程的实际UID.\n    *getgid():返回进程的实际GID.\n     以上两个子程序可用于确定是谁在运行进程.\n    *geteuid():返回进程的有效UID.\n    *getegid():返回进程的有效GID.\n     以上两个子程序可在一个程序不得不确定它是否在运行某用户而不是运行\n     它的用户的SUID程序时很有用,可调用它们来检查确认本程序的确是以该\n     用户的SUID许可在运行.\n    *setuid():用于改变有效的UID.\n     对于一般用户,此子程序仅对要在有效和实际的UID之间变换的SUID程序才\n     有用(从原有效UID变换为实际UID),以保护进程不受到安全危害.实际上该\n     进程不再是SUID方式运行.\n    *setgid():用于改变有效的GID.\n2.标准C库\n  (1)标准I/O\n    *fopen():打开一个文件供读或写,安全方面的考虑同open()一样.\n    *fread(),getc(),fgetc(),gets(),scanf()和fscanf():从已由fopen()打\n             开供读的文件中读取信息.它们并不关心文件的存取许可.这一点\n             同read().\n    *fwrite(),put(),fputc(),puts,fputs(),printf(),fprintf():写信息到\n             已由fopen()打开供写的文件中.它们也不关心文件的存取许可.\n             同write().\n    *getpass():从终端上读至多8个字符长的口令,不回显用户输入的字符.\n             需要一个参数: 提示信息.\n     该子程序将提示信息显示在终端上,禁止字符回显功能,从/dev/tty读取口\n     令,然后再恢复字符回显功能,返回刚敲入的口令的指针.\n    *popen():将在(5)运行shell中介绍.\n  (2)/etc/passwd处理\n    有一组子程序可对/etc/passwd文件进行方便的存取,可对文件读取到入口\n    项或写新的入口项或更新等等.\n    *getpwuid():从/etc/passwd文件中获取指定的UID的入口项.\n    *getpwnam():对于指定的登录名,在/etc/passwd文件检索入口项.\n     以上两个子程序返回一指向passwd结构的指针,该结构定义在\n     /usr/include/pwd.h中,定义如下:\n         struct passwd {\n             char * pw_name;        /* 登录名 */\n             char * pw_passwd;      /* 加密后的口令 */\n             uid_t  pw_uid;         /* UID */\n             gid_t  pw_gid;         /* GID */\n             char * pw_age;         /* 代理信息 */\n             char * pw_comment;     /* 注释 */\n             char * pw_gecos;\n             char * pw_dir;         /* 主目录 */\n             char * pw_shell;       /* 使用的shell */\n         };\n    *getpwent(),setpwent(),endpwent():对口令文件作后续处理.\n     首次调用getpwent(),打开/etc/passwd并返回指向文件中第一个入口项的\n     指针,保持调用之间文件的打开状态.\n     再调用getpwent()可顺序地返回口令文件中的各入口项.\n     调用setpwent()把口令文件的指针重新置为文件的开始处.\n     使用完口令文件后调用endpwent()关闭口令文件.\n    *putpwent():修改或增加/etc/passwd文件中的入口项.\n     此子程序将入口项写到一个指定的文件中,一般是一个临时文件,直接写口\n     令文件是很危险的.最好在执行前做文件封锁,使两个程序不能同时写一个\n     文件.算法如下:\n       . 建立一个独立的临时文件,即/etc/passnnn,nnn是PID号.\n       . 建立新产生的临时文件和标准临时文件/etc/ptmp的链,若建链失败,\n         则为有人正在使用/etc/ptmp,等待直到/etc/ptmp可用为止或退出.\n       . 将/etc/passwd拷贝到/etc/ptmp,可对此文件做任何修改.\n       . 将/etc/passwd移到备份文件/etc/opasswd.\n       . 建立/etc/ptmp和/etc/passwd的链.\n       . 断开/etc/passnnn与/etc/ptmp的链.\n     注意:临时文件应建立在/etc目录,才能保证文件处于同一文件系统中,建\n          链才能成功,且临时文件不会不安全.此外,若新文件已存在,即便建\n          链的是root用户,也将失败,从而保证了一旦临时文件成功地建链后\n          没有人能再插进来干扰.当然,使用临时文件的程序应确保清除所有\n          临时文件,正确地捕捉信号.\n  (3)/etc/group的处理\n    有一组类似于前面的子程序处理/etc/group的信息,使用时必须用include\n    语句将/usr/include/grp.h文件加入到自己的程序中.该文件定义了group\n    结构,将由getgrnam(),getgrgid(),getgrent()返回group结构指针.\n    *getgrnam():在/etc/group文件中搜索指定的小组名,然后返回指向小组入\n                口项的指针.\n    *getgrgid():类似于前一子程序,不同的是搜索指定的GID.\n    *getgrent():返回group文件中的下一个入口项.\n    *setgrent():将group文件的文件指针恢复到文件的起点.\n    *endgrent():用于完成工作后,关闭group文件.\n    *getuid():返回调用进程的实际UID.\n    *getpruid():以getuid()返回的实际UID为参数,确定与实际UID相应的登录\n              名,或指定一UID为参数.\n    *getlogin():返回在终端上登录的用户的指针.\n     系统依次检查STDIN,STDOUT,STDERR是否与终端相联,与终端相联的标准输\n     入用于确定终端名,终端名用于查找列于/etc/utmp文件中的用户,该文件\n     由login维护,由who程序用来确认用户.\n    *cuserid():首先调用getlogin(),若getlogin()返回NULL指针,再调用\n     getpwuid(getuid()).\n    *以下为命令:\n    *logname:列出登录进终端的用户名.\n    *who am i:显示出运行这条命令的用户的登录名.\n    *id:显示实际的UID和GID(若有效的UID和GID和实际的不同时也显示有效的\n        UID和GID)和相应的登录名.\n  (4)加密子程序\n    1977年1月,NBS宣布一个用于美国联邦政府ADP系统的网络的标准加密法:数\n    据加密标准即DES用于非机密应用方面.DES一次处理64BITS的块,56位的加\n    密键.\n    *setkey(),encrypt():提供用户对DES的存取.\n     此两子程序都取64BITS长的字符数组,数组中的每个元素代表一个位,为0\n     或1.setkey()设置将按DES处理的加密键,忽略每第8位构成一个56位的加\n     密键.encrypt()然后加密或解密给定的64BITS长的一块,加密或解密取决\n     于该子程序的第二个变元,0:加密 1:解密.\n    *crypt():是UNIX系统中的口令加密程序,也被/usr/lib/makekey命令调用.\n     crypt()子程序与crypt命令无关,它与/usr/lib/makekey一样取8个字符长\n     的关键词,2个salt字符.关键词送给setkey(),salt字符用于混合encrypt()\n     中的DES算法,最终调用encrypt()重复25次加密一个相同的字符串.\n     返回加密后的字符串指针.\n  (5)运行shell\n    *system():运行/bin/sh执行其参数指定的命令,当指定命令完成时返回.\n    *popen():类似于system(),不同的是命令运行时,其标准输入或输出联到由\n             popen()返回的文件指针.\n     二者都调用fork(),exec(),popen()还调用pipe(),完成各自的工作,因而\n     fork()和exec()的安全方面的考虑开始起作用.\n3.写安全的C程序\n    一般有两方面的安全问题,在写程序时必须考虑:\n      (1)确保自己建立的任何临时文件不含有机密数据,如果有机密数据,设置\n         临时文件仅对自己可读/写.确保建立临时文件的目录仅对自己可写.\n      (2)确保自己要运行的任何命令(通过system(),popen(),execlp(),\n         execvp()运行的命令)的确是自己要运行的命令,而不是其它什么命\n         令,尤其是自己的程序为SUID或SGID许可时要小心.\n    第一方面比较简单,在程序开始前调用umask(077).若要使文件对其他人可\n    读,可再调chmod(),也可用下述语名建立一个\"不可见\"的临时文件.\n         creat(\"/tmp/xxx\",0);\n         file=open(\"/tmp/xxx\",O_RDWR);\n         unlink(\"/tmp/xxx\");"
		},
		{
			"post_id": 20,
			"title": "Tor网桥",
			"date_published": 1468922817.716,
			"body": "获取网桥（需翻墙）\nhttps://bridges.torproject.org/bridges?transport=obfs3\nhttps://bridges.torproject.org/bridges?transport=obfs4\n\n利用电子邮件获取\nyahoo邮箱\nsubject:getbridges\n内容如下：\nbeidges obfs4 或者 bridges obfs3\n\n最近获取到的网桥，时间久了就会失效：\nobfs4 104.129.176.152:26145 072B62A5FE3D16598068596E96BE5878FE2A3C65 cert=8I6Qa0kstGhySz2zp5P3vP/mMPv6oMIwdfJMIRaGDqtLdjapibYVEPKYVXJ4i2u6DUQHTA iat-mode=0\nobfs4 192.36.31.233:35462 7C23DEDCC9FC6361FF8568B4312AF6182291B830 cert=blvHEuKx1dZ+jKNUMGvIkgl/wRy/4aqEtcGippc2ZPmHMCM5O8ippbOW5lXRGLzxGFYATA iat-mode=0\nobfs4 69.163.37.128:2483 383FDF8E29F6797F9F386E4D37241EF394B0C112 cert=50ESFeT8xbzSq97BP/4i660u7kPJCCsiXVqvebRZZmAlCN5+NwKngqK6hONw6tRqRXnoQg iat-mode=0"
		},
		{
			"post_id": 19,
			"title": "TOP 500网站",
			"date_published": 1468921953.079,
			"body": "https://soundcloud.com/\nhttp://www.xnxx.com/\nhttps://bongacams.com/\nhttp://xhamster.com/\nhttps://www.pixnet.net/blog\nhttp://www.pornhub.com/\nhttp://bbs.fc2.com/en/\nhttp://www.youporn.com"
		},
		{
			"post_id": 18,
			"title": "ubuntu命令汇总",
			"date_published": 1468921396.829,
			"body": "find /usr -name linux.so -print\nscp local_file remote_username@remote_ip:remote_folder\n"
		},
		{
			"post_id": 16,
			"title": "谷歌墙内搜索列表\t",
			"date_published": 1464868483.225,
			"body": "https://www.logcg.com/archives/877.html\nhttp://web.de"
		},
		{
			"post_id": 13,
			"title": " 细节的力量",
			"date_published": 1464066292.624,
			"body": "https://xijie.wordpress.com/ 希望他能在0Net办一个分站。"
		},
		{
			"post_id": 12,
			"title": "pdf测试！",
			"date_published": 1461637044.925,
			"body": "[比较全的树莓派资料<===](data/PDF/raspi.pdf)\n将PDF文件放入站点目录：data/PDF/xxx.pdf;pdf文件夹需要自己新建。\n语法和普通链接一样\\[foo](data/PDF/raspi.pdf)\n文件名必须英文。"
		},
		{
			"post_id": 11,
			"title": "Markdown语法",
			"date_published": 1461594983.98,
			"body": "[维基百科链接](https://zh.wikipedia.org/wiki/Markdown)\n[zeronet链接](http://127.0.0.1:43110/mosen.bit/?Post:2)\nMarkdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。[3]这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。\n\nMarkdown同时还是一个由Gruber编写的Perl脚本：Markdown.pl。它把用markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号('<')和&号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器.[3]\n\nMarkdown也已经被其他人用Perl和别的编程语言重新实现，其中一个Perl模块放在了CPAN(Text::Markdown)上。它基于一个BSD风格的许可证分发并可以作为几个内容管理系统的插件。[5][6]"
		},
		{
			"post_id": 10,
			"title": "ShadowsocksR Zeronet站点",
			"date_published": 1461594368.642,
			"body": "http://127.0.0.1:43110/1GUwoyRUxHWkUik5o4BBKgjrpbeCMXFj9z/"
		},
		{
			"post_id": 9,
			"title": "墙内的DNS方案",
			"date_published": 1461511990.497,
			"body": "**在墙内防止运营商劫持可以将DNS设置为\n首选DNSPod：119.29.29.29\n备用OneDNS：114.215.126.16\n当然在访问墙外网站时仍然会有污染，Amethyst-SSR提供非标准端口DNS\n162.243.52.237:1828\n欢迎试用。**"
		},
		{
			"post_id": 8,
			"title": "SSR+Tor+ZeroNet匿名浏览方法",
			"date_published": 1461511895.148,
			"body": "下载Tor：http://127.0.0.1:43110/1Mg82NHKBLzgnzp199NT1Mh8rUdXw2ij1h/T4Z.7z\n将压缩包内文件覆盖到ZeroBundle/ZeroNet/tools/tor\n配置torrc，使Tor通过SSR代理，默认为端口1080。\n关闭SSR的系统代理但不关闭程序（避免冲突）\n启动ZeroNet，右上角为TOR：OK证明成功，建议将TOR设为ALWAYS模式。"
		},
		{
			"post_id": 7,
			"title": "比特币 (Bitcoin) 系统是如何运行的？--知乎",
			"date_published": 1461508110,
			"body": "后面的回答很精彩！\nhttp://www.zhihu.com/question/20941124"
		},
		{
			"post_id": 6,
			"title": "贴图测试",
			"date_published": 1461473523.629,
			"body": "第一张\n![情人办公室OL诱惑1](data/img/20160417_04370eba132866c2efefviBlvEsn9SCh.jpg)\n第二张\n![情人办公室OL诱惑2](data/img/20160417_526fd7c4ae136372c6e8Os7Z7GWWSTQN.jpg)\n"
		},
		{
			"post_id": 5,
			"title": "福利",
			"date_published": 1461391481.612,
			"body": "https://zhanhaitao.tumblr.com\nhttps://the-r3df0x.tumblr.com/"
		},
		{
			"post_id": 2,
			"title": "我的博客开业啦！",
			"date_published": 1461388663.894,
			"body": "你好！0网！\n0Net:http://127.0.0.1:43110/16TkQqszbHV6wk6sQC3WH4CNLLfcWCPqzv\n0Net:http://127.0.0.1:43110/r3df0x.bit\nPublic Net:https://bit.no.com:43110/r3df0x.bit"
		},
		{
			"post_id": 1,
			"title": "Congratulations!",
			"date_published": 1433033779.604,
			"body": "Your zeronet blog has been successfully created!"
		}
	]
}