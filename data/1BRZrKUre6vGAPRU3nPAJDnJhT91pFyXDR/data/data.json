{
	"title": "Luf  Blog",
	"description": "by luf",
	"links": "- [感谢！](https://github.com/HelloZeroNet)\n[域名注册](http://127.0.0.1:43110/domains4free.bit/?Post:2:Free+.bit+Domains+for+ZeroNet+Sites)\n[种子](http://127.0.0.1:43110/1LtvsjbtQ2tY7SCtCZzC4KhErqEK3bXD4n)\n[代理地址](http://proxy.zeroexpose.com/lufs.bit)",
	"next_post_id": 3,
	"demo": false,
	"modified": 1461892664,
	"post": [
		{
			"post_id": 2,
			"title": "在OpenWrt上实现6lowpan边缘路由器",
			"date_published": 1461820092.397,
			"body": "一些概念：\n\n1、OpenWrt是一个功能强大的开源路由器linux系统。用户可以很方便的对其进行定制，优化。在国内外已经建立起了一个很活跃的生态圈。据说国内很火的极路由就是基于OpenWrt系统制作的。 https://openwrt.org/。\n2、6lowpan是当前无线传感器网络研究的热门领域，通过对IPv6数据包头进行压缩、解压缩，以及在IP层从添加适用于无线自组网的路由协议RPL。实现了在无线传感器网络中也能直接使用IPv6协议。目前支持6lowpan协议比较好的开源系统有contiki-os和tinyos。在本文中使用的是contki-os。\n3、边缘路由器是啥概念？ 边缘路由器是指将局域网汇接到广域互联网的一种路由设备。具体可参见百度百科：边缘路由器。在本文中实现的是将跑OpenWrt的路由器增加对6lowpan的支持，使其成为6lowpan网络的边缘路由器，最终实现传感器网络节点能够直接通过IPv6访问到互联网。本文仅从应用上说明应该如何做，对于原理性的东西不做深入分析，感兴趣的读者需要自行查找相关知识。\nPPPS：对6lowpan技术感兴趣的朋友欢迎加入到QQ技术群 228240962，一起讨论分享相关技术。\n硬件列表：\n\n1、TP-link的路由器，型号为703N。\n![IMG_20140304_115023](http://s3.sinaimg.cn/large/001UhjFQgy6OK1Nb6gi22&690)\n\n图上看到的黑色天线是后来DIY上去的。硬件也改为8M的FLASH和64M的RAM。我安装（刷机）的是OpenWrt官方编译的固件点此下载。由于我需要安装Python，8M的FLASH还是不够，因此我通过USBhub连接了一个U盘，把需要安装的软件都装在U盘上了。\n\n![IMG_20140304_115145](http://s1.sinaimg.cn/large/001UhjFQgy6OK1OZ8TS40&690)\n\n运行contiki系统的USB小板。\n![IMG_20140304_115057](http://s2.sinaimg.cn/large/001UhjFQgy6OK1R26ZPb1&690)   \n\n这个小板上面的两个芯片分别是CC2530无线单片机、CP210xUSB转串口芯片。小板上预留了下载口，方便用户升级调试程序。同时提供了一个复位按键和两个用户按键。另外我们也为这个小板提供的抓包固件，可以用于捕获分析802.15.4的空中数据包，这个功能以后会另外介绍。\n\n 开始折腾：\n\n1、制作无线传感器网络的根节点固件\n\n首先到contiki官方下载最新稳定版源码，我下载的是2.7版本。官方代码是在linux下开发编译的，这里我将其代码移植到IARfor8051编译器下，移植到IAR下有个好处就是可以直接仿真调试。contiki支持多个cpu平台，我使用的cc2530平台。移植完成后添加border-router.c 和slip-bridge.c文件。为当前工程添加边缘路由器功能支持，添加完成后，该节点将成为6lowpan网络中的根节点，接管其他所有无线传感器网络中向外部请求的IP数据包，并通过串口方式传递给外部处理器（我们这里是OpenWrt系统）。嫌移植麻烦或者不熟悉的朋友建议下载contiki官方提供好的虚拟机（ubuntu）镜像（下载），然后参考官方提供的编译方法在linux系统下编译CC2530目标平台的代码，同样可以生成相同功能的固件。\n\n![](http://s6.sinaimg.cn/large/001UhjFQgy6OK1SZIzz25&690)\n\n将程序烧写至USB小板。此时将小板连接至电脑USB口，并打开串口调试助手（57600 8n1），应该可以看到如下信息了：\n\n![asd32](http://s16.sinaimg.cn/large/001UhjFQgy6OK1TZlUPff&690)\n\n节点开始不停的打印 “?P” 用来向上级cpu请求网络地址的前缀信息。\n\n2 、为OpenWrt增加IPv6支持和6lowpan支持\n\n先路由器连接上网络，把USB无线小板也连接到路由器上\n\n![IMG_20140304_115215](http://s2.sinaimg.cn/large/001UhjFQgy6OK1WzWGB21&690)\n\n通过ssh登录到路由：\n\n![82](http://s2.sinaimg.cn/large/001UhjFQgy6OK1YqAFje1&690)\n\n我们通过opkg 安装所需的软件包：\n\nopkg update \n\nopkkg install kmod-usb-serial-cp210x  kmod-ipv6 kmod-tun  tunslip6 \n\n安装完毕应该就能在  /dev/目录下看到ttyUSB0这个设备了，说明USB小板已经成功被系统识别为串口了。\n\n以上安装的  tunslip6程序，就是用来打通6lowpan无线传感器网络与真实广域网的桥梁。运行时，该程序创建一个虚拟网卡tun0，并打开串口利用slip协议与USB小板通信。说到这里，其实也很容易理解了，tunslip6做的事情实际上很简单： tun0ip packet<—–>serial datapacket。把从根节点发过来的数据包进行解包，写入到tun网卡。如果tun网卡接收到了外界的数据包，则把该数据包发送到串口上。 tunslip6的源码。\n\n以上是简单的原理分析。在shell上运行如下命令：\n\ntunslip6  aaaa::1/64 -s /dev/ttyUSB0 -B57600\n\n指定网络前缀及串口、波特率。成功运行后，USB小板会自动被分配到aaaa::/64的网络地址前缀。结合小板的64位mac地址形成小板的全球唯一128位IPv6地址。此时shell被tunslip6占用了，不能继续输入。打开另一个终端，输入ifconfig，查看tun网卡是否成功生成：\n\ntun0 Link encap:UNSPEC HWaddr00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 \ninet6 addr: aaaa::1/64 Scope:Global\nUP POINTOPOINT RUNNING NOARP MULTICAST MTU:1500Metric:1\nRX packets:0 errors:0 dropped:0 overruns:0 frame:0\nTX packets:2 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:500 \nRX bytes:0 (0.0 B) TX bytes:152 (152.0 B)\n\n已经成功了！由于小板的mac地址固化成0x0000000000000001了。结合刚才已经设置的aaaa::/64前缀，则小板的IPv6地址应该是aaaa::200:0:0:1 这里多了一个2是IPv6协议规定的，暂不管他，知道地址就行了。ping一下吧！\n\n![](http://s1.sinaimg.cn/large/001UhjFQgy6OK209n7G30&690)\n\n可以看到，已经能ping通这个节点了。当然，因为根节点已经建立了无线网络了，如果这时候加入一个新的节点，也是能够在OpenWrt上直接ping通的。\n\n3、继续改进\n\n以上的tunslip6程序实际上不太好：1、不能指定信道及其他无线传感网的网络参数，2、运行中遇到错误会立即退出，更好的实现应该是做成daemon形式在后台运行，遇到错误自动继续尝试重启服务，尽最大可能保证系统的稳定。鉴于以上几点缺点，我写了个简单的Python脚本，对tunslip6进行了简单的处理。规避了以上提到的2的缺点，至于指定信道等参数的功能，以后在增加吧。该脚本是把自身变成系统的daemon进程，并调用tunslip6这个应用，监测其是否因为错误退出，若退出则继续调用，直到成功。\n\n```\n# -*- coding: utf-8 -*- \nimport subprocess, sys, os, time \ndef run(): \nshellCmd = \"tunslip6 aaaa::1/64 -s /dev/ttyUSB0 -B 57600\"  \nwhile True: \n''' 执行命令行，并等待tunslip6退出。实际上tunslip6没有遇到错误之前是不会退出的。 如果退出，则继续执行命令直到不再退出。 ''' \ntry: subprocess.Popen(shellCmd, shell=True).wait() \ntime.sleep(5) \nexcept Exception,e: pass if __name__ == \"__main__\": \ntry:  pid = os.fork()  \nif pid > 0: sys.exit(0)  \nexcept OSError, e:   sys.exit(1)  os.chdir(\"/\")  os.setsid()  os.umask(0)   try:  pid = os.fork()  if pid > 0: sys.exit(0)  except OSError, e: sys.exit(1)   # start the daemon main loop run()\n```\n如果以上脚本设置为开机启动，那么边缘路由器的功能就能系统启动而驱动了。\n\n最后一个问题：无线网里的设备怎么访问外部的ipv6网络？\n\n要让无线节点也能直接访问互联网，其实仅仅按照前面的方法搭建起边缘路由器是不够的，有细心的读者会发现我设置tunslip6的时候用的前缀是aaaa::其实这个前缀是我随便填的，因为我这里的网络没有ipv6的环境，无法在路由上获得ipv6地址。因此我的路由没有访问ipv6网络的能力，6lowpan网络也就更不可能访问到了。如果有ipv6网络支持，并且通过网络管理员获得了一个全球唯一可识别的地址前缀，那么把这个前缀设置给tunslip6应该就可以使无线传感网的节点获得访问互联网的能力了。"
		},
		{
			"post_id": 1,
			"title": "GPRS公网通讯",
			"date_published": 1433033779.604,
			"body": "GPRS应用中TCP/IP/PPP基本概念：（ＣＤＭＡ的原理与此差不多）\n\n实际上GPRS DTU上实现的是协议栈是TCP/IP Over PPP。我们在使用时必须要有一些相应的概念。因此在下面我们就与SARO-3130P使用相关的一些事项作一些简要的说明，如果您想详细了解这些协议，请参见相关书籍： \n\n1． 每一次SARO-3130P拨ATD*99***1#(或ATD*99***1#)之后其实都在采用PPP协议和移动的接入设备（一般是移动公司的一台特殊的GGSN路由器）进行握手，当PPP协议握手成功后，SARO-3130P都会获得一个动态IP地址。一般来说，每一次SARO-3130P下线后（挂断连接或者直接断电后）在重新进行拨号和PPP握手后取得的动态IP地址都是不一样的。但是移动公司可以通过为客户开通特定的APN和发行特殊的SIM卡，使得用这张SIM卡获得的动态IP地址每一次都不变。也就是说可以做到SIM卡和IP地址绑定。 \n\n2．  我们在做测试时，应当注意到如下事实：在采用公网的Apn（“cmnet”）的条件下，如果我们用SARO-3130P主动向公网上的一个静态公网IP地址发起TCP连接，只要这个公网上的机器确实有侦听相应的端口，这样是可以连上的;但是相反地，如果是由公网上的静态IP向SARO-3130P动态获得的IP地址主动发起的TCP连接将不会成功。这个现象的原因是：实际上SARO-3130P获得的动态IP地址是移动的一个特殊的内部网段上的地址，这个特殊内部网段里的地址如果要和外部网（公网）的地址进行TCP通信，必须通过一个类似于TCP代理（或者NAT）的设备进行通信的转发。换句话说，这个动态地址对于网络上的其他机器来说是不可访问的。 \n\n3． 标准AT命令+CGDCONT的主要作用是指定Apn。Apn是Access Point Name（访问接入点）的缩写，移动通过开通特殊的Apn为行业客户提供Vpn(Virtual Private Net)服务。比如说，如果是要上公网（Internet）,应当使用“cmnet”作为Apn。又如，某企业向移动公司申请了Vpn服务，移动公司为其开通了一个Apn为“hxsw.gd”，则我们就应当用这个Apn来设置Gprs模块，格式如下： AT+CGDCONT=1,“IP”,“hxsw.gd”\n\n4．  确定一条TCP连接有4个要素，这4个要素是双方的IP地址和双方的TCP端口号，这也就是SARO-3130P为什么将本地端口、目的端口和目的IP地址结合起来作为连接的ID号（SARO-3130P在PPP握手成功后获得的动态地址只要不断线重连就不会改变）的原因。 \n\n5．  使用TCP协议进行数据通信时，必须要经过三个阶段，第一个阶段是连接建立阶段，第二个阶段是数据收发阶段，第三个阶段是连接释放阶段：\n\n1）.连接建立阶段：连接的建立又有主动连接和被动连接之分，一般来说客户机都是主动发起连接的，而服务器是被动接受连接的。\n\n所谓的主动连接是指本方主动向远端发起连接请求， 而被动连接指的是本方侦听一个端口，等待远端及其主动向自己发起一个连接请求并且进行回应并且最终握手建链成功。\n\n在连接成功，切换到数据态后，我们可以通过OPEN命令帧控制SARO-3130P 进行主动连接。当然，连接时要指定对方的IP地址和端口号。至于被动连接，SARO-3130P也可以支持，目前的程序只支持侦听一个端口。对方主动连接（SARO-3130P被动连接）成功后将建立一条新的通信连接，SARO-3130P将把这个被动连接成功的事件通知给上位机。\n\n2）.数据收发阶段：当一条连接建立之后，我们就可以在这条连接上进行数据收发了。\n\n我们可以使用SEND命令帧控制SARO-3130P进行数据发送。当然，发送时要指定连接号（通过本地端口、目的地址和端口唯一确定）。\n\n对于对方发送过来的数据，SARO-3130P首先将其存储在自身的数据缓冲区中，然后将数据已到达此事件通知给上位机，上位机读取到数据已到达事件后，应当及时使用RECV命令帧控制SARO-3130P将相应连接上的所有数据通过串口读出，当数据读出后，这些数据原先占用的数据缓冲区空间将会被释放。注意，由于SARO-3130P的数据缓冲区有限（总量仅有25K Bytes）,所以，对于对方发来的数据，上位机一定要及时读出，否则数据越积越多，可能会导致数据缓冲区溢出，丢失数据。\n\n3）.挂断连接阶段：当一条连接上的所有数据都已经收发完成了，不再需要这条连接时，就可以把连接给挂断了。\n\n和连接建立阶段相类似，挂断也分为主动挂断和被动挂断。\n\n我们可以使用RSET命令帧控制SARO-3130P进行连接的主动挂断。\n\n如果连接被对方主动挂断，SARO-3130P将会把这个事件通知给上位机进行处理。\n\n \n\nＧＰＲＳ／ＣＤＭＡ行业应用中的TCP与UDP的比较！\n\n中国移动、中国联通推行的GPRS网络、CDMA网络已覆盖大量的区域，通过无线网络实现数据传输成为可能。无线Modem采用GPRS、CDMA模块通过中国移动、中国联通的GPRS、CDMA网络进行数据传输，并通过TCP/IP协议进行数据封包，可灵活地实现多种设备接入，工程安装简单，在工业现场数据传输的应用中，能很好的解决偏远无网络无电话线路地区的数据传输的难题。同传统的数传电台想比较，更具有简便性、灵活性、易操作性，同时还降低了成本，无线Modem传输方案是现代化工业现场数据传输最好的选择方案。\n　　目前中国移动、中国联通提供的GPRS网络、CDMA网络的数据传输带宽在40Kbps左右，且受带宽的限制，数据采集方案最好采用于主动告警、数据轮巡采集、告警主动回叫等对传输带宽占用较少的采集方式。同时考虑对前置机实时采集方案的支持，无线Modem传输方案只能作为目前传输方案的补充。\n　　随着无线通讯技术的不断发展，无线传输数据带宽将不断提高，采用3G无线网络，数据传输带宽将达到2M，无线传输方案将逐渐成为监控传输组网的主要应用方案。\n　　 目前，由于GPRS和CDMA固有的特性，在各个领域中GPRS和CDMA的应用也越来越广泛，但是关于传输中使用TCP/IP协议还是UDP协议，却争论很多。\n　　\n　　这里先简单的说一下TCP与UDP的区别：\n　　 1。基于连接与无连接 \n　　 2。对系统资源的要求（TCP较多，UDP少） \n　　 3。UDP程序结构较简单 \n　　 4。流模式与数据报模式 \n　　 5。TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证\n　　\n　　另外结合GPRS网络的情况具体的谈一下他们的区别：\n　　1。TCP传输存在一定的延时，大概是1600MS（移动提供），UDP响应速度稍微快一些。\n　　2。TCP包头结构\n　　　　源端口16位\n　　　　目标端口 16位\n　　　　序列号 32位\n　　　　回应序号 32位\n　　　　TCP头长度 4位\n　　　　reserved 6位\n　　　　控制代码6位\n　　　　窗口大小16位\n　　　　偏移量16位\n　　　　校验和16位\n　　　　选项 32位(可选) \n　　　　这样我们得出了TCP包头的最小大小.就是20字节. \n　　\n　　　　UDP包头结构\n　　　　源端口16位\n　　　　目的端口16位\n　　　　长度 16位\n　　　　校验和 16位\n　　　　UDP的包小很多.确实如此.因为UDP是非可靠连接.设计初衷就是尽可能快的将数据包发送出去.所以UDP协议显得非常精简. \n　　\n　　3。GPRS网络端口资源，UDP十分紧缺，变化很快；而TCP采用可靠链路传输，不存在端口变化的问题\n　　\n　　工业场合的应用一般都有以下特点，\n　　\n　　1。要求时时传输，但也有一些场合是定时传输，总的来说在整个传输过程中要求服务器中心端和GPRS终端设备能相互的、时时的传输数据。\n　　TCP本身就是可靠链路传输，提供一个时时的双向的传输通道，能很好的满足工业现场传输的要求。但是GPRS网络对TCP链路也存在一个限制：此条链路在长时间（大概20分钟左右，视具体情况而定）没有数据流量，会自动降低此链路的优先级直至强制断开此链路。所以在实际使用中也会采用心跳包（一般是一个字节的数据）来维持此链路。\n　　UDP由于自身特点，以及GPRS网络UDP端口资源的有限性，在一段时间没有数据流量后，端口容易改变，产生的影响就是从服务器中心端向GPRS终端发送数据，GPRS终端接收不到。具体的原因就是移动网关从中作了中转，需要隔一定时间给主机发UDP包来维持这个IP和端口号,这样主机就能主动给GPRS发UDP包了并且我在测试中发现,这个间隔时间很短,我在1多分钟发一次UDP包才能够维持,但是再长可能移动网关那边就要丢失这个端口了,此时如果主机想主动发数据给GPRS,那肯定是不行的了,只有GPRS终端设备再发一个UDP包过去,移动重新给你分配一个中转IP和端口,才能够进行双向通讯。\n　　\n　　2。要求数据的丢包率较小。有些工业场合，例如电力、水务抄表，环保监测等等，不容许传输过程中的数据丢失或者最大限度的要求数据的可靠性。\n　　从这一点来看，很显然在无线数据传输过程中，TCP比UDP更能保证数据的完整性、可靠性，存在更小的丢包率。在实际测试中也是如此。以厦门桑荣科技有限公司提供的GPRS终端设备为例：TCP的在千分之9，UDP的在千分之17左右。\n　　\n　　3。要求降低费用。目前有很大部分GPRS设备的应用都是取代前期无线数传电台，除了使用范围外，其考虑的主要问题就是费用。能降低费用当然都是大家最愿意接受的。和费用直接相关的就是流量了，流量低，费用就低了。\n　　虽然TCP本身的包头要比UDP多，但是UDP在实际应用中往往需要维护双向通道，就必须要通过大量的心跳包数据来维护端口资源。总的比较起来，UDP的实际流量要比TCP还要大。很多使用者在初期的时候并不了解UDP需要大量心跳包来维持端口资源这个问题，往往都认为UDP要比TCP更节省流量，实际上这里存在着一个误区。\n　　\n　　4。在某些特定的应用场合，例如一些银行的时时交互系统，对响应速度要求很高，此时数据传输频率较快，不需要大量心跳包维持UDP端口资源，采用UDP就比较有利了。\n　　\n　　5。在目前的1：N的传输模式中，既有多个GPRS终端设备往一个服务器中心传输数据，此时采用UDP会比TCP要好的多，因为UDP耗用更少的系统资源。但是在实际应用中却发现，很多用户还是采用TCP的传输方式，建立二级中心1：A（1：N），即每一个分中心对应N/A台设备，独立处理数据，再统一将数据传送到主中心。这样既能保证了传输过程中采用了TCP的传输协议，又能很好处理了中心服务器的多链路的系统耗用的问题。\n　　 \n　　 总的来说，TCP/IP协议更能满足目前各行业对远程数据传输的要求，它提供更稳定更便利的传输通道，很好的满足了远程数据传输的要求。桑荣公司所有ＤＴＵ产品都支持ＴＣＰ和ＵＤＰ协议，客户可以自行选择．\n"
		}
	]
}