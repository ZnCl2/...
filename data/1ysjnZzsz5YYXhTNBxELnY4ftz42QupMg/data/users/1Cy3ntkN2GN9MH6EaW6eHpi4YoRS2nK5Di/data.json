{
	"next_comment_id": 10,
	"comment": [
		{
			"comment_id": 1,
			"body": "Вы изобрели BASIC :) Но возможность полезная, согласен.",
			"post_id": 16,
			"date_added": 1525588356
		},
		{
			"comment_id": 2,
			"body": "ZeroNet не знает, существует ли файл, так как он может быть опциональным, не скачаться, content.json может быть старым и т.д. Когда жмешь Update, он пытается этот файл+content.json скачать, видит, что ни у кого этого файла нет и успокаивается.",
			"post_id": 17,
			"date_added": 1525621998
		},
		{
			"comment_id": 3,
			"body": "> Но вот что в Coffee одна стрелочка -> заменяет кучу бесполезных букв — это снижение баттхерта на 80 пунктов по стобалльной шкале. По сравнению с этим вышеперечисленные недостатки Coffee добавляют всего пунктов 20-25.\n\nА в JavaScript одна стрелочка `=>` xD",
			"post_id": 18,
			"date_added": 1525967073
		},
		{
			"comment_id": 4,
			"body": "> [geekless](#comment_11_1GooUE19488nDwG3TdkM8seYAHct4gjkq4): => в кофе тоже есть, семантика разная. => связывает this лексически, а -> нет.> Когда я активно кодил на JS, коротких лямбд там не было. Зато в то же время я кодил и на Ruby, и вот после Ruby жаваскрипт был реально боль.\n\nНа вкус и цвет все фломастеры разные. Пытался когда-то что-то делать на Ruby, мозг сломал от обилия спецсимволов.",
			"post_id": 18,
			"date_added": 1525970815
		},
		{
			"comment_id": 5,
			"body": "> [mokshanets2](#comment_2_1BTR1SP5uKs6nURymSE4uX74vJ8CmAXyB9): Где-то есть описание внутренней структуры ZeroNet-а со схемами?\n\nАктуального -- нет. Только исходники, только хардкор.",
			"post_id": 53,
			"date_added": 1603030985
		},
		{
			"comment_id": 6,
			"body": "Я вас поздравляю -- вы изобрели git. Там даже абсолютно такая же delta-encoding. Думаю, копать стоит в сторону интеграции гита, как плагин к ZN или через wasm к конкретному сайту.",
			"post_id": 35,
			"date_added": 1603033593
		},
		{
			"comment_id": 7,
			"body": "> [geekless](#comment_32_1GooUE19488nDwG3TdkM8seYAHct4gjkq4): Статью не читай, сразу отвечай...\n\nПо сути -- эта система прекрасно ложится на Git. Если ее реализовывать, то взять за основу его же будет логичным шагом.",
			"post_id": 35,
			"date_added": 1603751360
		},
		{
			"comment_id": 8,
			"body": "> [geekless](#comment_33_1GooUE19488nDwG3TdkM8seYAHct4gjkq4): В гит есть постоянная история, а в сабже нет.\n\nА это как? У вас каждый коммит ссылается на родителя, a la blockchain. Или вы про то, что старую историю можно удалять?\n\n> В гит коммиты всегда имеют родителя, а в сабже нет.\n\nНу вот нет.\n\n> В гит в рамках ветки один объект имеет линейную  историю, а в сабже нет.\n\nВ git, в отличие от hg, вообще нет веток. В git есть указатели, refs/heads, а не ветки. У git'а же тоже DAG, как у вас -- так пользуйтесь ветками исключительно как метками, не надо рассматривать их как часть истории.\n\n> Очень разные вещи.\n\nИдейно -- одно и то же.",
			"post_id": 35,
			"date_added": 1603781495
		},
		{
			"comment_id": 9,
			"body": "> [geekless](#comment_34_1GooUE19488nDwG3TdkM8seYAHct4gjkq4): В тексте выше всё написано же.\n> \n> Невозможно гарантировать сохранность истории, поэтому нет смысла её сохранять. История приводится лишь для справки \"кто следом за кем писал\".\n\nАналогия в git -- shallow clone.\n\n> Пользователь совершенно точно будет удалять старые или неудачные коммиты, чтобы освободить место. Поэтому надо хранить его коммиты максимально сжато, чтобы ему реже приходилось отвлекаться на нехватку места. Хранение дельт решает эту узкую задачу, а не задачу истории.\n\nКто спорит?\n\n> Дельты в истории (той, которая \"для справки\") вычисляются на лету, а не хранятся. Это другие дельты.\n\nЭто я понял, благо за справкой в известное место не приходится ездить.",
			"post_id": 35,
			"date_added": 1603799492
		}
	],
	"comment_vote": {},
	"topic_vote": {},
	"post_vote": {
		"14": 1,
		"19": 1,
		"23": 1,
		"37": 1,
		"38": 1,
		"45": 1,
		"48": 1,
		"49": 1,
		"53": 1
	}
}