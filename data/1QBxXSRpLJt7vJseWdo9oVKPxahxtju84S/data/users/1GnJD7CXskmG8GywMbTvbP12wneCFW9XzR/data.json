{
	"next_comment_id": 6,
	"comment": [
		{
			"comment_id": 1,
			"body": "这东西太有用了。应该合到 @nofish 的 Hello 站点里面。",
			"post_id": 14,
			"date_added": 1503904834
		},
		{
			"comment_id": 2,
			"body": "「来自深渊」豆瓣上只有一个友邻评价，一星，还有一则义愤填膺的短评，但是看了那个短评我更感兴趣了。。。",
			"post_id": 11,
			"date_added": 1503905975
		},
		{
			"comment_id": 3,
			"body": "> [sayo](#comment_4_1JNvu4M5bkyVv8UgiThzR7J64QorSLVf55): 看动画评分的话去 Bangumi 大概更合适。\n\n豆瓣评分 9.1, 只是我关注的人基本都没给这部打分罢了。。。\n\n",
			"post_id": 11,
			"date_added": 1503918261
		},
		{
			"comment_id": 4,
			"body": "`version` 看起来是 `1` 是老版，`2` 是新版，`3` 则是为了支持 merge 站点新加的东西。也就是版本号除了表示时间上的世代以外，还用来表现站点的类型？\n\n·to_table` 好乱。从 `to_table` 的结构上完全看不出同一时刻 `val_col` 和 `key_col` 只可能有一个起作用。",
			"post_id": 13,
			"date_added": 1503933360
		},
		{
			"comment_id": 5,
			"body": "> 现在可以得到如下结论\n\n从抽出的代码来看，好像确实是这样。\n\n但是这些规则的优先级运用后只是确定了规则的value，而这些值的含义仍取决于规则的key. 而规则的具体应用取决于verifyXXX等函数。\n而那些函数并不支持自定义规则，处理的都是写死的 key.\n\n而且看上下文发现实际上这段代码并没有试图解决优先级问题。\n\n> 对于整数类型的权限，取所有值中的最大值。\n\n目前只用来给特别用户提升配额 \n\n> 对于字符串类型的权限，取所有匹配的值中最长的一个。为了保证权限的完整性，更高权限的值应当包含所有更低权限的值。\n\n目前只用来给特别用户增加可写入的文件名\n\n> 对于数组类型的权限，取所有匹配的值连接的结果，但顺序不确定。为了避免重复，更高权限的值不应当包含更低权限的值。\n\n目前只用来处理针对特别用户的 signer \n（没细看，猜想是给一些版主修改该用户私人内容如评论等的权限）。\n\n> 对于所有其他类型的权限，只应在匹配范围最广的规则下设置一次，否则执行结果不可预测。\n\n这个其实是用来处理不针对特别用户的（没有在`permissions`里特别提到的用户）的一般规则，\n或者说是应用于全站的规则（用正则匹配路径名和用户名）。\n\n因为 `rules` 的定义在前面几行：\n\n    rules = copy.copy(user_contents[\"permissions\"].get(cert_user_id, {})) \n\n所以说这里抽出来的代码表面上是在处理任意自定规则的优先级，实际上：\n\n0. 只适用于那些写死的规则。\n1. 其实并没有真正试图去判断优先级，只是用来让特别用户规则可以覆盖一般规则而已。硬要说优先的话，也就是特定用户优先于一般规则这一条而已。\n\n这代码写得很有迷惑性，注释也缺乏，单独看这段很难看出真实意图。",
			"post_id": 12,
			"date_added": 1503937300
		}
	],
	"comment_vote": {},
	"topic_vote": {},
	"post_vote": {
		"11": 1,
		"12": 1,
		"13": 1,
		"14": 1
	}
}