{
	"title": "妖禍子日記",
	"description": "发或者不发一些有的没的\n\n- - -\n\n[空澄砂夜 | 传送门](/sorasumi.bit/)",
	"links": "- [Source code](https://github.com/HelloZeroNet)",
	"next_post_id": 15,
	"demo": false,
	"modified": 1503743754,
	"post": [
		{
			"post_id": 14,
			"title": "ZeroGreeter：可配置的标签化首页",
			"date_published": 1503743696,
			"body": "最近几天对 ZeroHello 信息流的混杂，以及站点列表的冗长感到有些不满，试着制作了一个替代品：[ZeroGreeter](/presto.greeter.bit)。看起来大概是这个样子的(/･ω･)/\n\n![greeter.png (961x773)](data/img/post_14_greeter.png)\n\n不同于默认首页，ZeroGreeter 可以为每个站点设置标签，并根据这些标签分类显示站点列表和信息流。这样，即便添加了较多站点，也可以方便地获取重要的信息流，或找到需求的站点。初始视图中的 `vivace` 就是一个这样的例子：在传统的 ZeroHello 布局上方，额外添加了博客和论坛的列表，以及单独的提及信息流。这些过滤器的数量、性质和位置，均可以由用户自行配置，以完成最适合自己的首页布局。\n\n除去手动设置，ZeroGreeter 还可以为符合一定条件的站点自动设置标签，例如从 ZeroBlog、ZeroTalk 等特定网站克隆得来的站点，或是被合并的站点。若有收录于使用 Kaffiene Search 格式的索引的站点，也可以从索引中获取标签。这样，即使不经过任何配置，也可以相对有效地使用。不过，如果熟悉一下 `local/conf` 下的配置文件，或许可以得到更加合适的体验也说不定。配置文件的文档已经嵌入在站点中：点击页面最上方的“Greetings ZeroNet_”并选择 `docs` 视图即可浏览。\n\n需要注意的是，在使用第三方首页时，必须给予其 `ADMIN` 权限，以允许查询站点列表和信息流。这是一个非常宽泛的权限，隐含着相当高的信任，**不适合随意地给出**。因此，ZeroGreeter 鼓励用户查看它的源代码（处在数据文件夹的 `src` 下），并自行构建私人使用的版本。这很重要，因为即使确信了当前版本的无害，也无法确信同一地址上未来的更新一定是无害的。你应当自行确认并构建每个更新版本。事实上，**若你没有将自己设置为站点的所有者，ZeroGreeter 将不会允许你的使用**。若你决定使用它，这意味着你以自由心证，确信了内容的无害，并将自己承担这一行为带来的一切风险。\n\n如果能够派上用场的话就太好了！\n\n* * *\n\n## 其他截图\n\n其实已经在 ZeroMe 发过啦。\n\n![greeter2.png (944x677)](data/img/post_14_greeter2.png)\n![greeter3.png (932x522)](data/img/post_14_greeter3.png)"
		},
		{
			"post_id": 13,
			"title": "ZeroNet 数据库描述文件的配置细节",
			"date_published": 1501396496,
			"body": "在编写动态站点时，经常需要收集分散在各个 JSON 文件中的数据。为了方便应用，ZeroNet 提供了由描述文件 dbschema.json 控制的数据库机制，但在文档方面，则只有一份代码样例。尽管代码样例经过注释，但许多细节仍未说明，需要阅读源码。现在我把发现写在这里，这样你就不需要费事啦(≧∇≦)b\n\n这篇文章是关于 ZeroNet 0.5.7 master 分支 rev2169 的分析，可能不适用于其他版本。\n\n* * *\n\n## version 的具体作用\n\n对于 `version` 这个键的值，文档是这样记述的：\n\n*   1 = `json` 表含有同时包含目录名和文件名的 `path` 列\n*   2 = `json` 表含有包含目录名的 `directory` 列和包含文件名的 `file_name` 列\n*   3 = 与 2 相同，但同时含有 `site` 列（用于 Merger Site）\n\n……是不是不太明白？嗯。我也不太明白。现在看一看对应的实现：\n\n```py\n# src/Db/Db.py#L180\n# Check json table\nif self.schema[\"version\"] == 1:\n    changed = cur.needTable(\"json\", [\n        [\"json_id\", \"INTEGER PRIMARY KEY AUTOINCREMENT\"],\n        [\"path\", \"VARCHAR(255)\"]\n    ], [\n        \"CREATE UNIQUE INDEX path ON json(path)\"\n    ], version=self.schema[\"version\"])\nelif self.schema[\"version\"] == 2:\n    changed = cur.needTable(\"json\", [\n        [\"json_id\", \"INTEGER PRIMARY KEY AUTOINCREMENT\"],\n        [\"directory\", \"VARCHAR(255)\"],\n        [\"file_name\", \"VARCHAR(255)\"]\n    ], [\n        \"CREATE UNIQUE INDEX path ON json(directory, file_name)\"\n    ], version=self.schema[\"version\"])\nelif self.schema[\"version\"] == 3:\n    changed = cur.needTable(\"json\", [\n        [\"json_id\", \"INTEGER PRIMARY KEY AUTOINCREMENT\"],\n        [\"site\", \"VARCHAR(255)\"],\n        [\"directory\", \"VARCHAR(255)\"],\n        [\"file_name\", \"VARCHAR(255)\"]\n    ], [\n        \"CREATE UNIQUE INDEX path ON json(directory, site, file_name)\"\n    ], version=self.schema[\"version\"])\nif changed:\n    changed_tables.append(\"json\")\n\n# Check schema tables\nfor table_name, table_settings in self.schema[\"tables\"].items():\n    changed = cur.needTable(\n        table_name, table_settings[\"cols\"],\n        table_settings[\"indexes\"], version=table_settings[\"schema_changed\"]\n    )\n    if changed:\n        changed_tables.append(table_name)\n```\n\n```py\n# src/Db/DbCursor.py#L118\n# Get or create a row for json file\n# Return: The database row\ndef getJsonRow(self, file_path):\n    directory, file_name = re.match(\"^(.*?)/*([^/]*)$\", file_path).groups()\n    if self.db.schema[\"version\"] == 1:\n        # One path field\n        res = self.execute(\"SELECT * FROM json WHERE ? LIMIT 1\", {\"path\": file_path})\n        row = res.fetchone()\n        if not row:  # No row yet, create it\n            self.execute(\"INSERT INTO json ?\", {\"path\": file_path})\n            res = self.execute(\"SELECT * FROM json WHERE ? LIMIT 1\", {\"path\": file_path})\n            row = res.fetchone()\n    elif self.db.schema[\"version\"] == 2:\n        # Separate directory, file_name (easier join)\n        res = self.execute(\"SELECT * FROM json WHERE ? LIMIT 1\", {\"directory\": directory, \"file_name\": file_name})\n        row = res.fetchone()\n        if not row:  # No row yet, create it\n            self.execute(\"INSERT INTO json ?\", {\"directory\": directory, \"file_name\": file_name})\n            res = self.execute(\"SELECT * FROM json WHERE ? LIMIT 1\", {\"directory\": directory, \"file_name\": file_name})\n            row = res.fetchone()\n    elif self.db.schema[\"version\"] == 3:\n        # Separate site, directory, file_name (for merger sites)\n        site_address, directory = re.match(\"^([^/]*)/(.*)$\", directory).groups()\n        res = self.execute(\"SELECT * FROM json WHERE ? LIMIT 1\", {\"site\": site_address, \"directory\": directory, \"file_name\": file_name})\n        row = res.fetchone()\n        if not row:  # No row yet, create it\n            self.execute(\"INSERT INTO json ?\", {\"site\": site_address, \"directory\": directory, \"file_name\": file_name})\n            res = self.execute(\"SELECT * FROM json WHERE ? LIMIT 1\", {\"site\": site_address, \"directory\": directory, \"file_name\": file_name})\n            row = res.fetchone()\n    else:\n        raise Exception(\"Dbschema version %s not supported\" % self.db.schema.get(\"version\"))\n    return row\n```\n\n可以看到，`version` 的值看上去有两项作用：其一是设置 `json` 表的结构和索引，其二是决定插入 `json` 行时的行为：\n\n*   `path` - 仅在 `version` 为 1 时设置，包含完整的路径。\n*   `directory` - 在 `version` 为 2 或 3 时设置，包含文件所在文件夹的路径。不包含最后的分隔符。\n*   `file_name` - 在 `version` 为 2 或 3 时设置，包含文件名。\n*   `site` - 仅在 `version` 为 3 时设置，包含文件所在站点的公钥地址。\n\n然而进一步观察，就可以发现 `json` 表的创建和紧接着的其他数据表的创建均调用了同一个方法 `needTable`。那么，这个方法又是如何实现的呢？\n\n```py\n# src/Db/DbCursor.py#L101\n# Create table if not exist\n# Return: True if updated\ndef needTable(self, table, cols, indexes=None, version=1):\n    current_version = self.db.getTableVersion(table)\n    if int(current_version) < int(version):  # Table need update or not extis\n        self.db.log.info(\"Table %s outdated...version: %s need: %s, rebuilding...\" % (table, current_version, version))\n        self.createTable(table, cols)\n        if indexes:\n            self.createIndexes(table, indexes)\n        self.execute(\n            \"INSERT OR REPLACE INTO keyvalue ?\",\n            {\"json_id\": 0, \"key\": \"table.%s.version\" % table, \"value\": version}\n        )\n        return True\n    else:  # Not changed\n        return False\n```\n\n可以看到，当同名数据表已经存在时，ZeroNet 会判断两者的 `version` 大小，并决定是否要重建数据表。而对于 `json` 表而言，这个值或者是 `version`，或者是自行定义 `json` 表时设置的 `schema_changed`。因此，当自行定义了 `json` 表，且 `schema_changed` 大于 `version` 时，**自行设置的表结构将会生效，但插入行时仍然将依照 `version` 设置的行为**；相反，若设置的 `schema_changed` 小于或等于 `version`，**自行定义的 `json` 表结构将不会生效**。\n\n……依稀记得一开始设置 `json` 表结构时总是无效，改过几次之后莫名其妙就变得正常了，原来是这样的原理(；´Д｀)\n\n## keyvalue 表\n\n关于 `keyvalue` 表和 `to_keyvalue` 键，文档是这样记述的：\n\n```\n\"to_keyvalue\": [\"next_message_id\", \"next_topic_id\"]\n# Load data.json[next_topic_id] to keyvalues table\n# (key: next_message_id, value: data.json[next_message_id] value)\n```\n\n……嗯，只有这两句话，而且表名还写错了。总之，看一看实现吧：\n\n```py\n# src/Db/Db.py#L168\n# Check keyvalue table\nchanged = cur.needTable(\"keyvalue\", [\n    [\"keyvalue_id\", \"INTEGER PRIMARY KEY AUTOINCREMENT\"],\n    [\"key\", \"TEXT\"],\n    [\"value\", \"INTEGER\"],\n    [\"json_id\", \"INTEGER\"],\n], [\n    \"CREATE UNIQUE INDEX key_id ON keyvalue(json_id, key)\"\n], version=self.schema[\"version\"])\nif changed:\n    changed_tables.append(\"keyvalue\")\n```\n\n```py\n# src/Db/Db.py#L273\nif dbmap.get(\"to_keyvalue\"):\n    # Get current values\n    res = cur.execute(\"SELECT * FROM keyvalue WHERE json_id = ?\", (json_row[\"json_id\"],))\n    current_keyvalue = {}\n    current_keyvalue_id = {}\n    for row in res:\n        current_keyvalue[row[\"key\"]] = row[\"value\"]\n        current_keyvalue_id[row[\"key\"]] = row[\"keyvalue_id\"]\n\n    for key in dbmap[\"to_keyvalue\"]:\n        if key not in current_keyvalue:  # Keyvalue not exist yet in the db\n            cur.execute(\n                \"INSERT INTO keyvalue ?\",\n                {\"key\": key, \"value\": data.get(key), \"json_id\": json_row[\"json_id\"]}\n            )\n        elif data.get(key) != current_keyvalue[key]:  # Keyvalue different value\n            cur.execute(\n                \"UPDATE keyvalue SET value = ? WHERE keyvalue_id = ?\",\n                (data.get(key), current_keyvalue_id[key])\n            )\n```\n\n首先，和之前的 `json` 表同样，`keyvalue` 表的结构版本也等同于 `version`。**默认情况下，`value` 的类型为整数。**如果需要 `(json_id, key)` 之外的索引，或者整型之外的 `value` 值，可以通过设置大于 `version` 的 `schema_changed` 来覆盖表结构。其次，对于每个 JSON 文件，`keyvalue` 表中的键是唯一的，且只能等同于文件中的键名。\n\n## to_table 的详细规则\n\n关于 `to_table` 的详细规则，文档是这样记述的：\n\n```\n{\n  \"node\": \"comment_votes\", # Reading data.json[comment_votes] key value\n  \"table\": \"comment_vote\", # Feeding data to comment_vote table\n  \"key_col\": \"comment_hash\",\n    # data.json[comment_votes] is a simple dict, the keys of the\n    # dict are loaded to comment_vote table comment_hash column\n  \"val_col\": \"vote\"\n    # The data.json[comment_votes] dict values loaded to comment_vote table vote column\n}\n{\n  \"node\": \"includes\",\n  \"table\": \"user\",\n  \"key_col\": \"path\",\n  \"import_cols\": [\"user_id\", \"user_name\", \"max_size\", \"added\"],\n    # Only import these columns to user table\n  \"replaces\": {\n    \"path\": {\"content.json\": \"data.json\"}\n      # Replace content.json to data.json in the\n      # value of path column (required for joining)\n  }\n}\n```\n\n嗯……意外地好像说得很清楚？不过为了放心，还是看一下实现吧：\n\n```py\n# src/Db/Db.py#L333\nif key_col:  # Map as dict\n    for key, val in data[node].iteritems():\n        if val_col:  # Single value\n            cur.execute(\n                \"INSERT OR REPLACE INTO %s ?\" % table_name,\n                {key_col: key, val_col: val, \"json_id\": json_row[\"json_id\"]}\n            )\n        else:  # Multi value\n            if isinstance(val, dict):  # Single row\n                row = val\n                if import_cols:\n                    row = {key: row[key] for key in row if key in import_cols}  # Filter row by import_cols\n                row[key_col] = key\n                # Replace in value if necessary\n                if replaces:\n                    for replace_key, replace in replaces.iteritems():\n                        if replace_key in row:\n                            for replace_from, replace_to in replace.iteritems():\n                                row[replace_key] = row[replace_key].replace(replace_from, replace_to)\n\n                row[\"json_id\"] = json_row[\"json_id\"]\n                cur.execute(\"INSERT OR REPLACE INTO %s ?\" % table_name, row)\n            else:  # Multi row\n                for row in val:\n                    row[key_col] = key\n                    row[\"json_id\"] = json_row[\"json_id\"]\n                    cur.execute(\"INSERT OR REPLACE INTO %s ?\" % table_name, row)\nelse:  # Map as list\n    for row in data[node]:\n        row[\"json_id\"] = json_row[\"json_id\"]\n        if import_cols:\n            row = {key: row[key] for key in row if key in import_cols}  # Filter row by import_cols\n        cur.execute(\"INSERT OR REPLACE INTO %s ?\" % table_name, row)\n```\n\n(´ﾟдﾟ｀)\n\n嗯……怎么描述呢，这个情况……\n\n*   规则中的 `node` 必须是 JSON 根对象下第一级的键名。\n*   规则中的 `import_cols` 当且仅当满足如下情况之一时有效：\n    *   未设置 `key_col`。\n    *   设置了 `key_col`，且满足如下全部情况：\n        *   未设置 `val_col`。\n        *   JSON 文件中名称等于 `node` 的值的键的值类型为 JSON Object。\n*   规则中的 `replaces` 当且仅当满足如下情况时有效：\n    *   设置了 `key_col`。\n    *   未设置 `val_col`。\n    *   JSON 文件中名称等于 `node` 的值的键的值类型为 JSON Object。\n\n**大体上而言，只有和代码样例完全相同的用法才能生效。**一定要说的话，后两项这样的情况与其说是有意的设计，不如说更像是为了特定用途临时增加功能的产物。ZeroNet 开发者在写下这段代码时是如何思考的，自然无从得知，不过对于希望使用 `import_cols` 和 `replaces` 的用户而言，这应该会成为一个不小的麻烦吧。\n\n就是这样！\n\n* * *\n\n附言：也许你已经注意到了，不过表结构的 `index` 数组中其实是可以填入任意 SQL 语句，使它在创建新表后执行的。可以用来做一些有趣的事情也说不定！"
		},
		{
			"post_id": 12,
			"title": "ZeroNet 中用户数据权限的判断机制",
			"date_published": 1500878695,
			"body": "由于 [ZeroNet 文档 (clearnet)](https://zeronet.readthedocs.io/en/latest/site_development/content_json/#user_contents) 中有关用户数据权限的部分语焉不详，不得不阅读 ZeroNet 本身的源码。我把发现写在这里，这样你就不需要费事啦（\\*´▽｀*）\n\n如果你想要在自己的站点配置用户权限规则的话，会有用处也说不定！\n\n- - -\n\n与 `permission_rules` 直接相关的[代码段 (clearnet)](https://github.com/HelloZeroNet/ZeroNet/blob/cbac57dc8824a9dff4a79dcfab008bebe5cddf6f/src/Content/ContentManager.py#L411) 并不难以寻找：\n\n```py\n# src/Content/ContentManager.py#L411\nfor permission_pattern, permission_rules in user_contents[\"permission_rules\"].items():  # Regexp rules\n    if not SafeRe.match(permission_pattern, user_urn):\n        continue  # Rule is not valid for user\n    # Update rules if its better than current recorded ones\n    for key, val in permission_rules.iteritems():\n        if key not in rules:\n            if type(val) is list:\n                rules[key] = val[:]  # Make copy\n            else:\n                rules[key] = val\n        elif type(val) is int:  # Int, update if larger\n            if val > rules[key]:\n                rules[key] = val\n        elif hasattr(val, \"startswith\"):  # String, update if longer\n            if len(val) > len(rules[key]):\n                rules[key] = val\n        elif type(val) is list:  # List, append\n            rules[key] += val\n```\n\n根据这段代码，当用户的 ID 符合正则表达式时，ZeroNet 将这样确定用户的权限：\n\n* 若对应值为整数，取所有值中的最大值。\n* 若对应值为字符串，取所有值中最长的一个。\n* 若对应值为数组，**按照规则匹配的顺序进行连接**。\n* 若对应值为其他类型，**取匹配的第一个规则的值，并丢弃之后的所有值**。\n\n从以上规则中可见，**有两项是与遍历顺序相关的**。由于 JSON Object 本身在规范中没有被定义顺序，而遍历顺序取决于 JSON 分析器的具体实现，这里就需要寻找读取 JSON 文件的位置：\n\n```py\n# src/Site/SiteStorage.py#L4\nimport json\n# src/Site/SiteStorage.py#L252\ndef loadJson(self, inner_path):\n    with self.open(inner_path) as file:\n    return json.load(file)\n```\n\n可以看到，ZeroNet 使用了 Python 2 标准库中的 `json.load` 方法，并没有提供文件名之外的参数。根据 [Python 2 文档 (clearnet)](https://docs.python.org/2/library/json.html#json.load)，可知在没有提供 `object_hook` 时，JSON Object 被解析为 `dict` 对象。由于前面的代码中调用了 `dict.iteritems` 方法，由[文档 (clearnet)](https://docs.python.org/2/library/stdtypes.html#dict.items) 进一步得知遍历顺序没有被定义，而且在 CPython 中是“任意但非随机的”。\n\n根据前面的信息，现在可以得到如下结论：\n\n* 权限的确定类似白名单机制。应该将更高的权限设置在匹配范围更小的正则表达式下。\n* 对于整数类型的权限，取所有值中的最大值。\n* 对于字符串类型的权限，取所有匹配的值中最长的一个。为了保证权限的完整性，更高权限的值**应当**包含所有更低权限的值。\n* 对于数组类型的权限，取所有匹配的值连接的结果，但顺序不确定。为了避免重复，更高权限的值**不应当**包含更低权限的值。\n* 对于所有其他类型的权限，只应在匹配范围最广的规则下设置一次，否则执行结果不可预测。\n\n就是这样！"
		},
		{
			"post_id": 11,
			"title": "2:3",
			"date_published": 1500723895,
			"body": "值得纪念的第七天！ヾ(｡>﹏<｡)ﾉﾞ\n\n不过，虽然经过了七天，这里好像还是一直只有关于 [0-Gallery](/0gallery.bit/) 的内容。虽然今天也有一点更新，不过为了避免无聊，今天还是说些其他的事情吧！\n\n毕竟无聊可是人类的敌人。\n\n本季的来自深渊是部有趣的动画。有些仿佛草莓棉花糖的可爱人设，和相比之下庞大地似乎有点不相称的世界观，两者的搭配有足够的新鲜感。加上原作展开十分正经的传言，可能会成为本季最有看点的一部吧！\n\n为了避免无聊，不一直接触新的信息就不行。失去了信息的渠道，人会变成什么样子呢。即便不想考虑，似乎也不行了。\n\n~~虽然雷古的声优也在演唱主题歌，不过果然还是女性的声音啊。这样说的话雷古其实是女孩子的可能性是不是也……在微粒子层面上存在着？！~~"
		},
		{
			"post_id": 7,
			"title": "在 0-Gallery 上展示你的图库",
			"date_published": 1500387742,
			"body": "作为刚刚的更新的一部分，[SayoGalleryHub](/1MQSfpS5TsqpTMLdu4gqejfcgQpBAGhPjv/) 可以克隆啦！现在任何人都可以（大概还算是）方便地在 [0-Gallery](/1jYE6vneWL1AfusEA31Bw35ARNdfcbpFh/) 上添加图库了。尽管如此，一个几乎空白的总览页面可能还是会让你感到有些困惑——别担心，援军来了(/･ω･)/\n\n7 月 21 日更新：现在可以直接在你拥有的 GalleryHub 网页上添加图库了！如果你的页面上还没有“上传向导”，试试在 ZeroHello 中更新代码吧。不过，手工添加仍然将提供最高图片质量。\n\n* * *\n\n## 需要准备的东西\n\n*   一个纯文本编辑器\n*   一个图片批处理工具，例如 [ImageMagick (clearnet)](https://www.imagemagick.org)\n*   一个新克隆的 [GalleryHub](/1MQSfpS5TsqpTMLdu4gqejfcgQpBAGhPjv/)\n*   一个准备发布的图库\n*   一个可以做种的节点\n*   还有一点耐心！\n\n## 取个名字吧！\n\n当你打开新克隆的站点，你会看到它有着一个非常平凡的标题和一个名为“Demo Gallery”的图库。你将会注意到，这个图库已经可以在你的 0-Gallery 中浏览了（如果它还没在列表中出现，你可以试试重建数据库）。不过，先不要忙着发布这个新的站点。为了方便区分内容的来源，你首先应该在侧栏为你的站点取一个独特的新名字——一个有关你的 ID 或你将要发布的内容的名字就很不错！\n\n在你保存站点设置并刷新页面后，你就能在页面顶部看到闪闪发亮的新名字了！现在，你可能会想把图库的名字也修改掉。不过，请你稍微沉住气，因为这要稍微多花点工夫……直到你熟悉为止。\n\n## 找到描述文件\n\n我们知道，ZeroNet 将你访问过的每个站点的数据存放在本地，不过你有没有去实际看过这些文件呢？如果你没有用命令行或配置文件指定其他的位置，ZeroNet 会将数据存储在安装位置的 `data` 文件夹下。接下来，只要进入以你的新站点的地址为名的子目录，就可以看到如下的文件结构：\n\n*   `galleries/[stub]/manifest.json` - 图库描述文件\n*   `galleries/[stub]/thumbs/*` - 缩略图\n*   `galleries/[stub]/img/*` - 大分辨率图片（默认为可选文件）\n*   其中 `[stub]` 为图库识别名，它在你的站点内是唯一的，并会在浏览时出现在 URL 中\n\n现在，重命名 `galleries/demo` 文件夹，然后用纯文本编辑器打开其中的 `manifest.json`。你可以这个文件中设定图库的标题、简介、页面顺序、标签等各项元数据。需要注意的是，如果你的 JSON 不符合格式要求，站点就无法检测到图库的存在。因此，如果你还没有接触过 JSON，你可能会希望先看一下它的[格式需求 (clearnet)](http://www.json.org/json-zh.html)——别担心，这个格式可是以简单闻名的！\n\n这里是一些可能不太明显的栏位的填写方式：\n\n*   `lang` - ISO 639-1 语言代码的前两个字符。\n*   `type` - 目前，0-Gallery 可以识别 `comic`、`doujinshi` 和 `collection`。如果你的图集带有成人内容，应当加上后缀 `-18`。\n*   `added` - UNIX 时间戳。如果你不知道怎样填写，你可以在浏览器控制台（F12）中输入 `(Date.now() / 1000)|0` 来获得当前时间。\n\n## 准备图片\n\n做完修改，保存并刷新，你就能看到填写的信息了。不过，你的图库还有一个显著的问题：最重要的图片不在里面。当然，你可以简单地将图片复制进 `img`，然后填写 `manifest.json` 中的 `files`，不过这可能对读者不太友好，因为越大的原图就需要越长的时间下载。同时，你还需要为各个页面准备缩略图。\n\n由于 0-Gallery 的页面宽度被限制在 1200px，推荐使用如下的大分辨率图片格式：\n\n*   最大 1200px x 2400px\n*   质量为 80 的 jpg 文件\n\n由于 0-Gallery 的缩略图大小被限制在 192px，推荐使用如下的缩略图格式：\n\n*   最大 192px x 192px\n*   质量为 70 的 jpg 文件\n\n如果要将文件名形如“image_00.png”、“image_01.png”……“image_40.png”的原图转换为推荐格式，可以使用如下的 ImageMagick 命令行（你也可以使用自己选择的批处理工具）：\n\n```\n$ convert 'image_%02d.png[0-40]' -resize \\>192x192   -quality 70 '[路径]/thumbs/thumb.jpg'\n$ convert 'image_%02d.png[0-40]' -resize \\>1200x2400 -quality 80 '[路径]/img/page.jpg'\n```\n\n转换完成后，按顺序填写 `manifest.json` 中的 `files` 和 `thumbs`，再挑选一个 `cover`，你的图库页面就会变得热闹多了！\n\n## 发布站点\n\n终于到了发布的时刻！在签名并发布之前，你应该再次确认描述文件的正确性。你的站点上的“错误检查”工具可以捕捉一些最基本的问题，确认无误后再签名并发布吧！\n\n祝贺！漫长的旅途已经结束……或者……可能是开始也说不定？\n\n* * *\n\n写了好久累死啦(´-﹏-`；)\n\n有人感兴趣的话就再好不过了！（树旗）"
		},
		{
			"post_id": 6,
			"title": "0-Gallery 的一天",
			"date_published": 1500308472.5,
			"body": "[0-Gallery](/1jYE6vneWL1AfusEA31Bw35ARNdfcbpFh/) 是一个图库浏览器。它可以从多个来源查询和展示图库。尽管现在还有些孤单，不过有趣的事就是好事！\n\n在过去的一天里，0-Gallery 发生了这些变化：\n\n*   增加了查询功能，可以用标签和标题来寻找图库了。\n*   增加了中文本地化，可以依据浏览器设置选择语言了。\n*   增加了缓存开关，点一下就可以开始缓存并帮助分发图库内容。\n*   提升了一点界面可用性。\n\n接下来可能会做也可能不会做的事情：\n\n*   让图库来源站变得好看一点，并制作方便复制新 Hub 的模板。\n*   写一些文档来协助新来源的创建。\n*   继续寻找分发源码的方式。\n\n……嗯，我就是没有什么可写的事情也要刷一下存在感(/_;)"
		},
		{
			"post_id": 3,
			"title": "0-Gallery: The 0 Makes It Sound Kewl",
			"date_published": 1500231863.9,
			"body": "与语焉不详的文档和人间蒸发的 dbschema 报错信息作战许久，总算写出了一个还算是能用的 Merger Demo。\n\n[0-Gallery](/1jYE6vneWL1AfusEA31Bw35ARNdfcbpFh/)\n\nヾ(｡>﹏<｡)ﾉﾞ✧*。\n\n嗯……就是这样一个非常原始的……本子站。不过这个地址本身并不包含内容，而是像 ZeroMe 一样，可以聚集多个内容来源。既然是在分布式网络上，不废除中心化的权限管理怎么行呢！(≧∇≦)/\n\n当然，现在这里还非常孤单，所以我放了一个（同样非常原始的）内容来源，好让图库有点事做：[SayoGalleryHub](/1MQSfpS5TsqpTMLdu4gqejfcgQpBAGhPjv/)。\n\n暂时就是这样啦！\n\n不知道 ZeroNet 上怎样分发源码比较好呢……"
		},
		{
			"post_id": 2,
			"title": "21:6",
			"date_published": 1500183801,
			"body": "经过一晚折腾终于做好了给站点做种的准备。于是先复制一个 Blog 试试吧。\n\n简略地看过一点文档，感到 ZeroNet 有些有趣的地方。今后或许会做一点实验也说不定。\n\n也可能什么都不会做。\n\n竭尽所能抵抗无聊吧(≧∇≦)/"
		}
	]
}