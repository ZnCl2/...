<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>早起</title>
 <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/" rel="self"/>
 <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq"/>
 <updated>2016-05-24T00:50:07+08:00</updated>
 <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq</id>
 <author>
   <name>Been Woo</name>
   <email>sqbing@gmail.com</email>
 </author>

 
 <entry>
   <title>C++ cast备忘</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2015/12/22/cpp-cast/index.html"/>
   <updated>2015-12-22T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2015/12/22/cpp-cast/cpp-cast</id>
   <content type="html">&lt;p&gt;Jekyll::Drops::SiteDrop
这格式见了鬼了，表格出不来，懒得找原因了。&lt;/p&gt;

&lt;p&gt;|名称|介绍|
|---|---|
|upcast|从派生到基类|
|downcast|从基类到派生|&lt;/p&gt;

&lt;p&gt;|名称|介绍|
|---|---|
|dynamic&lt;em&gt;cast|upcast and downcast with target type check|
|static&lt;/em&gt;cast|upcast and downcast without target type check|
|reinterpret&lt;em&gt;cast|all kinds cast without target type check|
|boost::static&lt;/em&gt;pointer&lt;em&gt;cast|作用范围同static&lt;/em&gt;cast，用于智能指针的类型转换，同时处理引用计数|
|boost::dynamic&lt;em&gt;pointer&lt;/em&gt;cast|作用范围同dynamic&lt;em&gt;cast，用于智能指针的类型转换，同时处理引用计数|
|boost::reinterpret&lt;/em&gt;pointer&lt;em&gt;cast|作用范围同reinterpret&lt;/em&gt;cast，用于智能指针的类型转换，同时处理引用计数|
|boost::shared&lt;em&gt;polymorphic&lt;/em&gt;downcast/boost::polymorphic&lt;em&gt;pointer&lt;/em&gt;downcast|作用范围同static&lt;em&gt;cast，在定义NDEBUG时，使用dynamic做运行时检测，未定义NDEBUG时，同static&lt;/em&gt;cast，用于智能指针的类型转换，同时处理引用计数|
|boost::shared&lt;em&gt;polymorphic&lt;/em&gt;cast/boost::polymorphic&lt;em&gt;pointer&lt;/em&gt;cast:|作用范围同dynamic&lt;em&gt;cast，类型转换失败时抛出异常，用于智能指针的类型转换，同时处理引用计数|
|boost::polymorphic&lt;/em&gt;cast|作用范围同dynamic&lt;em&gt;cast，类型转换失败时抛出异常，用于非智能指针的类型转换|
|boost::polymorphic&lt;/em&gt;downcast|作用范围同static&lt;em&gt;cast，未定义NDEBUG时，同static&lt;/em&gt;cast，用于智能指针的类型转换，同时处理引用计数，用于非智能指针的类型转换|&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>2015-09-07-小书匠测试.md</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2015/09/07/xiaoshujiang_test/index.html"/>
   <updated>2015-09-07T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2015/09/07/xiaoshujiang_test/xiaoshujiang_test</id>
   <content type="html">&lt;p&gt;测试通过小书匠发布github blog。&lt;/p&gt;

&lt;p&gt;测试通过小书匠修改已发布blog。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Errors running builder 'Android Pre Compiler' on project</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2015/04/01/android-pre-compiler-error/index.html"/>
   <updated>2015-04-01T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2015/04/01/android-pre-compiler-error/android-pre-compiler-error</id>
   <content type="html">&lt;p&gt;很久没用eclipse写android，今天想写个demo，先是启动是告诉我没有java 1.6，这个先不说，编译项目的时候居然报了如题错误。
试了这个&lt;a href=&quot;http://stackoverflow.com/questions/14455018/eclipse-android-errors-running-builder-android-pre-compiler-on-project&quot;&gt;方法&lt;/a&gt;
顺利解决。&lt;/p&gt;

&lt;p&gt;似乎是预编译器和.svn文件夹闹别扭，罢工了，过滤掉.svn文件夹就行了。&lt;/p&gt;

&lt;p&gt;这里顺便吐嘈下某些中文博客，原因讲不清楚就算了，给的解决方案也是够坑的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MP4 to HLS based on nginx-http-mp4-module</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2014/06/24/MP4-to-HLS-based-on-nginx-http-mp4-module/index.html"/>
   <updated>2014-06-24T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2014/06/24/MP4-to-HLS-based-on-nginx-http-mp4-module/MP4-to-HLS-based-on-nginx-http-mp4-module</id>
   <content type="html">&lt;p&gt;这里列出了我在基于nginx-http-mp4-module开发MP4直出HLS流时遇到的坑，哎，说多了都是泪啊……
希望对你有帮助，如果你发现了一些没有列出来的问题，欢迎反馈，你知道怎么联系我的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SPS和PPS何时发送？&lt;/p&gt;

&lt;p&gt;IDR(nalu_type=5)之前发送&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PMT和PAT如何构造？&lt;/p&gt;

&lt;p&gt;PMT和PAT为固定字段，每ts发送一次即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;加入条带分割NAL头部对现有的H.264数据有何影响？&lt;/p&gt;

&lt;p&gt;目前看无影响，每一sample前发送条带分割NAL(nalu_type=9)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;码流和网络流形式的NAL在转换时需要注意哪些？&lt;/p&gt;

&lt;p&gt;一般情况下发送0x00 00 00 01，仅在sample的非首slice时发送0x00 00 01&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AAC头部是否需要修改？&lt;/p&gt;

&lt;p&gt;AAC需要使用ADST封装&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ADST包含哪些参数？从MP4文件的何box中读取参数？&lt;/p&gt;

&lt;p&gt;profile: (object_type - 1)&lt;/p&gt;

&lt;p&gt;sampling frequency: sample&lt;em&gt;rate&lt;/em&gt;index&lt;/p&gt;

&lt;p&gt;channel configuration: channels&lt;/p&gt;

&lt;p&gt;通过mp4a-&amp;gt;esds读取上述参数&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;音频数据如何汇总成一个PES包再发送，而不是每一个sample封装一个PES？&lt;/p&gt;

&lt;p&gt;音频打包到一个PES再发送，大小为2930&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成m3u8时如何分割？&lt;/p&gt;

&lt;p&gt;以GOP为分割&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;aac的duration为什么固定是1024？遇到非固定duration的aac应如何处理？&lt;/p&gt;

&lt;p&gt;aac规定每个frame包含1024个samples；忽略stts中的delta，固定输出1024&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MP4中的elst atom应如何处理？&lt;/p&gt;

&lt;p&gt;pts -= elst&lt;em&gt;start&lt;/em&gt;time&lt;/p&gt;

&lt;p&gt;dts -= elst&lt;em&gt;start&lt;/em&gt;time&lt;/p&gt;

&lt;p&gt;http://wiki.multimedia.cx/index.php?title=QuickTime_container#elst&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;WARNING: Unable to read video timestamps in track 1; this may be due to not having a key frame in this segment.&lt;/p&gt;

&lt;p&gt;dts时间戳不为0即可，apple提供的切片工具(mediafilesegmenter)，使用的是10秒前缀;&lt;/p&gt;

&lt;p&gt;某些安卓平台的播放器，不支持非0开始的流，比如UC，遨游和小米自带的浏览器等等，表现为播放视频时自动跳到10秒之后播放。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PAT中最重要的字段&lt;/p&gt;

&lt;p&gt;PMT的PID，其他字段一般不变&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PMT中最重要的字段&lt;/p&gt;

&lt;p&gt;PID&lt;/p&gt;

&lt;p&gt;PCR PID&lt;/p&gt;

&lt;p&gt;音频类型&lt;/p&gt;

&lt;p&gt;音频PID&lt;/p&gt;

&lt;p&gt;视频类型&lt;/p&gt;

&lt;p&gt;视频PID&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PAT和PMT中的continuity counter是否需要递增？&lt;/p&gt;

&lt;p&gt;建议连续，以兼容某些平台，比如安卓&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;音、视频的continuity counter是否需要递增？&lt;/p&gt;

&lt;p&gt;iOS平台和Mac平台的safari浏览器能够处理continuity counter跳跃，但是安卓的自带浏览器不行，如果安卓平台也在考虑范围内，最好安安分分的处理continuity counter&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>HTTP Live Streaming 笔记</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2014/06/24/HTTP-Live-Streaming-notes/index.html"/>
   <updated>2014-06-24T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2014/06/24/HTTP-Live-Streaming-notes/HTTP-Live-Streaming-notes</id>
   <content type="html">&lt;h1&gt;Playlist&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;m3u8：扩展的M3U文件，以行分割，每一行结尾是LF或者CR LF。每一行表示一个URI，空行（被忽略）或者以#开头（注释或者tag/标签）。不能包含空格（？）。&lt;/li&gt;
&lt;li&gt;URI：表示一个分片或者一个playlist文件。可能是相对路径，若是，则根据该playlist路径拼凑完整路径。&lt;/li&gt;
&lt;li&gt;Media Playlist：仅包含分片的palylist&lt;/li&gt;
&lt;li&gt;Master Playlist：仅包含playlist的playlist&lt;/li&gt;
&lt;li&gt;Tags：以#EXT开头，所有其他的以#开头的行均是注释。&lt;/li&gt;
&lt;li&gt;duartion：所有分片duration之和&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编码：HTTP Content-Type &amp;quot;application/vnd.apple.mpegurl&amp;quot;的m3u8文件为UTF-8编码，HTTP Content-Type &amp;quot;audio/mpegurl&amp;quot;的m3u文件为US-ASCII编码&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AttributeName=AttributeValue,AttributeName=AttributeValue,…&lt;/p&gt;

&lt;p&gt;AttributeName不能包含空格，只能由A～Z和&amp;quot;-&amp;quot;组成，同一个AttributeName在一个attribute list中不能重复。
AttributeValue只能是10进制数字，十六进制数字(0x/0X)，十进制浮点数，引号包裹的字符串（“），没有引号包裹的可枚举字符串（？），十进制分辨率(widthxheight)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;EXTM3U&lt;/h2&gt;

&lt;p&gt;区分M3U8和M8U文件的标签&lt;/p&gt;

&lt;h2&gt;EXTINF&lt;/h2&gt;

&lt;p&gt;标识分片的duration，格式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#EXTINF:&amp;lt;duration&amp;gt;,&amp;lt;value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;duration是十进制数字或者十进制浮点数，单位为秒，协议版本号低于3的仅使用十进制证书
value可选&lt;/p&gt;

&lt;h2&gt;EXT-X-BYTERANGE:&amp;lt;n&amp;gt;[@o]&lt;/h2&gt;

&lt;p&gt;表示sub-range of resource
n表示sub-range长度，单位为字节
o是一个十进制整数，标识sub-range的起始位置，从resource的开始位置的偏移量，单位为字节
协议版本号从4开始使用该标签&lt;/p&gt;

&lt;h2&gt;EXT-X-TARGETDURATION:&amp;lt;s&amp;gt;&lt;/h2&gt;

&lt;p&gt;表示playlist文件中可能出现的最大duration
s是最大duration，以秒为单位&lt;/p&gt;

&lt;h2&gt;EXT-X-MEDIA-SEQUENCE:&amp;lt;number&amp;gt;&lt;/h2&gt;

&lt;p&gt;标识playlist文件中出现的第一个sequence number，仅出现一次&lt;/p&gt;

&lt;h2&gt;EXT-X-KEY:&lt;attribute-list&gt;&lt;/h2&gt;

&lt;p&gt;作用域到下一个包含相同KEYFORMAT attribute的EXT-X-KEY标签之前
METHOD：NONE, AES-128, SAMPLE-AES，若为NONE，则必须包含URI,VI,KEYFORMAT,KEYFORMATVERSIONS；若为AES-128，则必须包含URI，可选VI；若为SAMPLE-AES，可选VI
URI：key的URI
IV：Initialization Vector，十六进制整数，协议从版本号2开始包含此变量
KEYFORMAT：引用字符串
KEYFORMATVERSIONS：引用字符串，出现在协议版本号5中&lt;/p&gt;

&lt;h2&gt;EXT-X-PROGRAM-DATE-TIME:&lt;a href=&quot;YYYY-MM-DDThh:mm:ssZ&quot;&gt;YYYY-MM-DDThh:mm:ssZ&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;接下来的第一个的分片时间&lt;/p&gt;

&lt;h2&gt;EXT-X-ALLOW-CACHE:&lt;YES|NO&gt;&lt;/h2&gt;

&lt;p&gt;客户端是否可以缓存分片用于回放，仅能出现一次&lt;/p&gt;

&lt;h2&gt;EXT-X-PLAYLIST-TYPE:&lt;EVENT|VOD&gt;&lt;/h2&gt;

&lt;p&gt;playlist是否可修改&lt;/p&gt;

&lt;h2&gt;EXT-X-ENDLIST&lt;/h2&gt;

&lt;p&gt;表示不再有分片，仅能出现一次&lt;/p&gt;

&lt;h2&gt;EXT-X-MEDIA:&lt;attribute-list&gt;&lt;/h2&gt;

&lt;p&gt;用于表示同一内容的不同选择(alternative reditions)，比如只包含音频的英语，法语和西班牙语音轨，或者仅包含视频的两个摄像机机位，format相同
URI可选
TYPE三选一，VIDEO/AUDIO/SUBTITLES，同一GROUP的必须相同
GROUP-ID引用字符串
LANGUAGE可选 引用字符串，参考RFC 5646，若AUTOSELECT为YES，则LANGUAGE必须有效
NAME引用字符串，同一GROUP的必须不同
DEFAULT二选一YES/NO，同一GROUP仅有一个为YES
AUTOSELECT二选一YES/NO
FORCED二选一YES/NO 可选
CHARACTERISTICS引用字符串 可选&lt;/p&gt;

&lt;h2&gt;EXT-X-STREAM-INF:&lt;attribute-list&gt;&amp;lt;URI&amp;gt;&lt;/h2&gt;

&lt;p&gt;表示URI为playlist
BANDWIDTH必须包含，十进制整数，单位为比特
PROGRAM-ID Master Playlist中通过不同的PROGRAM-ID表示相同presentation的不同编码
CODECS引用字符串，value通过逗号分割，建议包含
RESOLUTION 视频分辨率
AUDIO 引用字符串，和GROUP-ID相同
VIDEO 引用字符串，和GROUP-ID相同
SUBTITLES 引用字符串，和GROUP-ID相同&lt;/p&gt;

&lt;h2&gt;EXT-X-DISCONTUNUITY&lt;/h2&gt;

&lt;p&gt;媒体信息发生变化，媒体信息包括文件格式，tracks的数量和类型，编码参数，编码顺序(encoding sequence)，时间戳顺序(timestamp sequence)&lt;/p&gt;

&lt;h2&gt;EXT-X-I-FRAMES-ONLY&lt;/h2&gt;

&lt;p&gt;表示分片只包含I帧，协议从版本号4开始包含此标签&lt;/p&gt;

&lt;h2&gt;EXT-X-MAP:&lt;attribute-list&gt;&lt;/h2&gt;

&lt;p&gt;标识如何获取分片的PAT/PMT，对该标签之后的分片有效
仅和EXT-X-I-FRAMES-ONLY一起出现，建议只用在没有PAT/PMT开头的分片
协议从版本号5开始使用该标签
URI引用字符串
BYTERANGE引用字符串&lt;/p&gt;

&lt;h2&gt;EXT-X-I-FRAME-STREAM-INF:&lt;attribute-list&gt;&lt;/h2&gt;

&lt;p&gt;表示I帧列表
URI
BANDWIDTH&lt;/p&gt;

&lt;h2&gt;EXT-X-VERSION:&lt;n&gt;&lt;/h2&gt;

&lt;p&gt;协议版本号&lt;/p&gt;

&lt;h1&gt;额外的注意：&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;media segment：分片&lt;/li&gt;
&lt;li&gt;编码 MPEG-2 Transport Stream/MPEG audio elementary stream/WebVTT（字幕）&lt;/li&gt;
&lt;li&gt;TS分片必须仅包含一个MPEG-2 Program。每一个TS分片都应当以PAT和PMT开头。视频分片必须包含一个I帧（完整GOP？）&lt;/li&gt;
&lt;li&gt;TS或者audio elementacontentry stream分片必须保证sequence number连续，时间戳连续，除非是第一个分片或者出现了EXT-X-DISCONTINUITY标签。&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Test From Gitblog</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2014/05/05/Test-From-Gitblog/index.html"/>
   <updated>2014-05-05T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2014/05/05/Test-From-Gitblog/Test-From-Gitblog</id>
   <content type="html">&lt;p&gt;Test from gitblog.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Node's XAuth Support</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/11/27/xauth_with_node/index.html"/>
   <updated>2013-11-27T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/11/27/xauth_with_node/xauth_with_node</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/ciaranj/node-oauth&quot;&gt;node-oauth&lt;/a&gt;模块提供了OAuth和XAuth支持，根据&lt;a href=&quot;http://stackoverflow.com/questions/7518795/instapaper-api-javascript-xauth/9645033#9645033&quot;&gt;stackoverflow&lt;/a&gt;提供的信息，使用如下接口即可:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;getOAuthRequestToken(extra_params, callback_function)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中extra_params:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;extra_params = {
    &amp;quot;x_auth_username&amp;quot;:&amp;quot;__username__&amp;quot;,
    &amp;quot;x_auth_password&amp;quot;:&amp;quot;__password__&amp;quot;,
    &amp;quot;x_auth_mode&amp;quot;:&amp;quot;client_auth&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;饭否的XAuth实测可用。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Rider's Resume</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/11/27/riders_resume/index.html"/>
   <updated>2013-11-27T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/11/27/riders_resume/riders_resume</id>
   <content type="html">&lt;h1&gt;SUMMARY OF QUALIFICATION&lt;/h1&gt;

&lt;p&gt;3 year&amp;#39;s working experience in C/C++ software development.&lt;/p&gt;

&lt;p&gt;Expertise in network analyzing, media transcoding, and media streaming.&lt;/p&gt;

&lt;p&gt;Team work spirit. High liability and attribution. Be able to work under great pressure.&lt;/p&gt;

&lt;p&gt;3年C/C++开发经验，包括网络协议分析（OSI 3层及以下），数据包信息挖掘，媒体处理（MP4、TS、FLV、H.264、AAC），流媒体（RTMP/HLS）&lt;/p&gt;

&lt;p&gt;对软件开发充满热情，关注技术潮流&lt;/p&gt;

&lt;p&gt;对代码有洁癖，有不断优化代码的强迫症&lt;/p&gt;

&lt;p&gt;平台/Platforms: ARM, MIPS, x86&lt;/p&gt;

&lt;p&gt;操作系统/Operating Systems: Linux(MIPS/ARM), Mac OS X, Android&lt;/p&gt;

&lt;p&gt;开发语言/Languages: C/C++, Python&lt;/p&gt;

&lt;p&gt;开发工具/Software &amp;amp; Tools:  Vim, GCC, GDB&lt;/p&gt;

&lt;h1&gt;PROFESSIONAL EXPERIENCE&lt;/h1&gt;

&lt;h2&gt;2012/07 - Present&lt;/h2&gt;

&lt;h3&gt;Hoge Software Co. Ltd.&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;职位/Title: &lt;/p&gt;

&lt;p&gt;Lead Developer of C/C++ Department&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;职责/Responsible: &lt;/p&gt;

&lt;p&gt;Lead of the C/C++ Department.&lt;/p&gt;

&lt;p&gt;Develop framework and all basic modules of transcoding service for our M2O platform.&lt;/p&gt;

&lt;p&gt;Develop live and VOD services based on nginx-rtmp-mod.&lt;/p&gt;

&lt;p&gt;公司目前主力产品为M2O新媒体服务平台，服务对象主要是致力于新媒体服务的各省市级电视台，在新媒体行业内产品占有率居前列。本人主要负责视频转码处理和流媒体相关的开发，处理的对象主要是MP4、TS、FLV封装的H.264和AAC数据以及HLS和RTMP流协议。&lt;/p&gt;

&lt;p&gt;完成了视频转码处理程序的主体框架（模块化分层结构）及主要功能模块的开发；&lt;/p&gt;

&lt;p&gt;完成了视频转码服务的视频入库转码，拆条，快编，多码流等功能开发；&lt;/p&gt;

&lt;p&gt;完成了针对RTMP和HLS协议，基于Nginx RTMP模块的二次开发。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;tags: &lt;/p&gt;

&lt;p&gt;nginx, ffmpeg, google-unittest, google-leveldb, boost&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;2011/05 - 2011/06&lt;/h2&gt;

&lt;h3&gt;iSoftstone Co. Ltd.&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;职位/Title: &lt;/p&gt;

&lt;p&gt;Embedded Developer of R&amp;amp;D Department&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;职责/Responsible:&lt;/p&gt;

&lt;p&gt;Embedded software development based with Atheros and Realtech boards, hardware driver development excluded.&lt;/p&gt;

&lt;p&gt;Network analysis based on packet capturing.&lt;/p&gt;

&lt;p&gt;Android JNI development, mainly 802.11 analysis related.&lt;/p&gt;

&lt;p&gt;嵌入式平台的802.11数据抓取和数据挖掘相关开发，通过传感器（嵌入式设备）抓取周围的无线数据包，分析其IP层及以下的头信息，简单过滤后发往服务端做进一步数据挖掘。&lt;/p&gt;

&lt;p&gt;完成JNI层接口设计与实现；&lt;/p&gt;

&lt;p&gt;实现用于JNI和Java层数据传递的基于内存映射的环状缓冲区；&lt;/p&gt;

&lt;p&gt;完成数据包解析，包括物理层，MAC层，IP层包头和内容解析；&lt;/p&gt;

&lt;p&gt;项目需求分析；&lt;/p&gt;

&lt;p&gt;主体框架设计与开发；&lt;/p&gt;

&lt;p&gt;协议分析相关功能的开发；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目标平台/Platforms：&lt;/p&gt;

&lt;p&gt;Atheros、Realtech、Android Tablet&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;EDUCATION&lt;/h1&gt;

&lt;h2&gt;Nanjing University of Post and Telecommunication&lt;/h2&gt;

&lt;p&gt;2006 - 2010&lt;/p&gt;

&lt;p&gt;B.E. degree in network engineering&lt;/p&gt;

&lt;h1&gt;TRAINING&lt;/h1&gt;

&lt;h2&gt;Cisco Certified Security Professional&lt;/h2&gt;

&lt;p&gt;2008/07 - 2011/07&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>尝试从Wordpress迁移到Github Pages</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/10/11/from-wordpress-to-github/index.html"/>
   <updated>2013-10-11T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/10/11/from-wordpress-to-github/from-wordpress-to-github</id>
   <content type="html">&lt;p&gt;我的另一个博客&lt;a href=&quot;http://sqbing.com&quot;&gt;sqbing.com&lt;/a&gt;使用Wordpress，目前挂在Appfog的免费主机上。当我们使用免费产品时，我们自己就变成了别人的产品。这个免费主机有很多问题，插件不时被删除，图片不时被删除，备份又麻烦。&lt;/p&gt;

&lt;p&gt;参考&lt;a href=&quot;http://jekyllrb.com/docs/migrations/&quot;&gt;Jekyll&lt;/a&gt;提供的博客迁移方法，主要是jekyll-import工具的安装，我使用的是Ubuntu 12.04，默认ruby版本是1.8，需要安装最新版本的ruby。如果已经安装了合适版本的ruby，直接运行第3步。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从&lt;a href=&quot;https://www.ruby-lang.org/zh_cn/&quot;&gt;ruby官网&lt;/a&gt;下载ruby 2.0.0源码包&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;解压源码包
进入源码目录，执行./configure
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用update-alternatives修改默认ruby&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo update-alternatives --install /usr/bin/ruby ruby /usr/local/bin/ruby
sudo update-alternatives --config ruby
根据提示选择/usr/local/bin/ruby
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装jekyll-import&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;gem install jekyll-import --pre
gem install hpricot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解析Wordpress导出文件&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ruby -rubygems -e &amp;#39;require &amp;quot;jekyll/jekyll-import/wordpressdotcom&amp;quot;;
    JekyllImport::WordpressDotCom.process({ :source =&amp;gt; &amp;quot;wordpress.xml&amp;quot; })&amp;#39;
这里的wordpress.xml是文件名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;导出结果不是很让人满意，排版一塌糊涂，不过总比一篇篇的复制要强，找时间再重排版吧。&lt;/p&gt;

&lt;p&gt;另外，如果嫌gem速度慢，试试换成taobao的源。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;gem sources --remove https://rubygems.org/
gem sources -a http://ruby.taobao.org/
gem sources -l
*** CURRENT SOURCES ***

http://ruby.taobao.org
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Write blog with prose.io</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/10/10/write-blog-with-prose/index.html"/>
   <updated>2013-10-10T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/10/10/write-blog-with-prose/write-blog-with-prose</id>
   <content type="html">&lt;p&gt;Try to write blog with &lt;a href=&quot;http://prose.io&quot;&gt;&lt;strong&gt;prose.io&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Prose.io会读取github项目，支持修改文件，只是似乎和jekyll配合的不好，创建出来的文件缺少一些基本的头部，无法正常生成post。&lt;/p&gt;

&lt;p&gt;恐怕只能当作是草稿箱来用了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用ffmpeg为视频打码</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/10/10/ffmpeg-mosaic/index.html"/>
   <updated>2013-10-10T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/10/10/ffmpeg-mosaic/ffmpeg-mosaic</id>
   <content type="html">&lt;p&gt;涉及的滤镜包括:crop，boxblur和overlay。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ffmpeg -i input.mp4 -vf &amp;quot;[in]split[blurin][originalin] [blurin]crop=60:30:in_w-70:10,boxblur=5:5[blurout];[originalin][blurout]overlay=x=main_w-70:y=10[out]&amp;quot; -y output.mp4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;“60:30”为马赛克面积

“in_w-70:10”为马赛克位置

boxblur的参数决定了马赛克的模糊程度
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;crop滤镜和overlay滤镜的位置相同效果最好。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Fix: librtmp not found in ffmpeg</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/09/30/fix-ffmpeg-librtmp-not-found/index.html"/>
   <updated>2013-09-30T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/09/30/fix-ffmpeg-librtmp-not-found/fix-ffmpeg-librtmp-not-found</id>
   <content type="html">&lt;p&gt;服务器的yum坏了，运维的同事说“无解”，好吧，好吧……&lt;/p&gt;

&lt;p&gt;手动编译ffmpeg，配置参数为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./configure --enable-libfaac --enable-libx264 --enable-nonfree --enable-gpl --enable-librtmp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就一直停在&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;“librtmp not found”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下载编译了librtmp，搞定了头文件和库的链接还是报这个错，检查config.log发现check&lt;em&gt;pkg&lt;/em&gt;config这个调用出错了，再看configure，这个调用貌似是检查librtmp这个包的安装情况，也许是手动安装没有更新包信息导致的。&lt;/p&gt;

&lt;p&gt;找到configure中对应librtmp检查的那行，可能长这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;enabled librtmp    &amp;amp;&amp;amp; require_pkg_config librtmp librtmp/rtmp.h RTMP_Socket
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注释该行，再配置一次，通过了。&lt;/p&gt;

&lt;p&gt;经过这样的修改，编译时可能会报错，librtmp中的一些函数未定义，可以修改config.mak，找到EXTRALIBS这个宏，在后面追加“-lrtmp”即可。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Fix: Nexus 7(2013) Wifi OTG Storage Issue</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/09/29/fix-nexus-7-2013-otg-storage/index.html"/>
   <updated>2013-09-29T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/09/29/fix-nexus-7-2013-otg-storage/fix-nexus-7-2013-otg-storage</id>
   <content type="html">&lt;p&gt;需要安装Nexus Photo Viewer(&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.homeysoft.nexususb.viewer&quot;&gt;Google Play&lt;/a&gt;)，依据软件开发者的博客(&lt;a href=&quot;http://nexususb.blogspot.com/&quot;&gt;blogspot&lt;/a&gt;)提供的解决方案即可解决。&lt;/p&gt;

&lt;p&gt;下面是软件开发者提供的解决步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hold the device in Portrait Mode（竖屏）&lt;/li&gt;
&lt;li&gt;Open Android Settings and make the following &lt;strong&gt;temporary&lt;/strong&gt; changes（以下步骤修改的配置，可在问题解决后恢复）&lt;/li&gt;
&lt;li&gt;Under Security -&amp;gt; Lock Screen.  Select None（取消密码、图案锁屏等）&lt;/li&gt;
&lt;li&gt;Under Accessibility -&amp;gt; Auto-rotate screen.  Make sure it is NOT checked（取消自动旋转屏幕）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(Nexus 7 2013 Only)&lt;/strong&gt; Under Language and input -&amp;gt; English (United States)（&lt;strong&gt;语言改为美式英文&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;Open NMI/NPV manually via the icon.（打开Nexus Photo Viewer）&lt;/li&gt;
&lt;li&gt;Connect the OTG and Flash/Pen Drive（连接OTS存储设备）&lt;/li&gt;
&lt;li&gt;Press and Hold Power until you see &amp;quot;Power Off&amp;quot;（关机）&lt;/li&gt;
&lt;li&gt;Tap OK to Power Off&lt;/li&gt;
&lt;li&gt;Power On（开机）&lt;/li&gt;
&lt;li&gt;Repeat steps 8-10 until you see this prompt or NMI opens automatically.  If you have repeated this more than 5 times see below.*（重复8～10，直到Nexus Photo Viewer开机自动打开，并且可以浏览OTG存储设备内容，软件开发者博客提供了效果图）&lt;/li&gt;
&lt;/ol&gt;

&lt;hr&gt;

&lt;p&gt;2013-10-10 更新&lt;/p&gt;

&lt;p&gt;按照上述方法虽然能够解决二代N7的OTG存储设备使用问题，但是会导致机器&lt;strong&gt;极其不稳定&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这种不稳定将直接导致机器&lt;strong&gt;重启&lt;/strong&gt;，并在重启之后恢复正常，当然OTG功能又不见了……&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Something About Nginx and HLS</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/09/26/something-about-nginx-and-hls/index.html"/>
   <updated>2013-09-26T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/09/26/something-about-nginx-and-hls/something-about-nginx-and-hls</id>
   <content type="html">&lt;p&gt;不涉及具体实现，只是总结一下近半个月来研究nginx和HLS以及综合两者时遇到的一些困难。&lt;/p&gt;

&lt;h2&gt;ngx&lt;em&gt;open&lt;/em&gt;cached_file()&lt;/h2&gt;

&lt;p&gt;完整原型如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ngx_int_t
ngx_open_cached_file(ngx_open_file_cache_t *cache, 
    ngx_str_t *name,
    ngx_open_file_info_t *of, 
    ngx_pool_t *pool)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的name参数比较有意思，在nginx中，ngx&lt;em&gt;str&lt;/em&gt;t比u_char*多了一个长度字段。小心！这个函数内部并没有考虑name的长度，而是粗暴的调用了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fd = ngx_open_file(name-&amp;gt;data, mode, create, access);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ngx&lt;em&gt;open&lt;/em&gt;file()是对open()的简单封装，如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#ifdef __CYGWIN__
    #define NGX_HAVE_CASELESS_FILESYSTEM  1
    #define ngx_open_file(name, mode, create, access)\
        open((const char *) name, mode|create|O_BINARY, access)
#else
    #define ngx_open_file(name, mode, create, access)\
        open((const char *) name, mode|create, access)
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，在调用这个函数打开文件时，除了要用ngx&lt;em&gt;str&lt;/em&gt;t封装文件路径，还要注意这个路径一定要用\0结尾。&lt;/p&gt;

&lt;h2&gt;tips&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;SPS和PPS何时发送？&lt;/p&gt;

&lt;p&gt;IDR(nalu_type=5)之前发送&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PMT和PAT如何构造？&lt;/p&gt;

&lt;p&gt;PMT和PAT为固定字段，每GOP发送一次即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;加入条带分割NAL头部对现有的H.264数据有何影响？&lt;/p&gt;

&lt;p&gt;目前看无影响，每一sample前发送条带分割NAL(nalu_type=9)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;码流和网络流形式的NAL在转换时需要注意哪些？&lt;/p&gt;

&lt;p&gt;一般情况下发送0x00 00 00 01，仅在sample的非首slice时发送0x00 00 01&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AAC头部是否需要修改？&lt;/p&gt;

&lt;p&gt;AAC需要使用ADST封装&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ADST包含哪些参数？从MP4文件的何box中读取参数？&lt;/p&gt;

&lt;p&gt;profile: (object_type - 1)&lt;/p&gt;

&lt;p&gt;sampling frequency: sample&lt;em&gt;rate&lt;/em&gt;index&lt;/p&gt;

&lt;p&gt;channel configuration: channels&lt;/p&gt;

&lt;p&gt;通过mp4a-&amp;gt;esds读取上述参数&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;音频数据如何汇总成一个PES包再发送，而不是每一个sample封装一个PES？&lt;/p&gt;

&lt;p&gt;音频打包到一个PES再发送，大小为2930&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成m3u8时如何分割？&lt;/p&gt;

&lt;p&gt;以GOP为分割&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;aac的duration为什么固定是1024？遇到非固定duration的aac应如何处理？&lt;/p&gt;

&lt;p&gt;aac规定每个frame包含1024个samples；忽略stts中的delta，固定输出1024&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MP4中的elst atom应如何处理？&lt;/p&gt;

&lt;p&gt;pts -= elst&lt;em&gt;start&lt;/em&gt;time&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>boost::property_tree threadsafe</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/07/27/boost-property_tree-threadsafe/index.html"/>
   <updated>2013-07-27T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/07/27/boost-property_tree-threadsafe/boost-property_tree-threadsafe</id>
   <content type="html">&lt;h2&gt;问题描述：&lt;/h2&gt;

&lt;p&gt;最近程序经常崩溃，GDB调试发现全部是read_json函数调用的问题。&lt;/p&gt;

&lt;h2&gt;问题原因：&lt;/h2&gt;

&lt;p&gt;boost::property_tree是boost提供的文本解析库，可用于解析或生成json，xml，ini等文件。&lt;/p&gt;

&lt;p&gt;property_tree依赖grammar库，grammar在多线程环境下使用（很）可能崩溃。&lt;/p&gt;

&lt;h2&gt;问题解决：&lt;/h2&gt;

&lt;p&gt;引用与property_tree头文件之前定义宏：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#define BOOST_SPIRIT_THREADSAFE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果非常显著，建议把宏的定义直接写入Makefile。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>nginx-rtmp-module summary</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/07/23/nginx-rtmp-module-summary/index.html"/>
   <updated>2013-07-23T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/07/23/nginx-rtmp-module-summary/nginx-rtmp-module-summary</id>
   <content type="html">&lt;h2&gt;项目主页:&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/arut/nginx-rtmp-module&quot;&gt;https://github.com/arut/nginx-rtmp-module&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;项目介绍：&lt;/h2&gt;

&lt;p&gt;nginx-rtmp-module是为nginx开发的一组模块，实现基于nginx的流媒体服务器，包括流发布，转发，录制等功能。具体参考项目主页及项目wiki。&lt;/p&gt;

&lt;p&gt;注意，该项目正在开发中，某些功能尚不稳定，代码结构也可能在将来发生较大的变化。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;h3&gt;配置解析&lt;/h3&gt;

&lt;p&gt;配置解析要从rtmp命令开始，这是一个顶级命令，和http、events等平级。通过阅读代码能看出来，该命令的解析参考了http的解析流程，具体代码位于nginx_rtmp.c中，如果以前对http命令解析过程有了解，相信这里也能很快理解。&lt;/p&gt;

&lt;p&gt;nginx-rtmp-module项目实现的是一组模块，这里为了描述方便，仅用短命名表示各模块，比如core模块，hls模块等，需要注意的是nginx_rtmp.c中声明的模块，这里称呼他为根模块。&lt;/p&gt;

&lt;p&gt;这是一份常见也很典型的rtmp模块配置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;rtmp {
    server {

        listen 1935; # 监听1935端口

        application live {
            live on; # 启用直播   

            hls on;  # 启用HLS
            hls_path /tmp/tv26; # HLS缓存路径

            recorder record_tv26{ # 启用录制
                record all; # 收录音视频
                record_path /tmp/rec; # 收录路径
            }   
        }   
    }   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体解析部分如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/* rtmp{}块解析函数，一切与rtmp有关的配置解析从这里开始 */
static char *
ngx_rtmp_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                        *rv;
    ngx_uint_t                   i, m, mi, s;
    ngx_conf_t                   pcf;
    ngx_array_t                  ports;
    ngx_rtmp_listen_t           *listen;
    ngx_rtmp_module_t           *module;
    ngx_rtmp_conf_ctx_t         *ctx;
    ngx_rtmp_core_srv_conf_t    *cscf, **cscfp;
    ngx_rtmp_core_main_conf_t   *cmcf;

    /* 
    typedef struct {
        void                  **main_conf;
        void                  **srv_conf;
        void                  **app_conf;
    } ngx_rtmp_conf_ctx_t;
     * 这个结构体再配置解析过程中见到非常多，server命令和application命令解析时也会创建一个这样的结构体，需要注意的时，这个结构体中main_conf是一次rtmp{}块解析过程中唯一的，其他命令解析到的配置将直接修改该main_conf，与另两个结构体不同。
     */
    ctx = ngx_pcalloc(cf-&amp;gt;pool, sizeof(ngx_rtmp_conf_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    *(ngx_rtmp_conf_ctx_t **) conf = ctx;

    /* count the number of the rtmp modules and set up their indices */
    /* 计算RTMP模块总数，并为模块编号 */

    ngx_rtmp_max_module = 0;
    for (m = 0; ngx_modules[m]; m++) {
        if (ngx_modules[m]-&amp;gt;type != NGX_RTMP_MODULE) {
            continue;
        }

        ngx_modules[m]-&amp;gt;ctx_index = ngx_rtmp_max_module++;
    }


    /* the rtmp main_conf context, it is the same in the all rtmp contexts */
    /* 再次强调，创建main_conf上下文变量，全局唯一 */
    ctx-&amp;gt;main_conf = ngx_pcalloc(cf-&amp;gt;pool,
                                 sizeof(void *) * ngx_rtmp_max_module);// 这里使用了max创建数组
    if (ctx-&amp;gt;main_conf == NULL) {
        return NGX_CONF_ERROR;
    }


    /*
     * the rtmp null srv_conf context, it is used to merge
     * the server{}s&amp;#39; srv_conf&amp;#39;s
     * 创建srv_conf上下文变量
     */

    ctx-&amp;gt;srv_conf = ngx_pcalloc(cf-&amp;gt;pool, sizeof(void *) * ngx_rtmp_max_module);
    if (ctx-&amp;gt;srv_conf == NULL) {
        return NGX_CONF_ERROR;
    }


    /*
     * the rtmp null app_conf context, it is used to merge
     * the server{}s&amp;#39; app_conf&amp;#39;s
     * 创建app_conf上下文变量
     */

    ctx-&amp;gt;app_conf = ngx_pcalloc(cf-&amp;gt;pool, sizeof(void *) * ngx_rtmp_max_module);
    if (ctx-&amp;gt;app_conf == NULL) {
        return NGX_CONF_ERROR;
    }


    /*
     * create the main_conf&amp;#39;s, the null srv_conf&amp;#39;s, and the null app_conf&amp;#39;s
     * of the all rtmp modules
     */
    /* 遍历所有的RTMP模块，保证所有模块对应的conf不为空 */

    for (m = 0; ngx_modules[m]; m++) {
        if (ngx_modules[m]-&amp;gt;type != NGX_RTMP_MODULE) {
            continue;
        }

        module = ngx_modules[m]-&amp;gt;ctx;
        mi = ngx_modules[m]-&amp;gt;ctx_index;

        // 分别调用各模块的:
        // create_main_conf，
        // create_srv_conf
        // create_app_conf
        if (module-&amp;gt;create_main_conf) {
            ctx-&amp;gt;main_conf[mi] = module-&amp;gt;create_main_conf(cf);
            if (ctx-&amp;gt;main_conf[mi] == NULL) {
                return NGX_CONF_ERROR;
            }
        }

        if (module-&amp;gt;create_srv_conf) {
            ctx-&amp;gt;srv_conf[mi] = module-&amp;gt;create_srv_conf(cf);
            if (ctx-&amp;gt;srv_conf[mi] == NULL) {
                return NGX_CONF_ERROR;
            }
        }

        if (module-&amp;gt;create_app_conf) {
            ctx-&amp;gt;app_conf[mi] = module-&amp;gt;create_app_conf(cf);
            if (ctx-&amp;gt;app_conf[mi] == NULL) {
                return NGX_CONF_ERROR;
            }
        }
    }

    // 备份ngx_conf_t，在rtmp{}块解析完成后恢复
    pcf = *cf;
    cf-&amp;gt;ctx = ctx;

    // 调用各RTMP模块的preconfiguration
    for (m = 0; ngx_modules[m]; m++) {
        if (ngx_modules[m]-&amp;gt;type != NGX_RTMP_MODULE) {
            continue;
        }

        module = ngx_modules[m]-&amp;gt;ctx;

        if (module-&amp;gt;preconfiguration) {
            if (module-&amp;gt;preconfiguration(cf) != NGX_OK) {
                return NGX_CONF_ERROR;
            }
        }
    }

    /* parse inside the rtmp{} block */
    /* 进入rtmp{}块中继续解析配置，仅解析cmd_type=NGX_RTMP_MAIN_CONF的指令，比如server{}块。
     * 这里要回顾一下ngx_rtmp_conf_ctx_t结构体，因为接下来的解析过程，实际上就是填充这三个结构体的过程。
     * 结构体包括三个数组，分别是main_conf，srv_conf和app_conf，
     * main_conf实际上一个ngx_rtmp_*_main_conf_t的数组，其中最重要的可能就是core模块的结构，

        typedef struct {
            ngx_array_t             servers;    // ngx_rtmp_core_srv_conf_t 
            ngx_array_t             listen;     // ngx_rtmp_listen_t 

            ngx_array_t             events[NGX_RTMP_MAX_EVENT];

            ngx_hash_t              amf_hash;
            ngx_array_t             amf_arrays;
            ngx_array_t             amf;
        } ngx_rtmp_core_main_conf_t;

     * 解析到的server{}块配置会保存到core模块的servers数组中
     * 同样的，srv_conf是一个ngx_rtmp_*_srv_main_t的数组，其中最重要的是core模块中针对server配置的结构体，

        typedef struct ngx_rtmp_core_srv_conf_s {
            ngx_array_t             applications; // ngx_rtmp_core_app_conf_t
            ...         
            ngx_rtmp_conf_ctx_t    *ctx;
        } ngx_rtmp_core_srv_conf_t;

     * 解析到的application{}块会保存到相应server块的applications数组中 */

    cf-&amp;gt;module_type = NGX_RTMP_MODULE;
    cf-&amp;gt;cmd_type = NGX_RTMP_MAIN_CONF;
    rv = ngx_conf_parse(cf, NULL);

    if (rv != NGX_CONF_OK) {
        *cf = pcf;
        return rv;
    }


    /* init rtmp{} main_conf&amp;#39;s, merge the server{}s&amp;#39; srv_conf&amp;#39;s */

    // cmcf =&amp;gt; core module conf
    cmcf = ctx-&amp;gt;main_conf[ngx_rtmp_core_module.ctx_index];
    cscfp = cmcf-&amp;gt;servers.elts;

    /* 合并各RTMP模块配置 
     * 这里的合并有一点需要注意的是，core模块的配置必须首先被合并，这个通过写config文件来实现，只有这样，才能保证上一轮解析中的配置全部合并到ctx的三大数组中。
     * 跟模块不在这一轮合并中出现，因为根模块的类型不是NGX_RTMP_MODULE而是NGX_CORE_MODULE
     */
    for (m = 0; ngx_modules[m]; m++) {
        if (ngx_modules[m]-&amp;gt;type != NGX_RTMP_MODULE) {
            continue;
        }

        module = ngx_modules[m]-&amp;gt;ctx;
        // mi =&amp;gt; module_index
        mi = ngx_modules[m]-&amp;gt;ctx_index;

        /* init rtmp{} main_conf&amp;#39;s */
        /* 调用各main模块的init_main_conf */

        cf-&amp;gt;ctx = ctx;

        // 调用各RTMP main模块的init_main_conf，因为全局统一使用一个main_conf数组，因此这里不需要“merge”
        if (module-&amp;gt;init_main_conf) {
            rv = module-&amp;gt;init_main_conf(cf, ctx-&amp;gt;main_conf[mi]);
            if (rv != NGX_CONF_OK) {
                *cf = pcf;
                return rv;
            }
        }

        /* 分别调用各模块merge_srv_conf和merge_app_conf，如果需要的话
         * ngx_parse_conf产生的servers用在这里*/
        for (s = 0; s &amp;lt; cmcf-&amp;gt;servers.nelts; s++) {

            /* merge the server{}s&amp;#39; srv_conf&amp;#39;s */

            cf-&amp;gt;ctx = cscfp[s]-&amp;gt;ctx;

            if (module-&amp;gt;merge_srv_conf) {
                rv = module-&amp;gt;merge_srv_conf(cf,
                                            ctx-&amp;gt;srv_conf[mi],
                                            cscfp[s]-&amp;gt;ctx-&amp;gt;srv_conf[mi]);
                if (rv != NGX_CONF_OK) {
                    *cf = pcf;
                    return rv;
                }
            }

            if (module-&amp;gt;merge_app_conf) {

                /* merge the server{}&amp;#39;s app_conf */

                /*ctx-&amp;gt;app_conf = cscfp[s]-&amp;gt;ctx-&amp;gt;loc_conf;*/

                rv = module-&amp;gt;merge_app_conf(cf, 
                                            ctx-&amp;gt;app_conf[mi],
                                            cscfp[s]-&amp;gt;ctx-&amp;gt;app_conf[mi]);
                if (rv != NGX_CONF_OK) {
                    *cf = pcf;
                    return rv;
                }

                /* merge the applications{}&amp;#39; app_conf&amp;#39;s 
                 * 解析applications数组
                 * cscfp = core server conf pointer*/

                cscf = cscfp[s]-&amp;gt;ctx-&amp;gt;srv_conf[ngx_rtmp_core_module.ctx_index];

                /* 递归的解析applications数组，因为application有可能有子块，比如recorder{}块 */
                rv = ngx_rtmp_merge_applications(cf, &amp;amp;cscf-&amp;gt;applications,
                                            cscfp[s]-&amp;gt;ctx-&amp;gt;app_conf,
                                            module, mi);
                if (rv != NGX_CONF_OK) {
                    *cf = pcf;
                    return rv;
                }
            }

        }
    }


    /* 初始化events数组和amf数组 */
    if (ngx_rtmp_init_events(cf, cmcf) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    /* 调用各RTMP模块的postconfiguration */
    for (m = 0; ngx_modules[m]; m++) {
        if (ngx_modules[m]-&amp;gt;type != NGX_RTMP_MODULE) {
            continue;
        }

        module = ngx_modules[m]-&amp;gt;ctx;

        if (module-&amp;gt;postconfiguration) {
            if (module-&amp;gt;postconfiguration(cf) != NGX_OK) {
                return NGX_CONF_ERROR;
            }
        }
    }

    // 恢复conf
    *cf = pcf;

    /* 初始化RTMP各事件响应函数，AMF各事件响应函数及hash表 */
    if (ngx_rtmp_init_event_handlers(cf, cmcf) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    /* 初始化端口数组 */
    if (ngx_array_init(&amp;amp;ports, cf-&amp;gt;temp_pool, 4, sizeof(ngx_rtmp_conf_port_t))
        != NGX_OK)
    {
        return NGX_CONF_ERROR;
    }

    listen = cmcf-&amp;gt;listen.elts;

    // 添加listen地址到port数组
    for (i = 0; i &amp;lt; cmcf-&amp;gt;listen.nelts; i++) {
        if (ngx_rtmp_add_ports(cf, &amp;amp;ports, &amp;amp;listen[i]) != NGX_OK) {
            return NGX_CONF_ERROR;
        }
    }

    /* 将port中的监听地址添加到nginx的监听列表 */
    return ngx_rtmp_optimize_servers(cf, &amp;amp;ports);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仅看根模块的rtmp{}块解析还无法全面了解配置解析过程，下面贴出另一个重要模块，core模块，的server{}块和applicaiton{}块解析过程，他们在ngx&lt;em&gt;rtmp&lt;/em&gt;core_module.c中。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;static char *
ngx_rtmp_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf/*srv_conf*/)
{
    char                       *rv;
    void                       *mconf;
    ngx_uint_t                  m;
    ngx_conf_t                  pcf;
    ngx_rtmp_module_t          *module;
    ngx_rtmp_conf_ctx_t        *ctx, *rtmp_ctx;
    ngx_rtmp_core_srv_conf_t   *cscf, **cscfp;
    ngx_rtmp_core_main_conf_t  *cmcf;

    // 每解析到一个server就创建一个新的conf_ctx
    ctx = ngx_pcalloc(cf-&amp;gt;pool, sizeof(ngx_rtmp_conf_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    rtmp_ctx = cf-&amp;gt;ctx;
    // 使用rtmp级conf_ctx的main_conf覆盖新建的本server的main_conf，以保证唯一的main_conf数组
    ctx-&amp;gt;main_conf = rtmp_ctx-&amp;gt;main_conf;

    /* the server{}&amp;#39;s srv_conf */
    /* 为srv_conf和app_conf申请内存 */

    ctx-&amp;gt;srv_conf = ngx_pcalloc(cf-&amp;gt;pool, sizeof(void *) * ngx_rtmp_max_module);
    if (ctx-&amp;gt;srv_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    ctx-&amp;gt;app_conf = ngx_pcalloc(cf-&amp;gt;pool, sizeof(void *) * ngx_rtmp_max_module);
    if (ctx-&amp;gt;app_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    // 初始化srv_conf和app_conf
    // 调用各RTMP模块的create_srv_conf和create_app_conf
    for (m = 0; ngx_modules[m]; m++) {
        if (ngx_modules[m]-&amp;gt;type != NGX_RTMP_MODULE) {
            continue;
        }

        module = ngx_modules[m]-&amp;gt;ctx;

        if (module-&amp;gt;create_srv_conf) {
            mconf = module-&amp;gt;create_srv_conf(cf);
            if (mconf == NULL) {
                return NGX_CONF_ERROR;
            }

            ctx-&amp;gt;srv_conf[ngx_modules[m]-&amp;gt;ctx_index] = mconf;
        }

        if (module-&amp;gt;create_app_conf) {
            mconf = module-&amp;gt;create_app_conf(cf);
            if (mconf == NULL) {
                return NGX_CONF_ERROR;
            }

            ctx-&amp;gt;app_conf[ngx_modules[m]-&amp;gt;ctx_index] = mconf;
        }
    }

    /* the server configuration context */
    /* 将新申请的conf_ctx放入main_conf的servers数组
     * servers数组是ngx_rtmp_core_srv_conf_t的集合*/
    cscf = ctx-&amp;gt;srv_conf[ngx_rtmp_core_module.ctx_index];
    cscf-&amp;gt;ctx = ctx; // 自我链接，用于下一步放入servers
    /* 至此，解析server{}块配置的过程实际上就结束了，需要合并配置时，main_conf[core_module]-&amp;gt;servers[...]-&amp;gt;ctx-&amp;gt;srv_conf[core_module]即可找到每一server{}块的配置，
     * application{}块的解析也同样如此，不同的时application块中也有applications[]数组，因此需要递归的合并子模块的配置
     */

    cmcf = ctx-&amp;gt;main_conf[ngx_rtmp_core_module.ctx_index];

    cscfp = ngx_array_push(&amp;amp;cmcf-&amp;gt;servers);/* 由于main_conf是直接覆盖而非另外生成，因此这里放入的servers数组就是输入的main_conf */
    if (cscfp == NULL) {
        return NGX_CONF_ERROR;
    }

    *cscfp = cscf;

    /* parse inside server{} 
     * 进入server{}块内部继续解析，这里仅解析NGX_RTMP_SRV_CONF类型的命令，包括listen和application等命令。
    */

    pcf = *cf;
    cf-&amp;gt;ctx = ctx;
    cf-&amp;gt;cmd_type = NGX_RTMP_SRV_CONF;

    rv = ngx_conf_parse(cf, NULL);

    *cf = pcf;

    return rv;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;TODO 接受PUSH RTMP流：&lt;/h3&gt;

&lt;h2&gt;参考：&lt;/h2&gt;

&lt;p&gt;Nginx模块开发入门 &lt;a href=&quot;http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html&quot;&gt;http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Emiller&amp;#39;s Guide To Nginx Module Development &lt;a href=&quot;http://www.evanmiller.org/nginx-modules-guide.html&quot;&gt;http://www.evanmiller.org/nginx-modules-guide.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Delpoy Bottle To GAE</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/07/20/delpoy-bottle-to-gae/index.html"/>
   <updated>2013-07-20T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/07/20/delpoy-bottle-to-gae/delpoy-bottle-to-gae</id>
   <content type="html">&lt;ol&gt;
&lt;li&gt;创建framework目录，并创建framework/&lt;strong&gt;init&lt;/strong&gt;.py文件，拷贝bottle.py到framework/中&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改app.yaml如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application: YOUR_APP_NAME
version: 1
runtime: python27
api_version: 1
threadsafe: yes

handlers:
    - url: /favicon\.ico
    static_files: favicon.ico
    upload: favicon\.ico

    - url: /.*
    script: main.app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改main.py如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
from framework import bottle
from framework.bottle import *

app = Bottle()
@app.get(&amp;#39;/&amp;#39;)
def DisplayForm():
    return &amp;quot;Hello World&amp;quot;

bottle.run(app=app, server=&amp;#39;gae&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，也可以参考&lt;a href=&quot;http://petergao.com/blog/using-bottle-with-python2-7-on-google-app-engine/&quot;&gt;这里&lt;/a&gt;的介绍。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>std::string::find和std::string::npos的使用备忘</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/04/12/std-string-find/index.html"/>
   <updated>2013-04-12T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/04/12/std-string-find/std::string::find</id>
   <content type="html">&lt;p&gt;项目中需要手动解析路径，我的开发机是32位系统，运行无问题，但是部署到64位的生产环境时，解析出现了莫名其妙的错误。
翻阅basic_string.h后发现了问题的原因，错误的将std::string:find的结果赋值给unsigned int。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;unsigned int begin; // 注意变量类型！
std::string test_str = &amp;quot;helloworld&amp;quot;;
if(std::string::npos != (begin = test_str.find(&amp;quot;/&amp;quot;))) // 赋值时出现了问题
{…}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改成如下的形式，问题解决。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;size_t begin; // 注意变量类型！
std::string test_str = &amp;quot;helloworld&amp;quot;;
if(std::string::npos != (begin = test_str.find(&amp;quot;/&amp;quot;))) // 问题解决
{…}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根本原因是basic&lt;em&gt;string.h将npos定义为size&lt;/em&gt;type的-1。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>一些.deps文件未更新导致的问题</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/04/03/deps/index.html"/>
   <updated>2013-04-03T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/04/03/deps/deps</id>
   <content type="html">&lt;p&gt;项目中有一个c文件，需要导入到c++项目中，并改为cpp文件。&lt;/p&gt;

&lt;p&gt;改了Makefile.am中**_SOURCES，用aclocal那一套重新构建了项目，但是编译的时候，make仍然去找原来的c文件，而不是已经改名的cpp文件。&lt;/p&gt;

&lt;p&gt;反复确认后发现，项目目录下的.deps目录下相应的.Po文件中的依赖关系没有跟随**_SOURCES更新，删除.deps文件夹，重新make，问题解决。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>不靠谱的backtrace</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/04/01/unreliable-backtrace/index.html"/>
   <updated>2013-04-01T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/04/01/unreliable-backtrace/unreliable-backtrace</id>
   <content type="html">&lt;h1&gt;起因&lt;/h1&gt;

&lt;p&gt;今天遇到一个问题，程序收到abort信号后退出，打开core文件后很快定位到目标代码，但是很奇怪的是目标代码似乎没有问题，反而是目标代码附近的代码看起来比较可疑。
增加日志后调试发现确实如此，backtrace报告的代码不是真正出问题的代码。&lt;/p&gt;

&lt;h1&gt;重现&lt;/h1&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#include &amp;quot;base.h&amp;quot;
#include &amp;quot;stdio.h&amp;quot;
boost::shared_ptr&amp;lt;std::string&amp;gt; err_str;
boost::shared_ptr&amp;lt;std::string&amp;gt; normal_str2;
int main(int argc, char **argv)
{
    err_str.reset();
    normal_str2 = boost::shared_ptr&amp;lt;std::string&amp;gt;(new std::string);
    *normal_str2 = &amp;quot;test&amp;quot;;
    printf(&amp;quot;before\n&amp;quot;);
    std::string l_test_str = *(err_str); // !!!
    printf(&amp;quot;after\n&amp;quot;);
    printf(&amp;quot;%c\n&amp;quot;, normal_str2-&amp;gt;at(0));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码的错误很明显，使用＊获取一个空指针的值，会导致BOOST_ASSERT失败，程序会因abort信号而退出。在我的机器上，gdb告诉我，是reset的那行代码出了问题，真让人摸不着头脑。当然before还是会打印出来的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#include &amp;quot;base.h&amp;quot;
#include &amp;quot;stdio.h&amp;quot;
boost::shared_ptr&amp;lt;std::string&amp;gt; err_str;
boost::shared_ptr&amp;lt;std::string&amp;gt; normal_str2;
int main(int argc, char **argv)
{
    err_str.reset();
    normal_str2 = boost::shared_ptr&amp;lt;std::string&amp;gt;(new std::string);
    *normal_str2 = &amp;quot;test&amp;quot;;
    printf(&amp;quot;before\n&amp;quot;);
    assert(err_str.get()); // !!!
    printf(&amp;quot;after\n&amp;quot;);
    printf(&amp;quot;%c\n&amp;quot;, normal_str2-&amp;gt;at(0));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码会在错误行abort，并且backtrace给出的行号是正确的。&lt;/p&gt;

&lt;h1&gt;结论&lt;/h1&gt;

&lt;p&gt;相信日志吧！backtrace仅供参考。
本人能力有限，目前只能怀疑是＊操作破坏了栈，导致backtrace报告了错误的代码位置。有心的朋友可以用objdump看看汇编代码，若找到真正原因，希望也能和我分享。谢谢！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>new post</title>
   <link href="http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/03/26/new-post/index.html"/>
   <updated>2013-03-26T00:00:00+08:00</updated>
   <id>http://127.0.0.1:43110/1NjDafJr3RR2ny3rJUoa76JjVmWidVaJkq/2013/03/26/new-post/new-post</id>
   <content type="html">&lt;p&gt;My first post on Jekyll blog.&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
