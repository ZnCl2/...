{"next_paste_id":1,"next_comment_id":0,"paste":[{"paste_id":0,"description":"Whitepaper do Bitcoin em português","body":"Bitcoin: Um sistema de dinheiro eletrônico ponto-a-ponto\n\nSatoshi Nakamoto\nsatoshin@gmx.com\nwww.bitcoin.org\nTradução: Lucas Bassotto\n\nlucas.bassotto@foxbit.com.br\n\nAbstract.   Uma   versão   de   dinheiro   eletrônico  puramente  ponto-a-ponto \n permitiria  que\npagamentos online fossem enviados diretamente de uma pessoa para outra sem a \nnecessidade\nde  passar  por  uma  instituição  financeira,  como  bancos,  por  exemplo.  \nAssinaturas  digitais\noferecem   uma   parte   da   solução,   mas   os   principais   benefícios   \nsão   perdidos   se   um\nintermediário  confiável  ainda  é  necessário para prevenir o gasto duplo. Nós \npropomos uma\nsolução ao problema do gasto duplo utilizando uma rede ponto-a-ponto. A rede \nregistra a data\ne hora das transações através de um sistema de carimbo de tempo, \ntransformando-as em uma\ncadeia  contínua  de  prova  de  trabalho  baseada  em  um  hash, formando um \nregistro que não\npode ser modificado sem que toda a prova de trabalho seja refeita. A cadeia \nmais longa não\nserve  apenas  como  uma  prova  da  sequência  dos  eventos testemunhados, ela \nserve também\ncomo  uma  prova  de  que  ela  veio  do  grupo  com  maior  poder  \ncomputacional.  Enquanto  a\nmaioria do poder computacional é controlada por nós de rede que não estão \ncooperando para\natacar a rede, eles vão gerar a maior cadeia e ultrapassar os atacantes. A \nprópria rede requer\numa mínima estrutura. As mensagens são transmitidas com o melhor esforço base \ne, os nós de\nrede  podem  sair  e  se  juntar  a  rede  quando  quiserem,  aceitando  a  \ncadeia  com  a  prova  de\ntrabalho mais longa como uma prova do que aconteceu enquanto eles estiveram \nfora da rede.\n\nIntrodução\n\nO  comércio  na  internet  passou  a  se  tornar  quase  que  exclusivamente  \ndependente  de  instituições\nfinanceiras se propondo como terceiros confiáveis para processar pagamentos \neletrônicos. Enquanto o\nsistema funciona bem o suficiente para a maioria das transações, ele ainda \nsofre de fraquezas inerentes\nem  modelos  baseados  na  confiança  em  terceiros  ou  intermediários.  \nTransações  completamente\nirreversíveis  não  são  realmente  possíveis,  porque  as  instituições  \nfinanceiras  não  podem  evitar\nmediação  de  disputas  judiciais.  O  custo  das mediações aumenta os custos \nde transação, limitando o\ntamanho  mínimo  que  uma  transação  deve  possuir  e  acabando  com  a  \npossibilidade  de  pequenas\ntransações   casuais,   além  disso,  há  um  custo  mais  amplo  na  perda  da \n possibilidade  de  fazer\npagamentos irreversíveis para serviços irreversíveis. Com a possibilidade de \npagamentos reversíveis, a\nnecessidade   de   confiança   aumenta.  Os  comerciantes  precisam  estar  \natentos  aos  seus  clientes,\nincomodando  eles  para  darem  mais  informações  do  que  eles  precisam  \noferecer  normalmente.  Uma\ncerta porcentagem de fraude é aceita como inevitável. Essas incertezas de \ncustos e pagamentos podem\nser  evitados  com  uma  pessoa  usando  uma  moeda  física,  entretanto,  não  \nexiste  nenhum  mecanismo\npara fazer pagamentos através de um canal de comunicações sem um terceiro.\n\nO   que   se   torna   necessário   é   um   sistema   de   pagamentos   \neletrônicos   baseado   em   provas\ncriptográficas  ao  invés  de  confiança,  permitindo  que  duas  partes  \ndispostas  a  negociar  diretamente\nentre   si   possam   o   fazer   sem   a   necessidade   de   um   terceiro   \nconfiável.   Transações   que   são\ncomputacionalmente impraticáveis de serem revertidas protegem os vendedores de \ncaírem em alguma\nfraude. Além disso, mecanismos de rotina de depósitos poderiam ser facilmente \nimplementados para\nproteger  os  compradores.  Neste  artigo  nós  propomos  uma  solução  para  o \n problema  do gasto duplo\n\n\nusando  um  servidor  ponta-a-ponta  de  carimbos  de  tempo  para  gerar  uma  \nprova  computacional  da\nordem  cronológica  das  transações.  O  sistema  é  seguro  enquanto  nós  de  \nrede  honestos  controlam\ncoletivamente  mais  poder  computacional  do  que  qualquer  outro  grupo  de  \nnós  de  rede  atacantes\ncooperando entre si.\n\nTransações\n\nNós  definimos  uma  moeda  eletrônica  como  uma  cadeia  de  assinaturas  \ndigitais.  Cada  proprietário\ntransfere a moeda para a próxima pessoa, assinando digitalmente um hash da \ntransação anterior e uma\nchave pública do próximo dono e adicionando a estes, a assinatura de sua chave \nprivada que libera as\nmoedas  para  a  pessoa  que  vai  recebê-las.  A  pessoa  que  recebeu  a  \ntransação  pode  verificar  as\nassinaturas para checar a cadeia de propriedade.\n\nO problema, claro, é que quem recebe a moeda não pode verificar se um dos donos \nnão gastou a\nmesma moeda duas vezes. Uma solução comum é introduzir uma autoridade central, \nou uma “Casa da\nMoeda”  que  verifica  se  houve  gasto  duplo  em  cada  transação.  Depois  \nde  cada  transação,  a  moeda\ndeve retornar à casa da moeda, que vai emitir novas moedas, e somente moedas \nemitidas diretamente\npela Casa da Moeda são confiáveis de não terem sido gastas duas vezes. O \nproblema dessa solução é\nque  o  destino  de  todo  sistema  monetário  dependeria  de  uma  instituição \n que  estaria  por  trás  da\ncunhagem das moedas, com cada transação tendo que passar por ela, como se fosse \num banco.\n\nNós  precisamos  de  um  modo  no  qual  quem  recebeu  a  moeda  saiba  que  \nos  donos  anteriores  da\nmoeda não assinou nenhuma outra transação prévia. Para nossos propósitos, a \ntransação mais antiga é\na  que conta, então não nos importamos com tentativas mais recentes de \ngastos-duplo. O único modo\nde confirmar a ausência de uma transação é estar atento a todas as transações \nque ocorrem. No modelo\nbaseado em “Casas da moeda”, elas estavam atentas de todas as transações e \ndecidiram qual delas foi\nfeita primeiro. Para que isso seja feito sem um intermediário confiável, todas \nas transações precisam\nser anunciadas publicamente [1], e nós precisamos de um sistema para que os \nparticipantes concordem\nem  uma  única  ordem  cronológica  na qual todos eles receberam. Quem recebe \nas moedas precisa de\n\n\numa  prova  para  comprovar  que  naquele  tempo,  todos  os  nós  de  rede  \nconcordaram  que  aquela\ntransação foi recebida primeiro.\n\nServidor de Carimbos de tempo\n\nA solução que propomos começa com um servidor de carimbo de tempo. Um servidor \nde carimbos de\ntempo funciona pegando a função hash de um bloco de itens que serão carimbados \ncom a data e a hora\ne  publicando  largamente  a  função  hash,  como  se  fosse  um  jornal  ou  \num  post  na  Usenet  [2-5].  O\nCarimbo de tempo inclui o carimbo de tempo anterior em sua função hash, \nformando uma espécie de\ncadeia ou corrente, com cada carimbo de tempo adicional reforçando os \nanteriores.\n\nProva de trabalho\n\nPara implementar um servidor de carimbos de tempo bem distribuído em uma base \nponto-a-ponto, nós\nvamos precisar usar um sistema de prova-de-trabalho similar ao Hashcash de Adam \nBack [6], ao invés\ndo  jornal  ou  posts  de  Usenet.  O  sistema  de  prova-de-trabalho  envolve  \nescanear  o  valor  que  foi\nadicionado à função hash, como em um sistema de criptografia SHA-256, a função \nhash começa com\num número de zero bits. O trabalho médio requerido é exponencial no número de \nzero bits requeridos\ne pode ser verificado executando um único hash.\n\nPara  a  nossa  rede  de  carimbo  de  tempos,  nós  implementamos  uma \nprova-de-trabalho através da\nincrementação  de  um  nonce no bloco até que o valor seja encontrado e dê ao \nhash do bloco os zero\nbits requeridos. Como o esforço computacional foi gasto para satisfazer a \nprova-de-trabalho, o bloco\nnão  pode  ser  mudado  sem  que  todo  esse  trabalho  seja  refeito.  \nConforme  os  últimos  blocos  são\nencadeados depois do primeiro, o trabalho para mudar o bloco incluiria refazer \ntodo o trabalho gasto\nnos blocos depois dele.\n\nA  prova-de-trabalho  também  soluciona  o  problema  de  determinar  a  \nrepresentação  com  uma\nmaioria  tomando  as  decisões.  Se  a  maioria  fosse  baseada  em  \num-ip-um-voto,  ela  poderia  ser\nfacilmente   subvertida   por   qualquer   um   que   pudesse   alocar   \ngrandes   quantidades   de   IPs.\n\n\nProva-de-trabalho  é  essencialmente  um-Computador-um-voto.  A  decisão  \ntomada  pela  maioria  é\nrepresentada  pela  maior  cadeia  de  blocos,  a  qual  contém  a  \nprova-de-trabalho  com  maior  esforço\ninvestido.  Se  a  maioria  do  poder  computacional  é  controlada  por  \nnós-de-rede  honestos,  a  cadeia\nhonesta irá crescer mais rapidamente e ultrapassar qualquer cadeia de blocos \ncompetidora.\n\nPara modificar um bloco anterior da rede, um atacante precisaria refazer toda a \nprova-de-trabalho\ndo  bloco  atual  e  todos  os  blocos  depois  dele  e,  então  recuperar o \natraso e ultrapassar o trabalho de\ntodos  os  nós-de-rede  honestos.  Mostraremos  mais  adiante  que  a \nprobabilidade de um atacante mais\nlento  ultrapassar  os  nós  honestos  diminui  exponencialmente  enquanto  \nblocos  subsequentes  são\nadicionados. Para compensar o aumento da velocidade dos hardwares e a variação \ndo interesse em se\nrodar         nós  com  o  passar  do tempo, a dificuldade da prova-de-trabalho \né determinada por uma média\nmóvel  focando  o  número  médio  de  blocos  por  hora.  Se  eles  estão  \nsendo  gerados  muito  rápido,  a\ndificuldade de gerar a prova-de-trabalho aumenta.\n\nRede\n\nOs passos para rodar a rede são conforme a seguir:\n\n1.    Novas transações são transmitidas para todos os nós;\n\n2.    Cada nó coleta novas transações para dentro de um bloco;\n\n3.    Cada nó trabalha para encontrar uma prova de trabalho difícil para seu \nbloco;\n\n4.    Quando um nó encontra uma prova-de-trabalho, ele transmite o bloco para \ntodos os nós;\n\n5.    Os nós aceitam o bloco somente se todas as transações contidas nele são \nválidas e não foram\ngastas anteriormente;\n\n6.    Nós de rede expressam a sua aceitação do bloco trabalhando na criação do \npróximo bloco na\ncadeia, usando o hash do bloco anterior que foi aceito como o hash anterior.\n\nNós de rede sempre consideram a maior cadeia como a correta e sempre \ncontinuarão trabalhando\npara estendê-la. Se dois nós de rede transmitem diferentes versões do próximo \nbloco simultaneamente,\nalguns nós de rede vão receber uma ou outra versão primeiro. Nesse caso, eles \ntrabalham em cima do\nprimeiro bloco que eles receberam, mas salvam o outro ramo no caso de ele se \ntornar maior do que o\nque  está  sendo  trabalhado.  O  consenso  será  alcançado  quando  a  próxima \n prova-de-trabalho  é\nencontrada e um dos ramos de blocos se torna maior, os nós de rede que estavam \ntrabalhando no ramo\nque   ficou menor, irão mudar para o ramo que se tornou maior.\n\nUma  nova  transação  transmitida  não  precisa,  necessariamente,  alcançar  \ntodos  os  nós  da  rede.\nDesde que ela alcance muitos nós de rede, elas serão incluídas em um bloco mais \ntarde. Transmissões\nde blocos também são tolerantes com mensagens descartadas. Se um nó de rede não \nrecebe um bloco,\nele irá solicitá-lo quando ele receber o próximo bloco e perceber que um bloco \nestá faltando.\n\nIncentivo\n\nPor convenção, a primeira transação em um bloco é uma transação especial, ela \ncria novas moedas\nque  são  possuídas  como  uma  forma  de  recompensa  pelo  criador  daquele  \nbloco.  Isso  adiciona  um\nincentivo  para  os  nós  de  rede  darem  suporte  e  aderir  à  rede,  além  \ndisso,  provê  uma  maneira  de\ndistribuir  inicialmente  as  moedas  para  a  circulação,  sem  que  haja  uma \n autoridade  central  para\nemiti-las.   Uma   adição   estável  de  uma  quantidade  constante  de  novas  \nmoedas  é  análoga  aos\nmineradores  de  ouro  gastando  seus  recursos  para  colocar  mais  ouro em \ncirculação. Em nosso caso,\napenas poder computacional, tempo e eletricidade são gastos.\n\n\nO incentivo também pode ser fundamentado através de taxas de transação. Se o \nvalor de saída de\numa transação é maior que o valor de entrada, a diferença desses valores é a \ntaxa de transação que é\nadicionada  como  um  valor  de  incentivo  do  bloco  contendo  a  transação.  \nDesde  que  o  número\npré-determinado  de  moedas  tenha  entrado  em  circulação,  o  incentivo  \npode  ser  dado  inteiramente\natravés           de taxas de transações, mantendo o sistema completamente \nlivre de inflação.\n\nO  incentivo  irá  ajudar  a  encorajar  os  nós  de  rede  a  se  manterem  \nhonestos.  Se  um  atacante\nganancioso  é  capaz  de  reunir  mais  poder  computacional  do  que  todos  \nos  nós  de rede honestos, ele\nteria     de escolher entre usar seu poder para fraudar as pessoas roubando de \nvolta seus pagamentos, ou\nusá-lo para gerar novas moedas. Ele iria achar mais lucrativo jogar conforme as \nregras, tais regras que\no favorecem com mais moedas novas do que todos os outros juntos, do que \nprejudicar o sistema e a\nvalidade de sua própria riqueza.\n\nRecuperando espaço em disco\n\nDesde  que  a  última  transação  em  uma  moeda  é  garantida  através  uma  \nquantidade  suficiente  de\nblocos,  as transações gastas antes dessa última transação podem ser \ndescartadas para guardar espaço\nno  disco  (hd)  do  computador.  Para  facilitar  isso  sem  quebrar  o hash \ndo bloco, transações assumem\nseus hashes em uma Árvore de Merkle [7][2][5], com a única raiz incluída no \nhash do bloco.\n\nBlocos  mais  antigos  podem ser compactos podando os ramos desta árvore. Os \nhashes interiores não\nprecisam ser armazenados.\n\nUm cabeçalho de bloco sem transações teria o tamanho aproximado de 80 bytes. Se \nnós supomos\nque  os  blocos  são  gerados  a  cada  10  minutos,  logo:  80  bytes  *  6  * \n 24  *  365  =  4.2MB  por  ano.\nAtualmente os computadores estão sendo vendidos tipicamente com 2GB de RAM em \n2008, e a Lei\nde     Moore  prevendo  que  o crescimento atual de 1.2gb por ano, o \narmazenamento não deverá ser um\nproblema mesmo se os cabeçalhos dos blocos precisarem ser armazenados na \nmemória.\n\n\nSimplificando a verificação de pagamentos\n\nSe  é  possível  verificar  pagamentos  sem  que  seja  necessário  rodar  um  \nnó  de  rede  inteiro.  Um\nusuário  precisa  manter  apenas  uma  cópia  dos  cabeçalhos  dos  blocos  da  \ncadeia  que  possua a maior\nprova-de-trabalho,  a  qual  pode  ser  obtida  consultando  nós  de  rede até \nque ele esteja convencido de\nque  ele  tem  a  cadeia  mais  longa  e  obtenha  o  ramo  da Árvore de Merkle \nvinculando a transação ao\nbloco  com  o  registro  de data e hora através de carimbos de tempo. Ele não \npode checar a transação\nsozinho, no entanto, ele pode vincular ligando-a a um lugar na cadeia, dessa \nforma, ele pode ver se os\nnós  de  rede  aceitaram  a  transação  e  se  os  blocos  adicionados  depois  \ndela  confirmam  que  a  rede\naceitou a transação.\n\nAssim sendo, a verificação é confiável enquanto os nós de rede honestos \ncontrolam a rede, mas ela\npode  se  tornar  vulnerável  se  a  rede  é  controlada  por  um  atacante.  \nEnquanto  os  nós de rede podem\nverificar  as  transações  por  eles  mesmos,  um método simplificado pode ser \nenganado por transações\nforjadas  pelo  atacante  enquanto  a  rede  continuar  sob  seu  domínio.  Uma \n estratégia  para se proteger\ncontra isso seria aceitar alertas de nós de rede quando eles detectam um bloco \ninválido, notificando o\nsoftware  dos  usuários  para  baixar  o  bloco  inteiro  e  as  transações  \nalertadas  para  confirmar  a\ninconsistência.  Estabelecimentos  que  recebem  pagamentos  frequentemente  \nvão  querer  rodar  seus\npróprios nós de rede para manter uma segurança mais independente e uma \nverificação mais rápida.\n\nCombinando e dividindo valores\n\nEmbora  fosse  possível  lidar  com  moedas  individualmente,  seria  difícil  \nfazer  uma  transação\nseparada  para  cada  centavo  em  uma  transferência.  Para  permitir  que  o  \nvalor  seja  dividido  e\ncombinado, transações contém múltiplas entradas e saídas. Normalmente, haverá \numa única entrada a\npartir       de  uma  transação  anterior  maior  ou  entradas  múltiplas  \ncombinando  quantidades  menores,  e\nfinalmente duas saídas: uma para o pagamento, e outra retornando o troco, que \nvolta para o remetente\ndo pagamento.\n\n\nDeve-se notar que o número de entradas que podem ser conectadas a uma saída \nespecificada, onde\numa  transação  depende  de  várias  transações,  não  há  um problema aqui. \nNunca há a necessidade de\nextrair cópia autônoma completa do histórico de uma transação.\n\nPrivacidade\n\nO  modelo  bancário  tradicional  alcança  um nível de privacidade limitando o \nacesso à informação\ndas  partes  envolvidas  e  do  intermediário  confiável.  A  necessidade  de  \nanunciar  todas  as  transações\npublicamente  torna  esse  método inviável, mas a privacidade ainda pode ser \nmantida quebrando-se o\nfluxo                de  informações  outro  lugar:  mantendo  as  chaves  \npúblicas  anônimas.  O  público  pode ver que\nalguém  está  enviando  uma  quantia  para  outra  pessoa,  mas  sem  \ninformações  ligando  a  transação  a\nninguém. Isto é semelhante ao nível de informação divulgado pelas bolsas de \nvalores, em que o tempo\ne                  o  tamanho  negócios  individuais,  a  “fita”,  é  tornada  \npública,  mas  sem  dizer  quem  eram  as  partes\nenvolvidas na negociação.\n\nComo  um  firewall  adicional,  um  novo  par  de  chaves  públicas  precisaria \n ser  usado  para  cada\ntransação  para  evitar  que  eles  sejam  ligados  a  um  dono comum. Alguma \nligação ainda é inevitável\ncom  transações  que  tenham  múltiplas  entradas,  as quais necessariamente \nrevelam que suas entradas\nsejam  possuídas  pelo  mesmo  dono.  O  risco  é  que  o dono da chave público \nseja revelado, caso isso\naconteça, seria possível ligar todas as outras transações que foram feitas pelo \nmesmo dono.\n\nCálculos\n\nNós  consideramos  o  cenário  no  qual  um  atacante  está  tentando  gerar  \numa  cadeia  alternativa  de\nblocos mais rápido que a cadeia honesta. Mesmo que isso seja feito, isso não \ntorna o sistema aberto a\nmudanças arbitrárias, como criar valores do nada, ou tomar dinheiro que nunca \npertenceu ao atacante.\n\n\nOs  nós  de  rede  não  irão  aceitar uma transação inválida como pagamento, e \nnós honestos nunca vão\naceitar o bloco contendo a transação fraudulenta. Um atacante pode apenas \ntentar mudar uma de suas\npróprias transações para tomar de volta o dinheiro que ele gastou recentemente.\n\nA corrida entre a cadeia honesta e a cadeia atacante pode ser caracterizada \ncomo uma Caminhada\nBinominal  Aleatória.  O  sucesso  do  evento  ocorre quando a cadeia honesta \nestá sendo estendida por\num  bloco,  aumentando  sua  liderança  em  +1, e a falha do evento ocorre se a \ncadeia do atacante está\nsendo estendida, diminuindo o gap em -1.\n\nA probabilidade de um atacante alcançar a cadeia honesta partindo de um dado \ndéficit é análogo ao\nproblema da Ruína do Apostador. Suponha que um apostador com crédito ilimitado \ncomece com um\ndéficit  e  jogue  potencialmente  um  número  infinito  de  tentativas  para  \ntentar  alcançar  o  ponto  de\nequilíbrio. Podemos calcular a probabilidade na qual o apostador atinge o ponto \nde equilíbrio, ou que\num invasor alcance a cadeia de blocos honesta, como segue abaixo:\n\np = probabilidade um nó honesto encontrar o próximo bloco\nq = probabilidade o atacante encontrar o próximo bloco\n\nqz = probabilidade de o atacante se recuperar de z blocos atrás\n\nDada a nossa suposição de que p>q, a probabilidade cai exponencialmente \nconforme o número de\nblocos que o atacante tem que acompanhar com o aumento da cadeia. Com as \nchances contra ele, se\nele  não  tiver  um  lance  de  sorte  logo  no  começo,  suas  chances  irão  \nse  tornar  cada  vez  menores\nconforme ele vai ficando para trás.\n\nNós  vamos  agora  considerar  o  quanto  a  pessoa  que  recebe  uma  nova  \ntransação  precisa  esperar\nantes que tenha a certeza suficiente de que quem enviou a transação não pode \nmudar a transação. Nós\nsupomos que quem enviou a moeda é um atacante que deseja fazer com que a pessoa \nque vai receber a\nmoeda acredite que ele recebeu o seu pagamento naquele momento, e então \nreverter o pagamento de\nvolta  para  ele  mesmo  depois de algum tempo. O destinatário da transação \nserá alertado quando isso\nacontece, mas quem enviou a transação acredita que será tarde demais.\n\nO destinatário gera um novo par de chaves e dá a chave pública para quem vai \nenviar as moedas\npor um curto momento antes de assinar. Isso impede que o atacante prepare uma \ncadeia de blocos com\nantecedência trabalhando continuamente até que ele tenha a sorte de chegar \nlonge o suficiente, e então\nexecutar    a transação no aquele momento. Uma vez que a transação é enviada, o \nremetente desonesto\ncomeça  a  trabalhar  em  segredo  em  uma  cadeia  paralela  contendo  uma  \nversão  alternativa  de  sua\ntransação.  A  pessoa  que  vai  receber  as  moedas  espera até que a \ntransação tenha sido adicionada ao\nbloco      e  z  blocos  tenham  sido  ligados  depois  disso.  Ele  não  \nprecisa  saber  a  quantidade  exata  de\nprogresso  que  o  atacante  fez,  mas  supondo  que  a  cadeia  de  blocos  \nhonestos tomou o tempo médio\nesperado  por  bloco,  o progresso potencial do atacante será uma distribuição \nde Poisson com o valor\nesperado:\n\n\nPara  obter  a  probabilidade  de  um  invasor  ainda  alcançar  neste  \nmomento,  nós  multiplicamos  a\ndensidade de Poisson por cada quantidade de progresso que ele poderia ter feito \npela probabilidade de\nele conseguir alcançar a partir daquele ponto:\n\nReorganizando para evitar a soma de uma cauda infinita da distribuição…\n\nConvertendo em código C…\n\n{\n\ndouble p = 1.0 – q;\n\ndouble lambda = z * (q / p);\ndouble sum = 1.0;\n\nint i, k;\n\nfor (k = 0; k <= z; k++)\n\n{\n\ndouble poisson = exp(-lambda);\nfor (i = 1; i <= k; i++)\n\npoisson *= lambda / i;\n\nsum -= poisson * (1 – pow(q / p, z – k));\n\n}\n\nreturn sum;\n\n}\n\nExecutando alguns resultados, podemos ver a probabilidade cair exponencialmente \ncom z.\nq=0.1\n\nz=0 P=1.0000000\nz=1 P=0.2045873\nz=2 P=0.0509779\nz=3 P=0.0131722\nz=4 P=0.0034552\nz=5 P=0.0009137\nz=6 P=0.0002428\nz=7 P=0.0000647\nz=8 P=0.0000173\nz=9 P=0.0000046\nz=10 P=0.0000012\nq=0.3\n\nz=0 P=1.0000000\nz=5 P=0.1773523\nz=10 P=0.0416605\nz=15 P=0.0101008\n\n\nz=20 P=0.0024804\nz=25 P=0.0006132\nz=30 P=0.0001522\nz=35 P=0.0000379\nz=40 P=0.0000095\nz=45 P=0.0000024\nz=50 P=0.0000006\n\nPara P menor que 0.1%\n\nP < 0.001\nq=0.10 z=5\nq=0.15 z=8\nq=0.20 z=11\nq=0.25 z=15\nq=0.30 z=24\nq=0.35 z=41\nq=0.40 z=89\nq=0.45 z=340\n\nConclusão\n\nPropusemos  um  sistema  para  transações  eletrônicas  sem  depender  da  \nconfiança  em  intermediários.\nNós começamos com o quadro usual de moedas feitas a partir de assinaturas \ndigitais, que fornece um\nforte  controle  de  propriedade,  mas  é  incompleta  sem  uma  maneira  de  \nevitar  o  gasto  duplo.  Para\nresolver  isso,  nós propusemos uma rede ponto-a-ponto usando a prova de \ntrabalho para registrar um\nhistórico  público  de  transações  que  rapidamente se torna \ncomputacionalmente impraticável para um\natacante  mudar,  se nós honestos controlarem a maioria da potência \ncomputacional da rede. A rede é\nrobusta  em  sua  simplicidade  não  estruturada.  Nós  de  rede  trabalham  \ntodos  de  uma  vez com pouca\ncoordenação. Eles não precisam ser identificados, pois as mensagens são não é \nroteado para qualquer\nlugar  específico  e  só  precisa  ser  entregue  com  base  no  melhor  \nesforço.  Nós  de  rede  podem  sair  e\nvoltar  à  rede  à  vontade,  aceitando  a  cadeia  de  prova  de  trabalho  \ncomo  prova  de  que  aconteceu\nenquanto eles estavam fora. Eles votam com seu poder de CPU, expressando sua \naceitação de blocos\nválidos,  trabalhando  em  estendê-los  e  rejeitando  blocos inválidos, \nrecusando-se a trabalhar em eles.\nQuaisquer regras e incentivos necessários podem ser aplicados com este \nmecanismo de consenso.\n\nReferências\n\n[1] W. Dai, “b-money,” http://www.weidai.com/bmoney.txt, 1998.\n\n[2]  H.  Massias,  X.S.  Avila,  and  J.-J.  Quisquater,  “Design  of  a  \nsecure  timestamping  service  with\nminimal\n\ntrust requirements,” In 20th Symposium on Information Theory in the Benelux, \nMay 1999.\n\n[3] S. Haber, W.S. Stornetta, “How to time-stamp a digital document,” In \nJournal of Cryptology, vol\n3, no\n\n2, pages 99-111, 1991.\n\n[4]   D.   Bayer,   S.   Haber,   W.S.   Stornetta,   “Improving   the   \nefficiency  and  reliability  of  digital\ntime-stamping,”\n\nIn Sequences II: Methods in Communication, Security and Computer Science, pages \n329-334, 1993.\n\n\n[5]  S.  Haber,  W.S.  Stornetta,  “Secure  names  for  bit-strings,”  In  \nProceedings  of  the  4th  ACM\nConference\n\non Computer and Communications Security, pages 28-35, April 1997.\n\n[6] A. Back, “Hashcash – a denial of service counter-measure,”\nhttp://www.hashcash.org/papers/hashcash.pdf, 2002.\n\n[7] R.C. Merkle, “Protocols for public key cryptosystems,” In Proc. 1980 \nSymposium on Security and\nPrivacy, IEEE Computer Society, pages 122-133, April 1980.\n\n[8] W. Feller, “An introduction to probability theory and its applications,” \n1957.\n","language":"text/plain","encrypted":false,"added":1577325308}],"comment":[]}