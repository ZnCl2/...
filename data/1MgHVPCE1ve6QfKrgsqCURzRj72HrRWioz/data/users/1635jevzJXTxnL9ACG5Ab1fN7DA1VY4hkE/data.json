{"next_paste_id":7,"next_comment_id":0,"paste":[{"paste_id":0,"description":"Keccak","body":"# -*- coding: utf-8 -*-\n# Implementation by Gilles Van Assche, hereby denoted as \"the implementer\".\n#\n# For more information, feedback or questions, please refer to our website:\n# https://keccak.team/\n#\n# To the extent possible under law, the implementer has waived all copyright\n# and related or neighboring rights to the source code in this file.\n# http://creativecommons.org/publicdomain/zero/1.0/\n\ndef ROL64(a, n):\n    return ((a >> (64-(n%64))) + (a << (n%64))) % (1 << 64)\n\ndef KeccakF1600onLanes(lanes):\n    R = 1\n    for round in range(24):\n        # θ\n        C = [lanes[x][0] ^ lanes[x][1] ^ lanes[x][2] ^ lanes[x][3] ^ lanes[x][4] for x in range(5)]\n        D = [C[(x+4)%5] ^ ROL64(C[(x+1)%5], 1) for x in range(5)]\n        lanes = [[lanes[x][y]^D[x] for y in range(5)] for x in range(5)]\n        # ρ and π\n        (x, y) = (1, 0)\n        current = lanes[x][y]\n        for t in range(24):\n            (x, y) = (y, (2*x+3*y)%5)\n            (current, lanes[x][y]) = (lanes[x][y], ROL64(current, (t+1)*(t+2)//2))\n        # χ\n        for y in range(5):\n            T = [lanes[x][y] for x in range(5)]\n            for x in range(5):\n                lanes[x][y] = T[x] ^((~T[(x+1)%5]) & T[(x+2)%5])\n        # ι\n        for j in range(7):\n            R = ((R << 1) ^ ((R >> 7)*0x71)) % 256\n            if (R & 2):\n                lanes[0][0] = lanes[0][0] ^ (1 << ((1<<j)-1))\n    return lanes\n\ndef load64(b):\n    return sum((b[i] << (8*i)) for i in range(8))\n\ndef store64(a):\n    return list((a >> (8*i)) % 256 for i in range(8))\n\ndef KeccakF1600(state):\n    lanes = [[load64(state[8*(x+5*y):8*(x+5*y)+8]) for y in range(5)] for x in range(5)]\n    lanes = KeccakF1600onLanes(lanes)\n    state = bytearray(200)\n    for x in range(5):\n        for y in range(5):\n            state[8*(x+5*y):8*(x+5*y)+8] = store64(lanes[x][y])\n    return state\n\ndef Keccak(rate, capacity, inputBytes, delimitedSuffix, outputByteLen):\n    outputBytes = bytearray()\n    state = bytearray([0 for i in range(200)])\n    rateInBytes = rate//8\n    blockSize = 0\n    if (((rate + capacity) != 1600) or ((rate % 8) != 0)):\n        return\n    inputOffset = 0\n    # === Absorb all the input blocks ===\n    while(inputOffset < len(inputBytes)):\n        blockSize = min(len(inputBytes)-inputOffset, rateInBytes)\n        for i in range(blockSize):\n            state[i] = state[i] ^ inputBytes[i+inputOffset]\n        inputOffset = inputOffset + blockSize\n        if (blockSize == rateInBytes):\n            state = KeccakF1600(state)\n            blockSize = 0\n    # === Do the padding and switch to the squeezing phase ===\n    state[blockSize] = state[blockSize] ^ delimitedSuffix\n    if (((delimitedSuffix & 0x80) != 0) and (blockSize == (rateInBytes-1))):\n        state = KeccakF1600(state)\n    state[rateInBytes-1] = state[rateInBytes-1] ^ 0x80\n    state = KeccakF1600(state)\n    # === Squeeze out all the output blocks ===\n    while(outputByteLen > 0):\n        blockSize = min(outputByteLen, rateInBytes)\n        outputBytes = outputBytes + state[0:blockSize]\n        outputByteLen = outputByteLen - blockSize\n        if (outputByteLen > 0):\n            state = KeccakF1600(state)\n    return outputBytes\n\ndef SHAKE128(inputBytes, outputByteLen):\n    return Keccak(1344, 256, inputBytes, 0x1F, outputByteLen)\n\ndef SHAKE256(inputBytes, outputByteLen):\n    return Keccak(1088, 512, inputBytes, 0x1F, outputByteLen)\n\ndef SHA3_224(inputBytes):\n    return Keccak(1152, 448, inputBytes, 0x06, 224//8)\n\ndef SHA3_256(inputBytes):\n    return Keccak(1088, 512, inputBytes, 0x06, 256//8)\n\ndef SHA3_384(inputBytes):\n    return Keccak(832, 768, inputBytes, 0x06, 384//8)\n\ndef SHA3_512(inputBytes):\n    return Keccak(576, 1024, inputBytes, 0x06, 512//8)\n","language":"text/x-python","encrypted":false,"added":1562022034},{"paste_id":1,"description":"RSA","body":"import binascii\n \nn = 9516311845790656153499716760847001433441357    # p*q = modulus\ne = 65537\nd = 5617843187844953170308463622230283376298685\n \nmessage='Rosetta Code!'\nprint('message                 ', message)\n \nhex_data   = binascii.hexlify(message.encode())\nprint('hex data                ', hex_data)\n \nplain_text = int(hex_data, 16)\nprint('plain text integer      ', plain_text)\n \nif plain_text > n:\n  raise Exception('plain text too large for key')\n \nencrypted_text = pow(plain_text,     e, n)\nprint('encrypted text integer  ', encrypted_text)\n \ndecrypted_text = pow(encrypted_text, d, n)\nprint('decrypted text integer  ', decrypted_text)\n \nprint('message                 ', binascii.unhexlify(hex(decrypted_text)[2:]).decode())     # [2:] slicing, to strip the 0x part ","language":"text/x-python","encrypted":false,"added":1562022569},{"paste_id":2,"description":"Bitcoin/address validation","body":"from hashlib import sha256\n \ndigits58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n \ndef decode_base58(bc, length):\n    n = 0\n    for char in bc:\n        n = n * 58 + digits58.index(char)\n    return n.to_bytes(length, 'big')\ndef check_bc(bc):\n    try:\n        bcbytes = decode_base58(bc, 25)\n        return bcbytes[-4:] == sha256(sha256(bcbytes[:-4]).digest()).digest()[:4]\n    except Exception:\n        return False\n \nprint(check_bc('1AGNa15ZQXAZUgFiqJ3i7Z2DPU2J6hW62i'))\nprint(check_bc(\"17NdbrSGoUotzeGCcMMCqnFkEvLymoou9j\"))","language":"text/x-python","encrypted":false,"added":1562022795},{"paste_id":3,"description":"One-time pad","body":"package main\n \nimport (\n    \"bufio\"\n    \"crypto/rand\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"math/big\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n    \"unicode\"\n)\n \nconst (\n    charsPerLine = 48\n    chunkSize    = 6\n    cols         = 8\n    demo         = true // would normally be set to false\n)\n \ntype fileType int\n \nconst (\n    otp fileType = iota\n    enc\n    dec\n)\n \nvar scnr = bufio.NewScanner(os.Stdin)\n \nfunc check(err error) {\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n \nfunc toAlpha(s string) string {\n    var filtered []rune\n    for _, r := range s {\n        if unicode.IsUpper(r) {\n            filtered = append(filtered, r)\n        }\n    }\n    return string(filtered)\n}\n \nfunc isOtpRelated(s string) bool {\n    return strings.HasSuffix(s, \".1tp\") || strings.HasSuffix(s, \"1tp_cpy\") ||\n        strings.HasSuffix(s, \".1tp_enc\") || strings.HasSuffix(s, \"1tp_dec\")\n}\n \nfunc makePad(nLines int) string {\n    nChars := nLines * charsPerLine\n    bytes := make([]byte, nChars)\n    /* generate random upper case letters */\n    max := big.NewInt(26)\n    for i := 0; i < nChars; i++ {\n        n, err := rand.Int(rand.Reader, max)\n        check(err)\n        bytes[i] = byte(65 + n.Uint64())\n    }\n    return inChunks(string(bytes), nLines, otp)\n}\n \nfunc vigenere(text, key string, encrypt bool) string {\n    bytes := make([]byte, len(text))\n    var ci byte\n    for i, c := range text {\n        if encrypt {\n            ci = (byte(c) + key[i] - 130) % 26\n        } else {\n            ci = (byte(c) + 26 - key[i]) % 26\n        }\n        bytes[i] = ci + 65\n    }\n    temp := len(bytes) % charsPerLine\n    if temp > 0 { // pad with random characters so each line is a full one\n        max := big.NewInt(26)\n        for i := temp; i < charsPerLine; i++ {\n            n, err := rand.Int(rand.Reader, max)\n            check(err)\n            bytes = append(bytes, byte(65+n.Uint64()))\n        }\n    }\n    ft := enc\n    if !encrypt {\n        ft = dec\n    }\n    return inChunks(string(bytes), len(bytes)/charsPerLine, ft)\n}\n \nfunc inChunks(s string, nLines int, ft fileType) string {\n    nChunks := len(s) / chunkSize\n    remainder := len(s) % chunkSize\n    chunks := make([]string, nChunks)\n    for i := 0; i < nChunks; i++ {\n        chunks[i] = s[i*chunkSize : (i+1)*chunkSize]\n    }\n    if remainder > 0 {\n        chunks = append(chunks, s[nChunks*chunkSize:])\n    }\n    var sb strings.Builder\n    for i := 0; i < nLines; i++ {\n        j := i * cols\n        sb.WriteString(\" \" + strings.Join(chunks[j:j+cols], \" \") + \"\\n\")\n    }\n    ss := \" file\\n\" + sb.String()\n    switch ft {\n    case otp:\n        return \"# OTP\" + ss\n    case enc:\n        return \"# Encrypted\" + ss\n    default: // case dec:\n        return \"# Decrypted\" + ss\n    }\n}\n \nfunc menu() int {\n    fmt.Println(`\n1. Create one time pad file.\n \n2. Delete one time pad file.\n \n3. List one time pad files.\n \n4. Encrypt plain text.\n \n5. Decrypt cipher text.\n \n6. Quit program.\n`)\n    choice := 0\n    for choice < 1 || choice > 6 {\n        fmt.Print(\"Your choice (1 to 6) : \")\n        scnr.Scan()\n        choice, _ = strconv.Atoi(scnr.Text())\n        check(scnr.Err())\n    }\n    return choice\n}\n \nfunc main() {\n    for {\n        choice := menu()\n        fmt.Println()\n        switch choice {\n        case 1: // Create OTP\n            fmt.Println(\"Note that encrypted lines always contain 48 characters.\\n\")\n            fmt.Print(\"OTP file name to create (without extension) : \")\n            scnr.Scan()\n            fileName := scnr.Text() + \".1tp\"\n            nLines := 0\n            for nLines < 1 || nLines > 1000 {\n                fmt.Print(\"Number of lines in OTP (max 1000) : \")\n                scnr.Scan()\n                nLines, _ = strconv.Atoi(scnr.Text())\n            }\n            check(scnr.Err())\n            key := makePad(nLines)\n            file, err := os.Create(fileName)\n            check(err)\n            _, err = file.WriteString(key)\n            check(err)\n            file.Close()\n            fmt.Printf(\"\\n'%s' has been created in the current directory.\\n\", fileName)\n            if demo {\n                // a copy of the OTP file would normally be on a different machine\n                fileName2 := fileName + \"_cpy\" // copy for decryption\n                file, err := os.Create(fileName2)\n                check(err)\n                _, err = file.WriteString(key)\n                check(err)\n                file.Close()\n                fmt.Printf(\"'%s' has been created in the current directory.\\n\", fileName2)\n                fmt.Println(\"\\nThe contents of these files are :\\n\")\n                fmt.Println(key)\n            }\n        case 2: // Delete OTP\n            fmt.Println(\"Note that this will also delete ALL associated files.\\n\")\n            fmt.Print(\"OTP file name to delete (without extension) : \")\n            scnr.Scan()\n            toDelete1 := scnr.Text() + \".1tp\"\n            check(scnr.Err())\n            toDelete2 := toDelete1 + \"_cpy\"\n            toDelete3 := toDelete1 + \"_enc\"\n            toDelete4 := toDelete1 + \"_dec\"\n            allToDelete := []string{toDelete1, toDelete2, toDelete3, toDelete4}\n            deleted := 0\n            fmt.Println()\n            for _, name := range allToDelete {\n                if _, err := os.Stat(name); !os.IsNotExist(err) {\n                    err = os.Remove(name)\n                    check(err)\n                    deleted++\n                    fmt.Printf(\"'%s' has been deleted from the current directory.\\n\", name)\n                }\n            }\n            if deleted == 0 {\n                fmt.Println(\"There are no files to delete.\")\n            }\n        case 3: // List OTPs\n            fmt.Println(\"The OTP (and related) files in the current directory are:\\n\")\n            files, err := ioutil.ReadDir(\".\") // already sorted by file name\n            check(err)\n            for _, fi := range files {\n                name := fi.Name()\n                if !fi.IsDir() && isOtpRelated(name) {\n                    fmt.Println(name)\n                }\n            }\n        case 4: // Encrypt\n            fmt.Print(\"OTP file name to use (without extension) : \")\n            scnr.Scan()\n            keyFile := scnr.Text() + \".1tp\"\n            if _, err := os.Stat(keyFile); !os.IsNotExist(err) {\n                file, err := os.Open(keyFile)\n                check(err)\n                bytes, err := ioutil.ReadAll(file)\n                check(err)\n                file.Close()\n                lines := strings.Split(string(bytes), \"\\n\")\n                le := len(lines)\n                first := le\n                for i := 0; i < le; i++ {\n                    if strings.HasPrefix(lines[i], \" \") {\n                        first = i\n                        break\n                    }\n                }\n                if first == le {\n                    fmt.Println(\"\\nThat file has no unused lines.\")\n                    continue\n                }\n                lines2 := lines[first:] // get rid of comments and used lines\n \n                fmt.Println(\"Text to encrypt :-\\n\")\n                scnr.Scan()\n                text := toAlpha(strings.ToUpper(scnr.Text()))\n                check(scnr.Err())\n                tl := len(text)\n                nLines := tl / charsPerLine\n                if tl%charsPerLine > 0 {\n                    nLines++\n                }\n                if len(lines2) >= nLines {\n                    key := toAlpha(strings.Join(lines2[0:nLines], \"\"))\n                    encrypted := vigenere(text, key, true)\n                    encFile := keyFile + \"_enc\"\n                    file2, err := os.Create(encFile)\n                    check(err)\n                    _, err = file2.WriteString(encrypted)\n                    check(err)\n                    file2.Close()\n                    fmt.Printf(\"\\n'%s' has been created in the current directory.\\n\", encFile)\n                    for i := first; i < first+nLines; i++ {\n                        lines[i] = \"-\" + lines[i][1:]\n                    }\n                    file3, err := os.Create(keyFile)\n                    check(err)\n                    _, err = file3.WriteString(strings.Join(lines, \"\\n\"))\n                    check(err)\n                    file3.Close()\n                    if demo {\n                        fmt.Println(\"\\nThe contents of the encrypted file are :\\n\")\n                        fmt.Println(encrypted)\n                    }\n                } else {\n                    fmt.Println(\"Not enough lines left in that file to do encryption.\")\n                }\n            } else {\n                fmt.Println(\"\\nThat file does not exist.\")\n            }\n        case 5: // Decrypt\n            fmt.Print(\"OTP file name to use (without extension) : \")\n            scnr.Scan()\n            keyFile := scnr.Text() + \".1tp_cpy\"\n            check(scnr.Err())\n            if _, err := os.Stat(keyFile); !os.IsNotExist(err) {\n                file, err := os.Open(keyFile)\n                check(err)\n                bytes, err := ioutil.ReadAll(file)\n                check(err)\n                file.Close()\n                keyLines := strings.Split(string(bytes), \"\\n\")\n                le := len(keyLines)\n                first := le\n                for i := 0; i < le; i++ {\n                    if strings.HasPrefix(keyLines[i], \" \") {\n                        first = i\n                        break\n                    }\n                }\n                if first == le {\n                    fmt.Println(\"\\nThat file has no unused lines.\")\n                    continue\n                }\n                keyLines2 := keyLines[first:] // get rid of comments and used lines\n \n                encFile := keyFile[0:len(keyFile)-3] + \"enc\"\n                if _, err := os.Stat(encFile); !os.IsNotExist(err) {\n                    file2, err := os.Open(encFile)\n                    check(err)\n                    bytes, err := ioutil.ReadAll(file2)\n                    check(err)\n                    file2.Close()\n                    encLines := strings.Split(string(bytes), \"\\n\")[1:] // exclude comment line\n                    nLines := len(encLines)\n                    if len(keyLines2) >= nLines {\n                        encrypted := toAlpha(strings.Join(encLines, \"\"))\n                        key := toAlpha(strings.Join(keyLines2[0:nLines], \"\"))\n                        decrypted := vigenere(encrypted, key, false)\n                        decFile := keyFile[0:len(keyFile)-3] + \"dec\"\n                        file3, err := os.Create(decFile)\n                        check(err)\n                        _, err = file3.WriteString(decrypted)\n                        check(err)\n                        file3.Close()\n                        fmt.Printf(\"\\n'%s' has been created in the current directory.\\n\", decFile)\n                        for i := first; i < first+nLines; i++ {\n                            keyLines[i] = \"-\" + keyLines[i][1:]\n                        }\n                        file4, err := os.Create(keyFile)\n                        check(err)\n                        _, err = file4.WriteString(strings.Join(keyLines, \"\\n\"))\n                        check(err)\n                        file4.Close()\n                        if demo {\n                            fmt.Println(\"\\nThe contents of the decrypted file are :\\n\")\n                            fmt.Println(decrypted)\n                        }\n                    }\n                } else {\n                    fmt.Println(\"Not enough lines left in that file to do decryption.\")\n                }\n            } else {\n                fmt.Println(\"\\nThat file does not exist.\")\n            }\n        case 6: // Quit program\n            return\n        }\n    }\n}","language":"text/x-go","encrypted":false,"added":1562023072},{"paste_id":4,"description":"Cifra de Vigenère","body":"'''Vigenere encryption and decryption'''\n \nfrom itertools import starmap, cycle\n \n \ndef encrypt(message, key):\n    '''Vigenere encryption of message using key.'''\n \n    # Converted to uppercase.\n    # Non-alpha characters stripped out.\n    message = filter(str.isalpha, message.upper())\n \n    def enc(c, k):\n        '''Single letter encryption.'''\n \n        return chr(((ord(k) + ord(c) - 2 * ord('A')) % 26) + ord('A'))\n \n    return ''.join(starmap(enc, zip(message, cycle(key))))\n \n \ndef decrypt(message, key):\n    '''Vigenere decryption of message using key.'''\n \n    def dec(c, k):\n        '''Single letter decryption.'''\n \n        return chr(((ord(c) - ord(k) - 2 * ord('A')) % 26) + ord('A'))\n \n    return ''.join(starmap(dec, zip(message, cycle(key))))\n \n \ndef main():\n    '''Demonstration'''\n \n    text = 'Beware the Jabberwock, my son! The jaws that bite, ' + (\n           'the claws that catch!'\n    )\n    key = 'VIGENERECIPHER'\n \n    encr = encrypt(text, key)\n    decr = decrypt(encr, key)\n \n    print(text)\n    print(encr)\n    print(decr)\n \n \nif __name__ == '__main__':\n    main()","language":"text/x-python","encrypted":false,"added":1562023292},{"paste_id":5,"description":"Cifra de César","body":"from string import ascii_uppercase as abc\n \ndef caesar(s, k, decode = False):\n    trans = dict(zip(abc, abc[(k,26-k)[decode]:] + abc[:(k,26-k)[decode]]))\n    return ''.join(trans[L] for L in s.upper() if L in abc)\n \nmsg = \"The quick brown fox jumped over the lazy dogs\"\nprint(caesar(msg, 11))\nprint(caesar(caesar(msg, 11), 11, True))","language":"text/x-python","encrypted":false,"added":1562023616},{"paste_id":6,"description":"Exponenciação modular","body":"package main\n \nimport (\n    \"fmt\"\n    \"math/big\"\n)\n \nfunc main() {\n    a, _ := new(big.Int).SetString(\n        \"2988348162058574136915891421498819466320163312926952423791023078876139\", 10)\n    b, _ := new(big.Int).SetString(\n        \"2351399303373464486466122544523690094744975233415544072992656881240319\", 10)\n    m := big.NewInt(10)\n    r := big.NewInt(40)\n    m.Exp(m, r, nil)\n \n    r.Exp(a, b, m)\n    fmt.Println(r)\n}","language":"text/x-go","encrypted":false,"added":1562024199}],"comment":[]}