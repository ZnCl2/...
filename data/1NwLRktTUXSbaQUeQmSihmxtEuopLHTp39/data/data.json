{
	"title": "Skw's Blog",
	"description": "Some notes on Linux and functional programming",
	"links": "- [Source code](https://github.com/HelloZeroNet)",
	"next_post_id": 4,
	"demo": false,
	"modified": 1552062368,
	"post": [
		{
			"post_id": 3,
			"title": "Enabling Native OpenSSL in ZeroNet on NixOS",
			"date_published": 1552059192.197,
			"body": "Since my last post, the ZeroNet devs have added support for checking the `LD_LIBRARY_PATH` environment variable. This means we can add the location of our native OpenSSL library to it to achieve optimal performance.\n\nSetting it is pretty easy; all we need to do is override the `postFixup` phase of the zeronet package, which is where the shell wrapper is created:\n\n```nix\npostFixup = ''\n  makeWrapper \"$out/share/zeronet.py\" \"$out/bin/zeronet\" \\\n    --set PYTHONPATH \"$PYTHONPATH\" \\\n    --set PATH ${pkgs.python2Packages.python}/bin \\\n    --set LD_LIBRARY_PATH ${pkgs.openssl_1_0_2.out}/lib\n'';\n```\n\nThe only difference between ours and the normal one is that we added that `LD_LIBRARY_PATH` line, and we prefixed the variable referenced in `PATH` with `pkgs.` since we're not inside nixpkgs.\n\nAll together, with the current commit info, our override looks like this:\n\n```nix\nnixpkgs.config.packageOverrides = pkgs: rec {\n  zeronet = pkgs.lib.overrideDerivation pkgs.zeronet (attrs: rec {\n    buildInputs = with pkgs; [ openssl_1_0_2 ] ++ attrs.buildInputs;\n    version = \"0.6.5-git\";\n    src = pkgs.fetchFromGitHub {\n      owner = \"HelloZeroNet\";\n      repo = \"ZeroNet\";\n      rev = \"1ad44ace0ad178b3f5c514774441f6c3e20eb795\";\n      sha256 = \"02qkj3ilmxvls4c9wxcpf55psnbm1mfjczgg2mxcv42yyz6c1zgc\";\n    };\n    postFixup = ''\n      makeWrapper \"$out/share/zeronet.py\" \"$out/bin/zeronet\" \\\n        --set PYTHONPATH \"$PYTHONPATH\" \\\n        --set PATH ${pkgs.python2Packages.python}/bin \\\n        --set LD_LIBRARY_PATH ${pkgs.openssl_1_0_2.out}/lib\n    '';\n  });\n};\n```\n\nNow, when you go to [the benchmark page](/Benchmark), you should see something like\n\n```\n- openssl verify x 100..........0.053s [x6.97: Insane!!]\n```\n\ninstead of\n\n```\n- openssl verify x 100...not avalible :(\n```"
		},
		{
			"post_id": 2,
			"title": "Zeronet over Tor on NixOS",
			"date_published": 1550907132,
			"body": "### NixOS\n\nFor those who don't know, [NixOS](https://nixos.org/) (warning: clearnet link) is a GNU/Linux distro with a pretty radical twist:\nthe package manager is declarative rather than imperative.\n\nThe implications of this might not be immediately obvious, so I'll quickly break them down here:\n\n*   The _entire_ system is managed by a single tool, using a pure-functional language. Even the installer is controlled by it.\n*   The configuration of a system (and the binaries on the system!) can be versioned, so rolling back to a previous version is trivial.\n*   Configuration versioning also means you can create a new version without switching to it. This is super useful for testing new settings.\n*   Upgrades are atomic, meaning the whole upgrade is completed without ever entering an inconsistent state, so failed upgrades are always safe.\n*   Packages can be installed per-user, so multiuser systems are both more convenient and safer than on traditional GNU/Linux systems.\n\nSo you can see NixOS's approach is very powerful. However, this power doesn't come for free. One major downside to this model is in how it has to be implemented: NixOS cannot use standardized paths for many files. This has performance implications for ZeroNet discussed in the [known issues](#known-issues) below.\n\n### Configuring Tor\n\nIn NixOS, packages can define services which can be enabled by the user. These services can in turn define options to modify the behavior of the service. The package for Tor defines a pretty powerful set of options we can use to set it up securely:\n\n```nix\n{ config, pkgs, ... }:\n{\n  services.tor = {\n    enable = true;\n    client = {\n      enable = true;\n      socksIsolationOptions = [\n        \"IsolateClientAddr\" \"IsolateSOCKSAuth\"\n        \"IsolateClientProtocol\" \"IsolateDestPort\"\n        \"IsolateDestAddr\"\n      ];\n      socksPolicy = \"accept 127.0.0.0/24\";\n    };\n    controlSocket = {\n      enable = true;\n    };\n  };\n}\n```\n\nThis enables the `tor` service, then enables the `tor.client` with extensive connection isolation, and a `socksPolicy` that only allows connections from local IPs (I have a virtual machine on my box, which is why it's not just `127.0.0.1/32`). This connection is used by the Tor Browser Bundle when connecting to non-zeronet resources.\nNext, we enable the `tor.controlSocket`, which used by ZeroNet to connect to the Tor network.\n\nIt's that simple! Just save `configuration.nix` and run `nixos-rebuild switch`, and Nix takes care of everything for us.\n\n### Configuring ZeroNet\n\nZeroNet is _slighty_ more complex to get going, since the package hosted in nixpkgs tends to lag behind live by a fair bit.\n\nThe first thing we need to do is override the version of ZeroNet in nixpkgs so we can pull from the repo ourselves, without waiting for nixpkgs to catch up.\n\nThere are 2 ways to do this: the safe, manual way, and the unsafe, automatic way.\n\nThe safe way first:\n\n```nix\n{ config, pkgs, ... }:\n{\n  nixpkgs.config.packageOverrides = pkgs: rec {\n    zeronet = pkgs.lib.overrideDerivation pkgs.zeronet (attrs: rec {\n      buildInputs = with pkgs; [ openssl_1_0_2 ];\n      version = \"0.6.5-git\";\n      src = pkgs.fetchFromGitHub {\n        owner = \"HelloZeroNet\";\n        repo = \"ZeroNet\";\n        rev = \"174e8d3c19e4dbe53bdab95db0aa3de416249df3\";\n        sha256 = \"0bbmjbz36nlf7il0ph2i7s32jnlxq2v0wc8nxi4aaqxns8qy2jkf\";\n      };\n    });\n  };\n}\n```\n\nThe downside of this is that we need to monitor the ZeroNet repo for changes, and calculate update the rev and hash manually. the upside is that it lets us verify that the version we're updating to is safe before running the update.\n\nNow, the unsafe way:\n\n```nix\n{ config, pkgs, ... }:\n{\n  nixpkgs.config.packageOverrides = pkgs: rec {\n    zeronet = pkgs.lib.overrideDerivation pkgs.zeronet (attrs: rec {\n      buildInputs = with pkgs; [ openssl_1_0_2 ];\n      version = \"git-master\";\n      src = fetchGit {\n        url = \"https://github.com/HelloZeroNet/ZeroNet\";\n      };\n    });\n  };\n}\n```\n\n**This way is unsafe** for 2 reasons:\n\n1.  It uses the undocumented `fetchGit` builtin without specifying an expected hash or revision. This means we cannot verify that sources were downloaded correctly when updating. Additionally, Nix will upgrade ZeroNet even when we do not pass `--upgrade` to `nixos-rebuild`, so we have no control over the version being used.\n2.  It does not allow us to verify the code is safe before updating.\n\nThe advantage is that it's a set and forget solution.\n\nNow that we've told NixOS to grab the correct version of ZeroNet, we need to enable and configure the service:\n\n```nix\n{ config, pkgs, ... }:\n{\n  services.zeronet = {\n    enable = true;\n    tor = true;\n    torAlways = true;\n    port = 43110;\n  };\n}\n```\n\nThis tells ZeroNet to run on `localhost:43110`, and to _always_ use Tor. It turns out that we don't need to do any further configuration here, since the default settings are pretty sane.<span data-cke-bookmark=\"1\" style=\"display: none;\">Â </span>\n\nNow we just run `nixos-rebuild switch`, and ZeroNet should become available on `localhost:43110`. Easy!\n\n### Known Issues\n\nIn order to achieve versioning and atomic upgrades, the Nix package manager uses a \"store\" to hold all the installed files. Each package, configuration file, service, etc. gets its own folder in the store, prefixed by a hash. Since these paths are unpredictable from a program's point of view, there's no way to find things like dependencies. Fortunately, Nix provides us with a fix for most cases: the installer will automatically patch binaries using `patchelf` so they reference the correct libraries. Unfortunately, this doesn't work in every case: non-binary files (like python scripts) are not handled automatically by the installer. Since ZeroNet uses the system OpenSSL, it will fail to find it and fall back to a slower pure-python implementation of `openssl verify`.\n\nThis can be confirmed by navigating to [the benchmark page](http://127.0.0.1:43110/Benchmark):\n\n```\nCryptBitcoin:\n- hdPrivatekey x 10..........0.091s [x7.72: Insane!!]\n- sign x 10..........0.177s [x1.98: Fast]\n- openssl verify x 100...not avalible :(\n- pure-python verify x 10..........0.129s [x12.36: Insane!!]\n```\n\nThis issue is being tracked [here](https://github.com/HelloZeroNet/ZeroNet/issues/1907) (warning: clearnet link)."
		}
	]
}