{
	"title": "Emeraude Blog",
	"description": "I catch segfaults.",
	"links": "- [GitHub](https://github.com/Emeraude) _(clearnet)_\n- [ZeroMePlus](http://127.0.0.1:43110/1Lj1oPcN7oZQL8HkS5KbkzQuKqs42zQWY6/?Profile/1BLueGvui1GdbtsjcKqCf4F67uKfritG49/1JwPBvZYXLJzrA6YisjpsyTuuieFLCARS6/erneraude@zeroid.bit)\n- [TOC](?Post:10)",
	"next_post_id": 13,
	"demo": false,
	"modified": 1477571546,
	"post": [
		{
			"post_id": 12,
			"title": "ZeroMePlus",
			"date_published": 1477564920.985,
			"body": "## ZeroMe\nYou probably already heard about [ZeroMe](http://127.0.0.1:43110/Me.ZeroNetwork.bit/), the famous zeronet social network. For those who don't, it's a social network similar to twitter, without characters limits and markdown support (I still don't understand why clearnet social networks are not supporting it), but with some limitations: there is no file upload, and no user blocking feature. It is the first zite using zeronet hubs, which is a way to split a zite database into several zites, to avoid downloading gigabytes of data when you are visiting a big zite.\n\n## ZeroMePlus\n[ZeroMePlus](http://127.0.0.1:43110/1Lj1oPcN7oZQL8HkS5KbkzQuKqs42zQWY6/) is a fork of ZeroMe, that brings up several features:\n- hashtags\n- improved research\n- image loading (but not upload)\n- see the liked posted of each user\n- more feeds on the home page\n- several ways of ignore/block a user\n\nSince ZeroMePlus is using the same hubs as ZeroMe, the two social networks contains exactly the same data, ZeroMePlus only adds interface feature.\n\nSometimes I'm writing some little, badly written posts on ZeroMe, [here is my profile](http://127.0.0.1:43110/1Lj1oPcN7oZQL8HkS5KbkzQuKqs42zQWY6/?Profile/1BLueGvui1GdbtsjcKqCf4F67uKfritG49/1JwPBvZYXLJzrA6YisjpsyTuuieFLCARS6/erneraude@zeroid.bit)."
		},
		{
			"post_id": 11,
			"title": "What's wrong with gitignores",
			"date_published": 1458575416.015,
			"body": "---\nYou know, **.gitignore** are files that tell git which files are excluded from the repo. It's an useful and powerful tool, that made git usage easier. Let's clarify some things : on our git repositories, we don't want any temporary file. That includes compiled files from the techno you used (like `*.o` files if you are using C, or the `__pycache__` directory in python), but also files from your OS or your IDE (like `Thumbs.db` in Windows or `#*#` files on emacs). But files depending on your OS MUST NOT BE in your .gitignore.\n\n---\n\nTake a look at this gitignore :\n```gitignore\n*~\n*.so\n*.o\n.idea\n```\nIt mixes project ignored files (`*.so` and `*.o`, due to C or C++ usage) and development environment files (`*~` tmp files and `.idea` IDE directory). It's a bad gitignore.\n\n## The right way\n\nWe have to split the gitignore above into two ones : \n```gitignore\n#This one will still be in your project directory\n*.o\n*.so\n```\n\n```gitignore\n#This one will be in your home directory\n*~\n.idea\n```\n\nBut it's not magical. Git doesn't know where your global gitignore file is. You have to tell it with this simple command:\n```bash\ngit config --global core.excludesfile '~/.gitignore'\n# You see, there is no fucking $ in the line above, and you understand it. Magic, isn't it ?\n```\n\n## The evil way\n\nYes, there is an evil way. Not the way I described at the beginning of this article, but a much more evil way. Yes, it's possible. Have you ever heard about **[gitignore.io](https://github.com/joeblau/gitignore.io)** ? It's a tool that claims to help you to create gitignores. You simply get them from an api and they are here. You can also retrieve several gitignores from several technos merged into one. But it's not as cool as it looks like. \nFirst, they are using [dirty `$`](?Post:7) in their bash command lines. Then, let's try some bash commands:\n```bash\ncurl https://www.gitignore.io/api/C\ncurl https://www.gitignore.io/api/C,C++\ncurl https://www.gitignore.io/api/C,C++,linux\n```\nTheir tool allow us to merge project ignored files and OS ignored files. That's a big big mistake.\nEven worse, it makes duplicates.\n```bash\ncurl https://www.gitignore.io/api/C,C++ 2>&- | wc -l # It prints 68\ncurl https://www.gitignore.io/api/C,C++ 2>&- | grep -v '^#' | sort | uniq | wc -l # It prints 25\n```\nYeah, there is a lot of duplicates. I just remove duplicates and commented lines. There is an empty line remaining. That means this gitignore could fit in 24 fucking lines. So why are you giving me 68 ? You have too many bandwidth and you want to waste it ?\n\n## Conclusion\n\nPlease never use gitignore.io again. Write your own gitignores, one per project plus a global one. If you want to use already done gitignores, please have a look to this [repo](https://github.com/github/gitignore), it's pretty good."
		},
		{
			"post_id": 10,
			"title": "Blog TOC",
			"date_published": 1457606086.446,
			"body": "Here is the list of all the posts I wrote. I will update it each time I add a new one.\n\n## Zeronet\n- [ZeroMePlus](?Post:12)\n\n## C++\n- [Include guards](?Post:8)\n\n## JavaScript\n- [Variable declarations](?Post:9)\n\n## General\n- [Let's talk about shebangs](?Post:6)\n- [What's wrong with READMEs](?Post:7)\n- [What's wrong with gitignores](?Post:11)"
		},
		{
			"post_id": 9,
			"title": "[JS] Variable declarations",
			"date_published": 1457605769.491,
			"body": "---\nI saw a lot of people misunderstanding the way variables are declared in JavaScript. It's very sad because declaring a variable is the simpliest feature of a lot of languages (some languages as OCaml can only define constant values).\nBut, there is something way worse: some guides are writing bullshit about it. Reading [this github readme](https://github.com/stevekwan/best-practices/blob/master/javascript/gotchas.md#the-var-keyword-what-exactly-does-it-do) gave me the idea of writing this article. So, let's talk about the old way of defining variables :\n\n---\n\n## The \"var\" keyword\n\nThe readme file I linked above let suggested that the `var` keyword defines scoped variables. You're all wrong. Let's see an example:\n```javascript\nif (true) {\n  var bar = 42;\n}\nconsole.log(bar);\n```\nThis code displays `42` in the stdout. But `bar` is defined in the condition block scope. So why can I access it from outside ? That's because **the `var` keyword does not define scoped variable**. Actually, it defines a variable in the current function scope, or in the current file scope. You cannot define global variables with the `var` keyword.\n\n## Without any keyword\n\nLet's look at this code:\n```javascript\nfunction foo() {\n  bar = 42;\n}\nfoo();\nconsole.log(bar);\n```\nThis code also displays `42` because if you do not use the `var` keyword, you define a global variable. But the readme linked above says it's bad to do this. But it does not tell why. Let's clarify it : **a global variable is not dirty**. Indeed, only this way of declaring one is dirty. Usage of an undefined variable should raise a `ReferenceError`. Furthermore, if you are using the strict mode, your code will not work.\nSo, how can we define a global variable without this syntax ? It's really simple :\n```javascript\nwindow.foo = 42; // in the browser\nGLOBAL.foo = 42;  // in node.js\n``` \n\n## The \"let\" keyword\n\nIn the first paragraph, I said the `var` keyword is the old way. So, what's the new way ? ECMAScript 6 added the `let` keyword in june 2015. It has almost the same behaviour as `var`. The only difference is that the `let` keyword define a **true scoped variable**. So no, this code will not work:\n```javascript\n\"use strict\";\nif (true) {\n  let bar = 42;\n}\nconsole.log(bar);\n```\nSo, from now, I suggest you to replace all your `var` by the  new `let` keyword. Note that it works natively in **SpiderMonkey** (the engine used in **firefox**), but it requires usage of the strict mode in **V8** (the engine used in **Google Chrome** and **node.js**).\n\n## Conclusion\n\nThe variables declarations is a good illustration of the problem of JavaScript. We had to wait 20 fucking years to have a way to define scoped variables. The language has been badly designed, and it's something that can be felt when using it. The language could have been awesome if it had been well designed from the beginning. The same problem can be found in a much more serious way in PHP."
		},
		{
			"post_id": 8,
			"title": "[C/C++] Include guards",
			"date_published": 1457430888.464,
			"body": "---\n## What is it ?\n\nToday I want to talk about include guards. For those who don't know what I mean, It's a macro that is defined at the top of a header file, like this:\n\n```C\n#ifndef FILE_NAME_H_\n# define FILE_NAME_H_\n...\n#endif\n```\n\n---\n\nYou probably already saw something similar. It prevents for double-inclusion and recursive-inclusion. As an example, let's write a file `parent.h`, a file `grandparent.h` and a file `son.h` like this:\n\n```C\n/* grandparent.h */\n#ifndef GRAND_PARENT_H_\n# define GRAND_PARENT_H_\n...\n#endif\n\n/* parent.h */\n#include \"grandparent.h\"\n...\n\n/* son.h */\n#include \"parent.h\"\n#include \"grandparent.h\"\n...\n```\n\nIn the file `son.h`, we require `parent.h`, that requires `grandparent.h`. So, when the preprocessor will reach the second line, it will not include `grandparent.h` twice, because the macro `GRAND_PARENT_H_` is already defined.\n\n## Inconveniences\n\nYou probably already know it, but this method, even if it works well, has a lot of inconveniences :\n- It's long to write. 3 fucking lines just to tell the compiler not to include the file several times.\n- It may result into conflicts, especially if you work with several libraries or with other people. This problem grows with your project size.\n- It requires to read all the file, that means you lost some milliseconds PER INCLUSION. On a big project, it could result in seconds, and even in minutes.\n- It's prone to mistakes. You just have to misspell the macro the first or the second time you write it to create compilation errors.\n- It defines a lot of useless macros that will never be re-used. It slows down the preprocessor (this point is similar to the third one).\n\n## Solution\n\nYou probably have already seen it in some source codes, it's the `#pragma once` directive. It solves each problem described above. The only drawback is that this solution is not standard, but almost each compiler supports it, even the dirty Microsoft Visual C++ one.\nIt replaces well the three lines you wrote before, it does not define useless macros, and it avoids conflicts. It's even faster because it does not require to read all the file content, because it's builtin into the compiler and it's not a trick.\nIt looks like a magical solution, especially if you never heard of it before. But let me ask you something : can we do something better ? You know, C has been released in 1972, and has barely changed (C99 and C11 added a few features, and this versions are not widespread). But C++ is an object oriented programming language based on C. It takes C and it adds some missing features to it. So, why have we to write the inclusion guards or the `#pragma once` directive ? Why isn't it a builtin of the language ? We never want to include a header file several times, so why do we have to precise it ?\n\nNB: Concerning the last part, I know you may want to include another file than a header file, like a small part of C/C++ code that will be reused. But doing this is a bad thing, you do not have to re-use several times the same part of code. If you think you have to, just create a fucking function!"
		},
		{
			"post_id": 7,
			"title": "What's wrong with READMEs",
			"date_published": 1457368550,
			"body": "---\nI spend a lot of time testing new softwares, and I have to read a lot of README files. But, really often, I find bad repositories, with bad formatted readme. Or worse, no README at all. What the fuck ? How I am supposed to figure out how your code works if you don't give me a fucking clue ?\nBut, sometimes, I see other big issues on readmes. First, the README.txt files on GitHub. HAVE YOU EVER WATCHED YOUR REPO ? Your shit is not parsed! GitHub only recognizes `.md` extension, and it's cool. Markdown is older than GitHub, even than git itself! What's wrong with you ? Why are you using inconsistent file extensions without any style ?\n\n---\n\nWell, bad file extensions are bad, but not very common. I want to tell you about something really really nastier: fucking `$` in bash command lines, like that:\n```bash\n$ git clone http://github.com/Kinto/kinto-heroku.git --depth=1 kinto-instance && cd kinto-instance\n$ heroku create && git push heroku master\n$ heroku open\n```\n\nWhat the fuck ? Have you ever used it ? Have you ever tried to copy-paste the lines ? What's wrong with you ? It's dirty and the argument \"But with this, you know it's bash command lines\" is bullshit. Learn how to use fucking markdown.\n\n```md\n```bash THIS means it's bash command lines\n$ Not that !\n```\n\nSo please, go fix your readme and open pull requests on repositories that do not respect conventions. It's good for you and it saves ponies."
		},
		{
			"post_id": 6,
			"title": "Let's talk about shebangs",
			"date_published": 1457365159.461,
			"body": "---\nShebangs are pretty useful. It allows you to tell which interpreter will be used. But, really often, you see misformed, dirty shebangs.\n\n---\n\n```\n#!/usr/bin/bash\n```\n\nThis is bad. Depending on the computer, it could work. Or maybe the exec path of bash is `/bin/bash`. Or maybe it's not system-wide installed. You have to use this kind of shebangs:\n\n```\n#!/usr/bin/env bash\n```\n\nWith this one, no problem. It will find the execution path correctly. But, I often see other dirty things. Something pretty awful, specitic to python language.\nToday, there are two versions of python still maintained and widely used. They are **python2** and **python3**. Even if python3 is 8 years old, a lot of people are still using python2. Why not. It's probably not the best thing to do, but using a language based on indentation is basically a bad idea. The problem is that depending on the machine, **python** may redirect to **python2** OR **python3**, YOU CANNOT KNOW.\nIt's why you HAVE TO use one of the following:\n\n```\n#!/usr/bin/env python2\n#!/usr/bin/env python3\n```\n\nNote that you have also access to **python2.7** and **python3.5**, but they are not really interesting, because if the guy updates his python to python3.6 when it will be available, your code will not work anymore."
		},
		{
			"post_id": 5,
			"title": "Welcome",
			"date_published": 1457356682.945,
			"body": "Hi all, here is my blog. I will share some tips here, and a little bit of rage, too."
		}
	]
}