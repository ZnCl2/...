{
	"comments": [
		{
			"comment_id": 1513857814009,
			"reference_type": "a",
			"reference_id": 1513857457850,
			"reference_auth_address": "1G5FwRWF7PRWos66wTcZPtFSbH7vQDnvNb",
			"body": "If you end up wanting to know how to do Vue's Single File Components (`.vue` files), you can also look at my ZeroExchange sourcecode on [GitHub](https://github.com/krixano/ZeroExchange) or [GitCenter](/17isV4gG9MmAwfcR6aroBN1nHmovrhodD4/) (which tends to be a little behind).",
			"date_added": 1513857814009
		},
		{
			"comment_id": 1513860249997,
			"reference_type": "a",
			"reference_id": 1513857457850,
			"reference_auth_address": "1G5FwRWF7PRWos66wTcZPtFSbH7vQDnvNb",
			"body": "When you have everything setup, if you are using my `gulpfile.js`, then you just run `gulp scripts` to build scripts, `gulp styles` to build styles, and `gulp html` to copy over html files form the src directory into the root. However, to use this, you need to install gulp globally by going `npm install -g gulp`. Also, the ability to include `.vue` files requires either vueify or vue-loader - ZeroExchange uses Vueify. For ZeroExchange, it is automatically done during the `gulp scripts` command. You can see this in the gulpfile on line 49 (`transform(vueify)`). With my gulpfile, I use browserify to aggregate all the js files into a bundle. It also allows you to do things like the vueify thing I mentioned previously.\n\nThis is kinda a lot to learn and remember right now. So, I would suggest learning about gulp and browserify and probably how to do sass with gulp as well.",
			"date_added": 1513860249997
		},
		{
			"comment_id": 1513922443971,
			"reference_type": "q",
			"reference_id": 1513915115209,
			"reference_auth_address": "164x9q7LJPLX4SMbhqLPraKAGZRPa2gTFe",
			"body": "btw, the Development topic for ZeroExchange includes all development-related questions, not just ZeroNet Dev questions.",
			"date_added": 1513922443971
		},
		{
			"comment_id": 1513931760771,
			"reference_type": "a",
			"reference_id": 1513924149507,
			"reference_auth_address": "12gAes6NzDS9E2q6Q1UXrpUdbPS6nvuBPu",
			"body": "You can, as long as `app` is global. What I was talking about though is sending info from component to parent. However, you can also send from parent to component in two different ways.\n\n1. using props. By using a prop, when you use the component, you set the prop as if it was an attribute on any other html element. You can bind variables to props in the same way by appending a colon to the beginning (or doing `v-bind:`, but just a colon is shorthand for that).\n2. attaching a function to an event emitted by the parent. Basically, whenever the parent uses $emit, you can set/attached a function to the event in your component. How you do this is like this: `this.$parent.$on('eventName', function)`. You should remember that if you want to modify data from the component, you cannot use `this`. Instead, you should make a new variable, usually called `that` or `self`, and set that to `this` outside of the function. Then you can use that variable inside the function.\n\nMost people will tell you that #2 is bad. However, I use #2 in ZeroExchange and ZeroMedium to get around certaint things with ZeroNet because the page's component is mounted before site information is set, so I just attach a function when the `userInfo` event is emited from the root vue instance, because when the site and user info has been set, it will then emit this event, and will call any functions that have been attached with `$on`.",
			"date_added": 1513931760771
		},
		{
			"comment_id": 1513932320646,
			"reference_type": "a",
			"reference_id": 1513924149507,
			"reference_auth_address": "12gAes6NzDS9E2q6Q1UXrpUdbPS6nvuBPu",
			"body": "I also use #2 to tell all of the pages to reload their data when the zite has been updated. This is used to dynamically load any new posts from users.",
			"date_added": 1513932320646
		},
		{
			"comment_id": 1514165727540,
			"reference_type": "q",
			"reference_id": 1514163593490,
			"reference_auth_address": "164x9q7LJPLX4SMbhqLPraKAGZRPa2gTFe",
			"body": "Hold on a little bit and I will answer this, I'm busy at the moment.",
			"date_added": 1514165727540
		},
		{
			"comment_id": 1514165961851,
			"reference_type": "a",
			"reference_id": 1513924149507,
			"reference_auth_address": "12gAes6NzDS9E2q6Q1UXrpUdbPS6nvuBPu",
			"body": "You should look up an article about using this inside functions. When using this, it goes to the object of the function. So, if you call a function from within a function, giving it a function, the word `this` inside that function you are passing to the function you are calling is *not* the same as `this` inside the function the function is being called from. Hopefully you understood that, but if you didn't, you should be able to find an article about this. It's one thing that is very stupid in JS, yet also has some reasoning behind it I guess.",
			"date_added": 1514165961851
		},
		{
			"comment_id": 1514295751881,
			"reference_type": "q",
			"reference_id": 1514293307849,
			"reference_auth_address": "1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di",
			"body": "I will fix this code box overflowing later - I'll add a horizontal scroll.",
			"date_added": 1514295751881
		},
		{
			"comment_id": 1514586373978,
			"reference_type": "q",
			"reference_id": 1514293307849,
			"reference_auth_address": "1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di",
			"body": "No, I haven't added horizontal scroll yet. I know I said I would, but I've just been taking a break. I am also gonna change tab size to 4 spaces.",
			"date_added": 1514586373978
		},
		{
			"comment_id": 1514599270372,
			"reference_type": "q",
			"reference_id": 1514293307849,
			"reference_auth_address": "1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di",
			"body": "I have pushed changes to fix the horizontal scroll and the tab size for code blocks.",
			"date_added": 1514599270372
		},
		{
			"comment_id": 1515391122799,
			"reference_type": "a",
			"reference_id": 1515239646111,
			"reference_auth_address": "1ETDBapTKwRan9V42jTWem8VAUEwBWdNFj",
			"body": "Sorry I didn't see this before, I was working on other things and ZeroExchange has been quiet for a while so I didn't think to look. I should really implement News Feed Following and Mentions on this zite soon.\n\nVueJs has their own coding practices where you are only supposed to send data to children using props and data to parents using events. However, Vue does provide, like you mentioned, a way to interact with events called by parent from children - but it isn't considered good practice by VueJs and its ecosystem. However, I don't particularly care for that coding practice so I use it anyways, but I only use it when absolutely needed.",
			"date_added": 1515391122799,
			"updated_date": 1519334593984
		},
		{
			"comment_id": 1555138074319,
			"reference_type": "a",
			"reference_id": 1554998561353,
			"reference_auth_address": "1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di",
			"body": "You should report that to @nofish.",
			"date_added": 1555138074319
		}
	],
	"answers": [
		{
			"answer_id": 1513924149507,
			"question_id": 1513915115209,
			"question_auth_address": "164x9q7LJPLX4SMbhqLPraKAGZRPa2gTFe",
			"body": "It looks like the main reason @Glightstar is using `$emit` is to send an event to the root. I think the main reason for him doing this is so that he can modify the data stored in the root vue instance. That is a difference between ZeroExchange and Thundote: I put the data related to a page inside the page's component, while he puts it in the root vue instance. *The difference between the two might depend on whether multiple components/pages (because my router that is used creates vue components for each page) use the same data.* If many different pages use the same data, then storing it inside the root would make sense because then it would remain the same no matter which page you are on and you wouldn't need to get the information from the database everything you go to a different page and come back. I don't do this in ZeroExchange because different pages would have to get different information from the database anyways. I would say more about Thundote, but I don't know much about the code, so instead I just gave what *could* be the reason why he stores the data in the root Vue instance.\n\nIf you look at ZeroExchange, there is one place where I store the data necessary for a page inside the page's vue component and then I use `$emit` for one of the components inside that page, the answer_list_item component. This allows the components to send an event to the parent component (the page) to modify the data in some way. A use for this would be having a component that has a button that needs to tell the parent to modify some data. In ZeroExchange, I have one emit that will send an event to the parent to mark a solution. This is because the button to mark a solution is inside the answer_list_item component. This allows me to reference the question's id and other information from the Question's page rather than from the answer component, because this component isn't passed in the question's information, it's only passed in the answer's information. However, I do still need to give the Question page the information of the answer that is to be marked as the solution, so I can pass that into the `$emit` like so: `this.$emit(\"mark-solution\", this.answer.answer_id, this.getAuthAddress);`\n\nI hope this helps to explain the main difference between how Thundote does it and how ZeroExchange does it and gives you more of an idea about how they actually aren't *that* different and why ZeroExchange does it the way it does.",
			"date_added": 1513924149507
		},
		{
			"answer_id": 1514449705483,
			"question_id": 1514163593490,
			"question_auth_address": "164x9q7LJPLX4SMbhqLPraKAGZRPa2gTFe",
			"body": "Okay, so firstly, if you are using the setup that I used for ZeroMedium and ZeroExchange, `import` and `export` statements are not supported. Instead you use `require` and `module.exports`. This is because my setup uses Browserify to handle the imports and exports when creating the bundle and by default, browserify uses require instead of import. However, there may be some type of setting to use `import` instead, I'm not sure about this.\n\nNext, you are trying to import a css file into javascript, which doesn't really make sense. You mention in the gulpfile about the styles task. What this task is doing is searching for all sass files inside the `src/sass` directory and bundling them together. The `includePaths` thing that you also mention is telling gulp that if it sees any import statements inside the sass files, that one of the places to look for the files is in the `node_modules` directory. What this will essentially do is allow you to import file without having to put the full path of the `node_modules` directory at the beginning of the file being imported.\n\nIn order to import a css file, you just import it from the sass file. So, what you want to do is create a main sass file, and import your sass and css files from that. Here is an example from ZeroExchange in the `main.sass` file:\n\n```sass\n@import \"node_modules/materialize-css/sass/materialize\"\n```",
			"date_added": 1514449705483
		}
	]
}