{
	"title": "GomZik's Blog",
	"description": "Русскоязычный блог\nо ZeroNet и не только\nглазами разработчика",
	"links": "[GomZik@ZeroMe](http://127.0.0.1:43110/Me.ZeroNetwork.bit/?Profile/1RedkCkVaXuVXrqCMpoXQS29bwaqsuFdL/1F6BMqittjWUStzUbRXm2kG2GQ3RdBLqFQ/gomzik@zeroid.bit)",
	"next_post_id": 21,
	"demo": false,
	"modified": 1576055343,
	"post": [
		{
			"post_id": 20,
			"title": "Elm-ZeroNet",
			"date_published": 1576055292.217,
			"body": "> It's been a looong time\n> \n> — <cite>GLaDOS</cite>\n\nДа, действительно, давненько блог не обновлялся. Не смотря на это - я все еще горячо люблю ZeroNet, хоть и руки в последнее время было не особо добирались. Но, вот он я, вернулся. Не знаю правда, насколько долго в этот раз, но по крайней мере с каким-никаким, да контрибьюшеном.\n\nКаким? Что ж. Именно за этим я и пишу эту заметку. Сейчас все расскажу!\n\n* * *\n\n## tldr;\n\nВ последнее время очень увлекся языком Elm и подумал, что было бы классно скрестить две замечательные вещи - Elm и ZeroNet. Задумался я об этом [год назад](http://127.0.0.1:43110/Me.ZeroNetwork.bit/?Post/1RedkCkVaXuVXrqCMpoXQS29bwaqsuFdL/1F6BMqittjWUStzUbRXm2kG2GQ3RdBLqFQ/1548865383), и совсем недавно дошли руки (и появилось достаточно опыта), что бы сделать это. Elm - знакомое слово? Тогда вот [репозиторий (Git Center)](http://127.0.0.1:43110/19ZNbKNRKFfL5nQHRs6h5L1zsoic87u55A), вот [демо страничка](http://127.0.0.1:43110/1ANAneTCtamh2dgZrJWNPNMTEX8iXKawPg), наслаждайтесь! Ах да, все это глубокое пре альфа, использовать на свой страх и риск, ишьюс и пулреквестс приветствуются.\n\nВсех же интересующихся деталями - предлагаю читать дальше.\n\n## Предыстория\n\nИтак, Elm. Наткнулся я на него совершенно случайно, далеко не сразу вообще вдуплил, что происходит (до этого, можно считать, не было опыта работы с функциональными языками программирования), но почему-то стало очень любопытно. Я уже сейчас и не скажу, как долго я на него смотрел, судя по всему с разной периодичностью я тыкаю в него года полтора (я просто очень удивился, что уже почти [год прошел](http://127.0.0.1:43110/Me.ZeroNetwork.bit/?Post/1RedkCkVaXuVXrqCMpoXQS29bwaqsuFdL/1F6BMqittjWUStzUbRXm2kG2GQ3RdBLqFQ/1548865383) с тех пор, как я в прошлый раз заходил в ZeroNet и высказывал свой интерес к Elm).\n\nЛадно, немного о том, что есть Elm вообще. Elm - функциональный, компилируемый в JS язык программирования. Киллер фичи, на мой взгляд, типизация, описание ошибок компиляции и тот факт, что если ваша программа скомпилировалась, то она не упадет, да, от логических багов вас никто не страхует, это само собой, но вот именно крешей быть не должно. Почему я говорю не должно? Что же, есть все же класс ситуаций, когда это может случится. Самый очевидный - взаимодействие с JavaScript кодом с помощью портов.\n\nВ любом гайде про Elm вы скорее всего встретите упоминание о The Elm Architecture (TEA). Грубо говоря, это описание того, как работают ваши приложения в Elm. Я все это пересказывать не буду, в конце статьи вы найдете ссылки на некоторые ресурсы. Важно лишь отметить, что и Elm, и TEA, все это было заточено для самостоятельных frontend приложений и уж точно никто не рассчитывал на такую экзотику как ZeroNet.\n\n## Окей, так что не так то?\n\nДело в том, как именно работает ZeroNet. Он помещает любой сайт в IFrame песочницу и делает недоступными некоторые методы, предлагая альтернативные либо вообще никакие. В целом понятно почему это сделано так, да вот только это абсолютно ломает Elm, если его хочется использовать как язык для зайтостроения. А мне ведь хочется!\n\nПлюс, каждый зайт может сделать свою базу данных и опрашивать ее так же специальными командами любезно предоставленными для нас ZeroNet'ом. В противовес же, обычные Http запросы здесь теряют смысл, во всяком случае в том виде, в котором они есть сейчас. В общем, все это дело ломает стандартную поставку Elm.\n\nКазалось бы на этом статью можно было бы закончить... Однако...\n\n## Elm как пример хорошего дизайна\n\nБлагодаря функциональности портов (`ports`) я легко добавил все необходимое всего парой строк кода на JS. _На момент написания данной заметки уже есть мысли, что можно и того меньше_. А дальше? А дальше я сделал практически тоже самое, что делает TEA, только обернул это все дело в команды ZeroNet.\n\nЕще не могу не отметить, что написание этого инструментария не заняло и более недели ситуационного желания пописать кода. Работа конечно же не окончена, но определенно функциональности сейчас достаточно, чтобы написать простецкий чат или даже вот такой вот блог как этот.\n\n## Elm как пример плохого дизайна\n\n_(На самом деле нет, просто запрос весьма специфичный)_\n\nДело в том, что на сегодняшний день создателем Elm было решено убить поддержку модулей, в поставке которых идет JavaScript код. Я прекрасно понимаю сие решение, оно описано [тут](https://discourse.elm-lang.org/t/native-code-in-0-19/826) (ссылка на эти ваши интернетики ака клирнет). Все доводы имеют смысл, тем не менее, есть мааааааленький процент ситуаций (интеграция с ZeroNet, например), где это мешает.\n\nКак же именно? Да очень просто, я не могу сделать из своих наработок модуль, который достаточно поставить пакетным менеджером, сделать импорт и полетели. Вместо этого, по крайней мере на текущий момент, я вынужден предлагать вам буквально скопировать (склонировать) репозиторий и заменить все, что написано в `Main.elm` на свое приложение, опираясь на примеры, которые там, в `Main.elm`, и описаны.\n\n## Стоп, стоп, стоп, что? О чем речь вообще?\n\nЯ такой сумбурный и не последовательный. Вернемся немного назад. Я хотел скрестить ежа с ужом, Elm и ZeroNet. Да, я прекрасно отдаю себе отчет о том, что количество людей интересующихся Elm'ом в пересечении с количеством людей, интересующихся ZeroNet, стремится к нулю. Что ж. Есть как минимум я! А себя я люблю! После Elm'a к этим вашим джаваскриптам уже и притрагиваться не хочется :)\n\nСказано - сделано. Представляю вашему вниманию [Elm-ZeroNet](http://127.0.0.1:43110/19ZNbKNRKFfL5nQHRs6h5L1zsoic87u55A)! На текущий момент поддерживается следующие ZeroFrame API\n\n*   pushState (упс, я не сделал popState и дошло это до меня только вот при написании этой заметки)\n*   Запись и чтение файла (fileGet, fileWrite)\n*   Нотификации враппера (wrapperNotification)\n*   Выбор пользовательского сертификата (certSelect) и подписка на его обновление\n*   Подписка на обновление файла (file_done)\n*   Запросы в базу данных (dbQuery)\n\nВ планах еще есть некоторый рефакторинг подписок, добавление Merger API, а так же Crypt API. Это в первую очередь. Потом в каком либо порядке опциональные файлы, фид, мьют.\n\nТак же планирую переделать [демо страничку](http://127.0.0.1:43110/1ANAneTCtamh2dgZrJWNPNMTEX8iXKawPg/) так, чтобы это стало больше похоже на документацию и демонстрацию.\n\nНа сим пока все, как там говорится обычно? Stay tuned :)\n\n## Ссылки\n\n*   [Elm](https://elm-lang.org/)\n*   [Elm and TEA Guide](https://guide.elm-lang.org/)\n*   [Elm-ZeroNet GitCenter](http://127.0.0.1:43110/19ZNbKNRKFfL5nQHRs6h5L1zsoic87u55A)\n*   [Elm-ZeroNet GitHub](https://github.com/GomZik/elm-zeronet)\n*   [Elm-ZeroNet Demo page](http://127.0.0.1:43110/1ANAneTCtamh2dgZrJWNPNMTEX8iXKawPg/)"
		},
		{
			"post_id": 19,
			"title": "Пишем свой зайт с нуля: еще немного прокачиваем роутер",
			"date_published": 1499963997.815,
			"body": "Совсем маленькая заметка о том, как сделать наш роутер еще немного лучше!\n\n* * *\n\nПосмотрев на этот кошмар:\n\n```html\n<a :href=\"router.url('test', {param: 123})\" @click=\"router.go('test', {param: 123}, $event)\">Test link</a>\n```\n\nПонял, что это очень сильно отличается от того, что я вижу при использовании Vue-router в обычном вебе и решил немного поправить данную несправедливость.\n\nДобавим файл `components/router_link.js`:\n\n```js\nimport router from 'router.js'\n\nfunction guardEvent(event) {\n  if (event && (event.ctrlKey || event.metaKey)) return\n  if (event) event.preventDefault()\n  return true\n}\n\nexport default {\n  name: 'router-link',\n  props: ['to', 'params'],\n  render: function(h) {\n    console.log(this.to, this.params)\n    let on = {\n      click: event => {\n        if (guardEvent(event)) {\n          router.go(this.to, this.params)\n        }\n      }\n    }\n    const data = {\n      on, attrs: {href: router.url(this.to, this.params)}\n    }\n    return h('a', data, this.$slots.default)\n  }\n}\n```\n\nА так же уберем строки из метода `go` нашего роутера:\n\n```js\n  // В сигнатуре метода стоит убрать параметр event\n  // ...\n  if (event && (event.ctrlKey || event.metaKey)) return\n  if (event) event.preventDefault()\n  // ...\n```\n\nДалее в наши компоненты мы заимпортируем наш свежеиспеченный `router_link.js` и начнем использовать его в разметке:\n\n```js\nimport RouterLink from 'components/router_link.js'\n// ...\nexport default {\n  // ...\n  components: { // ...\n    RouterLink\n  }\n}\n```\n\n```html\n<router-link to=\"test\" :params=\"{param: 123}\">Test Link</router-link>\n```\n\nНу ведь гораздо приятнее же, не так ли?\n\n### PS\n\nДа, я несколько задержииваюсь с дальнейшей разработкой, но не беда, я расковыряю детали по мерджеру и базам данных в ZeroNet и обязательно напишу об этом."
		},
		{
			"post_id": 17,
			"title": "Пишем свой зайт с нуля: прокачиваем роутер",
			"date_published": 1496762669.769,
			"body": "Итак, в прошлом уроке мы сделали самый-самый простенький роутер, в этом мы попробуем превратить его в крутой роутер с интеграцией с ZeroFrame API.\n\nДля начала - давайте определим, чего нам не хватает:\n\n*   При переходе со страницу на страницу, URL в строке браузера не меняется\n*   Нельзя по прямому URL перейти на необходимую страницу\n*   Не хватает параметризации URL\n\nЧто ж, сегодня попробуем это все поправить. Приступим?\n\n* * *\n\nНачнем с того, что реализуем клик по ссылке, который меняет URL в строке браузера, одновременно с этим мы сделаем параметризированные URL'ы\n\nДля этого идем в наш `src/router.js` и модифицируем его следующим образом:\n\n```js\n// ...\nimport pathToRegexp from 'path-to-regexp'\n\nimport ZeroApi from 'zero_api.js'\n// ...\n\nconst router = new Vue({\n  // ...\n  data: {\n    //...\n    routeParams: null\n  },\n  methods: {\n    go: function(to, params = {}) {\n      const url = this.relativeUrl(to, params)\n\n      /**\n       * Инструкция для ZeroFrame API, которая позволяет поменять URL браузера\n       * В качестве параметров можно передать объект-состояние, который поможет\n       * восстановить страницу при нажатии кнопки \"Назад\" в браузере\n       * (например {scrollTop: 100}), вторым параметром - тайтл новой страницы\n       * третьим - урл новой страницы.\n       * Интерфейс аналогичен соответствующему методу в HTML5 History API\n       * ZeroNet wrapper в итоге установит урл в строке браузера вида\n       * http://127.0.0.1:43110/<zite_address>/?<url>\n       */\n      ZeroApi.api().cmd('wrapperPushState', [{}, '', url])\n      this.route(url)\n    },\n\n    relativeUrl: function(to, params = {}) {\n      const route = this.routes.find(x => x.name === for_route)\n      const url = pathToRegexp.compile(route.path)(params)\n      return url\n    },\n\n    route: function(url) {\n      let matchedRoute = null\n      let params = null\n\n      // Находим подходящий route, устанавливаем соответствующий компонент\n      // Сохраняем внутри роутера параметры.\n      for (const route of this.routes) {\n        let keys = []\n        const re = pathToRegexp(route.path, keys)\n        const result = re.exec(url)\n        if (result !== null) {\n          matchedRoute = route\n          params = {}\n          keys.forEach((item, index) => {\n            params[item.name] = result[index + 1]\n          })\n          break\n        }\n      }\n\n      if (matchedRoute) {\n        this.currentView = matchedRoute.component\n        this.routeParams = params\n      }\n    }\n  }\n}\n// ...\n```\n\nДля эксперимента, сделаем особую ссылку с параметрами на Library, а в Library попытаемся их считать. В верху нашего `src/router.js`\n\n```js\nconst routes = [\n  // ...\n  {path: '/test/:param', name: 'test', component: 'library'} // А может это уже было добавлено в прошлом уроке?\n]\n```\n\nДелаем ссылку внутри `src/components/home.vue`\n\n```html\n<a href=\"javascript:;\" @click.prevent=\"router.go('test', {param: 123})\">Test link</a>\n```\n\nА внутри `src/components/library.vue`:\n\n```html\n<!-- Используем $data для доступа к raw объекту, без навешанных сеттеров-геттеров Vue -->\n<pre>{{ router.$data.routeParams }}</pre>\n```\n\nотобразим параметры, которые пришли из router. Теперь можем и поиграться с нашими ссылками. Обращаем внимание на то, что ссылки в браузере меняются. Однако, стоит нам обновить страницу используя F5 (кнопку обновить), мы, вне зависимости от того, где находились, снова придем на главную. К тому же, если в браузере нажать кнопку назад, мы также не вернемся на предыдущую страницу. Давайте же исправим это.\n\nСнова идем в наш `src/router.js`:\n\n```js\nconst router = new Vue({\n  data: {/*...*/},\n\n  computed: {\n    apiConnected: function() {\n      return ZeroApi.connected\n    }\n  },\n\n  watch: {\n    apiConnected: function(val) {\n      this.onConnect(val)\n    }\n  },\n\n  created: function() {\n    this.onConnect(this.apiConnected)\n  }\n\n  methods: {\n    // ...\n    // Как только ZeroFrame связался с ZeroNet сервером, мы определяем текущий\n    // URL, переходим на нужную страницу, а так же подписываемся на событие\n    // которое означает, что пользователь нажал кнопку назад в браузере.\n    onConnect: function(isConnected) {\n      if (!isConnected) {\n        return\n      }\n\n      this.route(this.getUrl(base.href))\n\n      ZeroApi.api().subscribe('wrapperPopState', (msg) => {\n        this.route(this.getUrl(msg.params.href))\n      })\n    },\n\n    getUrl: function(fullUrl) {\n      let url\n      if (fullUrl.indexOf('?') === -1) {\n        url = ''\n      } else {\n        url = fullUrl.replace(/.*?\\?/, \"\")\n      }\n      return url\n    }\n  }\n})\n```\n\nТеперь можно не только поиграть с сылками, но и с кнопками \"Назад\" и \"Обновить\".\n\n## В качестве бонуса\n\nОчень не хватает возможности нажать на ссылку правой кнопкой и нажать что-то вроде \"Открыть в новой вкладке\", такое же поведение есть при нажатии на среднюю кнопку мыши (колесико), такое же поведение есть при нажатии на ссылку обычным кликом с зажатым ctrl.\n\nНа самом деле, для этого нужно сделать две вещи:\n\n*   Подставить в `<a href=\"\">` настоящую ссылку\n*   Изменить `@click` обработчик, чтобы передать событие браузера в метод `go`, чтобы мы могли определить, нажата ли кнопка ctrl\n\nВ последний раз в этом уроке перейдем в `src/router.js` и добавим туда следующее:\n\n```js\nconst router = new Vue({\n  data: {/*...*/},\n  // ...\n  methods: {\n    // ...\n    go: function(to, params={}, event) {\n      // Если зажат ctrl или meta (насколько я знаю, это так работает в Mac-ах\n      // работаем так, как обычно работает браузер\n      if (event && (event.ctrlKey || event.metaKey)) return\n      // Отменяем дефолтное поведение (переход по ссылке)\n      if (event) event.preventDefault()\n\n      // Весь остальной код метода\n      // ...\n    },\n    // ...\n    // Данный метод вернет нам полный URL, включая часть с \n    // http://127.0.0.1:43110/<zite_address>/?/<url_to_route>\n    url: function(for_route, params = {}) {\n      const url = this.relativeUrl(for_route, params)\n      const absoluteUrl = base.href.split(/[?#]/)[0] + '?' + url;\n      return absoluteUrl\n    }\n  }\n})\n```\n\nТеперь нам нужно пройтись по всем местам, где есть ссылки и поменять их на что-то вроде:\n\n```html\n<a :href=\"router.url('test', {param: 123})\" @click=\"router.go('test', {param: 123}, $event)\">Test link</a>\n```\n\nТ.е. меняем `@click.prevent=\"router.go(...)\"` на `@click=\"router.go(..., $event)\"`, а так же изменить значение `href`, сделав его привязанным `:href=\"router.url(...)\"`. Все, теперь можно открывать ссылки в новой вкладке, так, как будто перед нами самый обычный сайт.\n\nНа текущий момент, разработка зайта ведется по адресу [http://localhost:43110/1JMNrd9FD19AhWVukYJ2gdxAiK2ohczwk5/](http://localhost:43110/1JMNrd9FD19AhWVukYJ2gdxAiK2ohczwk5/), там уже реализовано какое-то подобие плеера, однако оно сразу начинает проигрывать, будьте внимательны.\n\n**Внимание, вопрос!** Рассказывать ли в следующем уроке о создании плеера, учитывая, что там нет ничего, что связанно с ZeroNet и взаимодействием с ZeroFrame API?"
		},
		{
			"post_id": 16,
			"title": "Пишем свой зайт с нуля: свой простейший роутер",
			"date_published": 1495980093.623,
			"body": "Мы собираемся писать довольно большое приложение. В планах конечно же будет сам проигрыватель, возможность добавить музыку в общую базу, обязательно хочу добавить функцию \"Моя библиотека\", куда и будут попадать любимые треки пользователя. Любой плеер так же должен иметь возможность управлять плейлистами. Ну и конечно же, мы должны иметь возможность дать ссылку на трек другому пользователю ZeroNet. В общем без роутера нам не обойтись. Как я уже упоминал, Vue-router нам не подходит из-за специфики работы ZeroNet. В этой статье мы и попробуем решить проблему раутинга своими силами.\n\n* * *\n\nДля того, чтобы сделать свой набросок роутера, я изучал как делает раутинг в своих проектах Nofish, а так же изучал, как именно работает стандартный роутер Vue-router. Попробуем собрать это все воедино. Но сначала небольшая подготовка. Сделаем два небольших компонента, чтобы тестировать наш роутер. Пусть они будут называться Home, где в планах мы сделаем что-то для открытия новой музыки (может быть для начала - последние поступления в базе) и Library, где, как уже было отмечено выше, пользователь будет управлять своей музыкой (все по взрослому, да :)). Пока они будут максимально простыми и пустыми, к ним мы обязательно вернемся в более поздних статьях.\n\nИтак, создаем файл `src/components/home.vue` с простым содержимым:\n\n```vue\n<template>\n  <div>\n    <h1>Home</h1>\n  </div>\n</template>\n\n<style scoped>\n</style>\n\n<script>\nexport default {\n  data: () => {\n    return {}\n  }\n}\n</script>\n```\n\nДобавим его вместо нашего Hello, world'a в `src/components/app.vue`:\n\n```vue\n<template>\n  <div>\n    <home></home>\n  </div>\n</template>\n\n<style scoped>\n</style>\n\n<script>\nimport Vue from 'vue'\nimport ZeroApi from 'zero_api.js'\n\nimport Home from './home.vue'\n\nexport default {\n  data: () => {\n    return {\n      api: ZeroApi\n    }\n  },\n\n  components: {\n    Home\n  }\n}\n</script>\n```\n\nОбновив страницу, увидим надпись большими буквами **Home**.\n\nТеперь проделаем тоже самое с компонентом Library, `src/components/library.vue`:\n\n```vue\n<template>\n  <div>\n    <h1>Library</h1>\n  </div>\n</template>\n\n<style scoped>\n</style>\n\n<script>\nexport default {\n  data: () => {\n    return {}\n  }\n}\n</script>\n```\n\nИ также можем добавить его в наш `src/components/app.vue`:\n\n```vue\n<...>\n<home></home>\n<library></library>\n<...>\n<script>\n<...>\nimport Library from './library.js'\n<...>\ncomponents: {\n  Home, Library\n}\n<...>\n```\n\nИтак, теперь у нас есть два компонента, между которыми мы хотели бы переключаться, приступим же к роутеру. Для начала установим `path-to-regexp`, который используется для парсинга путей в Vue-router, дабы не заниматься какими-то непонятными парсингами. В терминале, в корне проекта набираем:\n\n```bash\nnpm install --save path-to-regexp\n```\n\nСделаем набросок нашего роутера, создаем `src/router.js`\n\n```javascript\nconst routes = [\n  {path: '', name: 'home', component: 'home'},\n  {path: '/my', name: 'library', component: 'library'},\n  {path: '/test/:param', name: 'test', component: 'library'} // Это для тестирования параметризованных урлов.\n]\n\nconst router = new Vue({\n  data: {\n    currentView: 'home', // Имя компонента, которое активно на текущий момент\n    routes\n  }\n})\n\nexport default router\n```\n\nЭто лишь набросок, а не работающий роутер, пробуем так сказать идти сверху, как бы мы им пользовались.\n\nДавайте теперь заставим наш App выводить лишь активный компонент. Добавим router в секцию data нашего приложения\n\n```javascript\n// ...\nimport router from 'router.js'\n//...\nexport default {\n  data: () => {\n    return {//...\n      router\n    }\n  }\n}\n```\n\nи заменим в темплейте приложения наши два новых компонента на такую конструкцию\n\n```html\n<!-- ... -->\n<!-- <home></home>\n</library></library> -->\n<keep-alive>\n  <component :is=\"router.currentView\"></component>\n</keep-alive>\n<!-- ... -->\n```\n\nОбновив страницу увидим лишь Home и более ничего. Попробуем сделать ссылку на Library. Идем в `src/components/home.vue` и проделаем такие вещи (представим, что наш роутер уже работает):\n\n```vue\n<template>\n  <div>\n    <h1>Home</h1>\n    <a href=\"javascript:;\" @click.prevent=\"router.go('library')\">Library</a>\n  </div>\n</template>\n\n<style scoped>\n</style>\n\n<script>\nimport router from 'router'\n\nexport default {\n  data: () => {\n    return {\n      router\n    }\n  }\n}\n</script>\n```\n\nКонечно же, работать сейчас ничего не будет, но давайте попробуем сделать что-то простое, чтобы заработало! Возвращаемся в `router.js` и пробуем заимплементировать метод go\n\n```javascript\n// ...\nconst router = new Vue({\n  data: { /*...*/ },\n  methods: {\n    go: function(to) {\n      const matchedRoute = this.routes.find(x => x.name === to)\n      if (matchedRoute !== undefined) {\n        this.currentView = matchedRoute.component\n      }\n    }\n  }\n})\n// ...\n```\n\nВот таким вот простым способом мы уже добавили интерактивность в наш зайт. Для тестов сделаем обратную ссылку из Library на Home (справитесь без вставки кода?) и можем уже обновить страницу и поиграться с этими переходами от Home к Library и обратно.\n\nОднако надо отметить, нам этого совсем недостаточно. Во-первых, мы бы хотели менять URL в адресной строке, в зависимости от того, где мы находимся. Во вторых, часто необходима возможность использовать параметризованные переходы. Например, когда мы открываем страницу какой-то группы, не важно, какая именно группа выбрана, компонент будет один и тот же, но будет он выводить разные списки альбомов, разную картинку артиста и тому подобное. Очевидно, наш роутер совсем еще детский и надо что-то с этим делать. Текста уже вышло как-то много, так что я думаю, мы это все исправим уже в следующей статье."
		},
		{
			"post_id": 15,
			"title": "Пишем свой зайт с нуля: ZeroNet Hello world",
			"date_published": 1495841163.532,
			"body": "_В этом уроке мы создадим стартовую страницу для нового сайта, но своим путем_.\n\nВ прошлом уроке мы подготовили окружение для разработки. Маленькое замечание к предыдущей статье:\n\nМожно было бы сделать еще лучше, и перенести папку с проектом куда-то в отдельное место, оставив в папке с ZeroNet лишь симлинку (справедливо для *nix-based систем). Делается это просто\n\n```bash\ncd <path to zeronet>/data/\nmv <our site address> ~/prg/zeronet/\nln -s /home/<user>/prg/zeronet/<our site address> ./\n```\n\nТаким образом мы вполне себе можем инициализировать например тот же git репозиторий в этой папке, однако не забудьте добавить `.git` в `ignore` ключ файла content.json\n\nА теперь начнем восстановление стандартной страницы с использованием наших \"современных\" штук.\n\n* * *\n\n## Перенесем `ZeroFrame.js` в папку `src`\n\nДля начала нам стоит сделать `ZeroFrame.js` доступным из нашего проекта через `import`. Для этого сделаем пару модификаций, перенесем файл `js/ZeroFrame.js` в `src/ZeroFrame.js`, а так же слегка модифицируем его, добавив в самый конец одну единственную строчку\n\n```javascript\nexport default ZeroFrame\n```\n\n## Создадим VueJS приложение\n\nСоздадим новый файл, например `src/components/app.vue` и опишем наше Hello, world! приложение:\n\n```vue\n<template>\n  <div>\n    <h1>Hello, world</h1>\n  </div>\n</template>\n\n<style scoped>\n</style>\n\n<script>\nimport Vue from 'vue'\n\nexport default {\n  data: () => {\n    return {}\n  }\n}\n</script>\n```\n\nА теперь, что бы что-то заработало, нам нужно сделать две вещи.\n\nИдем в `src/index.js` и пишем там всего пару строк\n\n```javascript\n\nimport Vue from 'vue'\n\nimport App from 'components/app.vue'\n\nconst app = new Vue({\n\n  render: h => h(App)\n\n}).$mount('#app')\n```\n\nУказываем VueJS где будет располагаться наше приложение. Так же нам нужно создать соответствующий элемент в нашей изначальной верстке, т.е. в `index.html`\n\nВо первых там стоит убрать все теги `<script>` кроме того, что мы написали в прошлый раз, а также добавить `<div id=\"app\"></div>`. Ваш итоговый html файл должен выглядеть следующим образом:\n\n```html\n\n<!DOCTYPE html>\n\n<html>\n<head>\n <title>New ZeroNet site!</title>\n <meta charset=\"utf-8\">\n <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />\n <base href=\"\" target=\"_top\" id=\"base\">\n <script>base.href = document.location.href.replace(\"/media\", \"\").replace(\"index.html\", \"\").replace(/[&?]wrapper=False/, \"\").replace(/[&?]wrapper_nonce=[A-Za-z0-9]+/, \"\")</script>\n</head>\n<body>\n\n<div id=\"app\"></div>\n\n<script type=\"text/javascript\" src=\"js/all.js\"></script>\n\n</body>\n</html>\n```\n\nНа текущий момент, вызвав `./node_modules/.bin/webpack` (а можно запустить его в watch режиме используюя `./node_modules/.bin/webpack -w`), а после, зайдя на свой зайт, мы легко должны увидеть надпись `Hello, world!`.\n\nДа, это все выглядит слишком многословно, для хелловорда, но мы обязательно еще ощутим профит от всей этой навороченности!\n\n## Подключаемся к ZeroNet API\n\nСледующим шагом мы выведем информацию о зайте точно так же, как это было сделано до того, как мы полезли своими ручками в проект.\n\nК сожалению, мистер Nofish создал свой ZeroFrame API с расчетом, что его будут использовать несколько иначе, однако мы все же сделаем некоторые шаги, чтобы использование ZeroFrame API было можно сказать нативным с точки зрения проекта на VueJS.\n\nТак что создадим свой `src/zero_api.js`, где и будем делать, так сказать, слой совместимости. Импортируем оригинальный `ZeroFrame.js`, наследуемся от класса, добавляем необходимые методы и оборачиваем это в инстанс Vue объекта.\n\n```javascript\n\nimport ZeroFrame from 'ZeroFrame.js'\nimport Vue from 'vue'\n\nclass App extends ZeroFrame {\n  init() {\n    this.subscribers = {}\n  }\n\n  setSiteInfo(siteInfo) {\n    apiWrapper.siteInfo = siteInfo\n  }\n\n  onOpenWebsocket() {\n    apiWrapper.connected = true\n    this.cmd(\"siteInfo\", [], siteInfo => {\n      this.setSiteInfo(siteInfo)\n    })\n  }\n\n  onRequest(cmd, msg) {\n    if (this.subscribers[cmd] !== undefined) {\n      this.subscribers[cmd].forEach(cb => {\n        cb(msg)\n      })\n    } else {\n      console.log('No listers for', cmd, msg)\n    }\n  }\n\n  subscribe(cmd, cb) {\n    if (this.subscribers[cmd] === undefined) {\n      this.subscribers[cmd] = []\n    }\n\n    this.subscribers[cmd].push(cb);\n  }\n}\n\nconst app = new App()\n\nconst apiWrapper = new Vue({\n  data: {\n    connected: false,\n    siteInfo: null\n  },\n\n  computed: {\n    siteModifiedDate: function() {\n      return new Date(this.siteInfo.content.modified*1000)\n    }\n  },\n\n  created: function() {\n    app.subscribe('setSiteInfo', msg => {\n      this.siteInfo = msg.params\n    })\n  },\n\n  methods: {\n    api: () => app,\n  }\n})\n\nexport default apiWrapper\n```\n\nПока так, криво и коряво, думаю чуть позже это все мы исправим, когда столкнемся с уже действительно частым и серьезным использованием ZeroFrame API\n\nНаверное стоит оставить немного пояснений: как только ZeroFrame сообщает нам, что он готов к использованию мы запрашиваем информацию о нашем зайте, а как только ее получим, запишем эту информацию в объект Vue, да бы иметь возможность использовать это информацию \"реактивно\" (т.е. как только она по каким-либо причинам обновится, благодаря самому Vue, все приложение об этом сразу узнает). Из модуля мы уже вернем инстанс Vue, но на всякий случай дадим ему возможность вернуть оригинальный ZeroFrame инстанс, позже придумаем, что с ним делать :)\n\nЗа деталями имеет смысл читать [оригинальную документацию](https://zeronet.readthedocs.io/en/latest/site_development/zeroframe_api_reference/). Она конечно не фонтан, но какую-то информацию предоставляет.\n\nЧто ж, осталось всего ничего, отобразить полученную информацию о зайте на странице. Для этого идем в наш `src/components/app.vue` и модифицируем его следующим образом:\n\n```vue\n<template>\n  <div>\n    <h1>Hello, world</h1>\n    <div>{{ api.connected ? 'Connected' : 'Disconnected' }}</div>\n    <template v-if=\"api.siteInfo !== null\">\n      <h2>Site Info</h2>\n      <p>Page address: {{ api.siteInfo.adress }}</p>\n      <p>- Peers: {{ api.siteInfo.peers }}</p>\n      <p>- Size: {{ api.siteInfo.settings.size }}</p>\n      <p>- Modified: {{ api.siteModifiedDate }} </p>\n    </template>\n  </div>\n</template>\n\n<style scoped>\n</style>\n\n<script>\nimport Vue from 'vue'\n\nimport ZeroApi from 'zero_api.js'\n\nexport default {\n  data: () => {\n    return {\n      api: ZeroApi,\n    }\n  }\n}\n</script>\n```\n\nОбновив наш зайт, мы увидим вcю ту же информацию, что видели при создании нового зайта. В качестве эксперимента, можно потянуть за \"нолик\" справа вверху, изменить Title или Description, сохранить и в течении пары секунд мы увидим, как Modified поле изменится на более актуальное.\n\nНа этом на сегодня все. В следующем уроке мы с вами начнем наконец двигаться к цели и делать что-то на пользу нашему приложению. Например напишем роутер, так как Vue-router, как оказалось, немного не готов для использования внутри iFrame, заменяет GET параметры, которые ZeroNet прокидывает в целях безопасности. К тому же, url в ZeroNet меняется иначе, нежели в обычных веб-приложениях."
		},
		{
			"post_id": 14,
			"title": "Пишем свой зайт с нуля: Окружение",
			"date_published": 1495821300.352,
			"body": "_Да, я уже пробовал что-то сделать с нуля. Да я уже пробовал рассказывать об этом в блоге. Ну и что. Попробую еще раз! Мой блог, что хочу, то и делаю!_\n\nВсем привет, сегодня мы в очередной раз попробуем написать что-нибудь с нуля! И дабы не тратить силы совсем впустую, я собираюсь рассказывать, как я делаю зайт для ZeroNet. Поэтому будем делать что-то полезное, по пути раскапывать особенности работы ZeroNet и отличия от обычного веба.\n\n* * *\n\nЯ по разным личным причинам немного связан с музыкой, потому и решил, что можно было бы попробовать написать музыкальный плеер, что-то похоже на Google Play Music и подобных. Почему-то на первый взгляд кажется, что использование Site Merger (Та самая штука, которая используется в ZeroMe) будет вполне себе уместно, ведь я планирую, чтобы каждый пользователь мог добавить в базу любую музыку. Сюда же конечно же войдет и авторизация (пользовательский контент иначе не сохранить, насколько я понимаю). Так же мы коснемся фичи опциональных файлов, не будем гонять всю возможную музыку по всему ZeroNet. Это конечно может вызвать проблемы с доступностью некоторых песен, но посмотрим что выйдет в конечном итоге.\n\nВообще странное дело. Я вроде как нахожусь по ту сторону баррикад, где хочется, чтобы музыку покупали, а сейчас собираюсь положить начало ~~удобному~~ (не факт) плееру без правообладателей. Наверное это потому что ту музыку, которую я выпускаю (не путать с исполняю, я на самом деле не музыкант) доступна бесплатно в MP3 320kbps, а вот уже FLAC раздаю за денюшку. Так что вроде как и так музыка бесплатная. В общем тут можно долго размышлять на тему пиратства, контента и прочего и да, должен сказать, что молодые артисты живут бедно, но я не думаю, что от зайта в зеронете вообще кто-то сильно пострадает.\n\nВообще я думаю, что по аналогии кто-нибудь может сесть и пилить рядом зайт с фильмами или сериалами (эдакий обновленный Play, что блуждал тут какое-то время назад, он вообще актуален сейчас?), буквально проходя данный цикл статей, это уже оставлю на откуп читателям.\n\nВижу уже сейчас несколько препятствий на пути к поставленной цели. Документации по мерджеру совсем нет. Если есть, то в руки она мне не попадалась, поэтому если вы знаете какие-либо ссылочки, будет очень полезно!\n\nНу что ж, хватит лить воду, поехали!\n\n## Создаем новый зайт\n\nБлагодаря нашему всеми любимому **Nofish**, это теперь вообще крайне просто! Нужно лишь зайти на домашнюю страницу ZeroNet (он же ZeroHello), нажать на три точки и выбрать кнопку **Create new site**\n\n![_______________2017-05-26_21-15-02.png (400x574)](data/img/post_14________________2017-05-26_21-15-02.png)\n\nПосле этого вас отправит на ваш свежесозданный сайт. Запоминаем адрес, потому что теперь мы возьмем в руки терминал и перейдем в эту папку.\n\n## Инициализируем окружение\n\nПрошло довольно много времени с предыдущих статей, опыта даже немного прибавилась. И даже сейчас я думаю, что VueJS отличный фреймворк для старта. Так что прямо как по предыдущим статьям, так и начнем\n\nСтавим webpack, babel, vuejs и все надлежащие штуки\n\n```bash\nnpm init -y\nnpm install --save babel-core babel-loader babel-polyfill babel-preset-es2015 css-loader vue vue-loader vue-template-compiler webpack\n```\n\nЯ не буду объяснять, что все это значит, рекомендую ознакомиться с предыдущими постами, там это все кое-как разжовывается, просто на текущий момент это, пожалуй, самый актуальный способ настроить свой проект к скриптингу с использованием VueJS.\n\n## Подготовим специфичный для ZeroNet файл content.json\n\nПо большей части, на текущий момент нам нужно сделать так, что бы наши девелоперские штуки не попадали в папки к конечным пользователям. Добавим все наши непонятные штуки в ключ `ignore` в content.json\n\n```javascript\n{\n...\n\"ignore\": \"((node_modules/.*)|(webpack.config.js)|(package.json)|(src/.*))\",\n...\n}\n```\n\nЯ храню исходные js файлы в папке src, однако конечного пользователя будет интересовать только собранные файлы. Поэтому мы исключаем папку src. Так же уберем из раздачи все, что связанно с папкой node_modules (туда npm поставил все наши зависимости), package.json (файл, в котором описаны все наши зависимости) и webpack.config.js (об этом файле читайте ниже).\n\n## Подготовим проект к сборке\n\nТак выглядит мой `webpack.config.js`. Опять же, вы можете прочитать о настройке в ранних статьях (внимание, немного отстало от реальности), или же на официальном сайте [тыц](https://webpack.js.org/concepts/configuration/)\n\n```javascript\n\nmodule.exports = {\n  entry: ['babel-polyfill', __dirname + '/src/index.js'],\n  output: {\n    path: __dirname + '/js',\n    filename: 'all.js'\n  },\n  module: {\n    loaders: [{\n      test: /\\.jsx?$/,\n      exclude: /node_modules/,\n      loader: 'babel-loader',\n      options: {\n        presets: ['es2015']\n      }\n    }, {\n      test: /\\.vue$/,\n      loader: 'vue-loader'\n    }]\n  },\n  resolve: {\n    modules: [\n      'src',\n      'node_modules'\n    ]\n  }\n}\n```\n\nСоздадим наш главный файл в `src/index.js`, можно для теста написать там\n\n```javascript\nconsole.log('Hello, world!')\n```\n\nчтобы проверить работоспособность, выполним команду\n\n```bash\n./node_modules/.bin/webpack\n```\n\nВ итоге в папке `js/` у нас появится файл `all.js`, в котором будет собран наш клиентский код, который и надо раздавать всем пирам.\n\n## Подключим собранный файл на страницу\n\nОткрываем index.html и добавим туда для начала строчку\n\n```html\n<script type=\"text/javascript\" src=\"js/all.js\"></script>\n```\n\nВ общем, подключаем наш собранный файл.\n\nВ следующей статье, я расскажу, как сделать ту же самую страницу, что была по-умолчанию, только с использованием всех наших прибамбасов и используюя VueJS"
		},
		{
			"post_id": 11,
			"title": "PlantUML",
			"date_published": 1471904398.664,
			"body": "Очень хочу, что бы ZeroNet продолжал развиваться и один из залогов развития, конечно же контент. Я сейчас не могу выделить достаточно времени, чтобы разбираться с особенностями зайтостроения, однако готов рассказать немного о своей повседневной технической жизни.\n\nСовсем недавно я сменил место работы и занимаемую позицию. Написание кода немного уменьшилось, однако интересной работы прибавилось.\n\nНа сегодняшний день я активно пользуюсь тремя инструментами: мой, довольно корявый, английский язык, гугл переводчик и [PlantUML](http://plantuml.com). Ну и если с первыми двумя все понятно, то на третьем я бы хотел остановиться подробнее.\n\n---\n\nВпервые я познакомился с этим инструментом около года назад. Восторга моему не было предела. После выпуска из универа, где-то раз в год я вспоминал, что нас учили проектированию с помощью UML. Конечно, пока я был неопытным разработчиком, рисовать диаграммы особо не приходилось, однако интерес к \"академическому\" проектированию ПО иногда просыпался. И вот я, такой весь из себя специалист, начинал искать инструменты для создания UML. Да ещё так, чтобы это работало под Linux. И что бы понятно и удобно.\n\nСколько всего мне пришлось пересмотреть и как сильно мне пришлось разочароваться. Основные способы сделать это - взять одну из существующих тулов, запустить и дальше возможны несколько вариантов:\n\n* Оно упадет\n* Оно будет выглядеть как ужасный Франкенштейн\n* Оно будет работать и даже выглядеть прилично, однако соединить объекты \"стрелочками\" было невозможно. Промахнулся на полпикселя, все, некрасивенько.\n\nКороче говоря, после некоторых попыток я бросал это занятие и забывал об этом.\n\nА через год все по новой.\n\nОднако где-то год назад, один добрый человек показал мне PlantUML. В первые несколько дней у меня было ощущение, что Интернет сговорился против меня и усердно скрывал эту штуку в самых недрах. Не индексируя. Не говоря об этом на StackOverflow. Никакого, как мне казалось, упоминания.\n\nЭто, в общем, такая тула, которая конвертирует вашу ASCII псевдографику в картинки. Тут проще показать пример. Предоставлю вам пару картинок и пару исходников для наглядности.\n\n```\n@startuml\nactor \"User\" as user\nparticipant \"Service\" as service\nparticipant \"3rd party\" as tp\n\n\nuser -> service : HTTP GET\nactivate service\nservice -> service : Do some work\nservice -> tp : Call webhook\nactivate tp\nservice -> user : HTTP 200 OK\ndeactivate service\ntp -> tp : Do some background job\ntp -> service : Callback\ndeactivate tp\nactivate service\nservice -> service : Change state\nservice -> tp : HTTP 200 OK\ndeactivate service\n@enduml\n```\n\n![Example 1](img/puml1.png)\n\nВот таким вот не сложным образом мы получаем так называемую Sequence Diagram.\n\nЕщё пример:\n\n```\n@startuml\nclass \"BaseClass\" as bc {\n    - private_field: integer\n    + public_field: string\n    + {static} static_method()\n    + {abstract} say_hi(name: string)\n}\n\nclass \"InheritedClass\" as ic {\n    + say_hi(name: string)\n}\n\nic --|> bc\n@enduml\n```\n\n![Example 2](img/puml2.png)\n\nИ вот перед нами диаграмма классов.\n\nСамое прекрасное, что это все можно положить под контроль версий (git например) и там будет видны изменения! Можно подключить это все добро в автоматический генератор документации.\n\nЯ настоятельно рекомендую разработчикам, лидам, архитекторам использовать данный инструмент.\n\nСпасибо за внимание!"
		},
		{
			"post_id": 9,
			"title": "Невероятно долгое отсутствие",
			"date_published": 1469746111.95,
			"body": "Созываю русскоязычное сообщество вернуться в мир ZeroNet. Скоро должна появится первая социальная сеть на технологиях ZeroNet, чего я так сильно и жду. В связи с этим, хочу как-то вернуть русскоязычное сообщество в сеть.\n\nВ планах есть вернуться к туториальным постам про ZeroNet. С обновленным ZeroTalk пока все заглохло, поэтому я думаю, что могу выделить немного свободного времени для оживления этого блога.\n\nСумбурная заметка под пивом. Простите :)"
		},
		{
			"post_id": 8,
			"title": "Я не умер",
			"date_published": 1460359451.209,
			"body": "Я все еще с вами, просто слишком много личных дел, с которыми хотелось бы разобраться. На текущий момент регулярно просматриваю всяческие обновления, но сам контента генерирую не много, за что и прошу у всех прощения..."
		},
		{
			"post_id": 7,
			"title": "Как я готовлю свой проект. Часть 2.",
			"date_published": 1455568141.159,
			"body": "_Первая часть тут, чуть ниже, но для ленивых - вот: [Как я готовлю свой проект](/blog.gomzik.bit/?Post:5:Как+я+готовлю+свой+проект)_\n\nСегодня мы поговорим про то, как к нашему добру подключить Vue.js\n\n---\n\nНо для начала поговорим о том, что такое [Vue.js](http://vuejs.org). Точнее скорее мы поговорим о том, что такое Vue.js моими глазами.\n\nКак я уже упоминал, я в первую очередь python-developer, который занимается в основном web'ом. Ну и по долгу службы приходится часто работать с JavaScript. Я прошел положенные [пять стадий](https://ru.wikipedia.org/wiki/%D0%9A%D1%8E%D0%B1%D0%BB%D0%B5%D1%80-%D0%A0%D0%BE%D1%81%D1%81,_%D0%AD%D0%BB%D0%B8%D0%B7%D0%B0%D0%B1%D0%B5%D1%82#.D0.9F.D1.8F.D1.82.D1.8C_.D1.81.D1.82.D0.B0.D0.B4.D0.B8.D0.B9_.D0.BF.D1.80.D0.B8.D0.BD.D1.8F.D1.82.D0.B8.D1.8F_.D1.81.D0.BC.D0.B5.D1.80.D1.82.D0.B8) до тех пор, пока не смог его даже полюбить. Так вот, пика этой любви я достиг познакомившись с Vue.js.\n\nОднако, как и все (ну или действительно очень многие), я начинал с jQuery, спаггети-кода, колбэчного ада и вот этого вот всего. Если вы как раз на этой стадии, то думаю вам стоит вдумчиво дочитать эту статью до конца.\n\nВ конце концов, после очередной задачи на работе, я понял, что мне это все порядком надоело, код стал очень тяжело модифицируем, искать причину бага тоже становилось все тяжелее и тяжелее. Я тогда только впервые услышал про [React.js](https://facebook.github.io/react/) да и он относительно недавно появился и только начинал вызывать бурление масс. С мыслью о том, что люди живут как-то проще, что им не нужно программировать пошагово, как из одного состояния перейти в другое, причем когда их штук 5 и все они друг в друга могут переходить между собой я обратился за помощью к другим командам в компании, где были именно специалисты frontend разработки.\n\nПередо мной стояла задача - облегчить жизнь себе и своим коллегам, а так же уметь работать (на тот момент еще) с IE7+. И да, мне очень подкупал на тот момент React. Выслушав мою боль и мои требования, ребята почти хором сказали: \"Тебе нужен [knockout.js](http://knockoutjs.com)\".\n\nИ вот знаете - мне понравилось! Писать код стало заметно проще. Заметно проще стало и понимать, что происходит не так. Были разве что пару неочевидных моментов в этом knockout'е, да и то, если вдумчиво читать (а с моим английским это иногда бывает трудно) то это будет на поверхности (или почти). Ну вот из-за всяких мелких нюансов я и начал поглядывать на то, что еще в мире JS существует.\n\nНу и как-то ненароком наткнулся я на Vue.js. Совершенно случайно. Листая какую-то связанную статью на хабре. В комментариях. Тогда оно еще было версии 0.12 или что-то около того. Потыкав на дому я понял, что мне оно нравится, однако требование к браузерам в виде IE9+ не позволило мне его попробовать в реальных проектах. Так оно и осталось в загашнике того, что я хочу обязательно попробовать.\n\nРелизнулась версия 1.0 и я понял, что дальше тянуть нельзя. Работу я уже сменил, требования к браузерам стали не такими жестокими. Да и сама MS их всех разом решила похоронить. К сожалению на новой работе я уже успел начать проект, в котором взял уже знакомый мне knockout.js, так что версию 1.0 изучать мне пришлось снова на дому. Особых конкретных отличий я не заметил, но вспомнил, что это то, с чем я хочу работать.\n\nЕсли коротко, то Vue.js для меня выглядит некоторым компромиссом между knockout.js (с его нюансами для поддержки старых браузеров) и React (который не нравится довольно многим за то, что пропагандирует шаблоны прямо в JS коде). У Vue.js хоть и не самое большое, но очень толковое сообщество, а автор библиотеки настолько радеет за свое детище, что понаписал дополнительных утилит к ней на все случаи жизни. И черт возьми, это просто прекрасно.\n\nВы можете использовать Vue.js и по старинке, подключив его скриптом к вашему документу, и с помощью ES6, и с помощью ES5, и есть адаптеры к webpack, которые позволяют держать компоненты в удобном, структурированном виде, и подсветка синтаксиса для популярных редакторов имеется (там есть особый формат, который идеально подходит для компонентной структуре, как по мне)\n\nПолучилось какое-то очень большое предисловие, но надеюсь я еще не успел вас утомить, ведь мы еще ничего полезного не сделали!\n\nНу так давайте же наконец попробуем этот ваш Vue.js! Итак, надеюсь вы все еще в директории с нашим проектом из прошлой статьи, а если нет, то уверен, вы быстро туда придете. Ставим Vue.js\n\n```bash\n$ npm install vue --save\n```\n\nНо одной библиотеки нам пожалуй мало. Раз уж мы решили использовать всю мощь Webpack, то ставим сюда же рядом [vue-loader](https://vuejs.github.io/vue-loader/). С ним есть некоторая трудность, ему нужно еще куча всего, чтобы работать правильно. Вот полная команда\n\n```bash\n$ npm install vue-loader vue-html-loader css-loader vue-style-loader babel-plugin-transform-runtime babel-runtime@5 --save\n```\n\nbabel-runtime умышленно используется 5-ой версии ([объяснение](https://github.com/vuejs/vue-loader/issues/96#issuecomment-162910917)).\n\nНу вот такие вот зависимости. Скорее всего автор просто очень радеет за гибкость и за то, чтобы многое можно было при желании заменить на что-то другое. Например, если мы будем для каскадных стилей использовать какой-то препроцессор (например stylus), нам достаточно будет установить его\n\n```bash\nnpm install stylus stylus-loader --save\n```\n\nи... Ну в общем сами все увидите, а то сложно объяснять, непонятно что.\n\nТак же мне нравится идея, которую продвигает facebook рядом со своим React.js про паттерн [flux](https://facebook.github.io/flux/). Довольно удачная идея, которая получила одну из реализаций от автора библиотеки Vue.js, и называется [Vuex](http://vuex.vuejs.org/en/index.html). Нам она тоже понадобиться для демонстрации.\n\n```bash\n$ npm install vuex --save\n```\n\nИтак, давайте же уже писать код!\n\nНам нужна небольшая правка в нашем webpack.config.js\n\n```javascript\nmodule.exports = {\n  //...\n  module: {\n    loaders: [\n      {test: /\\.js$/, exclude: /node_modules/, loader: 'babel'},\n      {test: /\\.vue$/, loader: 'vue'}\n    ]\n  }\n}\n```\n\nГоворим webpack'у, что файлы, которые оканчиваются на .vue мы должны грузить с помощью специального лоадера vue-loader.\n\nЗачем же мы все это делаем. Сейчас маленький примерчик и я начну объясняться. Очистим все, кроме самой первой строчки (напомню, это `import 'babel-polyfill'`) в нашем файле assets/index.js. Создадим файл assets/App.vue\n\nТут вы немного сейчас удивитесь. Пишем туда следующее\n```vue\n<script>\nimport MyButton from 'components/Button.vue'\nimport MyCounter from 'components/Counter.vue'\nimport store from 'store.js'\n\nexport default {\n  computed: {\n    counter() {\n      return store.state.counter\n    }\n  },\n\n  methods: {\n    buttonClicked() {\n      store.actions.increment()\n    }\n  },\n\n  components: {\n    MyButton, MyCounter\n  }\n}\n</script>\n\n<template>\n  <div class=\"app\">\n    <my-button @button-click=\"buttonClicked\">Click me!</my-button>\n    <my-counter :counter=\"counter\"></my-counter>\n  </div>\n</template>\n\n<style lang=\"stylus\">\n  body, html\n    margin 0\n    padding 0\n</style>\n\n<style lang=\"stylus\" scoped>\n.app\n  padding 10px\n  border 1px solid black\n</style>\n```\n\nТут мы объявили компонент в рекомендуемом для Vue.js стиле. Здесь одновременно все вместе, что удобно для компонента и в то же время раздельно (а не как в React.js)\n\nСначала мы объявляем секцию `<script />` в которой размещаем наш [ES6 скрипт][1][2] компонента. Ниже идет секция `<template />`  в котором мы пишем html разметку, связанную с этим компонентом.\n\nЕще ниже мы видим почему-то две секции `<style />`. Я просто для себя вывел такое правило, что в самом корневом компоненте (App в данном случае) я объявлю глобальные стили, которые накладываются на весь документ, и рядом объявлю стили локальные, которые работают только для этого компонента. За то, каким именно стиль является отвечает атрибут `scoped`. Его действие мы особенно хорошо заметим чуть позже.\n\nТак же внимательный читатель мог увидеть атрибут `lang` со значением `stylus`. Это собственно про то, что я говорил. Нравится вам какой-то другой язык, вы можете использовать его. Тоже самое касается и `<template />`, и `<script />`. Можно подставить туда CoffeeScript вполне спокойно (раз уж тут его любят, грех обойти :) ), сделав `lang=\"coffee\"` (не забудьте установить пакеты `coffe coffe-loader`)\n\nПосмотрим на секцию `<script />` внимательнее. Мы воспользовались предлагаемым автором Vue.js \"синтаксическим сахаром\" по объявлению компонента. Мы не импортируем библиотеку Vue.js явно и ни от чего не наследуемся. Однако экспортируемый объект должен быть определенной структуры. Подробнее читайте в документации, ссылки я собрал в конце статьи.\n\nПервым делом мы импортируем наши компоненты (которые мы пока еще не создали, ну да ладно), а так же, по идее flux, мы импортируем наш единый store (о нем тоже чуть позже).\n\nПользуясь сахаром ES6 мы просто перечисляем в атрибуте `components` объекта наши компоненты.\n\nТак же мы объявляем одно вычисляемое свойство (оно будет изменятся вместе с изменением нашего глобального состояния) и один метод (он же хэндлер).\n\nВ целом довольно просто.\n\nСледом очередь за `<template />`. Тут тоже есть несколько особенностей. Во-первых, мы вставляем наши компоненты используя немного модифицированное имя этого самого компонента. Во вторых, возле некоторых атрибутов мы видим странные символы `@` и `:`. Это такие сокращения, которые нам предоставляет Vue.js. Первый используется, чтобы подписаться на события дочернего компонента, а второй, чтобы \"прокинуть\" свойство из родительского контекста. В данном случае мы прокидываем наше вычисляемое свойство `counter`.\n\nВ целом тут вроде и все. Я приведу код components/Button.vue и components/Counter.vue без комментариев, так как там все даже проще, чем здесь.\n\nassets/components/Counter.vue\n```vue\n<script>\n  export default {\n    props: ['counter']\n  }\n</script>\n\n<template>\n  <p>{{ counter }}</p>\n</template>\n\n<style lang=\"stylus\" scoped>\n  p\n    font-weight bolder\n</style>\n```\n\nassets/components/Button.vue\n```vue\n<script>\n  export default {\n    methods: {\n      buttonClicked() {\n        this.$dispatch('button-click')\n      }\n    }\n  }\n</script>\n\n<template>\n  <button @click=\"buttonClicked\">\n    <slot></slot>\n  </button>\n</template>\n\n<style lang=\"stylus\" scoped>\n  button\n    padding 5px\n    border-radius 4px\n</style>\n```\n\nХотя нет, есть три вещи, на которых стоит остановиться. Во-первых, обратите внимание, как мы бесцеремонно навешиваем стили на теги. Этого конечно даже вместе с Vue.js делать не очень-то стоит, но сделано это нарочно, для демонстрации возможности `scoped`. Дело в том, что после обработки webpack'ом, мы получим стили следующего вида\n\n```css\nbutton[_v-123124] {\n}\n```\n\nа в html у нас будет красоваться не просто `<button />`, а `<button _v-123124>`\n\nТаким образом достигается изоляция стилей. Данный стиль не будет действовать ни на одну родительскую кнопку. Однако прошу заметить, что на дочерние кнопки (даже если они в других компонентах) это действовать будет.\n\nСледующая маленькая вещь, на которую я обращу ваше внимание - это атрибут `props` у Counter.vue. Если посмотреть еще разок на код App.vue, то вы увидите, что мы передаем свойство, которое не похоже на обычное DOM-свойство. Так вот чтобы его получить, компонент должен сказать, что он принимает это свойство.\n\nИ на последок: магический тег `<slot />` - используется для того, чтобы вставлять контент, так сказать, сверху. Если мы снова вернемся к коду App.vue, то увидим, что в template в теге `<my-button />` внутри мы написали Click me! Так вот этот самый контент и вставляется на место тега `<slot />`.\n\nЗнаю, вы уже утомились, но тут осталось три маленькие детали. Во-первых - магический store.js. Привожу его код\n\nassets/store.js\n\n```javascript\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store({\n  state: {\n    counter: 0\n  },\n\n  actions: {\n    increment(store) {\n      store.dispatch('INCREMENT')\n    }\n  },\n\n  mutations: {\n    INCREMENT(state) {\n      state.counter += 1\n    }\n  }\n})\n\nexport default store\n```\n\nОдновременно простой и не совсем. Тут мы используем Vuex, реализацию идеи flux от автора библиотеки Vue.js. В общем и целом это обычный объект, только построен он на геттерах и сеттерах и оттого \"излучает\" события всем подписчикам, коим и является наш App.vue (вспомните вычисляемое свойство). У него также есть особая структура, о которой подробнее вы прочитаете в доках.\n\nТеперь нам нужно все это как-то запустить в нашем assets/index.js\n\n```javascript\nimport 'babel-polyfill'\n\nimport Vue from 'vue'\nimport App from 'App.vue'\n\nconst app = new Vue({\n  el: 'body',\n  components: {\n    App\n  }\n})\n```\n\nВсего в пару строк мы создаем наш Vue application, говорим, к какому элементу DOM-дерева мы привязываемся и так же говорим о том, что у нас единственный компонент - App. Также нам нужно немного подправить index.html, чтобы довести это все до рабочего состояния.\n\nВнутрь `<body />` вставляем простой тег `<app></app>` чтобы получилось так\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body>\n  <app></app>\n  <script src=\"js/all.js\"></script>\n</body>\n</html>\n```\n\nНе забываем запустить \n```bash\n./node_modules/.bin/webpack\n```\n\nИ можем смело открывать index.html в нашем браузере. Обязательно выполните просьбу кнопки и пожмякайте на нее.\n\n## Литература на дом\n\n1. [официальный сайт Vue.js](http://vuejs.org), там вы найдете действительно хорошую документацию\n2. [документация по vue-loader](https://vuejs.github.io/vue-loader/index.html)\n3. [документация по Vuex](http://vuex.vuejs.org/en/index.html)\n4. [видео уроки по Redux](https://egghead.io/lessons/javascript-redux-the-single-immutable-state-tree?series=getting-started-with-redux) - еще одна имплементация идеи flux, откровенно говоря я так и не посмотрел, но сообщество рекомендует.\n\n## В качестве послесловия\n\nСнова большая статья. Надеюсь вам будет относительно легко ее переварить. Хотя я понимаю, что техническая часть статьи получилась несколько сумбурной и наверняка оставил у вас множество вопросов, но это сделано и нарочно, и нет. Во-первых, если я буду застревать на каждом моменте, это будет долго, скучно (особенно если человек уже скилловый), да и наверное выйдет за рамки всех возможных квот. Да и времени на это наверное убить нужно много. Во-вторых - призываю вас читать документацию, тем более, что она очень хорошая и простая, со всякими там Getting started и прочими туториалами. Ну и в третьих - я всегда рад пообщаться по поводу каких-то конкретных проблем, поэтому смело пишите мне на почту (ссылка слева есть), сюда в комментарии или заходите в наш уютный [Ru-ZeroTalk](/1Apr5ba6u9Nz6eFASmFrefGvyBKkM76QgE). Я там регулярно обитаю и подписан на все темы и комментарии.\n\nСпасибо за потраченное время!\n\n### Что-то похожее на сноски\n\n[1]: У меня после версии 1.0 как-то даже не получилось воспользоваться ES5 синтаксисом, именно по этому я попробовал ES6 (хоть и относился к нему скептически) и больше стараюсь с ним не расставаться.\n[2]: я не знаю, почему сноски не работают, в подсказке написано, что должно."
		},
		{
			"post_id": 5,
			"title": "Как я готовлю свой проект",
			"date_published": 1455311488.061,
			"body": "_Статья получилась заметно больше, чем я ожидал, поэтому ждите второй части_\n\nЕсли вы читали предыдущий пост, потом заглянули в мой GitHub и у вас остались вопросы о том, как это все работает, то наверное вам стоит заглянуть под кат.\n\n---\n\nПредставленный способ в принципе работает для любых проектов, но я упомяну также и ZeroNet-specific вещи.\n\nИтак, заводим проект.\n\nПервое, что я настоятельно рекомендую это использовать unix-like системы. Это может быть любой дистрибутив Linux, MacOS, FreeBSD (чем черт не шутит, но не проверял ничего) или даже виртуалка с Linux в Windows (необязательно целиком вести проект там, но там стоит его собирать).\n\nВторое - это таки завести отдельную директорию под проект. Начитавших всяких там доков можно подумать, что создал директорию под будущий сайт с помощью zeronet.py и там и работать. Однако это не удобно даже банально в силу того, что директория с сайтом - это человеконечитаемая абракадабра.\n\nОтдельная директория также позволит нам более удобно работать с тем же git-ом и т.п.\n\nНам также нужны node.js и npm\n\nNode.js, если кто не знает, это интерпретатор JavaScript, основанный на базе движка V8, который в свою очередь был разработан в Google (если конечно ничего не поменялось). Npm это менеджер пакетов для того самого node.js (для python'истов - это местный pip).\n\nИтак, у нас есть отдельная директория, пустая. Пусть называется она hello_zero. У нас установлена node.js вместе с npm. Берем в руки терминал (какая ж разработка без него) заходим в hello_zero и начинаем строить скелет нашего проекта. Инициализируйте git (mercurial, etc.) репозиторий, если нужно. Далее нам нужен файл, в который будут записываться зависимости нашего проекта. Для этого наберем \n\n```bash\n$ npm init\n```\n\nНас спросят пару вопросов. Обычно я не заморачиваюсь и отвечаю по-дефолту. Скажем так, более подробная информация нужна, если вы делаете какую-то библиотеку, которую будете шарить в сообщество. А так как у нас проект, можно не загоняться.\n\nДалее. Если вы еще не знаете, что такое Webpack, requirejs, browserify, срочно узнайте. Рекомендую Webpack ([оффсайт](https://webpack.github.io), он как смесь browserify и require.js. Собрал в себе все самое лучшее от обоих. Нужно оно нам, чтобы собирать из аккуратно структурированных js-файлов (которые даже совсем не обязательно написаны на js), кашу в одном файле, как это принято делать, чтобы не нагружать браузер лишними запросам.\n\nСтавим:\n\n```bash\nnpm install webpack --save\n```\n\nФлаг ```--save``` говорит, чтобы npm сохранил данную зависимость (и ее версию) в сгенерированный на прошлом шаге package.json\n\nПосле установки у нас в корне проекта появляется директория node_modules. Там на текущий момент хранится только что установленный webpack. Смело добавляем эту директорию в .gitignore (или что там у нас используется). Чуть позже мы настроим webpack и посмотрим, как это все дело заставить работать.\n\nНастало время определиться с непосредственно структурой проекта. Если это ZeroNet сайт или какое либо другое HTML\\JS\\CSS only приложение, то советую вам тут же, в корне создать файл `index.html`, а так же директорию `assets`. Если с index.html все понятно, то пожалуй поясню, для чего нужна директория assets. Туда я обычно складываю js скрипты и любую другую статику так, как мне удобно, структурировано. Также все эти js'ы не обязательно должны быть js'ами. Они вполне могут быть CoffeeScript'ами или чем там еще люди балуются. Webpack при правильной настройке все скушает, все переварит и выплюнет нам готовый для браузера js скрипт.\n\nВ папке assets создайте index.js, оставьте его пустым. Это будет точкой входа. Не пугайтесь, я сейчас все объясню.\n\nindex.html мы можем заполнить довольно стандартно\n\n```html\n<!DOCTYPE html>\n<html>\n<head></head>\n<body>\n  <script src=\"js/all.js\"></script>\n</body>\n</html>\n```\n\nТут все просто, кроме того, что мы ссылаемся на не существующий скрипт js/all.js\n\nПока несуществующий.\n\nДалее мы создадим начальный конфиг для webpack. Создаем в корне файл webpack.config.js со следующим содержимым\n\n```javascript\nmodule.exports = {\n  entry: {\n    all: './assets/index.js'\n  },\n  output: {\n    path: './js/',\n    filename: '[name].js'\n  },\n  resolve: {\n    modulesDirectories: [\n      'assets',\n      'node_modules'\n    ]\n  }\n}\n```\n\nВ целом, о том, что означают те или иные настройки, вы можете прочитать [на одной из страниц документации webpack](https://webpack.github.io/docs/configuration.html). Я коротко пройдусь по этим настройкам.\n\nЯ привык называть собранные webpack'ом скрипты - _бандлами (bundle)_. Так вот, в `entry` мы говорим webpack'у о том, какие бандлы у нас есть (all) и откуда он, так сказать, начинается. webpack во время сборки начнет осматривать этот файл, найдет все импорты и обработает.\n\nВ `output` мы конфигурируем то, куда именно будут складываться наши выходные файлы и какой формат имени они будут иметь. Т.е. наш бандл all после обработки webpack'ом соберется в файл с названием all.js и будет находится в папке js (т.е. js/all.js относително нашей корневой папки проекта). А это именно тот файл, который мы указали в нашем html файле.\n\nПараметр `resolve` я использую исключительно для удобства. Стандартный способ webpack запросить какой либо модуль - это написать `require('путь/до/модуля.js')`. Иногда это очень не удобно и получается что-то вроде `require('../../../../models/products/fixed_price.js')`. Жутко да? Поэтому я сообщаю webpack'у, как искать модули, если он увидел что-то вроде `require('util/mymodule.js')`. В данном конкретном случае он сначала поищет в папке assets файл util/mymodule.js, если там не найдет, начнет искать в node_modules. node_modules мы оставляем (так оно работает по-умолчанию) для того, чтобы можно было установить например jquery с помощью npm, и обращаться к нему весьма простым\n\n```javascript\nvar $ = require('jquery');\n```\n\nЯ тут все распинаюсь да распинаюсь. А казалось бы, зачем все так сложно? Зачем мне выпендривться с какими-то webpack'ами, можно ж по старинке, подключить себе на страницу несколько скриптов, да и обращаться к ним через `window.$` или какая там у вас библиотека.\n\nОтвечаю:\n\n1. Наш код в итоге соберется в один файл, что уменьшает количество запросов на сервер (не совсем справедливо для zeronet, но все равно приятно)\n2. Мы могли бы подключить какую-то библиотеку, о которой потом забыли. Решили изменить код и так уж получилось, что эта библиотека не используется больше нигде. Но тем не менее, она продолжает скачиваться нашему посетителю. В случае с webpack'ом мы получаем явное указание зависимостей, которые просто не попадут в итоговый бандл, если они больше не используются. Все счастливы\n3. У нас появляется две особые возможности. Первая - использовать библиотеки, написанные для node.js в браузере (разуметеся, если у них нет какой-то особой работы с файловой системой, процессом и другими штуками, которые в браузере отсутствуют). Вторая - мы теперь можем использовать разные препроцессоры кода, будь то coffeescript или babel (ES6, об этом далее). Так же, если углубиться в доки, можно научиться делать код разбитый на куски, и куски подгружать тогда, когда они действительно нужны (это несколько бесполезно в рамках ZeroNet, по крайней мере пока один файл не занимает очень много мегабайт)\n4. Если совсем постараться, то мы сможем писать unit-тесты на наш код, который не взаимодействует с DOM-деревом и прочими browser-specific штуками. А это уже много!\n5. Ваш window свободен, там теперь не хранятся куча всяких jQuery, underscore и прочих имен, т.к. все это добро работает в замыкании\n6. Вы можете подключить свою итоговую сборку с помощью async аттрибута и не думать о том, в каком порядке у вас загрузятся все ваши библиотеки.\n\nНу хватит уже разговаривать, давайте посмотрим, что получилось!\n\nКак запускать: просто идем в корень проекта, если вы еще не там, и выполняем \n```bash\n$ ./node_modules/bin/webpack\n```\n\nWebpack немного подумав выдаст вам несколько строк текста. Если вы видите только зеленый текст - все хорошо. Можно смотреть файл js/all.js хотя там должно быть пусто (или пару строк webpack'овского рантайма, это все вам стоит изучить самостоятельно)\n\nОткрыв index.html, зайдя в developer tools мы видим, что никаких 404 не произошло, но это скучно довольно.\n\nДавайте попробуем подключить к нашему проекту препроцессор babel, который поможет нам писать с использованием синтаксиса ES6. Ознакомится с синтаксисом и с самим babel можно на официальной странице [BabelJS](https://babeljs.io/docs/learn-es2015/)\n\nВ целом инструкции по установке вы можете найти [здесь](https://babeljs.io/docs/setup/#webpack), но раз уж я взялся вас учить, то будем идти до конца. Следите за руками\n\n```bash\n$ npm install babel-core babel-loader babel-preset-es2015 babel-polyfill --save\n```\n\nДа, тут несколько много всего, больше чем на оф. сайте.\n\nПакет babel-core - обеспечивает базовую функциональность. Подробнее читайте сами, ибо я в подробности уже не уходил.\n\nПакет babel-loader - специальный пакет для webpack, который позволяет последнему загружать ES6 код и правильно его обрабатывать.\n\n Вообще для webpack есть множество разных loader'ов, но я боюсь я скоро из-за этой статьи привышу стандартную квоту.\n\nПакет babel-preset-es2015 насколько я понял, babel более универсальная штука, чем просто дать вам возможность писать на ES6, и непосредственно ES6 находится в отдельном пакете. Нужно копать, чтобы до конца понимать\n\nПакет babel-polyfill. ES6 привносит довольно много всяких штук, которые не поддерживаются даже самыми современными браузерами. Данный пакет поможет исправить эти недостатки и создаст в экосистеме браузера все необходимое для работы. Конкретный пример Symbols.\n\nФух. Едем дальше. ES6 на этом у нас магическим образом не появится. Нам нужно:\n\n- Сконфигурировать вебпак\n  Добавьте строки, чтобы получилось так\n  ```javascript\nmodule.exports = {\n  entry: {\n    all: './assets/index.js'\n  },\n  output: {\n    path: './js/',\n    filename: '[name].js'\n  },\n  module: {\n    loaders: [\n      {test: /\\.js$/, exclude: /node_modules/, loader: 'babel'},\n    ]\n  },\n  resolve: {\n    modulesDirectories: [\n      'assets',\n      'node_modules'\n    ]\n  }\n}```\n  Намекну, что речь про параметр `module` с внутренним массивом `loaders`. Тут мы указали, что любой js файл, кроме тех, что лежат внутри node_modules (чаще всего они не ES6 совместимы) нужно обрабатывать babel-loader'ом\n\n- Сказать babel'у, какой preset использовать.\n  Создаем в корне проекта .babelrc с следующим содержимым\n  ```json\n{ \"presets\": [\"es2015\"] }\n```\n\nПосле этого мы можем писать с использованием ES6. Давайте перейдем в ранее созданный assets/index.js и напишем что-то с использованием нового синтаксиса. Можно попробовать вот такое\n```javascript\nimport 'babel-polyfill' // См. выше. Дополняем возможности браузера\n\nfunction iteritems(obj) {\n  return {\n    [Symbol.iterator]: function*() {\n      for (let key in obj) {\n        let value = obj[key]\n        yield [key, value]\n      }\n    }\n  }\n}\n\nlet obj = {\n  keyA: 'valueA',\n  keyB: 'valueB'\n}\n\nfor (let [key, value] of iteritems(obj)) {\n  console.log(key, value)\n}\n```\n\nДемонстрирует сразу несколько возможностей и обычных изменений в ES6 по сравнению с ES5. Тут и генераторы, и итераторы, и Symbols, и новое объявление переменных. Показательно.\n\nТеперь запуск\n\n```bash\n$ ./node_modules/.bin/webpack\n```\n\nИ открываем в браузере. В консоли должно быть что-то вроде\n```\nkeyA valueA\nkeyB valueB\n```\n\nЯ помоему действительно не расчитал количество букв и видимо придется дробить на две статьи. В следующей мы рассмотрим, что такое Vue.js что такое Vuex, как это все собрать вместе. А сейчас еще пару вещей\n\n```bash\n$ ./node_modules/.bin/webpack -wd\n```\n\nЗапустит webpack в виде продолжительного процесса, который будет следить за любым изменением в любом файле, который входит в bundle и сразу собирать новую версию этого бандла. И это будет быстро! Дополнительно генерирует map файлы, чтобы быстро можно было ориентироваться в коде во время выполнения. Полезно для дебага.\n\n```bash\n$ ./node_modules/.bin/webpack -p\n```\nВыведет вам большое желтое полотно. Не пугайтесь, все хорошо. Webpack изготовил нам \"продакшен\" версию, минифицированную и обфусцированную на столько, на сколько он смог.\n\nИииии...\n\n### Домашнее задание\n\nИли что еще почитать на тему.\n\nКак я уже говорил, штудируем\n\n- [Webpack](https://webpack.github.io)\n- [BabelJS](https://babeljs.io/docs/learn-es2015/)\n- [Неплохая статья на английском](http://blog.madewithlove.be/post/webpack-your-bags/)\n\nНу и если интересно, всегда можете написать мне сюда или на почту (ссылка слева).\n\nСпасибо за внимание, извините за МНОГАБУКАВ"
		},
		{
			"post_id": 4,
			"title": "Копаем в глубь ZeroFrame. Часть 1. certSelect.",
			"date_published": 1455271037.581,
			"body": "Вроде бы рассматривать по одной команде API за раз как-то маловато, зато с другой стороны можно выдать выжимки кода и все разложить по полочкам. В общем прошу под кат, сегодня у нас на повестке дня команда [certSelect](https://zeronet.readthedocs.org/en/latest/site_development/zeroframe_api_reference/#certselect-accepted_domains).\n\n---\n\nВообще, сначала я должен сделать некоторое лирическое отступление. Я уже ругался на выбор CoffeScript в первом своем посте, поэтому рассказываю, что и как мы будем делать.\n\nВо первых, у нас тут Bleeding edge, используем ES6! Достигается это довольно просто, если использовать [Babel.js](https://babeljs.io). Однако babeljs это всего-лишь транслятор. Для полного комфорта и автоматической сборки кода мы возьмем [webpack](https://webpack.github.io)\n\nТак же хочу отметить, что я очень большой любитель такого прекрасного фреймворка как [Vue.js](http://vuejs.org), так что буду использовать его.\n\nО том, как я организую проект, я чуть позже выпущу отдельную статью.\n\nОднако я очень буду стараться давать описание, не привязанное к фреймворку.\n\nВернемся к нашим баранам.\n\ncertSelect очень простая команда, которая отображает пользователю что-то вроде местного окошка логина. Вот если зайти на какой-нибудь [ZeroTalk](/Talk.ZeroNetwork.bit) и попробовать написать пост или даже в этом блоге написать комментарий, вас непременно попросят войти. Справа в углу появется плашечка, где вы сможете выбрать идентификатор. На текущий момент там выбор из двух пунктов. По факту - один из них анонимус, второй - зарегестрированный аккаунт на сайте [ZeroID](/zeroid.bit). Вообще говоря, таких \"точек идентификации\" как ZeroID может быть много, только неувязочка в том, что сайт, который запрашивает информацию у вас о логине должен принудительно сказать, какие именно домены он принимает в качестве id. На текущий момент мне не известны другие \"точки идентификации\", да и вряд ли скоро появятся (хотя ради академического интереса - можно).\n\nМы таким образом подошли к параметрам команды certSelect. А именно, certSelect принимает всего один параметр, называется он accepted_domains. Значение accepted_domains это массив со списком доменов \"точек идентификации\" и так как он у нас пока один единственный, то это массив из одного элемента. Конкретного. `'zeroid.bit'`\n\nИтого, конструкция вполне конкретная:\n```javascipt\nclass ZeroSite extends ZeroFrame {}\nlet zeroSite = new ZeroFrame()\nzeroSite.cmd('certSelect', {\n\taccepted_domains: ['zeroid.bit']\n})\n```\n_конечно же это дело упрощено, полный листинг ниже_\n\nДанный код покажет пользователю знакомую плашку с выбором идентификатора и все вроде бы хорошо. Вот только как получить результат всего этого?\n\nА вот тут немного интереснее. Дело в том, что стандартный ZeroFrame позволяет вам добавить callback к вызову `zeroSite.cmd`, однако добавив его к certSelect мы ничего не получим. Потому что ответа на это дело нет. Однако ZeroNet оповещает наш сайт отдельным сообщением, которое называется `setSiteInfo`. Каждый раз, когда там что-то меняется, к нам приходит новое сообщение.\n\nДанное сообщение глубже мы рассматривать будем чуть позже, однако кое-что нас оттуда таки интересует. В параметрах сообщения можно найти поле `cert_user_id` которое будет равно null, если выбран анонимный пользователь и строке с идентификатором в ином случае. Т.е. если я выберу zeroid.bit идентификатор, то поле `cert_user_id` будет равно `'gomzik@zeroid.bit'`\n\nТам есть еще несколько параметров, в том числе и намекающих на авторизацию, но об этом опять же, позже.\n\nПолный листинг вы найдете здесь: [GitHub](https://github.com/GomZik/ZeroNet-TestSite/tree/step01.certSelect.tutorial), а потыкать можно [тут](/1AQj7DF45w5DK2Ga486YT8QaYhpedgE5tR)\n\nНе серчайте, повторюсь, что обязательно расскажу более подробно, как у меня устроен проект чуть позже\n\n### Почему меня везде просят авторизоваться?\n\nЧто ж, чтобы ответить на этот вопрос, нужно понимать специфику сети. Дело в том, что чтобы сайты были динамическими, каждому пользователю нужен приватный ключ, чтобы использовать его для публикации своих изменений на сайте и чтобы быть уверенным, что именно этот пользователь эти изменения и сделал. В общем и целом этот ключ есть и у анонимного пользователя, однако я так понимаю, что сделано так нарочно, чтобы повысить секьюрность, препятствовать спаму и разрастанию сайта до необъятных размеров за счет неправомерных пользователей. Если я ошибаюсь, напишите пожалуйста в комментариях более подробно, буду рад."
		},
		{
			"post_id": 3,
			"title": "Понимаем ZeroFrame API",
			"date_published": 1455217344.717,
			"body": "Итак, что же у нас под капотом. Если вы девелопер, хотите замутить свой оригинальный сайт, вас ждет большой сюрприз. Если вы хотите создать что-то отличное от единичной HTML'ки, где будет какой-то контент, то вам нужно погрузиться в то, как работает ZeroNet, как разные пользователи могут оставлять комментарии и прочие ништяки, доступные нам в обычном Интернете.\n\n---\n\nИтак, если мы пройдем на [сайт с документацией для девелоперов](https://zeronet.readthedocs.org/en/latest/site_development/getting_started/), то увидим, что нам предлагают встроить в свой сайт нейкий [ZeroFrame.coffee](https://github.com/HelloZeroNet/ZeroHello/blob/master/js/lib/ZeroFrame.coffee)\n\nНу тут я немного сначала расстроился, зачем казалось бы этот CoffeScript, есть ли возможность использовать не его (ведь все это выполняется в браузере, наверняка есть!) и что за чертов ZeroFrame и как его юзать?\n\nЧуть выдохнув и посмотрел в этот самый [скрипт](https://github.com/HelloZeroNet/ZeroHello/blob/master/js/lib/ZeroFrame.coffee), понял, что ничего сложного в этом нет и на самом деле, это ни что иное, как небольшая обертка над iframe-коммуникациями.\n\nЧто я имею ввиду. Ну во первых, достаточно быстро понимаешь, что любой ZeroNet сайт открывается в iframe основной оболочки. Таким образом ZeroNet делает для сайта песочницу, в рамках которой он вполне может вытворять все, что угодно, однако вне - ничего (ну или я так надеюсь). Но будь у нас в распоряжении один лишь iframe, было бы очень не весело. Здравствуй freenet, статический и беспощадный. Пипл что называется не схавает.\n\nНо разработчики ZeroNet поступили довольно изящно.\n\nДело в том, что современные web-стандарты позволяют контактировать с iframe-родителем. Разумеется iframe-родитель должен об этом знать и ожидать. Так вот, он знает и ожидает. Он предоставляет вам несколько вызовов для того, чтобы вы, как разработчик, могли сделать действительно толковое приложение.\n\nСтоит правда заметить, что о своем личном backend придется забыть. Оно и понятно, если фронтенд можно раздавать, будто бы это обычный контент торрент-трекера, то как поступать с бэкендом? Как посетители сайта смогут его запустить? Всем на машины тащить каждый существующий интерпретатор и компилятор? Не круто же!\n\nТак вот, роль backend'а будет выполнять ядро ZeroNet'а. Оно предоставляет нам некоторые особые вызовы, чтобы сделать ~~распределенную~~ децентрализованную базу данных, обращаться к ней и в общем все по взрослому и с динамикой. Однако об этих возможностях мы поговорим позже, а сейчас вернемся к нашему ZeroFrame\n\nХотя что тут возвращаться, всего лишь класс с парой функций, самая интересные две строчки в нем\n\n```coffescript\nwindow.addEventListener(\"message\", @onMessage, false)\n```\n\nи\n\n```coffescript\n@target.postMessage(message, \"*\")\n```\n\nв первой строчке мы начинаем слушать сообщения от оболочки ZeroNet'а (он же родительский iframe), а во второй осуществляется отправка команд родительскому iframe.\n\nПодробнее о командах мы поговорим в следующей записи.\n\nИ напоследок, мой вариант ZeroFrame, переписанный на ES6\n[тыц](https://gist.github.com/GomZik/02e85df5fb7a5eb819cd)"
		},
		{
			"post_id": 2,
			"title": "Первый пост.",
			"date_published": 1455215561.882,
			"body": "Начнем небольшой разбор полетов с ZeroNet.\n\nНу в первую очередь, хочу отметить, что проект действительно меня удивил. Децентрализация, которая работает быстро, динамично и действительно хорошо.\n\nОднако на текущий момент я не могу оценить безопасность данного проекта. Нет, не анонимность, с ней все понятно. Именно безопасность. Однако по мере разборок, я обязательно буду рассказывать вам и писать об этом разработчикам.\n\n---\n\nОднако как бы замечательно все не было, есть тут и к чему и придраться. Мне, как разработчику, очень не понравился выбор именно CoffeeScript в качестве основного языка для документации и примеров. Все существующие и немногочисленные разработки (конечно, которые я видел) также написаны с использованием онного. Однако я буду очень стараться это исправить.\n\nКто я такой? Я вообще python developer, но в основном занимаюсь web разработкой и по своему долгу довольно неплохо знаком с JS. На текущий момент я в сети относительно новичок, так что познаю этот новый для меня мир.\n\nРазработка сайта для ZeroNet довольно сильно отличается от разработки аналогичного в привычном нам Интернете. Посему я собираюсь разобраться с этим, написать каких-нибудь pet-project'ов и в последствии начать делать что-то серьезное и участвовать в действительно нужных ZeroNet'у проектах.\n\nВ процессе всех своих разбирательств, буду вести этот блог с разными примерами, кусками кода. Так что подписывайтесь на блог, комментируйте, спрашивайте."
		}
	]
}