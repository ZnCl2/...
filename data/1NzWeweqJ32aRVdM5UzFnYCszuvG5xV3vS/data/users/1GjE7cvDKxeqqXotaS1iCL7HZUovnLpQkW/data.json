{
	"next_topic_id": 12,
	"topic": [
		{
			"topic_id": 1,
			"title": "group.test",
			"body": "如果置顶过头了，真的抱歉 -_-|| ",
			"type": "group",
			"added": 2431925465
		},
		{
			"topic_id": 4,
			"title": "make group",
			"body": "本主题的翻译贴都是tuzi（本站 GXQ 的站长）翻译的，am630修改了一下json把源代码偷过来，然后偷到零网教学wiki里面…………会注明出处，翻译版权归tuzi所有。\n\n为什么要偷过去wiki？ 协作，合作。\n\n* * *\n修改了自己的json文件后（修改或增加贴子），需要签名发布。\n在上述情况下：在浏览器里对应的网站里 发一条留言 OR 新建一个贴子 ，那么系统会自动签名并发布。\nPS：最好不要在通过修改留言来让系统自动签名发布，因为可能会失败（如果只是修改而不增减，那么可以通过修改留言来自动签名发布），最好是新建留言或帖子。另外，记得修改前备份文件，否则就不要修改，如果你不知道我在说什么，那么我也不知道该对你说什么。",
			"added": 2461941283,
			"parent_topic_uri": "1_1GjE7cvDKxeqqXotaS1iCL7HZUovnLpQkW"
		},
		{
			"topic_id": 6,
			"title": "站点开发篇：一 概述和调试模式",
			"body": "**_译自http://zeronet.readthedocs.org/en/latest/site_development/getting_started/_**\n#概述\nZeroNet allows you to publish static and dynamic sites.\n_ZeroNet允许建立静态和动态的网站_\nAlthough ZeroNet can't run scripting languages like PHP or Ruby, you can create dynamic sites using ZeroNet's API (called ZeroFrame), JavaScript (or CoffeeScript) and the built-in SQL database.\n_虽然ZeroNet不能运行像PHP、Ruby这类的脚本编程语言，但我们可以使用ZeroNet API（又叫ZeroFrame）JavaScript(CoffeeScript)和内置SQL数据库完成动态网站建设。_\n　　\n#调试模式的特性\nZeroNet comes with a `--debug` flag that will make site development easier.\n_使用`-debug`标示可以是网站开发变得容易。_\nTo run ZeroNet in debug mode use: `python zeronet.py --debug`\n_要运行调试模式，可使用`python zeronet.py --debug`_\n###Debug mode features（调试模式的特点）\n- Automatic CoffeeScript -> JavaScript conversion (All examples used in this documentation and sample sites are written in CoffeeScript)\n_自动实现CoffeeScript到JavaScript转变。在技术文档中的示例和样本网站都是用CoffeeScript写就。_\n- Debug messages will appear in the console\n_调试信息会显示在控制台窗口。_\n- Auto reload of some source files (UiRequest, UiWebsocket, FileRequest) on modification to prevent restarting (Requires PyFilesystem on GNU/Linux)\n_在编辑中能自动重载源码文件(UiRequest, UiWebsocket, FileRequest) 从而避免重启（在GNU/Linux系统上需要PyFilesystem。_\n- `http://127.0.01:43110/Debug` Traceback and interactive Python console at the last error position (using the wonderful Werkzeug debugger - Requires Werkzeug)\n_`http://127.0.01:43110/Debug` 可以追踪到最近的错误位置。_\n- `http://127.0.01:43110/Console` Spawns an interactive Python console (Requires Werkzeug)\n_重现可交互Python控制台。_\n\n#额外特性（仅用于具有拥有权的）\n- Merged CSS files: All CSS files inside the site folder will be merged into one file called `all.css`. You can choose to include only this file to your site. If you want to keep the other CSS files to make the development easier, you can add them to the ignore key of your content.json. This way, they won't be published with your site. (eg: add to your content.json \"ignore\": \"(js|css)/(?!all.(js|css))\" this will ignore all CSS and JS files except all.js and all.css)\n_合并的CSS文件：所有的CSS文件被合并进一个`all.css`文件，你可以将它作为你网站的唯一CSS文件。如果为了开发方便想保留其他的CSS文件，可以在`content.json`中加入参数。（请参考[content.json的结构解析](http://127.0.0.1:43110/1NzWeweqJ32aRVdM5UzFnYCszuvG5xV3vS/?Topic:7_1M1c7x7SLau8D2bm8Gw8iWQbBqe9X4zqPw/content+json)这篇文章）这样设置后他们不会随着网站发布。_\n- Merged JS files: All JS files inside the site folder will be merged into one file called `all.js`. If a CoffeeScript compiler is present (bundled for Windows) it will convert` .coffee` to` .js`.\n_合并的JS文件：所有的JS文件被合并进一个`all.js`文件。CoffeeScript编译器会将`.coffee`转换成`.js`_\n- Order in which files are merged into all.css/all.js: Files inside subdirectories of the css/js folder comes first; Files in the css/js folder will be merged according to file name ordering (01_a.css, 02_a.css, etc)\n_按序合并：在css/js文件夹子目录中的文件会按文件名顺序合并。_",
			"added": 1463962299,
			"parent_topic_uri": "1_1GjE7cvDKxeqqXotaS1iCL7HZUovnLpQkW"
		},
		{
			"topic_id": 7,
			"title": "content.json文件结构解析",
			"body": "**_译自http://zeronet.readthedocs.org/en/latest/site_development/content_json/_**\n\nEvery ZeroNet site will have a `content.json` file. (Example `content.json` file)\n_每个站点都会有一个`content.json`文件_\nThis file will carry, amont other things, a list of all files on your site and a signature created with your private key. This is done to avoid file tampering (ie: only you, or people you trust, can update the site content).\n_这个文件包含了站点文件目录、私钥签名等参数。它的作用是防止站点被随意的篡改。_\nHere is a list of supported keys:(Generated automatically)\n_关键参数（键值）列表_\n###自动产生的参数\n- address\nYour site address,Example: 1NzWeweqJ32aRVdM5UzFnYCszuvG5xV3vS\n_你站点的地址，如 `\"address\": \"1NzWeweqJ32aRVdM5UzFnYCszuvG5xV3vS\"`,其中的`1NzWeweqJ32aRVdM5UzFnYCszuvG5xV3vS`就是http://127.0.0.1:43110后面的地址。_\n- address_index\n_地址索引_\nThe site's address BIP32 sub-key index of your BIP32 seed. Auto-added when you clone a site. It allows to recover the site privatekey from your BIP32 seed.\n_站点地址的种子索引子键值_\n_举例如`\"address_index\": 86166121`_\n\n- cloned_from\nThe site address where the site is cloned from.\n_标明克隆来源网站地址_\n_举例如：`\"cloned_from\": \"1Nse6WcodQ5Mj6ZwvZvuyCVvQESwuxbCUy\"`，即本站克隆自GFW talk。_\n- files\nSize and sha512 hash of automatically downloaded files contained in your site. Automatically added by the command `zeronet.py siteSign siteaddress privatekey`.\n_列出你的网站包含并需要自动下载的文件的文件名、哈希值和文件大小。当运行`zeronet.py siteSign siteaddress privatekey`命令时自动添加和更新。_\n举例:\n```\n \"css/all.css\": {\n      \"sha512\": \"869b09328f07bac538c313c4702baa5276544346418378199fa5cef644c139e8\",\n      \"size\": 148208\n｝```\n- `files_optional`\n_非强制性文件_\nSize and sha512 hash of optional files contained in your site. Automatically added by the command `zeronet.py siteSign siteaddress privatekey`.\n_包含在你的网站的非强制、可选择文件的哈希值和大小。当运行`zeronet.py siteSign siteaddress privatekey`命令时自动添加和更新。_\n举例:\n\n ```\n\"data/myvideo.mp4\": {\n      \"sha512\": \"538c09328aa52765443464135cef644c144346418378199fa5cef61837819538\",\n      \"size\": 832103\n}\n```\n_运用这个参数可以突破限制建设大型的网站。_\n- modified\nTime when the content.json was generated.Example: 1425857522.076\n_`content.json`文件产生时间_\n- sign (deprecated)\nECDSA sign of the content.json file content. (keys sorted, without whitespace and the sign and signers_sign nodes). For backward compatibility, will be removed soon.\n_不推荐，该参数为后续版本的兼容性，将会移除_\n举例:\n```\n\"sign\": [\n43117356513690007125104018825100786623580298637039067305407092800990252156956,\n94139380599940414070721501960181245022427741524702752954181461080408625270000\n],```\n- `signers_sign`\nPossible signers address for the root content.json signed using the site address private key. (Multisig possibility)\n_使用站点私钥签名的根`content.json`文件签名者的地址_\n_如: HKNDz9IUHcBc/l2Jm2Bl70XQDL9HYHhJ2hUdg8AMyunACLgxyXBr7EW1/ME4hGkaFZSFmIxlInmxH+BrMVXbnLw=_\n- signs\nECDSA signs for the the content.json file content. (keys sorted, without whitespace and the sign and signers_sign nodes).\n_`content.json`文件ECDSA（关键字排序、无空格和签名者签名）_\n举例:\n```\n\"signs\": {\n\"1NzWeweqJ32aRVdM5UzFnYCszuvG5xV3vS\": \"G7vDvMBob+Eeb3zWETq6fm0l0ZLhuYAtYoeQ079ZqBYkiv020akJLn1Wlc8JyV0L1lo70wr4nSSzZspcZNThUQE=\"\n },```\n- zeronet_version\nZeroNet version used to generate content.json file.Example: 0.2.5\n_版本号，如0.3.6._\n###可设置参数\n\n- background-color\n背景色，如：`\"background-color\": \"#F5F5F5\"`\n\n- cloneable\nAllow to clone the site if true.\n_是否允许克隆。`true`是允许。_\nTo make your site properly cloneable you have to add data files for clean start (eg. without any blog posts). To do this you have to add -default postfix to your data files and directories. On the cloning process every file and directory is skipped if it has -default postfixed alternative and then the -default postfix will be removed from the affected files and directories.\n_想要使你的网站可以克隆，仅仅设置上面的参数是不行的，我们还需要设置缺省的开始文件（如：没有任何发帖，干净的论坛或博客）。在我们的文件和文件夹加上-default。在克隆的过程中，这些文件和文件夹被移除`-default`后用来覆盖受影响的文件。_\n- description\nDescription of your site, displayed under site title on ZeroHello. Example: Decentralized forum demo\n_站点描述_\n\n\n- domain\nNamecoin domain name of your site. ZeroHello will link to this if the user has Zeroname plugin enabled.Example: Blog.ZeroNetwork.bit\n_你的站点的Namecoin域名。_\n- ignore\nIgnore files from signing matching this preg pattern\n_按预设的格式忽略这些的签名匹配。_\n举例: ((js|css)/(?!all.(js|css))|data/users/.*) (ignore all js and css files except all.js and all.css and don't add anything from data/users/ directory)\n- includes\nInclude an another content.json\n_包含另外的`content.json`文件_\n举例:\n``` \"includes\":{\n  \"data/users/content.json\": {\n    \"signers\": [ # Possible signers address for the file\n      \"1LSxsKfC9S9TVXGGNSM3vPHjyW82jgCX5f\"\n    ],\n    \"signers_required\": 1 # Valid signs required to accept the file (Multisig possibility),\n    \"files_allowed\": \"data.json\", # Preg pattern for the allowed files in the include file\n    \"includes_allowed\": false, # Nested includes allowed or not\n    \"max_size\": 10000, # Max sum filesize allowed in the include (in bytes)\n  }\n}```\n- optional\nPreg pattern of optional files\n_可选择文件的格式。_\n_如: (data/mp4/.*|updater/.*) (everything in data/mp4 and updater directory is optional)_\n- `signs_required`\nValid signs required to accept the file (Multisig possibility)\n_需要有效的签名才能接收文件_\n- title\nSite's title, visible in browser title and on ZeroHello.\n_站点标题，可在浏览器的标题栏里看到，在ZeroHello中也能看到_\n_如:GXQ Talk_\n\n##——————以下是user_contents结构——————\nRules of allowed user content of current directory.\n_当前目录的用户规则。_\n- cert signers  \nAccepted domains and it's valid signer's addresses\n_域名和有效签名者地址_\n- permission_rules  \nAllowed file names and total directory size based on cert domain or authorization method\n_在域名和认证模式基础上的可允许文件名和目录大小。_\n- permissions   \nPer-user permissions. (false = banned user)\n_针对每个用户的限定。_",
			"added": 1463962300,
			"parent_topic_uri": "1_1GjE7cvDKxeqqXotaS1iCL7HZUovnLpQkW"
		},
		{
			"topic_id": 8,
			"title": "站点开发篇：二 示例 #1",
			"body": "**_译自http://127.0.0.1:43110/Blog.ZeroNetwork.bit/?Post:43:ZeroNet+site+development+tutorial+1 _**\n\n本示例会一步步建立一个简单的、多用户、P2P聊天程序。\n为了做到这一点，第一步是要建立一个新的站点，添加些简单的html和javascript以便于借助API与客户端交互。\n\n#建一个新站点\n- 在ZeroNet目录下打开命令行窗口（控制台）。（如果是Windows系统可使用Ctrl+Shift+Alt和鼠标右键的配合）\n- 执行`zeronet.py siteCreate `(没有经过安装，使用的是压缩包形式的用这个命令` ..\\python\\python.exe zeronet.py siteCreate `)\n- 命令行窗口会显示这个站点的私钥，请一定保存，更新网站需要它。\n- 输入`yes`。\n\n一个新的站点已经建好了，它会显示在ZeroNet的起始欢迎界面。\n下面就是往里面填内容了。\n\n#调试模式启动ZeroNet\n虽然不是必须的，但是建议这么做。因为这个示例的代码使用CoffeeScript写的，在调试模式下可以自动完成向JavaScript\t的转化。否则，就要自己手工完成了。\n- 先关闭ZeroNet\n- 使用`zeronet.py --debug`命令行启动\n\n_需要注意的是，CoffeeScript编译器在windows版本中已经捆绑了。如果是使用的其他平台，可使用`npm install -g coffee-script`命令安装。_\n\n#编辑index.html\n- 进入data/1N1Ga6T2wiCZujYD7yCAgV8EiNwWEsjzVo(请更换成你自己的站点地址)\n- 按以下代码编辑 index.html\n\n```\n<html>\n<body>\n<input type=\"text\" id=\"message\"><input type=\"button\" id=\"send\" value=\"Send!\"/>\n<ul id=\"messages\">\n\t<li>Welcome to ZeroChat!</li>\n</ul>\n</body>\n</html>\n```\n\n#调用ZeroNet API\nAPI允许查询服务器、站点和用户信息，借助连接到客户机的WebSocket载入和编辑文件。\n创建**js**和**js/lib**目录。下载[ZeroFrame.coffee](http://127.0.0.1:43110/Blog.ZeroNetwork.bit/data/files/ZeroFrame.coffee)并将之拷贝到**js/lib**目录下，有助于使用ZeroFrame API。\n- 使用以下代码在**js**目录创建ZeroChat.coffee文件\n\n```\nclass ZeroChat extends ZeroFrame\n    init: ->\n        @addLine \"inited!\"\n\n    addLine: (line) ->\n        messages = document.getElementById(\"messages\")\n        messages.innerHTML = \"<li>#{line}</li>\"+messages.innerHTML\n\n\n    # Wrapper websocket connection ready\n    onOpenWebsocket: (e) =>\n        @cmd \"serverInfo\", {}, (server_info) =>\n            @addLine \"serverInfo response: <pre>\" + JSON.stringify(server_info,null,2) + \"</pre>\"\n        @cmd \"siteInfo\", {}, (site_info) =>\n            @addLine \"siteInfo response: <pre>\" + JSON.stringify(site_info,null,2) + \"</pre>\"\n\nwindow.Page = new ZeroChat()\n```\n\n在WebSocket链接准备好后，上面的代码将查询站点和服务器（也就是你的客户机）上的所有信息，然后以json的格式添加到html文件的`messages`节点中。\n- 在index.html文件的</body>前一行添加` <script type=\"text/javascript\" src=\"js/all.js\" async></script> `，这是为了自动地编译和合并.coffee文件至一个单一的**all.js**文件。\n- 在浏览器键入你的网站地址（如 http://127.0.0.1:43110/1N1Ga6T2wiCZujYD7yCAgV8EiNwWEsjzVo ），如果一切无误，应如下图所示：\n[图例](http://127.0.0.1:43110/Blog.ZeroNetwork.bit/data/img/tutorial-1.png)\n\n然后，在你相应的站点目录下应该有如下文件结构：\n\n```\ndata/[你的站点地址]\n├─ js/\n│  ├─ lib/\n│  │  └─ ZeroFrame.coffee\n│  ├─ ZeroChat.coffee\n│  └─ all.js\n├── index.html\n└── content.json\n```\n\n- 以后只要编辑了站点文件就要重新签名和发布。（原文文档用的还是命令行形式，这里推荐使用 P2P 在 [这篇](http://127.0.0.1:43110/1Nse6WcodQ5Mj6ZwvZvuyCVvQESwuxbCUy/?Topic:1_13Z7XxTa7JuFat3KzzMWu3onwM6biLuurJ/+ZeroNet+4+1+update) 帖子里的做法，简单方便。签名和发布前记得先备份整个站点文件夹。切记！切记！切记！别问我是怎么知道的，说多了全是泪。\n",
			"added": 1463962301,
			"parent_topic_uri": "1_1GjE7cvDKxeqqXotaS1iCL7HZUovnLpQkW"
		},
		{
			"topic_id": 9,
			"title": "站点开发篇：二 示例 #2",
			"body": "**_译自http://127.0.0.1:43110/Blog.ZeroNetwork.bit/?Post:46:ZeroNet+site+development+tutorial+2_**\n在第一部分，我们调用简单的ZeroFrame API 建了一个站点。\n在这一部分，我们将继续扩展它的功能让它接收、存储和查询SQLite数据库信息，使用ZeroID验证用户名。\n最终的完整示例和源码见：\nhttp://127.0.0.1:43110/1N1Ga6T2wiCZujYD7yCAgV8EiNwWEsjzVo/\n\n#加入ZeroID用户选择\n\n 我们需要在index.html中加入一个新的链接，可让我们选择想使用的ZeroID身份。\n```\n<html>\n<body>\n<a href=\"#Select+user\" id=\"select_user\" onclick='return Page.selectUser()'>Select user</a>:\n<input type=\"text\" id=\"message\"><input type=\"button\" id=\"send\" value=\"Send!\"/>\n<ul id=\"messages\">\n <li>Welcome to ZeroChat!</li>\n</ul>\n<script type=\"text/javascript\" src=\"js/all.js\" async></script>\n</body>\n</html>\n```\n想要让它工作还有在**js/ZeroChat.coffee**中加入显示用户身份选择对话框的功能。\n```\n    selectUser: =>\n        Page.cmd \"certSelect\", [[\"zeroid.bit\"]]\n        return false\n```\n作为一个重要的参数，必须包含证书颁发机构的名称。（这里是：zeroid.bit）。\n当我们刷新浏览器并点击`Select User`(中文示例中已经改为`登陆`，此时，建议先按原文的做测试)，能看到出现对话框，但是当我们选择身份时不会引起其它的变化。\n\n#显示当前ZeroID账户\n\n当有新内容送达、用户改变等会影响网站的情况发生时，相应的Websocket事件应推送到浏览器。\n_(其格式如查询 setSiteInfo 命令一样)_\n加入以下代码，实时更新用户选择的身份：\n```\n    route: (cmd, message) ->\n        if cmd == \"setSiteInfo\"\n            if message.params.cert_user_id\n                document.getElementById(\"select_user\").innerHTML = message.params.cert_user_id\n            else\n                document.getElementById(\"select_user\").innerHTML = \"Select user\"\n            @site_info = message.params  # Save site info data to allow access it later\n```\n要在浏览器中同步更新用户名，还需要一个**onOpenWebsocket**的功能:\n```\nonOpenWebsocket: (e) =>\n        @cmd \"serverInfo\", {}, (server_info) =>\n            @addLine \"serverInfo response: <pre>\" + JSON.stringify(server_info,null,2) + \"</pre>\"\n        @cmd \"siteInfo\", {}, (site_info) =>\n            @addLine \"siteInfo response: <pre>\" + JSON.stringify(site_info,null,2) + \"</pre>\"\n            # Update currently selected username\n            if site_info.cert_user_id\n                document.getElementById(\"select_user\").innerHTML = site_info.cert_user_id\n            @site_info = site_info  # Save site info data to allow access it later\n```\n#设置用户内容权限\n确定好用户内容权限，才能允许用户发送信息。\n新建一个 **data/users** 目录，然后在目录下新建 **content.json** 文件。\n_(这个目录是你的网站目录下面的，如：`ZeroNet\\data\\1N1Ga6T2wiCZujYD7yCAgV8EiNwWEsjzVo\\data\\users`  ，不能混淆)_\n文件内容如下：\n```\n{\n  \"files\": {},\n  \"ignore\": \".*\",\n  \"modified\": 0.0,\n  \"signs\": {},\n  \"user_contents\": {\n    \"cert_signers\": {\n      \"zeroid.bit\": [ \"1iD5ZQJMNXu43w1qLB8sfdHVKppVMduGz\" ]\n    },\n    \"permission_rules\": {\n      \".*\": {\n        \"files_allowed\": \"data.json\",\n        \"max_size\": 10000\n      },\n      \"bitmsg/.*@zeroid.bit\": { \"max_size\": 15000 }\n    },\n    \"permissions\": {\n      \"bad@zeroid.bit\": false,\n      \"nofish@zeroid.bit\": { \"max_size\": 100000 }\n    }\n  }\n}\n```\n- `\"ignore\": \".*\",`:：当站点拥有人签名**content.json**时，不会有任何文件添加，它们会被用户签名。\n_(这句话的原文意思不是太明确，我猜想大概是想表明：在每个用户对应的文件夹下面还有一个content.json，这个文件可以被相应的用户签名。如果所有的用户的签名都是有效的，那么合并起来的文件也会是有效的。所以，例子中的**content.json**文件默认跳过文件签名，将签名的工作分给每个发信息的用户。如果有理解的不对的地方，请大家指出。)_\n- `cert_signers`: 接受获得 **zeroid.bit** 证书的用户。\n- `permission_rules`: 每个用户10K空间。如果是 bitmessage 注册的15K。\n- `permissions`: 指定用户权限设置：禁止bad@zeroid.bit，给nofish@zeroid.bit user特权100K。为什么他会有这么多？我不用解释了吧？\n\n保存文件。编辑`root_content.json`。（在一个站点的目录下有好多的content.json。第一个为`root_content.json`，在user目录下的一个是`user_content.json`，在user\\yourUserID\\目录下还有content.json。不要搞混了。）\n```\n\"ignore\": \"data/.*\",\n  \"includes\": {\n    \"data/users/content.json\": {\n      \"signers\": [],\n      \"signers_required\": 1\n    }\n  },\n```\n- `\"ignore\": \"data/.*\"`：忽略这个目录下的文件。\n- `includes`：载入 **user_content.json**，它含有用户权限等内容。\n\n> 注意：通过添加地址到 **signers** 列表可赋予其他用户适度的权限。\n\n现在我们需要给这个`data/users/content.json`文件签名。\n- 命令行\n`zeronet.py siteSign [siteaddress] --inner_path data/users/content.json`\n- 使用隐藏菜单，前面已经推荐过，不详述。\n\n#向json文件添加信息\n实现的功能是：当点击`发送`(原文**send**)时，添加信息至**data.json**，签名，发布给其他用户。\n- 向发送按钮对应的html标签添加`onclick=\"return Page.sendMessage()\"`事件。\n- 在**ZeroChat.coffee**中添加如下代码：\n\n```\n    sendMessage: =>\n        if not Page.site_info.cert_user_id  # No account selected, display error\n            Page.cmd \"wrapperNotification\", [\"info\", \"Please, select your account.\"]\n            return false\n\n        inner_path = \"data/users/#{@site_info.auth_address}/data.json\"  # This is our data file\n\n        # Load our current messages\n        @cmd \"fileGet\", {\"inner_path\": inner_path, \"required\": false}, (data) =>\n            if data  # Parse if already exits\n                data = JSON.parse(data)\n            else  # Not exits yet, use default data\n                data = { \"message\": [] }\n\n            # Add the message to data\n            data.message.push({\n                \"body\": document.getElementById(\"message\").value,\n                \"date_added\": (+new Date)\n            })\n\n            # Encode data array to utf8 json text\n            json_raw = unescape(encodeURIComponent(JSON.stringify(data, undefined, '\\t')))\n\n            # Write file to disk\n            @cmd \"fileWrite\", [inner_path, btoa(json_raw)], (res) =>\n                if res == \"ok\"\n                    # Publish the file to other users\n                    @cmd \"sitePublish\", {\"inner_path\": inner_path}, (res) =>\n                        document.getElementById(\"message\").value = \"\"  # Reset the message input\n                else\n                    @cmd \"wrapperNotification\", [\"error\", \"File write error: #{res}\"]\n\n        return false\n```\n转到浏览器页面，在信息输入框里随便输入点什么，然后点击发送。浏览器虽然没有什么变化，可是在 **data/users/[your auth address]/data.json** 多了这个文件。\n\n#建立数据库　\n\n在存储和发送信息以后，让信息可以显示出来最好的办法就是将 **data.json** 存进数据库。\n只要有描述数据库数据表结构的 **dbschema.json** 在你的站点目录下，那么将**data.json** 中的信息导入进数据库的工作ZeroNet就可以自动完成。\n下面是 **dbschema.json** 文件的内容：\n```\n{\n    \"db_name\": \"ZeroChat\",\n    \"db_file\": \"data/zerochat.db\",\n    \"version\": 2,\n    \"maps\": {\n        \"users/.+/data.json\": {\n            \"to_table\": [ \"message\" ]\n        },\n        \"users/.+/content.json\": {\n            \"to_keyvalue\": [ \"cert_user_id\" ]\n        }\n    },\n    \"tables\": {\n        \"message\": {\n            \"cols\": [\n                [\"body\", \"TEXT\"],\n                [\"date_added\", \"INTEGER\"],\n                [\"json_id\", \"INTEGER REFERENCES json (json_id)\"]\n            ],\n            \"indexes\": [\"CREATE UNIQUE INDEX message_key ON message(json_id, date_added)\"],\n            \"schema_changed\": 1\n        }\n    }\n}\n```\n按照惯例，让我们逐条解释一下：\n- `\"db_name\": \"ZeroChat\"`: 仅仅用作调试。\n- `\"db_file\": \"data/zerochat.db\"`: SQLite数据库文件保存在这里。\n- `\"version\": 2`: 定义json数据表结构，Ver 2更加适合ZeroID基础站点。可参考[官方文档](http://zeronet.readthedocs.org/en/latest/site_development/dbschema_json/)。\n- `\"maps\": {`: 描述 **json** 文件如何转换至数据表。\n- `\"users/.+/data.json\": { \"to_table\": [ \"message\" ] }`: 将每个用户的 **data.json** 文件放进 **message** 数据表。\n- `\"users/.+/content.json\": { \"to_keyvalue\": [ \"cert_user_id\" ] }`: 将用户的授权ID存储进单一键值 **cert_user_id**。\n- `\"tables\": {`: 描述数据表和索引结构。\n- `[\"json_id\", \"INTEGER REFERENCES json (json_id)\"]`: 每个数据表都有 **json_id** 列，它定义原始文件路径。\n- `\"schema_changed\": 1`: 更改数据表结构数值+1。客户端能删除这个表并从json文件重建。\n\n>小技巧：: 在数据表中建立**json_id**索引可以保证最好的性能。\n执行`zeronet.py dbRebuild [your site address]`命令，`data/zerochat.db`文件将被创建。开源的SQLiteStudio可以查看这个文件。\n在这一步，我们又要重启ZeroNet客户端了。话不多说，重启吧。\n>在Windows环境下，上面的命令运行起来有些困难。所以，想要一劳永逸的，还是为python设置好环境参数和路径吧。\n\n#显示信息\n使用`dbQuery`查新数据库。\n```\n    loadMessages: ->\n        @cmd \"dbQuery\", [\"SELECT * FROM message ORDER BY date_added\"], (messages) =>\n            document.getElementById(\"messages\").innerHTML = \"\"  # Always start with empty messages\n            for message in messages\n                @addLine message.body\n```\n在子函数 **onOpenWebsocket** 中添加`@loadMessages()` 。刷新浏览器应该可以看到自己键入的信息了。\n为了又新信息进入我们能实时看到，还需要将`@loadMessages() `添加到 **route** :\n```\n    route: (cmd, message) ->\n        if cmd == \"setSiteInfo\"\n            if message.params.cert_user_id\n                document.getElementById(\"select_user\").innerHTML = message.params.cert_user_id\n            else\n                document.getElementById(\"select_user\").innerHTML = \"Select user\"\n            @site_info = message.params  # Save site info data to allow access it later\n\n            # Reload messages if new file arrives\n            if message.params.event[0] == \"file_done\"\n                @loadMessages()\n```\n提交一个信息就重新加载一遍数据：\n```\n    sendMessage: =>\n        ...\n            # Write file to disk\n            @cmd \"fileWrite\", [inner_path, btoa(json_raw)], (res) =>\n                @loadMessages()\n```\n好了，现在信息可以实时更新了。可以打开另外的一个浏览器窗口测试一下。\n#显示ZeroID用户名\n为了显示发送信息人员的用户名，我们不得不建一个复杂一点的SQL查询，这是因为用户名保存在`content.json`文件里，而信息保存在`data.json`文件里。在这个查询中我们还得将信息里的html标签剔除。\n```\n    loadMessages: ->\n        query = \"\"\"\n            SELECT message.*, keyvalue.value AS cert_user_id FROM message\n            LEFT JOIN json AS data_json USING (json_id)\n            LEFT JOIN json AS content_json ON (\n                data_json.directory = content_json.directory AND content_json.file_name = 'content.json'\n            )\n            LEFT JOIN keyvalue ON (keyvalue.key = 'cert_user_id' AND keyvalue.json_id = content_json.json_id)\n            ORDER BY date_added\n        \"\"\"\n        @cmd \"dbQuery\", [query], (messages) =>\n            document.getElementById(\"messages\").innerHTML = \"\"  # Always start with empty messages\n            for message in messages\n                body = message.body.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\")  # Escape html tags in body\n                @addLine \"<b>#{message.cert_user_id}</b>: #{body}\"\n```\n#见证奇迹的时刻\n- 移除**siteInfo** 和 **serverInfo** 的调试信息\n\n```\n    onOpenWebsocket: (e) =>\n        @cmd \"siteInfo\", {}, (site_info) =>\n            # Update currently selected username\n            if site_info.cert_user_id\n                document.getElementById(\"select_user\").innerHTML = site_info.cert_user_id\n            @site_info = site_info  # Save site info data to allow access it later\n        @loadMessages()\n```\n- 回车也能发送信息\n\n```<input type=\"text\" id=\"message\" onkeypress=\"if (event.keyCode == 13) Page.sendMessage()\">```\n- 添加CSS让网站更好看\n\n```\n<style>\n* { font-family: monospace; line-height: 1.5em; font-size: 13px; vertical-align: middle; }\nbody { background-color: white; }\ninput#message { padding: 5px; width: 50%; height: 34px; }\ninput#send { height: 34px; margin-left: -2px; }\nul { padding: 0px; }\nli { list-style-type: none; border-top: 1px solid #eee; padding: 5px 0px; }\nli:nth-child(odd) { background-color: #F9FAFD; }\nli b { color: #3F51B5; }\n</style>\n```\n都是高手，添加到哪里就不用我说了吧？\n- 最后记住，更改了任何文件都要重新签名并发布。请习惯使用隐藏菜单的`sign & publish`。\n\n>友情提示：**签名有风险，发布需谨慎！**。请提前备份好网站。\n\n###到这一步你已经有了一个无服务器、纯P2P的SQL聊天室了。\n###恭喜你！！！\n　　\n——全文完——",
			"added": 1463962302,
			"parent_topic_uri": "1_1GjE7cvDKxeqqXotaS1iCL7HZUovnLpQkW"
		}
	],
	"topic_vote": {},
	"next_comment_id": 2,
	"comment": {
		"4_1GjE7cvDKxeqqXotaS1iCL7HZUovnLpQkW": []
	},
	"comment_vote": {}
}