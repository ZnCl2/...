{
	"content":"几乎每个人都听说过像比特币和以太币这样的加密货币，但是只有极少数人懂得隐藏在它们背后的技术。在这篇文章中，将会用JavaScript来创建一个简单的区块链来演示它们的内部究竟是如何工作的。这里将它称之为SavjeeCoin！  \r\n\r\n全文分为三个部分：  \r\nPART-1：实现一个基本的区块链  \r\nPART-2：实现POW  \r\nPART-3：交易与挖矿奖励  \r\n\r\n**PART-1：实现一个基本的区块链**  \r\n\r\n区块链是由一个个任何人都可以访问的区块构成的公共数据库。这好像没什么特别的，不过它们有一个有趣的属性：它们是不可变的。一旦一个区块被添加到区块链中，除非让剩余的其余区块失效，否则它是不会再被改变的。  \r\n\r\n这就是为什么加密货币是基于区块链的原因。你肯定不希望人们在交易完成后再变更交易吧？  \r\n\r\n**创造一个区块**  \r\n\r\n区块链是由许许多多的区块链接在一起的（这听上去好像没毛病..）。链上的区块通过某种方式允许我们检测到是否有人操纵了之前的任何区块。  \r\n\r\n那么我们如何确保数据的完整性呢？每个区块都包含一个基于其内容计算出来的hash。同时也包含了前一个区块的hash。  \r\n\r\n**下面是一个区块类用JavaScript写出来大致的样子**：  \r\n````\r\nconst SHA256 = require('crypto-jsa256');\r\nclass Block {\r\n  constructor(index, timestamp, data, previousHash = '') {\r\n    this.index = index;\r\n    this.previousHash = previousHash;\r\n    this.timestamp = timestamp;\r\n    this.data = data;\r\n    this.hash = this.calculateHash();\r\n  }\r\n\r\n  calculateHash() {\r\n    return SHA256(this.index + this.previousHash + this.timestamp + JSON.stringify(this.data)).toString();\r\n  }\r\n}\r\n````  \r\n\r\n因为JavaScript中并不支持sha256所以我引入了crypto-js库。然后我定义了一个构造函数来初始化我区块的属性。每一个区块上都被赋予了index属性来告知我们这个区块在整个链上的位置。我们同时也生成了一个时间戳，以及需要在区块里存储的一些数据。最后是前一个区块的hash。  \r\n\r\n**创造一个链**  \r\n\r\n现在我们可以在Blockchain类中将区块链接起来了！下面是用JavaScript实现的代码：\r\n````\r\nclass Blockchain{\r\n    constructor() {\r\n        this.chain = [this.createGenesisBlock()];\r\n    }\r\n\r\n    createGenesisBlock() {\r\n        return new Block(0, '01/01/2017', 'Genesis block', '0');\r\n    }\r\n\r\n    getLatestBlock() {\r\n        return this.chain[this.chain.length - 1];\r\n    }\r\n\r\n    addBlock(newBlock) {\r\n        newBlock.previousHash = this.getLatestBlock().hash;\r\n        newBlock.hash = newBlock.calculateHash();\r\n        this.chain.push(newBlock);\r\n    }\r\n\r\n    isChainValid() {\r\n        for (let i = 1; i < this.chain.length; i++){\r\n            const currentBlock = this.chain[i];\r\n            const previousBlock = this.chain[i - 1];\r\n            if (currentBlock.hash !== currentBlock.calculateHash()) {\r\n                return false;\r\n            }\r\n\r\n            if (currentBlock.previousHash !== previousBlock.hash) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n````  \r\n\r\n在构造函数里，通过创建一个包含创世块的数组来初始化整个链。第一个区块是特殊的，因为它不能指向前一个区块。还添加了下面两个方法：  \r\n\r\ngetLatestBlock()返回我们区块链上最新的区块。  \r\n\r\naddBlock()负责将新的区块添加到我们的链上。为此，我们将前一个区块的hash添加到我们新的区块中。这样我们就可以保持整个链的完整性。因为只要我们变更了最新区块的内容，我们就需要重新计算它的hash。当计算完成后，并将把这个区块推进链里（一个数组）。  \r\n\r\n最后，创建一个isChainValid()来确保没有人篡改过区块链。它会遍历所有的区块来检查每个区块的hash是否正确。它会通过比较previousHash来检查每个区块是否指向正确的上一个区块。如果一切都没有问题它会返回true否则会返回false。  \r\n\r\n**使用区块链**  \r\n\r\n我们的区块链类已经写完啦，可以真正的开始使用它了！  \r\n\r\n````\r\nlet savjeeCoin = new Blockchain();\r\nsavjeeCoin.addBlock(new Block(1, '20/07/2017', { amount: 4 }));\r\nsavjeeCoin.addBlock(new Block(2, '20/07/2017', { amount: 8 }));\r\n````  \r\n\r\n在这里仅仅是创建了一个区块链的实例，并且命名它为SavjeeCoin！之后在链上添加了一些区块。区块里可以包含任何你想要放的数据，不过在上面的代码里，选择添加了一个带有amount属性的对象。  \r\n\r\n**试着操作吧！**  \r\n\r\n在介绍里曾说过区块链是不可变的。一旦添加，区块就不可能再变更了。让我们试一下！  \r\n\r\n````\r\n// 检查是否有效(将会返回true)\r\nconsole.log('Blockchain valid? ' + savjeeCoin.isChainValid());\r\n// 现在尝试操作变更数据\r\nsavjeeCoin.chain[1].data = { amount: 100 };\r\n// 再次检查是否有效 (将会返回false)\r\nconsole.log('Blockchain valid? ' + savjeeCoin.isChainValid());\r\n````  \r\n\r\n会在一开始通过运行isChainValid()来验证整个链的完整性。我们操作过任何区块，所以它会返回true。  \r\n\r\n之后将链上的第一个（索引为1）区块的数据进行了变更。再次检查整个链的完整性，发现它返回了false。我们的整个链不再有效了。  \r\n\r\n**结论**  \r\n\r\n这个小例子还远远未达到完成的程度。它还没有实现POW（工作量证明机制）或P2P网络来与其它矿工来进行交流。  \r\n\r\n但他确实证明了区块链的工作原理。许多人认为原理会非常复杂，但这篇文章证明了区块链的基本概念是非常容易理解和实现的。  \r\n\r\n**PART-2：实现POW(proof-of-work:工作量证明)**  \r\n\r\n在PART-1中我们用JavaScript创建了一个简单的区块链来演示区块链的工作原理。不过这个实现并不完整，很多人发现依旧可以篡改该系统。没错！我们的区块链需要另一种机制来抵御攻击。那么让我们来看看我们该如何做到这一点！  \r\n\r\n**问题**  \r\n\r\n现在我们可以很快的创造区块然后非常迅速的将它们添加进我们的区块链中。不过这导致出现了三个问题：  \r\n\r\n第一：人们可以快速创建区块然后在我们的链里塞满垃圾。大量的区块会导致我们区块链过载并让其无法使用。  \r\n\r\n第二：因为创建一个有效的区块太容易了，人们可以篡改链中的某一个区块，然后重新计算所有区块的hash。即使它们已经篡改了区块，他们仍然可以以有效的区块来作为结束。  \r\n\r\n第三：你可以通过结合上述两个破绽来有效控制区块链。区块链由p2p网络驱动， 其中节点会将区块添加到可用的最长链中。所以你可以篡改区块，然后计算所有其他的区块，最后添加多任意你想要添加的区块。你最后会得到一个最长的链，所有的其它节点都会接受它然后往上添加自己的区块。  \r\n\r\n**显然我们需要一个方案来解决这些问题：POW。**  \r\n\r\n什么是POW：  \r\n\r\nPOW是在第一个区块链被创造之前就已经存在的一种机制。这是一项简单的技术，通过一定数量的计算来防止滥用。工作量是防止垃圾填充和篡改的关键。如果它需要大量的算力，那么填充垃圾就不再值得。  \r\n\r\n比特币通过要求hash以特定0的数目来实现POW。这也被称之为难度，不过等一下！一个区块的hash怎么可以改变呢？在比特币的场景下，一个区块包含有各种金融交易信息。我们肯定不希望为了获取正确的hash而混淆了那些数据。  \r\n\r\n为了解决这个问题，区块链添加了一个nonce值。Nonce是用来查找一个有效Hash的次数。而且，因为无法预测hash函数的输出，因此在获得满足难度条件的hash之前，只能大量组合尝试。寻找到一个有效的hash（创建一个新的区块）在圈内称之为挖矿。  \r\n\r\n在比特币的场景下，POW确保每10分钟只能添加一个区块。你可以想象垃圾填充者需要多大的算力来创造一个新区块，他们很难欺骗网络，更不要说篡改整个链。  \r\n\r\n**实现POW**  \r\n\r\n我们该如何实现呢？我们先来修改我们区块类并在其构造函数中添加Nonce变量。我会初始化它并将其值设置为0。  \r\n\r\n````  \r\nconstructor(index, timestamp, data, previousHash = '') {\r\n    this.index = index;\r\n    this.previousHash = previousHash;\r\n    this.timestamp = timestamp;\r\n    this.data = data;\r\n    this.hash = this.calculateHash();\r\n    this.nonce = 0;\r\n}\r\n````  \r\n我们还需要一个新的方法来增加Nonce，直到我们获得一个有效hash。强调一下，这是由难度决定的。所以我们会收到作为参数的难度。  \r\n\r\n````  \r\nmineBlock(difficulty) {\r\n    while (this.hash.substring(0, difficulty) !== Array(difficulty + 1).join('0')) {\r\n        this.nonce++;\r\n        this.hash = this.calculateHash();\r\n    }\r\n    console.log('BLOCK MINED: ' + this.hash);\r\n}\r\n````  \r\n\r\n最后，我们还需要更改一下calculateHash()函数。因为目前他还没有使用Nonce来计算hash。  \r\n\r\n````  \r\ncalculateHash() {\r\n    return SHA256(this.index +\r\n        this.previousHash +\r\n        this.timestamp +\r\n        JSON.stringify(this.data) +\r\n        this.nonce\r\n    ).toString();\r\n}\r\n````  \r\n将它们结合在一起，你会得到如下所示的区块类：  \r\n\r\n````  \r\nclass Block {\r\n    constructor(index, timestamp, data, previousHash = '') {\r\n        this.index = index;\r\n        this.previousHash = previousHash;\r\n        this.timestamp = timestamp;\r\n        this.data = data;\r\n        this.hash = this.calculateHash();\r\n        this.nonce = 0;\r\n    }\r\n    calculateHash() {\r\n        return SHA256(this.index + this.previousHash + this.timestamp + JSON.stringify(this.data) + this.nonce).toString();\r\n    }\r\n    mineBlock(difficulty) {\r\n        while (this.hash.substring(0, difficulty) !== Array(difficulty + 1).join('0')) {\r\n            this.nonce++;\r\n            this.hash = this.calculateHash();\r\n        }\r\n        console.log('BLOCK MINED: ' + this.hash);\r\n    }\r\n}\r\n````  \r\n\r\n**修改区块链**  \r\n\r\n现在，我们的区块已经拥有Nonce并且可以被开采了，我们还需要确保我们的区块链支持这种新的行为。让我们先在区块链中添加一个新的属性来跟踪整条链的难度。然后会将它设置为2（这意味着区块的hash必须以2个0开头）。  \r\n\r\n````  \r\nconstructor() {\r\n    this.chain = [this.createGenesisBlock()];\r\n    this.difficulty = 2;\r\n}\r\n````  \r\n现在剩下要做的就是改变addBlock()方法，以便在将其添加到链中之前确保实际挖到该区块。下面我们将难度传给区块。  \r\n\r\n````  \r\naddBlock(newBlock) {\r\n    newBlock.previousHash = this.getLatestBlock().hash;\r\n    newBlock.mineBlock(this.difficulty);\r\n    this.chain.push(newBlock);\r\n}\r\n````  \r\n\r\n大功告成！我们的区块链现在拥有了POW来抵御攻击了。  \r\n\r\n**测试**  \r\n\r\n现在让我们来测试一下我们的区块链，看看在POW下添加一个新区块会有什么效果。我将会使用之前的代码。我们将创建一个新的区块链实例然后往里添加2个区块。  \r\n\r\n````  \r\nlet savjeeCoin = new Blockchain();\r\nconsole.log('Mining block 1');\r\nsavjeeCoin.addBlock(new Block(1, '20/07/2017', { amount: 4 }));\r\nconsole.log('Mining block 2');\r\nsavjeeCoin.addBlock(new Block(2, '20/07/2017', { amount: 8 }));\r\n````  \r\n\r\n如果你运行了上面的代码，你会发现添加新区块依旧非常快。这是因为目前的难度只有2（或者你的电脑性能非常好）。  \r\n\r\n如果你创建了一个难度为5的区块链实例，你会发现你的电脑会花费大概十秒钟来挖矿。随着难度的提升，你的防御攻击的保护程度也会越高。  \r\n\r\n**PART-3：交易与挖矿奖励**  \r\n\r\n在前面两部分我们创建了一个简单的区块链，并且加入了POW来抵御攻击。然而我们在途中也偷了懒：我们的区块链只能在一个区块中存储一笔交易，而且矿工没有奖励。现在，让我们解决这个问题！  \r\n\r\n**重构区块类**  \r\n\r\n现在一个区块拥有index,previousHash,timestamp,data,hash和nonce属性。这个index属性并不是很有用，于此同时将data改名为transactions来更语义化。  \r\n\r\n````  \r\nclass Block{\r\n    constructor(timestamp, transactions, previousHash = '') {\r\n        this.previousHash = previousHash;\r\n        this.timestamp = timestamp;\r\n        this.transactions = transactions;\r\n        this.hash = this.calculateHash();\r\n        this.nonce = 0;\r\n    }\r\n}\r\n````  \r\n\r\n当我们改变区块类时，我们也必须更改calculateHash()函数。现在它还在使用老旧的index和data属性。  \r\n\r\n````  \r\ncalculateHash() {\r\n    return SHA256(this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce).toString();\r\n}\r\n````  \r\n\r\n交易类  \r\n\r\n在区块内，我们将可以存储多笔交易。因此我们还需要定义一个交易类，一边我们可以锁定交易应当具有的属性：  \r\n\r\n````  \r\nclass Transaction{\r\n    constructor(fromAddress, toAddress, amount){\r\n        this.fromAddress = fromAddress;\r\n        this.toAddress = toAddress;\r\n        this.amount = amount;\r\n    }\r\n}\r\n````  \r\n\r\n这个交易例子非常的简单，仅仅包含了发起方（fromAddress）和接受方（toAddress）以及数量。如果有需求，你也可以在里面加入更多字段，不过这个只是为了最小实现。  \r\n\r\n**调整我们的区块链**  \r\n\r\n当前的最大任务：调整我们的区块链来适应这些新变化。我们需要做的第一件事就是存储待处理交易的地方。  \r\n\r\n正如你所知道的，由于POW，区块链可以稳定的创建区块。在比特币的场景下，难度被设置成大约每10分钟创建一个新区块。但是，是可以在创造两个区块之间提交新的交易。  \r\n\r\n为了做到这一点，首先需要改变我们区块链的构造函数，以便他可以存储待处理的交易。我们还将创造一个新的属性，用于定义矿工获得多少钱作为奖励：  \r\n\r\n````  \r\nclass Blockchain{\r\n    constructor() {\r\n        this.chain = [this.createGenesisBlock()];\r\n        this.difficulty = 5;\r\n        // 在区块产生之间存储交易的地方\r\n        this.pendingTransactions = [];\r\n        // 挖矿回报\r\n        this.miningReward = 100;\r\n    }\r\n}\r\n````  \r\n\r\n下一步，我们将调整我们的addBlock()方法。我们将不再允许人们直接为链上添加区块。相反，他们必须将交易添加至下一个区块中。而且我们将addBlock()更名为createTransaction()，这看起来更语义化：  \r\n\r\n````  \r\ncreateTransaction(transaction) {\r\n    // 这里应该有一些校验!\r\n    // 推入待处理交易数组\r\n    this.pendingTransactions.push(transaction);\r\n}\r\n````  \r\n\r\n**挖矿**  \r\n\r\n人们现在可以将新的交易添加到待处理交易的列表中。但无论如何，我们需要将他们清理掉并移入实际的区块中。为此，我们来创建一个minePendingTransactions()方法。这个方法不仅会挖掘所有待交易的新区块，而且还会向采矿者发送奖励。  \r\n\r\n````  \r\nminePendingTransactions(miningRewardAddress) {\r\n    // 用所有待交易来创建新的区块并且开挖..\r\n    let block = new Block(Date.now(), this.pendingTransactions);\r\n    block.mineBlock(this.difficulty);\r\n    // 将新挖的看矿加入到链上\r\n    this.chain.push(block);\r\n    // 重置待处理交易列表并且发送奖励\r\n    this.pendingTransactions = [\r\n        new Transaction(null, miningRewardAddress, this.miningReward)\r\n    ];\r\n}\r\n````  \r\n\r\n请注意，该方法采用了参数miningRewardAddress。如果你开始挖矿，你可以将你的钱包地址传递给此方法。一旦成功挖到矿，系统将创建一个新的交易来给你挖矿奖励（在这个例子里是100枚币）。  \r\n\r\n有一点需要注意的是，在这个例子中，我们将所有待处理交易一并添加到一个区块中。但实际上，由于区块的大小是有限制的，所以这是行不通的。在比特币里，一个区块的大小大概是2Mb。如果有更多的交易能够挤进一个区块，那么矿工可以选择哪些交易达成哪些交易不达成（通常情况下费用更高的交易容易获胜）。  \r\n\r\n**地址的余额**  \r\n\r\n在测试我们的代码前让我们再做一件事，如果能够检查我们区块链上地址的余额将会更好。  \r\n\r\n````  \r\ngetBalanceOfAddress(address){\r\n    let balance = 0; // you start at zero!\r\n    // 遍历每个区块以及每个区块内的交易\r\n    for(const block of this.chain){\r\n        for(const trans of block.transactions){\r\n            // 如果地址是发起方 -> 减少余额\r\n            if(trans.fromAddress === address){\r\n                balance -= trans.amount;\r\n            }\r\n            // 如果地址是接收方 -> 增加余额\r\n            if(trans.toAddress === address){\r\n                balance += trans.amount;\r\n            }\r\n        }\r\n    }\r\n    return balance;\r\n}\r\n````  \r\n\r\n**测试**  \r\n\r\n好吧，我们已经完成并可以最终一切是否可以正常工作！为此，我们创建了一些交易：  \r\n\r\n````  \r\nlet savjeeCoin = new Blockchain();\r\nconsole.log('Creating some transactions...');\r\nsavjeeCoin.createTransaction(new Transaction('address1', 'address2', 100));\r\nsavjeeCoin.createTransaction(new Transaction('address2', 'address1', 50));\r\n````  \r\n\r\n这些交易目前都处于等待状态，为了让他们得到证实，我们必须开始挖矿：  \r\n\r\n````  \r\nconsole.log('Starting the miner...');\r\nsavjeeCoin.minePendingTransactions('xaviers-address');\r\n````  \r\n\r\n当我们开始挖矿，我们也会传递一个我们想要获得挖矿奖励的地址。在这种情况下，我的地址是xaviers-address（非常复杂！）。  \r\n\r\n之后，让我们检查一下xaviers-address的账户余额：  \r\n\r\n````  \r\nconsole.log('Balance of Xaviers address is', savjeeCoin.getBalanceOfAddress('xaviers-address'));\r\n// 输出: 0\r\n````  \r\n\r\n我的账户输出竟然是0？！等等，为什么？难道我不应该得到我的挖矿奖励么？那么，如果你仔细观察代码，你会看到系统会创建一个交易，然后将您的挖矿奖励添加为新的待处理交易。这笔交易将会包含在下一个区块中。所以如果我们再次开始挖矿，我们将收到我们的100枚硬币奖励！  \r\n\r\n````  \r\nconsole.log('Starting the miner again!');\r\nsavjeeCoin.minePendingTransactions('xaviers-address');\r\nconsole.log('Balance of Xaviers address is', savjeeCoin.getBalanceOfAddress('xaviers-address'));\r\n// 输出: 100\r\n````  \r\n\r\n**局限性与结论**  \r\n\r\n现在我们的区块链已经可以在一个区块上存储多笔交易，并且可以为矿工带来回报。  \r\n\r\n不过，还是有一些不足：发送货币，是我们不检查发起人是否有足够的余额来实际进行交易。然而，这其实是一件容易解决的事情。我们也没有创建一个新的钱包和签名交易（传统上用公钥/私钥加密完成）。"
}
