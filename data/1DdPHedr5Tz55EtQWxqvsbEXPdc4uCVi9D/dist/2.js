(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[2],{

/***/ "./node_modules/bip32/crypto.js":
/*!**************************************!*\
  !*** ./node_modules/bip32/crypto.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("let createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\")\nlet createHmac = __webpack_require__(/*! create-hmac */ \"./node_modules/create-hmac/browser.js\")\n\nfunction hash160 (buffer) {\n  const sha256Hash = createHash('sha256').update(buffer).digest()\n  try {\n    return createHash('rmd160').update(sha256Hash).digest()\n  } catch (err) {\n    return createHash('ripemd160').update(sha256Hash).digest()\n  }\n}\n\nfunction hmacSHA512 (key, data) {\n  return createHmac('sha512', key).update(data).digest()\n}\n\nmodule.exports = { hash160, hmacSHA512 }\n\n\n//# sourceURL=webpack:///./node_modules/bip32/crypto.js?");

/***/ }),

/***/ "./node_modules/bip32/index.js":
/*!*************************************!*\
  !*** ./node_modules/bip32/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("let Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nlet bs58check = __webpack_require__(/*! bs58check */ \"./node_modules/bs58check/index.js\")\nlet crypto = __webpack_require__(/*! ./crypto */ \"./node_modules/bip32/crypto.js\")\nlet ecc = __webpack_require__(/*! tiny-secp256k1 */ \"./node_modules/tiny-secp256k1/js.js\")\nlet typeforce = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nlet wif = __webpack_require__(/*! wif */ \"./node_modules/wif/index.js\")\n\nlet UINT256_TYPE = typeforce.BufferN(32)\nlet NETWORK_TYPE = typeforce.compile({\n  wif: typeforce.UInt8,\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32\n  }\n})\n\nlet BITCOIN = {\n  wif: 0x80,\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4\n  }\n}\n\nfunction BIP32 (d, Q, chainCode, network) {\n  typeforce(NETWORK_TYPE, network)\n\n  this.__d = d || null\n  this.__Q = Q || null\n\n  this.chainCode = chainCode\n  this.depth = 0\n  this.index = 0\n  this.network = network\n  this.parentFingerprint = 0x00000000\n}\n\nObject.defineProperty(BIP32.prototype, 'identifier', { get: function () { return crypto.hash160(this.publicKey) } })\nObject.defineProperty(BIP32.prototype, 'fingerprint', { get: function () { return this.identifier.slice(0, 4) } })\nObject.defineProperty(BIP32.prototype, 'privateKey', {\n  enumerable: false,\n  get: function () { return this.__d }\n})\nObject.defineProperty(BIP32.prototype, 'publicKey', { get: function () {\n  if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__d, this.compressed)\n  return this.__Q\n}})\n\n// Private === not neutered\n// Public === neutered\nBIP32.prototype.isNeutered = function () {\n  return this.__d === null\n}\n\nBIP32.prototype.neutered = function () {\n  let neutered = fromPublicKey(this.publicKey, this.chainCode, this.network)\n  neutered.depth = this.depth\n  neutered.index = this.index\n  neutered.parentFingerprint = this.parentFingerprint\n  return neutered\n}\n\nBIP32.prototype.toBase58 = function () {\n  let network = this.network\n  let version = (!this.isNeutered()) ? network.bip32.private : network.bip32.public\n  let buffer = Buffer.allocUnsafe(78)\n\n  // 4 bytes: version bytes\n  buffer.writeUInt32BE(version, 0)\n\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n  buffer.writeUInt8(this.depth, 4)\n\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  buffer.writeUInt32BE(this.parentFingerprint, 5)\n\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in big endian. (0x00000000 if master key)\n  buffer.writeUInt32BE(this.index, 9)\n\n  // 32 bytes: the chain code\n  this.chainCode.copy(buffer, 13)\n\n  // 33 bytes: the public key or private key data\n  if (!this.isNeutered()) {\n    // 0x00 + k for private keys\n    buffer.writeUInt8(0, 45)\n    this.privateKey.copy(buffer, 46)\n\n  // 33 bytes: the public key\n  } else {\n    // X9.62 encoding for public keys\n    this.publicKey.copy(buffer, 45)\n  }\n\n  return bs58check.encode(buffer)\n}\n\nBIP32.prototype.toWIF = function () {\n  if (!this.privateKey) throw new TypeError('Missing private key')\n  return wif.encode(this.network.wif, this.privateKey, true)\n}\n\nlet HIGHEST_BIT = 0x80000000\n\n// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\nBIP32.prototype.derive = function (index) {\n  typeforce(typeforce.UInt32, index)\n\n  let isHardened = index >= HIGHEST_BIT\n  let data = Buffer.allocUnsafe(37)\n\n  // Hardened child\n  if (isHardened) {\n    if (this.isNeutered()) throw new TypeError('Missing private key for hardened child key')\n\n    // data = 0x00 || ser256(kpar) || ser32(index)\n    data[0] = 0x00\n    this.privateKey.copy(data, 1)\n    data.writeUInt32BE(index, 33)\n\n  // Normal child\n  } else {\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    this.publicKey.copy(data, 0)\n    data.writeUInt32BE(index, 33)\n  }\n\n  let I = crypto.hmacSHA512(this.chainCode, data)\n  let IL = I.slice(0, 32)\n  let IR = I.slice(32)\n\n  // if parse256(IL) >= n, proceed with the next value for i\n  if (!ecc.isPrivate(IL)) return this.derive(index + 1)\n\n  // Private parent key -> private child key\n  let hd\n  if (!this.isNeutered()) {\n    // ki = parse256(IL) + kpar (mod n)\n    let ki = ecc.privateAdd(this.privateKey, IL)\n\n    // In case ki == 0, proceed with the next value for i\n    if (ki == null) return this.derive(index + 1)\n\n    hd = fromPrivateKey(ki, IR, this.network)\n\n  // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    let Ki = ecc.pointAddScalar(this.publicKey, IL, true)\n\n    // In case Ki is the point at infinity, proceed with the next value for i\n    if (Ki === null) return this.derive(index + 1)\n\n    hd = fromPublicKey(Ki, IR, this.network)\n  }\n\n  hd.depth = this.depth + 1\n  hd.index = index\n  hd.parentFingerprint = this.fingerprint.readUInt32BE(0)\n  return hd\n}\n\nlet UINT31_MAX = Math.pow(2, 31) - 1\nfunction UInt31 (value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX\n}\n\nBIP32.prototype.deriveHardened = function (index) {\n  typeforce(UInt31, index)\n\n  // Only derives hardened private keys by default\n  return this.derive(index + HIGHEST_BIT)\n}\n\nfunction BIP32Path (value) {\n  return typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/)\n}\n\nBIP32.prototype.derivePath = function (path) {\n  typeforce(BIP32Path, path)\n\n  let splitPath = path.split('/')\n  if (splitPath[0] === 'm') {\n    if (this.parentFingerprint) throw new TypeError('Expected master, got child')\n\n    splitPath = splitPath.slice(1)\n  }\n\n  return splitPath.reduce(function (prevHd, indexStr) {\n    let index\n    if (indexStr.slice(-1) === \"'\") {\n      index = parseInt(indexStr.slice(0, -1), 10)\n      return prevHd.deriveHardened(index)\n    } else {\n      index = parseInt(indexStr, 10)\n      return prevHd.derive(index)\n    }\n  }, this)\n}\n\nBIP32.prototype.sign = function (hash) {\n  return ecc.sign(hash, this.privateKey)\n}\n\nBIP32.prototype.verify = function (hash, signature) {\n  return ecc.verify(hash, this.publicKey, signature)\n}\n\nfunction fromBase58 (string, network) {\n  let buffer = bs58check.decode(string)\n  if (buffer.length !== 78) throw new TypeError('Invalid buffer length')\n  network = network || BITCOIN\n\n  // 4 bytes: version bytes\n  let version = buffer.readUInt32BE(0)\n  if (version !== network.bip32.private &&\n    version !== network.bip32.public) throw new TypeError('Invalid network version')\n\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n  let depth = buffer[4]\n\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  let parentFingerprint = buffer.readUInt32BE(5)\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new TypeError('Invalid parent fingerprint')\n  }\n\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n  let index = buffer.readUInt32BE(9)\n  if (depth === 0 && index !== 0) throw new TypeError('Invalid index')\n\n  // 32 bytes: the chain code\n  let chainCode = buffer.slice(13, 45)\n  let hd\n\n  // 33 bytes: private key data (0x00 + k)\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new TypeError('Invalid private key')\n    let k = buffer.slice(46, 78)\n\n    hd = fromPrivateKey(k, chainCode, network)\n\n  // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    let X = buffer.slice(45, 78)\n\n    hd = fromPublicKey(X, chainCode, network)\n  }\n\n  hd.depth = depth\n  hd.index = index\n  hd.parentFingerprint = parentFingerprint\n  return hd\n}\n\nfunction fromPrivateKey (privateKey, chainCode, network) {\n  typeforce({\n    privateKey: UINT256_TYPE,\n    chainCode: UINT256_TYPE\n  }, { privateKey, chainCode })\n  network = network || BITCOIN\n\n  if (!ecc.isPrivate(privateKey)) throw new TypeError('Private key not in range [1, n)')\n  return new BIP32(privateKey, null, chainCode, network)\n}\n\nfunction fromPublicKey (publicKey, chainCode, network) {\n  typeforce({\n    publicKey: typeforce.BufferN(33),\n    chainCode: UINT256_TYPE\n  }, { publicKey, chainCode })\n  network = network || BITCOIN\n\n  // verify the X coordinate is a point on the curve\n  if (!ecc.isPoint(publicKey)) throw new TypeError('Point is not on the curve')\n  return new BIP32(null, publicKey, chainCode, network)\n}\n\nfunction fromSeed (seed, network) {\n  typeforce(typeforce.Buffer, seed)\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits')\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits')\n  network = network || BITCOIN\n\n  let I = crypto.hmacSHA512('Bitcoin seed', seed)\n  let IL = I.slice(0, 32)\n  let IR = I.slice(32)\n\n  return fromPrivateKey(IL, IR, network)\n}\n\nmodule.exports = {\n  fromBase58,\n  fromPrivateKey,\n  fromPublicKey,\n  fromSeed\n}\n\n\n//# sourceURL=webpack:///./node_modules/bip32/index.js?");

/***/ }),

/***/ "./node_modules/bitcoin-ops/index.json":
/*!*********************************************!*\
  !*** ./node_modules/bitcoin-ops/index.json ***!
  \*********************************************/
/*! exports provided: OP_FALSE, OP_0, OP_PUSHDATA1, OP_PUSHDATA2, OP_PUSHDATA4, OP_1NEGATE, OP_RESERVED, OP_TRUE, OP_1, OP_2, OP_3, OP_4, OP_5, OP_6, OP_7, OP_8, OP_9, OP_10, OP_11, OP_12, OP_13, OP_14, OP_15, OP_16, OP_NOP, OP_VER, OP_IF, OP_NOTIF, OP_VERIF, OP_VERNOTIF, OP_ELSE, OP_ENDIF, OP_VERIFY, OP_RETURN, OP_TOALTSTACK, OP_FROMALTSTACK, OP_2DROP, OP_2DUP, OP_3DUP, OP_2OVER, OP_2ROT, OP_2SWAP, OP_IFDUP, OP_DEPTH, OP_DROP, OP_DUP, OP_NIP, OP_OVER, OP_PICK, OP_ROLL, OP_ROT, OP_SWAP, OP_TUCK, OP_CAT, OP_SUBSTR, OP_LEFT, OP_RIGHT, OP_SIZE, OP_INVERT, OP_AND, OP_OR, OP_XOR, OP_EQUAL, OP_EQUALVERIFY, OP_RESERVED1, OP_RESERVED2, OP_1ADD, OP_1SUB, OP_2MUL, OP_2DIV, OP_NEGATE, OP_ABS, OP_NOT, OP_0NOTEQUAL, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD, OP_LSHIFT, OP_RSHIFT, OP_BOOLAND, OP_BOOLOR, OP_NUMEQUAL, OP_NUMEQUALVERIFY, OP_NUMNOTEQUAL, OP_LESSTHAN, OP_GREATERTHAN, OP_LESSTHANOREQUAL, OP_GREATERTHANOREQUAL, OP_MIN, OP_MAX, OP_WITHIN, OP_RIPEMD160, OP_SHA1, OP_SHA256, OP_HASH160, OP_HASH256, OP_CODESEPARATOR, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, OP_NOP1, OP_NOP2, OP_CHECKLOCKTIMEVERIFY, OP_NOP3, OP_CHECKSEQUENCEVERIFY, OP_NOP4, OP_NOP5, OP_NOP6, OP_NOP7, OP_NOP8, OP_NOP9, OP_NOP10, OP_PUBKEYHASH, OP_PUBKEY, OP_INVALIDOPCODE, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"OP_FALSE\\\":0,\\\"OP_0\\\":0,\\\"OP_PUSHDATA1\\\":76,\\\"OP_PUSHDATA2\\\":77,\\\"OP_PUSHDATA4\\\":78,\\\"OP_1NEGATE\\\":79,\\\"OP_RESERVED\\\":80,\\\"OP_TRUE\\\":81,\\\"OP_1\\\":81,\\\"OP_2\\\":82,\\\"OP_3\\\":83,\\\"OP_4\\\":84,\\\"OP_5\\\":85,\\\"OP_6\\\":86,\\\"OP_7\\\":87,\\\"OP_8\\\":88,\\\"OP_9\\\":89,\\\"OP_10\\\":90,\\\"OP_11\\\":91,\\\"OP_12\\\":92,\\\"OP_13\\\":93,\\\"OP_14\\\":94,\\\"OP_15\\\":95,\\\"OP_16\\\":96,\\\"OP_NOP\\\":97,\\\"OP_VER\\\":98,\\\"OP_IF\\\":99,\\\"OP_NOTIF\\\":100,\\\"OP_VERIF\\\":101,\\\"OP_VERNOTIF\\\":102,\\\"OP_ELSE\\\":103,\\\"OP_ENDIF\\\":104,\\\"OP_VERIFY\\\":105,\\\"OP_RETURN\\\":106,\\\"OP_TOALTSTACK\\\":107,\\\"OP_FROMALTSTACK\\\":108,\\\"OP_2DROP\\\":109,\\\"OP_2DUP\\\":110,\\\"OP_3DUP\\\":111,\\\"OP_2OVER\\\":112,\\\"OP_2ROT\\\":113,\\\"OP_2SWAP\\\":114,\\\"OP_IFDUP\\\":115,\\\"OP_DEPTH\\\":116,\\\"OP_DROP\\\":117,\\\"OP_DUP\\\":118,\\\"OP_NIP\\\":119,\\\"OP_OVER\\\":120,\\\"OP_PICK\\\":121,\\\"OP_ROLL\\\":122,\\\"OP_ROT\\\":123,\\\"OP_SWAP\\\":124,\\\"OP_TUCK\\\":125,\\\"OP_CAT\\\":126,\\\"OP_SUBSTR\\\":127,\\\"OP_LEFT\\\":128,\\\"OP_RIGHT\\\":129,\\\"OP_SIZE\\\":130,\\\"OP_INVERT\\\":131,\\\"OP_AND\\\":132,\\\"OP_OR\\\":133,\\\"OP_XOR\\\":134,\\\"OP_EQUAL\\\":135,\\\"OP_EQUALVERIFY\\\":136,\\\"OP_RESERVED1\\\":137,\\\"OP_RESERVED2\\\":138,\\\"OP_1ADD\\\":139,\\\"OP_1SUB\\\":140,\\\"OP_2MUL\\\":141,\\\"OP_2DIV\\\":142,\\\"OP_NEGATE\\\":143,\\\"OP_ABS\\\":144,\\\"OP_NOT\\\":145,\\\"OP_0NOTEQUAL\\\":146,\\\"OP_ADD\\\":147,\\\"OP_SUB\\\":148,\\\"OP_MUL\\\":149,\\\"OP_DIV\\\":150,\\\"OP_MOD\\\":151,\\\"OP_LSHIFT\\\":152,\\\"OP_RSHIFT\\\":153,\\\"OP_BOOLAND\\\":154,\\\"OP_BOOLOR\\\":155,\\\"OP_NUMEQUAL\\\":156,\\\"OP_NUMEQUALVERIFY\\\":157,\\\"OP_NUMNOTEQUAL\\\":158,\\\"OP_LESSTHAN\\\":159,\\\"OP_GREATERTHAN\\\":160,\\\"OP_LESSTHANOREQUAL\\\":161,\\\"OP_GREATERTHANOREQUAL\\\":162,\\\"OP_MIN\\\":163,\\\"OP_MAX\\\":164,\\\"OP_WITHIN\\\":165,\\\"OP_RIPEMD160\\\":166,\\\"OP_SHA1\\\":167,\\\"OP_SHA256\\\":168,\\\"OP_HASH160\\\":169,\\\"OP_HASH256\\\":170,\\\"OP_CODESEPARATOR\\\":171,\\\"OP_CHECKSIG\\\":172,\\\"OP_CHECKSIGVERIFY\\\":173,\\\"OP_CHECKMULTISIG\\\":174,\\\"OP_CHECKMULTISIGVERIFY\\\":175,\\\"OP_NOP1\\\":176,\\\"OP_NOP2\\\":177,\\\"OP_CHECKLOCKTIMEVERIFY\\\":177,\\\"OP_NOP3\\\":178,\\\"OP_CHECKSEQUENCEVERIFY\\\":178,\\\"OP_NOP4\\\":179,\\\"OP_NOP5\\\":180,\\\"OP_NOP6\\\":181,\\\"OP_NOP7\\\":182,\\\"OP_NOP8\\\":183,\\\"OP_NOP9\\\":184,\\\"OP_NOP10\\\":185,\\\"OP_PUBKEYHASH\\\":253,\\\"OP_PUBKEY\\\":254,\\\"OP_INVALIDOPCODE\\\":255}\");\n\n//# sourceURL=webpack:///./node_modules/bitcoin-ops/index.json?");

/***/ }),

/***/ "./node_modules/bitcoin-ops/map.js":
/*!*****************************************!*\
  !*** ./node_modules/bitcoin-ops/map.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var OPS = __webpack_require__(/*! ./index.json */ \"./node_modules/bitcoin-ops/index.json\")\n\nvar map = {}\nfor (var op in OPS) {\n  var code = OPS[op]\n  map[code] = op\n}\n\nmodule.exports = map\n\n\n//# sourceURL=webpack:///./node_modules/bitcoin-ops/map.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/address.js":
/*!***************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/address.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nconst bech32 = __webpack_require__(/*! bech32 */ \"./node_modules/bech32/index.js\")\nconst bs58check = __webpack_require__(/*! bs58check */ \"./node_modules/bs58check/index.js\")\nconst bscript = __webpack_require__(/*! ./script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst networks = __webpack_require__(/*! ./networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\")\nconst typeforce = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\")\nconst payments = __webpack_require__(/*! ./payments */ \"./node_modules/bitcoinjs-lib/src/payments/index.js\")\n\nfunction fromBase58Check (address) {\n  const payload = bs58check.decode(address)\n\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short')\n  if (payload.length > 21) throw new TypeError(address + ' is too long')\n\n  const version = payload.readUInt8(0)\n  const hash = payload.slice(1)\n\n  return { version: version, hash: hash }\n}\n\nfunction fromBech32 (address) {\n  const result = bech32.decode(address)\n  const data = bech32.fromWords(result.words.slice(1))\n\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data)\n  }\n}\n\nfunction toBase58Check (hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments)\n\n  const payload = Buffer.allocUnsafe(21)\n  payload.writeUInt8(version, 0)\n  hash.copy(payload, 1)\n\n  return bs58check.encode(payload)\n}\n\nfunction toBech32 (data, version, prefix) {\n  const words = bech32.toWords(data)\n  words.unshift(version)\n\n  return bech32.encode(prefix, words)\n}\n\nfunction fromOutputScript (output, network) {\n  network = network || networks.bitcoin\n\n  try { return payments.p2pkh({ output, network }).address } catch (e) {}\n  try { return payments.p2sh({ output, network }).address } catch (e) {}\n  try { return payments.p2wpkh({ output, network }).address } catch (e) {}\n  try { return payments.p2wsh({ output, network }).address } catch (e) {}\n\n  throw new Error(bscript.toASM(output) + ' has no matching Address')\n}\n\nfunction toOutputScript (address, network) {\n  network = network || networks.bitcoin\n\n  let decode\n  try {\n    decode = fromBase58Check(address)\n  } catch (e) {}\n\n  if (decode) {\n    if (decode.version === network.pubKeyHash) return payments.p2pkh({ hash: decode.hash }).output\n    if (decode.version === network.scriptHash) return payments.p2sh({ hash: decode.hash }).output\n  } else {\n    try {\n      decode = fromBech32(address)\n    } catch (e) {}\n\n    if (decode) {\n      if (decode.prefix !== network.bech32) throw new Error(address + ' has an invalid prefix')\n      if (decode.version === 0) {\n        if (decode.data.length === 20) return payments.p2wpkh({ hash: decode.data }).output\n        if (decode.data.length === 32) return payments.p2wsh({ hash: decode.data }).output\n      }\n    }\n  }\n\n  throw new Error(address + ' has no matching Script')\n}\n\nmodule.exports = {\n  fromBase58Check: fromBase58Check,\n  fromBech32: fromBech32,\n  fromOutputScript: fromOutputScript,\n  toBase58Check: toBase58Check,\n  toBech32: toBech32,\n  toOutputScript: toOutputScript\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/address.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/block.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/block.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nconst bcrypto = __webpack_require__(/*! ./crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\")\nconst fastMerkleRoot = __webpack_require__(/*! merkle-lib/fastRoot */ \"./node_modules/merkle-lib/fastRoot.js\")\nconst typeforce = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\")\nconst varuint = __webpack_require__(/*! varuint-bitcoin */ \"./node_modules/varuint-bitcoin/index.js\")\n\nconst Transaction = __webpack_require__(/*! ./transaction */ \"./node_modules/bitcoinjs-lib/src/transaction.js\")\n\nfunction Block () {\n  this.version = 1\n  this.prevHash = null\n  this.merkleRoot = null\n  this.timestamp = 0\n  this.bits = 0\n  this.nonce = 0\n}\n\nBlock.fromBuffer = function (buffer) {\n  if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)')\n\n  let offset = 0\n  function readSlice (n) {\n    offset += n\n    return buffer.slice(offset - n, offset)\n  }\n\n  function readUInt32 () {\n    const i = buffer.readUInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  function readInt32 () {\n    const i = buffer.readInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  const block = new Block()\n  block.version = readInt32()\n  block.prevHash = readSlice(32)\n  block.merkleRoot = readSlice(32)\n  block.timestamp = readUInt32()\n  block.bits = readUInt32()\n  block.nonce = readUInt32()\n\n  if (buffer.length === 80) return block\n\n  function readVarInt () {\n    const vi = varuint.decode(buffer, offset)\n    offset += varuint.decode.bytes\n    return vi\n  }\n\n  function readTransaction () {\n    const tx = Transaction.fromBuffer(buffer.slice(offset), true)\n    offset += tx.byteLength()\n    return tx\n  }\n\n  const nTransactions = readVarInt()\n  block.transactions = []\n\n  for (var i = 0; i < nTransactions; ++i) {\n    const tx = readTransaction()\n    block.transactions.push(tx)\n  }\n\n  return block\n}\n\nBlock.prototype.byteLength = function (headersOnly) {\n  if (headersOnly || !this.transactions) return 80\n\n  return 80 + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n    return a + x.byteLength()\n  }, 0)\n}\n\nBlock.fromHex = function (hex) {\n  return Block.fromBuffer(Buffer.from(hex, 'hex'))\n}\n\nBlock.prototype.getHash = function () {\n  return bcrypto.hash256(this.toBuffer(true))\n}\n\nBlock.prototype.getId = function () {\n  return this.getHash().reverse().toString('hex')\n}\n\nBlock.prototype.getUTCDate = function () {\n  const date = new Date(0) // epoch\n  date.setUTCSeconds(this.timestamp)\n\n  return date\n}\n\n// TODO: buffer, offset compatibility\nBlock.prototype.toBuffer = function (headersOnly) {\n  const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly))\n\n  let offset = 0\n  function writeSlice (slice) {\n    slice.copy(buffer, offset)\n    offset += slice.length\n  }\n\n  function writeInt32 (i) {\n    buffer.writeInt32LE(i, offset)\n    offset += 4\n  }\n  function writeUInt32 (i) {\n    buffer.writeUInt32LE(i, offset)\n    offset += 4\n  }\n\n  writeInt32(this.version)\n  writeSlice(this.prevHash)\n  writeSlice(this.merkleRoot)\n  writeUInt32(this.timestamp)\n  writeUInt32(this.bits)\n  writeUInt32(this.nonce)\n\n  if (headersOnly || !this.transactions) return buffer\n\n  varuint.encode(this.transactions.length, buffer, offset)\n  offset += varuint.encode.bytes\n\n  this.transactions.forEach(function (tx) {\n    const txSize = tx.byteLength() // TODO: extract from toBuffer?\n    tx.toBuffer(buffer, offset)\n    offset += txSize\n  })\n\n  return buffer\n}\n\nBlock.prototype.toHex = function (headersOnly) {\n  return this.toBuffer(headersOnly).toString('hex')\n}\n\nBlock.calculateTarget = function (bits) {\n  const exponent = ((bits & 0xff000000) >> 24) - 3\n  const mantissa = bits & 0x007fffff\n  const target = Buffer.alloc(32, 0)\n  target.writeUIntBE(mantissa, 29 - exponent, 3)\n  return target\n}\n\nBlock.calculateMerkleRoot = function (transactions) {\n  typeforce([{ getHash: types.Function }], transactions)\n  if (transactions.length === 0) throw TypeError('Cannot compute merkle root for zero transactions')\n\n  const hashes = transactions.map(function (transaction) {\n    return transaction.getHash()\n  })\n\n  return fastMerkleRoot(hashes, bcrypto.hash256)\n}\n\nBlock.prototype.checkMerkleRoot = function () {\n  if (!this.transactions) return false\n\n  const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions)\n  return this.merkleRoot.compare(actualMerkleRoot) === 0\n}\n\nBlock.prototype.checkProofOfWork = function () {\n  const hash = this.getHash().reverse()\n  const target = Block.calculateTarget(this.bits)\n\n  return hash.compare(target) <= 0\n}\n\nmodule.exports = Block\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/block.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/bufferutils.js":
/*!*******************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/bufferutils.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint (value, max) {\n  if (typeof value !== 'number') throw new Error('cannot write a non-number as a number')\n  if (value < 0) throw new Error('specified a negative value for writing an unsigned value')\n  if (value > max) throw new Error('RangeError: value out of range')\n  if (Math.floor(value) !== value) throw new Error('value has a fractional component')\n}\n\nfunction readUInt64LE (buffer, offset) {\n  const a = buffer.readUInt32LE(offset)\n  let b = buffer.readUInt32LE(offset + 4)\n  b *= 0x100000000\n\n  verifuint(b + a, 0x001fffffffffffff)\n  return b + a\n}\n\nfunction writeUInt64LE (buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff)\n\n  buffer.writeInt32LE(value & -1, offset)\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4)\n  return offset + 8\n}\n\nmodule.exports = {\n  readUInt64LE: readUInt64LE,\n  writeUInt64LE: writeUInt64LE\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/bufferutils.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/classify.js":
/*!****************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/classify.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const decompile = __webpack_require__(/*! ./script */ \"./node_modules/bitcoinjs-lib/src/script.js\").decompile\nconst multisig = __webpack_require__(/*! ./templates/multisig */ \"./node_modules/bitcoinjs-lib/src/templates/multisig/index.js\")\nconst nullData = __webpack_require__(/*! ./templates/nulldata */ \"./node_modules/bitcoinjs-lib/src/templates/nulldata.js\")\nconst pubKey = __webpack_require__(/*! ./templates/pubkey */ \"./node_modules/bitcoinjs-lib/src/templates/pubkey/index.js\")\nconst pubKeyHash = __webpack_require__(/*! ./templates/pubkeyhash */ \"./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/index.js\")\nconst scriptHash = __webpack_require__(/*! ./templates/scripthash */ \"./node_modules/bitcoinjs-lib/src/templates/scripthash/index.js\")\nconst witnessPubKeyHash = __webpack_require__(/*! ./templates/witnesspubkeyhash */ \"./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/index.js\")\nconst witnessScriptHash = __webpack_require__(/*! ./templates/witnessscripthash */ \"./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/index.js\")\nconst witnessCommitment = __webpack_require__(/*! ./templates/witnesscommitment */ \"./node_modules/bitcoinjs-lib/src/templates/witnesscommitment/index.js\")\n\nconst types = {\n  P2MS: 'multisig',\n  NONSTANDARD: 'nonstandard',\n  NULLDATA: 'nulldata',\n  P2PK: 'pubkey',\n  P2PKH: 'pubkeyhash',\n  P2SH: 'scripthash',\n  P2WPKH: 'witnesspubkeyhash',\n  P2WSH: 'witnessscripthash',\n  WITNESS_COMMITMENT: 'witnesscommitment'\n}\n\nfunction classifyOutput (script) {\n  if (witnessPubKeyHash.output.check(script)) return types.P2WPKH\n  if (witnessScriptHash.output.check(script)) return types.P2WSH\n  if (pubKeyHash.output.check(script)) return types.P2PKH\n  if (scriptHash.output.check(script)) return types.P2SH\n\n  // XXX: optimization, below functions .decompile before use\n  const chunks = decompile(script)\n  if (!chunks) throw new TypeError('Invalid script')\n\n  if (multisig.output.check(chunks)) return types.P2MS\n  if (pubKey.output.check(chunks)) return types.P2PK\n  if (witnessCommitment.output.check(chunks)) return types.WITNESS_COMMITMENT\n  if (nullData.output.check(chunks)) return types.NULLDATA\n\n  return types.NONSTANDARD\n}\n\nfunction classifyInput (script, allowIncomplete) {\n  // XXX: optimization, below functions .decompile before use\n  const chunks = decompile(script)\n  if (!chunks) throw new TypeError('Invalid script')\n\n  if (pubKeyHash.input.check(chunks)) return types.P2PKH\n  if (scriptHash.input.check(chunks, allowIncomplete)) return types.P2SH\n  if (multisig.input.check(chunks, allowIncomplete)) return types.P2MS\n  if (pubKey.input.check(chunks)) return types.P2PK\n\n  return types.NONSTANDARD\n}\n\nfunction classifyWitness (script, allowIncomplete) {\n  // XXX: optimization, below functions .decompile before use\n  const chunks = decompile(script)\n  if (!chunks) throw new TypeError('Invalid script')\n\n  if (witnessPubKeyHash.input.check(chunks)) return types.P2WPKH\n  if (witnessScriptHash.input.check(chunks, allowIncomplete)) return types.P2WSH\n\n  return types.NONSTANDARD\n}\n\nmodule.exports = {\n  input: classifyInput,\n  output: classifyOutput,\n  witness: classifyWitness,\n  types: types\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/classify.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/crypto.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\")\n\nfunction ripemd160 (buffer) {\n  try {\n    return createHash('rmd160').update(buffer).digest()\n  } catch (err) {\n    return createHash('ripemd160').update(buffer).digest()\n  }\n}\n\nfunction sha1 (buffer) {\n  return createHash('sha1').update(buffer).digest()\n}\n\nfunction sha256 (buffer) {\n  return createHash('sha256').update(buffer).digest()\n}\n\nfunction hash160 (buffer) {\n  return ripemd160(sha256(buffer))\n}\n\nfunction hash256 (buffer) {\n  return sha256(sha256(buffer))\n}\n\nmodule.exports = {\n  hash160: hash160,\n  hash256: hash256,\n  ripemd160: ripemd160,\n  sha1: sha1,\n  sha256: sha256\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/crypto.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/ecpair.js":
/*!**************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/ecpair.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const ecc = __webpack_require__(/*! tiny-secp256k1 */ \"./node_modules/tiny-secp256k1/js.js\")\nconst randomBytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\")\nconst typeforce = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\")\nconst wif = __webpack_require__(/*! wif */ \"./node_modules/wif/index.js\")\n\nconst NETWORKS = __webpack_require__(/*! ./networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\")\nconst isOptions = typeforce.maybe(typeforce.compile({\n  compressed: types.maybe(types.Boolean),\n  network: types.maybe(types.Network)\n}))\n\nfunction ECPair (d, Q, options) {\n  options = options || {}\n\n  this.compressed = options.compressed === undefined ? true : options.compressed\n  this.network = options.network || NETWORKS.bitcoin\n\n  this.__d = d || null\n  this.__Q = null\n  if (Q) this.__Q = ecc.pointCompress(Q, this.compressed)\n}\n\nObject.defineProperty(ECPair.prototype, 'privateKey', {\n  enumerable: false,\n  get: function () { return this.__d }\n})\n\nObject.defineProperty(ECPair.prototype, 'publicKey', { get: function () {\n  if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__d, this.compressed)\n  return this.__Q\n}})\n\nECPair.prototype.toWIF = function () {\n  if (!this.__d) throw new Error('Missing private key')\n  return wif.encode(this.network.wif, this.__d, this.compressed)\n}\n\nECPair.prototype.sign = function (hash) {\n  if (!this.__d) throw new Error('Missing private key')\n  return ecc.sign(hash, this.__d)\n}\n\nECPair.prototype.verify = function (hash, signature) {\n  return ecc.verify(hash, this.publicKey, signature)\n}\n\nfunction fromPrivateKey (buffer, options) {\n  typeforce(types.Buffer256bit, buffer)\n  if (!ecc.isPrivate(buffer)) throw new TypeError('Private key not in range [1, n)')\n  typeforce(isOptions, options)\n\n  return new ECPair(buffer, null, options)\n}\n\nfunction fromPublicKey (buffer, options) {\n  typeforce(ecc.isPoint, buffer)\n  typeforce(isOptions, options)\n  return new ECPair(null, buffer, options)\n}\n\nfunction fromWIF (string, network) {\n  const decoded = wif.decode(string)\n  const version = decoded.version\n\n  // list of networks?\n  if (types.Array(network)) {\n    network = network.filter(function (x) {\n      return version === x.wif\n    }).pop()\n\n    if (!network) throw new Error('Unknown network version')\n\n  // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin\n\n    if (version !== network.wif) throw new Error('Invalid network version')\n  }\n\n  return fromPrivateKey(decoded.privateKey, {\n    compressed: decoded.compressed,\n    network: network\n  })\n}\n\nfunction makeRandom (options) {\n  typeforce(isOptions, options)\n  options = options || {}\n  const rng = options.rng || randomBytes\n\n  let d\n  do {\n    d = rng(32)\n    typeforce(types.Buffer256bit, d)\n  } while (!ecc.isPrivate(d))\n\n  return fromPrivateKey(d, options)\n}\n\nmodule.exports = {\n  makeRandom,\n  fromPrivateKey,\n  fromPublicKey,\n  fromWIF\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/ecpair.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const script = __webpack_require__(/*! ./script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\n\nmodule.exports = {\n  Block: __webpack_require__(/*! ./block */ \"./node_modules/bitcoinjs-lib/src/block.js\"),\n  ECPair: __webpack_require__(/*! ./ecpair */ \"./node_modules/bitcoinjs-lib/src/ecpair.js\"),\n  Transaction: __webpack_require__(/*! ./transaction */ \"./node_modules/bitcoinjs-lib/src/transaction.js\"),\n  TransactionBuilder: __webpack_require__(/*! ./transaction_builder */ \"./node_modules/bitcoinjs-lib/src/transaction_builder.js\"),\n\n  address: __webpack_require__(/*! ./address */ \"./node_modules/bitcoinjs-lib/src/address.js\"),\n  bip32: __webpack_require__(/*! bip32 */ \"./node_modules/bip32/index.js\"),\n  crypto: __webpack_require__(/*! ./crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\"),\n  networks: __webpack_require__(/*! ./networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\"),\n  opcodes: __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\"),\n  payments: __webpack_require__(/*! ./payments */ \"./node_modules/bitcoinjs-lib/src/payments/index.js\"),\n  script: script\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/index.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/networks.js":
/*!****************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/networks.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// https://en.bitcoin.it/wiki/List_of_address_prefixes\n// Dogecoin BIP32 is a proposed standard: https://bitcointalk.org/index.php?topic=409731\n\nmodule.exports = {\n  bitcoin: {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bc',\n    bip32: {\n      public: 0x0488b21e,\n      private: 0x0488ade4\n    },\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80\n  },\n  regtest: {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bcrt',\n    bip32: {\n      public: 0x043587cf,\n      private: 0x04358394\n    },\n    pubKeyHash: 0x6f,\n    scriptHash: 0xc4,\n    wif: 0xef\n  },\n  testnet: {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'tb',\n    bip32: {\n      public: 0x043587cf,\n      private: 0x04358394\n    },\n    pubKeyHash: 0x6f,\n    scriptHash: 0xc4,\n    wif: 0xef\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/networks.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/embed.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/embed.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\")\nconst typef = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\n\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst BITCOIN_NETWORK = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\").bitcoin\n\nfunction stacksEqual (a, b) {\n  if (a.length !== b.length) return false\n\n  return a.every(function (x, i) {\n    return x.equals(b[i])\n  })\n}\n\n// output: OP_RETURN ...\nfunction p2data (a, opts) {\n  if (\n    !a.data &&\n    !a.output\n  ) throw new TypeError('Not enough data')\n  opts = Object.assign({ validate: true }, opts || {})\n\n  typef({\n    network: typef.maybe(typef.Object),\n    output: typef.maybe(typef.Buffer),\n    data: typef.maybe(typef.arrayOf(typef.Buffer))\n  }, a)\n\n  const network = a.network || BITCOIN_NETWORK\n  const o = { network }\n\n  lazy.prop(o, 'output', function () {\n    if (!a.data) return\n    return bscript.compile([OPS.OP_RETURN].concat(a.data))\n  })\n  lazy.prop(o, 'data', function () {\n    if (!a.output) return\n    return bscript.decompile(a.output).slice(1)\n  })\n\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output)\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid')\n      if (!chunks.slice(1).every(typef.Buffer)) throw new TypeError('Output is invalid')\n\n      if (a.data && !stacksEqual(a.data, o.data)) throw new TypeError('Data mismatch')\n    }\n  }\n\n  return Object.assign(o, a)\n}\n\nmodule.exports = p2data\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/payments/embed.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const embed = __webpack_require__(/*! ./embed */ \"./node_modules/bitcoinjs-lib/src/payments/embed.js\")\nconst p2ms = __webpack_require__(/*! ./p2ms */ \"./node_modules/bitcoinjs-lib/src/payments/p2ms.js\")\nconst p2pk = __webpack_require__(/*! ./p2pk */ \"./node_modules/bitcoinjs-lib/src/payments/p2pk.js\")\nconst p2pkh = __webpack_require__(/*! ./p2pkh */ \"./node_modules/bitcoinjs-lib/src/payments/p2pkh.js\")\nconst p2sh = __webpack_require__(/*! ./p2sh */ \"./node_modules/bitcoinjs-lib/src/payments/p2sh.js\")\nconst p2wpkh = __webpack_require__(/*! ./p2wpkh */ \"./node_modules/bitcoinjs-lib/src/payments/p2wpkh.js\")\nconst p2wsh = __webpack_require__(/*! ./p2wsh */ \"./node_modules/bitcoinjs-lib/src/payments/p2wsh.js\")\n\nmodule.exports = { embed, p2ms, p2pk, p2pkh, p2sh, p2wpkh, p2wsh }\n\n// TODO\n// witness commitment\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/payments/index.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/lazy.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/lazy.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function prop (object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      let value = f.call(this)\n      this[name] = value\n      return value\n    },\n    set: function (value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: value,\n        writable: true\n      })\n    }\n  })\n}\n\nfunction value (f) {\n  let value\n  return function () {\n    if (value !== undefined) return value\n    value = f()\n    return value\n  }\n}\n\nmodule.exports = { prop, value }\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/payments/lazy.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2ms.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2ms.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\")\nconst typef = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\nconst ecc = __webpack_require__(/*! tiny-secp256k1 */ \"./node_modules/tiny-secp256k1/js.js\")\n\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst BITCOIN_NETWORK = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\").bitcoin\nconst OP_INT_BASE = OPS.OP_RESERVED // OP_1 - 1\n\nfunction stacksEqual (a, b) {\n  if (a.length !== b.length) return false\n\n  return a.every(function (x, i) {\n    return x.equals(b[i])\n  })\n}\n\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\nfunction p2ms (a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  ) throw new TypeError('Not enough data')\n  opts = Object.assign({ validate: true }, opts || {})\n\n  function isAcceptableSignature (x) {\n    return bscript.isCanonicalScriptSignature(x) || (opts.allowIncomplete && (x === OPS.OP_0))\n  }\n\n  typef({\n    network: typef.maybe(typef.Object),\n    m: typef.maybe(typef.Number),\n    n: typef.maybe(typef.Number),\n    output: typef.maybe(typef.Buffer),\n    pubkeys: typef.maybe(typef.arrayOf(ecc.isPoint)),\n\n    signatures: typef.maybe(typef.arrayOf(isAcceptableSignature)),\n    input: typef.maybe(typef.Buffer)\n  }, a)\n\n  const network = a.network || BITCOIN_NETWORK\n  const o = { network }\n\n  let chunks\n  let decoded = false\n  function decode (output) {\n    if (decoded) return\n    decoded = true\n    chunks = bscript.decompile(output)\n    o.m = chunks[0] - OP_INT_BASE\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE\n    o.pubkeys = chunks.slice(1, -2)\n  }\n\n  lazy.prop(o, 'output', function () {\n    if (!a.m) return\n    if (!o.n) return\n    if (!a.pubkeys) return\n    return bscript.compile([].concat(\n      OP_INT_BASE + a.m,\n      a.pubkeys,\n      OP_INT_BASE + o.n,\n      OPS.OP_CHECKMULTISIG\n    ))\n  })\n  lazy.prop(o, 'm', function () {\n    if (!o.output) return\n    decode(o.output)\n    return o.m\n  })\n  lazy.prop(o, 'n', function () {\n    if (!o.pubkeys) return\n    return o.pubkeys.length\n  })\n  lazy.prop(o, 'pubkeys', function () {\n    if (!a.output) return\n    decode(a.output)\n    return o.pubkeys\n  })\n  lazy.prop(o, 'signatures', function () {\n    if (!a.input) return\n    return bscript.decompile(a.input).slice(1)\n  })\n  lazy.prop(o, 'input', function () {\n    if (!a.signatures) return\n    return bscript.compile([OPS.OP_0].concat(a.signatures))\n  })\n  lazy.prop(o, 'witness', function () {\n    if (!o.input) return\n    return []\n  })\n\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output)\n      if (!typef.Number(chunks[0])) throw new TypeError('Output is invalid')\n      if (!typef.Number(chunks[chunks.length - 2])) throw new TypeError('Output is invalid')\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG) throw new TypeError('Output is invalid')\n\n      if (\n        o.m <= 0 ||\n        o.n > 16 ||\n        o.m > o.n ||\n        o.n !== chunks.length - 3) throw new TypeError('Output is invalid')\n      if (!o.pubkeys.every(x => ecc.isPoint(x))) throw new TypeError('Output is invalid')\n\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch')\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch')\n      if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys)) throw new TypeError('Pubkeys mismatch')\n    }\n\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length) throw new TypeError('Pubkey count mismatch')\n      o.n = a.pubkeys.length\n\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m')\n    }\n\n    if (a.signatures) {\n      if (a.signatures.length < o.m) throw new TypeError('Not enough signatures provided')\n      if (a.signatures.length > o.m) throw new TypeError('Too many signatures provided')\n    }\n\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid')\n      if (o.signatures.length === 0 || !o.signatures.every(isAcceptableSignature)) throw new TypeError('Input has invalid signature(s)')\n\n      if (a.signatures && !stacksEqual(a.signatures, o.signatures)) throw new TypeError('Signature mismatch')\n      if (a.m !== undefined && a.m !== a.signatures.length) throw new TypeError('Signature count mismatch')\n    }\n  }\n\n  return Object.assign(o, a)\n}\n\nmodule.exports = p2ms\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/payments/p2ms.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2pk.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2pk.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\")\nconst typef = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\nconst ecc = __webpack_require__(/*! tiny-secp256k1 */ \"./node_modules/tiny-secp256k1/js.js\")\n\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst BITCOIN_NETWORK = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\").bitcoin\n\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\nfunction p2pk (a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !a.pubkey &&\n    !a.input &&\n    !a.signature\n  ) throw new TypeError('Not enough data')\n  opts = Object.assign({ validate: true }, opts || {})\n\n  typef({\n    network: typef.maybe(typef.Object),\n    output: typef.maybe(typef.Buffer),\n    pubkey: typef.maybe(ecc.isPoint),\n\n    signature: typef.maybe(bscript.isCanonicalScriptSignature),\n    input: typef.maybe(typef.Buffer)\n  }, a)\n\n  const _chunks = lazy.value(function () { return bscript.decompile(a.input) })\n\n  const network = a.network || BITCOIN_NETWORK\n  const o = { network }\n\n  lazy.prop(o, 'output', function () {\n    if (!a.pubkey) return\n    return bscript.compile([\n      a.pubkey,\n      OPS.OP_CHECKSIG\n    ])\n  })\n  lazy.prop(o, 'pubkey', function () {\n    if (!a.output) return\n    return a.output.slice(1, -1)\n  })\n  lazy.prop(o, 'signature', function () {\n    if (!a.input) return\n    return _chunks()[0]\n  })\n  lazy.prop(o, 'input', function () {\n    if (!a.signature) return\n    return bscript.compile([a.signature])\n  })\n  lazy.prop(o, 'witness', function () {\n    if (!o.input) return\n    return []\n  })\n\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG) throw new TypeError('Output is invalid')\n      if (!ecc.isPoint(o.pubkey)) throw new TypeError('Output pubkey is invalid')\n      if (a.pubkey && !a.pubkey.equals(o.pubkey)) throw new TypeError('Pubkey mismatch')\n    }\n\n    if (a.signature) {\n      if (a.input && !a.input.equals(o.input)) throw new TypeError('Signature mismatch')\n    }\n\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid')\n      if (!bscript.isCanonicalScriptSignature(o.signature)) throw new TypeError('Input has invalid signature')\n    }\n  }\n\n  return Object.assign(o, a)\n}\n\nmodule.exports = p2pk\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/payments/p2pk.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2pkh.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2pkh.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {const lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\")\nconst typef = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\nconst ecc = __webpack_require__(/*! tiny-secp256k1 */ \"./node_modules/tiny-secp256k1/js.js\")\n\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\")\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst BITCOIN_NETWORK = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\").bitcoin\nconst bs58check = __webpack_require__(/*! bs58check */ \"./node_modules/bs58check/index.js\")\n\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\nfunction p2pkh (a, opts) {\n  if (\n    !a.address &&\n    !a.hash &&\n    !a.output &&\n    !a.pubkey &&\n    !a.input\n  ) throw new TypeError('Not enough data')\n  opts = Object.assign({ validate: true }, opts || {})\n\n  typef({\n    network: typef.maybe(typef.Object),\n    address: typef.maybe(typef.String),\n    hash: typef.maybe(typef.BufferN(20)),\n    output: typef.maybe(typef.BufferN(25)),\n\n    pubkey: typef.maybe(ecc.isPoint),\n    signature: typef.maybe(bscript.isCanonicalScriptSignature),\n    input: typef.maybe(typef.Buffer)\n  }, a)\n\n  const _address = lazy.value(function () {\n    const payload = bs58check.decode(a.address)\n    const version = payload.readUInt8(0)\n    const hash = payload.slice(1)\n    return { version, hash }\n  })\n  const _chunks = lazy.value(function () { return bscript.decompile(a.input) })\n\n  const network = a.network || BITCOIN_NETWORK\n  const o = { network }\n\n  lazy.prop(o, 'address', function () {\n    if (!o.hash) return\n\n    const payload = Buffer.allocUnsafe(21)\n    payload.writeUInt8(network.pubKeyHash, 0)\n    o.hash.copy(payload, 1)\n    return bs58check.encode(payload)\n  })\n  lazy.prop(o, 'hash', function () {\n    if (a.output) return a.output.slice(3, 23)\n    if (a.address) return _address().hash\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey)\n  })\n  lazy.prop(o, 'output', function () {\n    if (!o.hash) return\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG\n    ])\n  })\n  lazy.prop(o, 'pubkey', function () {\n    if (!a.input) return\n    return _chunks()[1]\n  })\n  lazy.prop(o, 'signature', function () {\n    if (!a.input) return\n    return _chunks()[0]\n  })\n  lazy.prop(o, 'input', function () {\n    if (!a.pubkey) return\n    if (!a.signature) return\n    return bscript.compile([a.signature, a.pubkey])\n  })\n  lazy.prop(o, 'witness', function () {\n    if (!o.input) return\n    return []\n  })\n\n  // extended validation\n  if (opts.validate) {\n    let hash\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash) throw new TypeError('Invalid version or Network mismatch')\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address')\n      hash = _address().hash\n    }\n\n    if (a.hash) {\n      if (hash && !hash.equals(a.hash)) throw new TypeError('Hash mismatch')\n      else hash = a.hash\n    }\n\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG) throw new TypeError('Output is invalid')\n\n      const hash2 = a.output.slice(3, 23)\n      if (hash && !hash.equals(hash2)) throw new TypeError('Hash mismatch')\n      else hash = hash2\n    }\n\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey)\n      if (hash && !hash.equals(pkh)) throw new TypeError('Hash mismatch')\n      else hash = pkh\n    }\n\n    if (a.input) {\n      const chunks = _chunks()\n      if (chunks.length !== 2) throw new TypeError('Input is invalid')\n      if (!bscript.isCanonicalScriptSignature(chunks[0])) throw new TypeError('Input has invalid signature')\n      if (!ecc.isPoint(chunks[1])) throw new TypeError('Input has invalid pubkey')\n\n      if (a.signature && !a.signature.equals(chunks[0])) throw new TypeError('Signature mismatch')\n      if (a.pubkey && !a.pubkey.equals(chunks[1])) throw new TypeError('Pubkey mismatch')\n\n      const pkh = bcrypto.hash160(chunks[1])\n      if (hash && !hash.equals(pkh)) throw new TypeError('Hash mismatch')\n    }\n  }\n\n  return Object.assign(o, a)\n}\n\nmodule.exports = p2pkh\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/payments/p2pkh.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2sh.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2sh.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {const lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\")\nconst typef = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\n\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\")\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst BITCOIN_NETWORK = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\").bitcoin\nconst bs58check = __webpack_require__(/*! bs58check */ \"./node_modules/bs58check/index.js\")\n\nfunction stacksEqual (a, b) {\n  if (a.length !== b.length) return false\n\n  return a.every(function (x, i) {\n    return x.equals(b[i])\n  })\n}\n\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\nfunction p2sh (a, opts) {\n  if (\n    !a.address &&\n    !a.hash &&\n    !a.output &&\n    !a.redeem &&\n    !a.input\n  ) throw new TypeError('Not enough data')\n  opts = Object.assign({ validate: true }, opts || {})\n\n  typef({\n    network: typef.maybe(typef.Object),\n\n    address: typef.maybe(typef.String),\n    hash: typef.maybe(typef.BufferN(20)),\n    output: typef.maybe(typef.BufferN(23)),\n\n    redeem: typef.maybe({\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.Buffer),\n      input: typef.maybe(typef.Buffer),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer))\n    }),\n    input: typef.maybe(typef.Buffer),\n    witness: typef.maybe(typef.arrayOf(typef.Buffer))\n  }, a)\n\n  let network = a.network\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || BITCOIN_NETWORK\n  }\n\n  const o = { network }\n\n  const _address = lazy.value(function () {\n    const payload = bs58check.decode(a.address)\n    const version = payload.readUInt8(0)\n    const hash = payload.slice(1)\n    return { version, hash }\n  })\n  const _chunks = lazy.value(function () { return bscript.decompile(a.input) })\n  const _redeem = lazy.value(function () {\n    const chunks = _chunks()\n    return {\n      network,\n      output: chunks[chunks.length - 1],\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || []\n    }\n  })\n\n  // output dependents\n  lazy.prop(o, 'address', function () {\n    if (!o.hash) return\n\n    const payload = Buffer.allocUnsafe(21)\n    payload.writeUInt8(network.scriptHash, 0)\n    o.hash.copy(payload, 1)\n    return bs58check.encode(payload)\n  })\n  lazy.prop(o, 'hash', function () {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22)\n    if (a.address) return _address().hash\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output)\n  })\n  lazy.prop(o, 'output', function () {\n    if (!o.hash) return\n    return bscript.compile([\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUAL\n    ])\n  })\n\n  // input dependents\n  lazy.prop(o, 'redeem', function () {\n    if (!a.input) return\n    return _redeem()\n  })\n  lazy.prop(o, 'input', function () {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return\n    return bscript.compile([].concat(\n      bscript.decompile(a.redeem.input),\n      a.redeem.output\n    ))\n  })\n  lazy.prop(o, 'witness', function () {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness\n    if (o.input) return []\n  })\n\n  if (opts.validate) {\n    let hash\n    if (a.address) {\n      if (_address().version !== network.scriptHash) throw new TypeError('Invalid version or Network mismatch')\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address')\n      hash = _address().hash\n    }\n\n    if (a.hash) {\n      if (hash && !hash.equals(a.hash)) throw new TypeError('Hash mismatch')\n      else hash = a.hash\n    }\n\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL) throw new TypeError('Output is invalid')\n\n      const hash2 = a.output.slice(2, 22)\n      if (hash && !hash.equals(hash2)) throw new TypeError('Hash mismatch')\n      else hash = hash2\n    }\n\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = function (redeem) {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output)\n        if (!decompile || decompile.length < 1) throw new TypeError('Redeem.output too short')\n\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output)\n        if (hash && !hash.equals(hash2)) throw new TypeError('Hash mismatch')\n        else hash = hash2\n      }\n\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0\n        const hasWitness = redeem.witness && redeem.witness.length > 0\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input')\n        if (hasInput && hasWitness) throw new TypeError('Input and witness provided')\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input)\n          if (!bscript.isPushOnly(richunks)) throw new TypeError('Non push-only scriptSig')\n        }\n      }\n    }\n\n    if (a.input) {\n      const chunks = _chunks()\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short')\n      if (!Buffer.isBuffer(_redeem().output)) throw new TypeError('Input is invalid')\n\n      checkRedeem(_redeem())\n    }\n\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network) throw new TypeError('Network mismatch')\n      if (a.input) {\n        const redeem = _redeem()\n        if (a.redeem.output && !a.redeem.output.equals(redeem.output)) throw new TypeError('Redeem.output mismatch')\n        if (a.redeem.input && !a.redeem.input.equals(redeem.input)) throw new TypeError('Redeem.input mismatch')\n      }\n\n      checkRedeem(a.redeem)\n    }\n\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !stacksEqual(a.redeem.witness, a.witness)) throw new TypeError('Witness and redeem.witness mismatch')\n    }\n  }\n\n  return Object.assign(o, a)\n}\n\nmodule.exports = p2sh\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/payments/p2sh.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2wpkh.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2wpkh.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {const lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\")\nconst typef = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\nconst ecc = __webpack_require__(/*! tiny-secp256k1 */ \"./node_modules/tiny-secp256k1/js.js\")\n\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\")\nconst bech32 = __webpack_require__(/*! bech32 */ \"./node_modules/bech32/index.js\")\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst BITCOIN_NETWORK = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\").bitcoin\n\nconst EMPTY_BUFFER = Buffer.alloc(0)\n\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\nfunction p2wpkh (a, opts) {\n  if (\n    !a.address &&\n    !a.hash &&\n    !a.output &&\n    !a.pubkey &&\n    !a.witness\n  ) throw new TypeError('Not enough data')\n  opts = Object.assign({ validate: true }, opts || {})\n\n  typef({\n    address: typef.maybe(typef.String),\n    hash: typef.maybe(typef.BufferN(20)),\n    input: typef.maybe(typef.BufferN(0)),\n    network: typef.maybe(typef.Object),\n    output: typef.maybe(typef.BufferN(22)),\n    pubkey: typef.maybe(ecc.isPoint),\n    signature: typef.maybe(bscript.isCanonicalScriptSignature),\n    witness: typef.maybe(typef.arrayOf(typef.Buffer))\n  }, a)\n\n  const _address = lazy.value(function () {\n    const result = bech32.decode(a.address)\n    const version = result.words.shift()\n    const data = bech32.fromWords(result.words)\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data)\n    }\n  })\n\n  const network = a.network || BITCOIN_NETWORK\n  const o = { network }\n\n  lazy.prop(o, 'address', function () {\n    if (!o.hash) return\n\n    const words = bech32.toWords(o.hash)\n    words.unshift(0x00)\n    return bech32.encode(network.bech32, words)\n  })\n  lazy.prop(o, 'hash', function () {\n    if (a.output) return a.output.slice(2, 22)\n    if (a.address) return _address().data\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey)\n  })\n  lazy.prop(o, 'output', function () {\n    if (!o.hash) return\n    return bscript.compile([\n      OPS.OP_0,\n      o.hash\n    ])\n  })\n  lazy.prop(o, 'pubkey', function () {\n    if (a.pubkey) return a.pubkey\n    if (!a.witness) return\n    return a.witness[1]\n  })\n  lazy.prop(o, 'signature', function () {\n    if (!a.witness) return\n    return a.witness[0]\n  })\n  lazy.prop(o, 'input', function () {\n    if (!o.witness) return\n    return EMPTY_BUFFER\n  })\n  lazy.prop(o, 'witness', function () {\n    if (!a.pubkey) return\n    if (!a.signature) return\n    return [a.signature, a.pubkey]\n  })\n\n  // extended validation\n  if (opts.validate) {\n    let hash\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix) throw new TypeError('Invalid prefix or Network mismatch')\n      if (_address().version !== 0x00) throw new TypeError('Invalid address version')\n      if (_address().data.length !== 20) throw new TypeError('Invalid address data')\n      hash = _address().data\n    }\n\n    if (a.hash) {\n      if (hash && !hash.equals(a.hash)) throw new TypeError('Hash mismatch')\n      else hash = a.hash\n    }\n\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14) throw new TypeError('Output is invalid')\n      if (hash && !hash.equals(a.output.slice(2))) throw new TypeError('Hash mismatch')\n      else hash = a.output.slice(2)\n    }\n\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey)\n      if (hash && !hash.equals(pkh)) throw new TypeError('Hash mismatch')\n      else hash = pkh\n    }\n\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid')\n      if (!bscript.isCanonicalScriptSignature(a.witness[0])) throw new TypeError('Witness has invalid signature')\n      if (!ecc.isPoint(a.witness[1])) throw new TypeError('Witness has invalid pubkey')\n\n      if (a.signature && !a.signature.equals(a.witness[0])) throw new TypeError('Signature mismatch')\n      if (a.pubkey && !a.pubkey.equals(a.witness[1])) throw new TypeError('Pubkey mismatch')\n\n      const pkh = bcrypto.hash160(a.witness[1])\n      if (hash && !hash.equals(pkh)) throw new TypeError('Hash mismatch')\n    }\n  }\n\n  return Object.assign(o, a)\n}\n\nmodule.exports = p2wpkh\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/payments/p2wpkh.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2wsh.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2wsh.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {const lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\")\nconst typef = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\n\nconst bech32 = __webpack_require__(/*! bech32 */ \"./node_modules/bech32/index.js\")\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\")\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst BITCOIN_NETWORK = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\").bitcoin\n\nconst EMPTY_BUFFER = Buffer.alloc(0)\n\nfunction stacksEqual (a, b) {\n  if (a.length !== b.length) return false\n\n  return a.every(function (x, i) {\n    return x.equals(b[i])\n  })\n}\n\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\nfunction p2wsh (a, opts) {\n  if (\n    !a.address &&\n    !a.hash &&\n    !a.output &&\n    !a.redeem &&\n    !a.witness\n  ) throw new TypeError('Not enough data')\n  opts = Object.assign({ validate: true }, opts || {})\n\n  typef({\n    network: typef.maybe(typef.Object),\n\n    address: typef.maybe(typef.String),\n    hash: typef.maybe(typef.BufferN(32)),\n    output: typef.maybe(typef.BufferN(34)),\n\n    redeem: typef.maybe({\n      input: typef.maybe(typef.Buffer),\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.Buffer),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer))\n    }),\n    input: typef.maybe(typef.BufferN(0)),\n    witness: typef.maybe(typef.arrayOf(typef.Buffer))\n  }, a)\n\n  const _address = lazy.value(function () {\n    const result = bech32.decode(a.address)\n    const version = result.words.shift()\n    const data = bech32.fromWords(result.words)\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data)\n    }\n  })\n  const _rchunks = lazy.value(function () { return bscript.decompile(a.redeem.input) })\n\n  let network = a.network\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || BITCOIN_NETWORK\n  }\n\n  const o = { network }\n\n  lazy.prop(o, 'address', function () {\n    if (!o.hash) return\n    const words = bech32.toWords(o.hash)\n    words.unshift(0x00)\n    return bech32.encode(network.bech32, words)\n  })\n  lazy.prop(o, 'hash', function () {\n    if (a.output) return a.output.slice(2)\n    if (a.address) return _address().data\n    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output)\n  })\n  lazy.prop(o, 'output', function () {\n    if (!o.hash) return\n    return bscript.compile([\n      OPS.OP_0,\n      o.hash\n    ])\n  })\n  lazy.prop(o, 'redeem', function () {\n    if (!a.witness) return\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1)\n    }\n  })\n  lazy.prop(o, 'input', function () {\n    if (!o.witness) return\n    return EMPTY_BUFFER\n  })\n  lazy.prop(o, 'witness', function () {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks())\n\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem)\n      o.redeem.input = EMPTY_BUFFER\n      return [].concat(stack, a.redeem.output)\n    }\n\n    if (!a.redeem) return\n    if (!a.redeem.output) return\n    if (!a.redeem.witness) return\n    return [].concat(a.redeem.witness, a.redeem.output)\n  })\n\n  // extended validation\n  if (opts.validate) {\n    let hash\n    if (a.address) {\n      if (_address().prefix !== network.bech32) throw new TypeError('Invalid prefix or Network mismatch')\n      if (_address().version !== 0x00) throw new TypeError('Invalid address version')\n      if (_address().data.length !== 32) throw new TypeError('Invalid address data')\n      hash = _address().data\n    }\n\n    if (a.hash) {\n      if (hash && !hash.equals(a.hash)) throw new TypeError('Hash mismatch')\n      else hash = a.hash\n    }\n\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20) throw new TypeError('Output is invalid')\n      const hash2 = a.output.slice(2)\n      if (hash && !hash.equals(hash2)) throw new TypeError('Hash mismatch')\n      else hash = hash2\n    }\n\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network) throw new TypeError('Network mismatch')\n\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      ) throw new TypeError('Ambiguous witness source')\n\n      // is the redeem output non-empty?\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0) throw new TypeError('Redeem.output is invalid')\n\n        // match hash against other sources\n        const hash2 = bcrypto.sha256(a.redeem.output)\n        if (hash && !hash.equals(hash2)) throw new TypeError('Hash mismatch')\n        else hash = hash2\n      }\n\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks())) throw new TypeError('Non push-only scriptSig')\n      if (a.witness && a.redeem.witness && !stacksEqual(a.witness, a.redeem.witness)) throw new TypeError('Witness and redeem.witness mismatch')\n    }\n\n    if (a.witness) {\n      if (a.redeem && a.redeem.output && !a.redeem.output.equals(a.witness[a.witness.length - 1])) throw new TypeError('Witness and redeem.output mismatch')\n    }\n  }\n\n  return Object.assign(o, a)\n}\n\nmodule.exports = p2wsh\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/payments/p2wsh.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/script.js":
/*!**************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/script.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nconst bip66 = __webpack_require__(/*! bip66 */ \"./node_modules/bip66/index.js\")\nconst ecc = __webpack_require__(/*! tiny-secp256k1 */ \"./node_modules/tiny-secp256k1/js.js\")\nconst pushdata = __webpack_require__(/*! pushdata-bitcoin */ \"./node_modules/pushdata-bitcoin/index.js\")\nconst typeforce = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\")\nconst scriptNumber = __webpack_require__(/*! ./script_number */ \"./node_modules/bitcoinjs-lib/src/script_number.js\")\n\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\nconst REVERSE_OPS = __webpack_require__(/*! bitcoin-ops/map */ \"./node_modules/bitcoin-ops/map.js\")\nconst OP_INT_BASE = OPS.OP_RESERVED // OP_1 - 1\n\nfunction isOPInt (value) {\n  return types.Number(value) &&\n    ((value === OPS.OP_0) ||\n    (value >= OPS.OP_1 && value <= OPS.OP_16) ||\n    (value === OPS.OP_1NEGATE))\n}\n\nfunction isPushOnlyChunk (value) {\n  return types.Buffer(value) || isOPInt(value)\n}\n\nfunction isPushOnly (value) {\n  return types.Array(value) && value.every(isPushOnlyChunk)\n}\n\nfunction asMinimalOP (buffer) {\n  if (buffer.length === 0) return OPS.OP_0\n  if (buffer.length !== 1) return\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0]\n  if (buffer[0] === 0x81) return OPS.OP_1NEGATE\n}\n\nfunction compile (chunks) {\n  // TODO: remove me\n  if (Buffer.isBuffer(chunks)) return chunks\n\n  typeforce(types.Array, chunks)\n\n  const bufferSize = chunks.reduce(function (accum, chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1\n      }\n\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length\n    }\n\n    // opcode\n    return accum + 1\n  }, 0.0)\n\n  const buffer = Buffer.allocUnsafe(bufferSize)\n  let offset = 0\n\n  chunks.forEach(function (chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk)\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset)\n        offset += 1\n        return\n      }\n\n      offset += pushdata.encode(buffer, chunk.length, offset)\n      chunk.copy(buffer, offset)\n      offset += chunk.length\n\n    // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset)\n      offset += 1\n    }\n  })\n\n  if (offset !== buffer.length) throw new Error('Could not decode chunks')\n  return buffer\n}\n\nfunction decompile (buffer) {\n  // TODO: remove me\n  if (types.Array(buffer)) return buffer\n\n  typeforce(types.Buffer, buffer)\n\n  const chunks = []\n  let i = 0\n\n  while (i < buffer.length) {\n    const opcode = buffer[i]\n\n    // data chunk\n    if ((opcode > OPS.OP_0) && (opcode <= OPS.OP_PUSHDATA4)) {\n      const d = pushdata.decode(buffer, i)\n\n      // did reading a pushDataInt fail?\n      if (d === null) return null\n      i += d.size\n\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null\n\n      const data = buffer.slice(i, i + d.number)\n      i += d.number\n\n      // decompile minimally\n      const op = asMinimalOP(data)\n      if (op !== undefined) {\n        chunks.push(op)\n      } else {\n        chunks.push(data)\n      }\n\n    // opcode\n    } else {\n      chunks.push(opcode)\n\n      i += 1\n    }\n  }\n\n  return chunks\n}\n\nfunction toASM (chunks) {\n  if (Buffer.isBuffer(chunks)) {\n    chunks = decompile(chunks)\n  }\n\n  return chunks.map(function (chunk) {\n    // data?\n    if (Buffer.isBuffer(chunk)) {\n      const op = asMinimalOP(chunk)\n      if (op === undefined) return chunk.toString('hex')\n      chunk = op\n    }\n\n    // opcode!\n    return REVERSE_OPS[chunk]\n  }).join(' ')\n}\n\nfunction fromASM (asm) {\n  typeforce(types.String, asm)\n\n  return compile(asm.split(' ').map(function (chunkStr) {\n    // opcode?\n    if (OPS[chunkStr] !== undefined) return OPS[chunkStr]\n    typeforce(types.Hex, chunkStr)\n\n    // data!\n    return Buffer.from(chunkStr, 'hex')\n  }))\n}\n\nfunction toStack (chunks) {\n  chunks = decompile(chunks)\n  typeforce(isPushOnly, chunks)\n\n  return chunks.map(function (op) {\n    if (Buffer.isBuffer(op)) return op\n    if (op === OPS.OP_0) return Buffer.allocUnsafe(0)\n\n    return scriptNumber.encode(op - OP_INT_BASE)\n  })\n}\n\nfunction isCanonicalPubKey (buffer) {\n  return ecc.isPoint(buffer)\n}\n\nfunction isDefinedHashType (hashType) {\n  const hashTypeMod = hashType & ~0x80\n\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04\n}\n\nfunction isCanonicalScriptSignature (buffer) {\n  if (!Buffer.isBuffer(buffer)) return false\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false\n\n  return bip66.check(buffer.slice(0, -1))\n}\n\nmodule.exports = {\n  compile: compile,\n  decompile: decompile,\n  fromASM: fromASM,\n  toASM: toASM,\n  toStack: toStack,\n\n  number: __webpack_require__(/*! ./script_number */ \"./node_modules/bitcoinjs-lib/src/script_number.js\"),\n  signature: __webpack_require__(/*! ./script_signature */ \"./node_modules/bitcoinjs-lib/src/script_signature.js\"),\n\n  isCanonicalPubKey: isCanonicalPubKey,\n  isCanonicalScriptSignature: isCanonicalScriptSignature,\n  isPushOnly: isPushOnly,\n  isDefinedHashType: isDefinedHashType\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/script.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/script_number.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/script_number.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nfunction decode (buffer, maxLength, minimal) {\n  maxLength = maxLength || 4\n  minimal = minimal === undefined ? true : minimal\n\n  const length = buffer.length\n  if (length === 0) return 0\n  if (length > maxLength) throw new TypeError('Script number overflow')\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0) throw new Error('Non-minimally encoded script number')\n    }\n  }\n\n  // 40-bit\n  if (length === 5) {\n    const a = buffer.readUInt32LE(0)\n    const b = buffer.readUInt8(4)\n\n    if (b & 0x80) return -(((b & ~0x80) * 0x100000000) + a)\n    return (b * 0x100000000) + a\n  }\n\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0\n  for (var i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i)\n  }\n\n  if (buffer[length - 1] & 0x80) return -(result & ~(0x80 << (8 * (length - 1))))\n  return result\n}\n\nfunction scriptNumSize (i) {\n  return i > 0x7fffffff ? 5\n    : i > 0x7fffff ? 4\n      : i > 0x7fff ? 3\n        : i > 0x7f ? 2\n          : i > 0x00 ? 1\n            : 0\n}\n\nfunction encode (number) {\n  let value = Math.abs(number)\n  const size = scriptNumSize(value)\n  const buffer = Buffer.allocUnsafe(size)\n  const negative = number < 0\n\n  for (var i = 0; i < size; ++i) {\n    buffer.writeUInt8(value & 0xff, i)\n    value >>= 8\n  }\n\n  if (buffer[size - 1] & 0x80) {\n    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1)\n  } else if (negative) {\n    buffer[size - 1] |= 0x80\n  }\n\n  return buffer\n}\n\nmodule.exports = {\n  decode: decode,\n  encode: encode\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/script_number.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/script_signature.js":
/*!************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/script_signature.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const bip66 = __webpack_require__(/*! bip66 */ \"./node_modules/bip66/index.js\")\nconst Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nconst typeforce = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\")\n\nconst ZERO = Buffer.alloc(1, 0)\nfunction toDER (x) {\n  let i = 0\n  while (x[i] === 0) ++i\n  if (i === x.length) return ZERO\n  x = x.slice(i)\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length)\n  return x\n}\n\nfunction fromDER (x) {\n  if (x[0] === 0x00) x = x.slice(1)\n  const buffer = Buffer.alloc(32, 0)\n  const bstart = Math.max(0, 32 - x.length)\n  x.copy(buffer, bstart)\n  return buffer\n}\n\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\nfunction decode (buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1)\n  const hashTypeMod = hashType & ~0x80\n  if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error('Invalid hashType ' + hashType)\n\n  const decode = bip66.decode(buffer.slice(0, -1))\n  const r = fromDER(decode.r)\n  const s = fromDER(decode.s)\n\n  return {\n    signature: Buffer.concat([r, s], 64),\n    hashType: hashType\n  }\n}\n\nfunction encode (signature, hashType) {\n  typeforce({\n    signature: types.BufferN(64),\n    hashType: types.UInt8\n  }, { signature, hashType })\n\n  const hashTypeMod = hashType & ~0x80\n  if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error('Invalid hashType ' + hashType)\n\n  const hashTypeBuffer = Buffer.allocUnsafe(1)\n  hashTypeBuffer.writeUInt8(hashType, 0)\n\n  const r = toDER(signature.slice(0, 32))\n  const s = toDER(signature.slice(32, 64))\n\n  return Buffer.concat([\n    bip66.encode(r, s),\n    hashTypeBuffer\n  ])\n}\n\nmodule.exports = {\n  decode: decode,\n  encode: encode\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/script_signature.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/multisig/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/multisig/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  input: __webpack_require__(/*! ./input */ \"./node_modules/bitcoinjs-lib/src/templates/multisig/input.js\"),\n  output: __webpack_require__(/*! ./output */ \"./node_modules/bitcoinjs-lib/src/templates/multisig/output.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/multisig/index.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/multisig/input.js":
/*!********************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/multisig/input.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// OP_0 [signatures ...]\n\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\n\nfunction partialSignature (value) {\n  return value === OPS.OP_0 || bscript.isCanonicalScriptSignature(value)\n}\n\nfunction check (script, allowIncomplete) {\n  const chunks = bscript.decompile(script)\n  if (chunks.length < 2) return false\n  if (chunks[0] !== OPS.OP_0) return false\n\n  if (allowIncomplete) {\n    return chunks.slice(1).every(partialSignature)\n  }\n\n  return chunks.slice(1).every(bscript.isCanonicalScriptSignature)\n}\ncheck.toJSON = function () { return 'multisig input' }\n\nmodule.exports = { check }\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/multisig/input.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/multisig/output.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/multisig/output.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// m [pubKeys ...] n OP_CHECKMULTISIG\n\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst types = __webpack_require__(/*! ../../types */ \"./node_modules/bitcoinjs-lib/src/types.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\nconst OP_INT_BASE = OPS.OP_RESERVED // OP_1 - 1\n\nfunction check (script, allowIncomplete) {\n  const chunks = bscript.decompile(script)\n\n  if (chunks.length < 4) return false\n  if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG) return false\n  if (!types.Number(chunks[0])) return false\n  if (!types.Number(chunks[chunks.length - 2])) return false\n  const m = chunks[0] - OP_INT_BASE\n  const n = chunks[chunks.length - 2] - OP_INT_BASE\n\n  if (m <= 0) return false\n  if (n > 16) return false\n  if (m > n) return false\n  if (n !== chunks.length - 3) return false\n  if (allowIncomplete) return true\n\n  const keys = chunks.slice(1, -2)\n  return keys.every(bscript.isCanonicalPubKey)\n}\ncheck.toJSON = function () { return 'multi-sig output' }\n\nmodule.exports = { check }\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/multisig/output.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/nulldata.js":
/*!**************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/nulldata.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// OP_RETURN {data}\n\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\n\nfunction check (script) {\n  const buffer = bscript.compile(script)\n\n  return buffer.length > 1 &&\n    buffer[0] === OPS.OP_RETURN\n}\ncheck.toJSON = function () { return 'null data output' }\n\nmodule.exports = { output: { check: check } }\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/nulldata.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/pubkey/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/pubkey/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  input: __webpack_require__(/*! ./input */ \"./node_modules/bitcoinjs-lib/src/templates/pubkey/input.js\"),\n  output: __webpack_require__(/*! ./output */ \"./node_modules/bitcoinjs-lib/src/templates/pubkey/output.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/pubkey/index.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/pubkey/input.js":
/*!******************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/pubkey/input.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// {signature}\n\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\n\nfunction check (script) {\n  const chunks = bscript.decompile(script)\n\n  return chunks.length === 1 &&\n    bscript.isCanonicalScriptSignature(chunks[0])\n}\ncheck.toJSON = function () { return 'pubKey input' }\n\nmodule.exports = {\n  check: check\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/pubkey/input.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/pubkey/output.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/pubkey/output.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// {pubKey} OP_CHECKSIG\n\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\n\nfunction check (script) {\n  const chunks = bscript.decompile(script)\n\n  return chunks.length === 2 &&\n    bscript.isCanonicalPubKey(chunks[0]) &&\n    chunks[1] === OPS.OP_CHECKSIG\n}\ncheck.toJSON = function () { return 'pubKey output' }\n\nmodule.exports = { check }\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/pubkey/output.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  input: __webpack_require__(/*! ./input */ \"./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/input.js\"),\n  output: __webpack_require__(/*! ./output */ \"./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/output.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/index.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/input.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/input.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// {signature} {pubKey}\n\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\n\nfunction check (script) {\n  const chunks = bscript.decompile(script)\n\n  return chunks.length === 2 &&\n    bscript.isCanonicalScriptSignature(chunks[0]) &&\n    bscript.isCanonicalPubKey(chunks[1])\n}\ncheck.toJSON = function () { return 'pubKeyHash input' }\n\nmodule.exports = { check }\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/input.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/output.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/output.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// OP_DUP OP_HASH160 {pubKeyHash} OP_EQUALVERIFY OP_CHECKSIG\n\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\n\nfunction check (script) {\n  const buffer = bscript.compile(script)\n\n  return buffer.length === 25 &&\n    buffer[0] === OPS.OP_DUP &&\n    buffer[1] === OPS.OP_HASH160 &&\n    buffer[2] === 0x14 &&\n    buffer[23] === OPS.OP_EQUALVERIFY &&\n    buffer[24] === OPS.OP_CHECKSIG\n}\ncheck.toJSON = function () { return 'pubKeyHash output' }\n\nmodule.exports = { check }\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/output.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/scripthash/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/scripthash/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  input: __webpack_require__(/*! ./input */ \"./node_modules/bitcoinjs-lib/src/templates/scripthash/input.js\"),\n  output: __webpack_require__(/*! ./output */ \"./node_modules/bitcoinjs-lib/src/templates/scripthash/output.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/scripthash/index.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/scripthash/input.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/scripthash/input.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// <scriptSig> {serialized scriptPubKey script}\n\nconst Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\n\nconst p2ms = __webpack_require__(/*! ../multisig/ */ \"./node_modules/bitcoinjs-lib/src/templates/multisig/index.js\")\nconst p2pk = __webpack_require__(/*! ../pubkey/ */ \"./node_modules/bitcoinjs-lib/src/templates/pubkey/index.js\")\nconst p2pkh = __webpack_require__(/*! ../pubkeyhash/ */ \"./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/index.js\")\nconst p2wpkho = __webpack_require__(/*! ../witnesspubkeyhash/output */ \"./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/output.js\")\nconst p2wsho = __webpack_require__(/*! ../witnessscripthash/output */ \"./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/output.js\")\n\nfunction check (script, allowIncomplete) {\n  const chunks = bscript.decompile(script)\n  if (chunks.length < 1) return false\n\n  const lastChunk = chunks[chunks.length - 1]\n  if (!Buffer.isBuffer(lastChunk)) return false\n\n  const scriptSigChunks = bscript.decompile(bscript.compile(chunks.slice(0, -1)))\n  const redeemScriptChunks = bscript.decompile(lastChunk)\n\n  // is redeemScript a valid script?\n  if (!redeemScriptChunks) return false\n\n  // is redeemScriptSig push only?\n  if (!bscript.isPushOnly(scriptSigChunks)) return false\n\n  // is witness?\n  if (chunks.length === 1) {\n    return p2wsho.check(redeemScriptChunks) ||\n      p2wpkho.check(redeemScriptChunks)\n  }\n\n  // match types\n  if (p2pkh.input.check(scriptSigChunks) &&\n    p2pkh.output.check(redeemScriptChunks)) return true\n\n  if (p2ms.input.check(scriptSigChunks, allowIncomplete) &&\n    p2ms.output.check(redeemScriptChunks)) return true\n\n  if (p2pk.input.check(scriptSigChunks) &&\n    p2pk.output.check(redeemScriptChunks)) return true\n\n  return false\n}\ncheck.toJSON = function () { return 'scriptHash input' }\n\nmodule.exports = { check }\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/scripthash/input.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/scripthash/output.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/scripthash/output.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// OP_HASH160 {scriptHash} OP_EQUAL\n\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\n\nfunction check (script) {\n  const buffer = bscript.compile(script)\n\n  return buffer.length === 23 &&\n    buffer[0] === OPS.OP_HASH160 &&\n    buffer[1] === 0x14 &&\n    buffer[22] === OPS.OP_EQUAL\n}\ncheck.toJSON = function () { return 'scriptHash output' }\n\nmodule.exports = { check }\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/scripthash/output.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/witnesscommitment/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/witnesscommitment/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  output: __webpack_require__(/*! ./output */ \"./node_modules/bitcoinjs-lib/src/templates/witnesscommitment/output.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/witnesscommitment/index.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/witnesscommitment/output.js":
/*!******************************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/witnesscommitment/output.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// OP_RETURN {aa21a9ed} {commitment}\n\nconst Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst types = __webpack_require__(/*! ../../types */ \"./node_modules/bitcoinjs-lib/src/types.js\")\nconst typeforce = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\n\nconst HEADER = Buffer.from('aa21a9ed', 'hex')\n\nfunction check (script) {\n  const buffer = bscript.compile(script)\n\n  return buffer.length > 37 &&\n    buffer[0] === OPS.OP_RETURN &&\n    buffer[1] === 0x24 &&\n    buffer.slice(2, 6).equals(HEADER)\n}\n\ncheck.toJSON = function () { return 'Witness commitment output' }\n\nfunction encode (commitment) {\n  typeforce(types.Hash256bit, commitment)\n\n  const buffer = Buffer.allocUnsafe(36)\n  HEADER.copy(buffer, 0)\n  commitment.copy(buffer, 4)\n\n  return bscript.compile([OPS.OP_RETURN, buffer])\n}\n\nfunction decode (buffer) {\n  typeforce(check, buffer)\n\n  return bscript.decompile(buffer)[1].slice(4, 36)\n}\n\nmodule.exports = {\n  check: check,\n  decode: decode,\n  encode: encode\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/witnesscommitment/output.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  input: __webpack_require__(/*! ./input */ \"./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/input.js\"),\n  output: __webpack_require__(/*! ./output */ \"./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/output.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/index.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/input.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/input.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// {signature} {pubKey}\n\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\n\nfunction isCompressedCanonicalPubKey (pubKey) {\n  return bscript.isCanonicalPubKey(pubKey) && pubKey.length === 33\n}\n\nfunction check (script) {\n  const chunks = bscript.decompile(script)\n\n  return chunks.length === 2 &&\n    bscript.isCanonicalScriptSignature(chunks[0]) &&\n    isCompressedCanonicalPubKey(chunks[1])\n}\ncheck.toJSON = function () { return 'witnessPubKeyHash input' }\n\nmodule.exports = { check }\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/input.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/output.js":
/*!******************************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/output.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// OP_0 {pubKeyHash}\n\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\n\nfunction check (script) {\n  const buffer = bscript.compile(script)\n\n  return buffer.length === 22 &&\n    buffer[0] === OPS.OP_0 &&\n    buffer[1] === 0x14\n}\ncheck.toJSON = function () { return 'Witness pubKeyHash output' }\n\nmodule.exports = {\n  check\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/output.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  input: __webpack_require__(/*! ./input */ \"./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/input.js\"),\n  output: __webpack_require__(/*! ./output */ \"./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/output.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/index.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/input.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/input.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// <scriptSig> {serialized scriptPubKey script}\n\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst types = __webpack_require__(/*! ../../types */ \"./node_modules/bitcoinjs-lib/src/types.js\")\nconst typeforce = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\n\nconst p2ms = __webpack_require__(/*! ../multisig/ */ \"./node_modules/bitcoinjs-lib/src/templates/multisig/index.js\")\nconst p2pk = __webpack_require__(/*! ../pubkey/ */ \"./node_modules/bitcoinjs-lib/src/templates/pubkey/index.js\")\nconst p2pkh = __webpack_require__(/*! ../pubkeyhash/ */ \"./node_modules/bitcoinjs-lib/src/templates/pubkeyhash/index.js\")\n\nfunction check (chunks, allowIncomplete) {\n  typeforce(types.Array, chunks)\n  if (chunks.length < 1) return false\n\n  const witnessScript = chunks[chunks.length - 1]\n  if (!Buffer.isBuffer(witnessScript)) return false\n\n  const witnessScriptChunks = bscript.decompile(witnessScript)\n\n  // is witnessScript a valid script?\n  if (!witnessScriptChunks || witnessScriptChunks.length === 0) return false\n\n  const witnessRawScriptSig = bscript.compile(chunks.slice(0, -1))\n\n  // match types\n  if (p2pkh.input.check(witnessRawScriptSig) &&\n    p2pkh.output.check(witnessScriptChunks)) return true\n\n  if (p2ms.input.check(witnessRawScriptSig, allowIncomplete) &&\n    p2ms.output.check(witnessScriptChunks)) return true\n\n  if (p2pk.input.check(witnessRawScriptSig) &&\n    p2pk.output.check(witnessScriptChunks)) return true\n\n  return false\n}\ncheck.toJSON = function () { return 'witnessScriptHash input' }\n\nmodule.exports = { check }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/input.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/output.js":
/*!******************************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/output.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// OP_0 {scriptHash}\n\nconst bscript = __webpack_require__(/*! ../../script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\n\nfunction check (script) {\n  const buffer = bscript.compile(script)\n\n  return buffer.length === 34 &&\n    buffer[0] === OPS.OP_0 &&\n    buffer[1] === 0x20\n}\ncheck.toJSON = function () { return 'Witness scriptHash output' }\n\nmodule.exports = { check }\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/templates/witnessscripthash/output.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/transaction.js":
/*!*******************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/transaction.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nconst bcrypto = __webpack_require__(/*! ./crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\")\nconst bscript = __webpack_require__(/*! ./script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst bufferutils = __webpack_require__(/*! ./bufferutils */ \"./node_modules/bitcoinjs-lib/src/bufferutils.js\")\nconst opcodes = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\nconst typeforce = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\")\nconst varuint = __webpack_require__(/*! varuint-bitcoin */ \"./node_modules/varuint-bitcoin/index.js\")\n\nfunction varSliceSize (someScript) {\n  const length = someScript.length\n\n  return varuint.encodingLength(length) + length\n}\n\nfunction vectorSize (someVector) {\n  const length = someVector.length\n\n  return varuint.encodingLength(length) + someVector.reduce(function (sum, witness) {\n    return sum + varSliceSize(witness)\n  }, 0)\n}\n\nfunction Transaction () {\n  this.version = 1\n  this.locktime = 0\n  this.ins = []\n  this.outs = []\n}\n\nTransaction.DEFAULT_SEQUENCE = 0xffffffff\nTransaction.SIGHASH_ALL = 0x01\nTransaction.SIGHASH_NONE = 0x02\nTransaction.SIGHASH_SINGLE = 0x03\nTransaction.SIGHASH_ANYONECANPAY = 0x80\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01\n\nconst EMPTY_SCRIPT = Buffer.allocUnsafe(0)\nconst EMPTY_WITNESS = []\nconst ZERO = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex')\nconst ONE = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex')\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex')\nconst BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX\n}\n\nTransaction.fromBuffer = function (buffer, __noStrict) {\n  let offset = 0\n  function readSlice (n) {\n    offset += n\n    return buffer.slice(offset - n, offset)\n  }\n\n  function readUInt32 () {\n    const i = buffer.readUInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  function readInt32 () {\n    const i = buffer.readInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  function readUInt64 () {\n    const i = bufferutils.readUInt64LE(buffer, offset)\n    offset += 8\n    return i\n  }\n\n  function readVarInt () {\n    const vi = varuint.decode(buffer, offset)\n    offset += varuint.decode.bytes\n    return vi\n  }\n\n  function readVarSlice () {\n    return readSlice(readVarInt())\n  }\n\n  function readVector () {\n    const count = readVarInt()\n    const vector = []\n    for (var i = 0; i < count; i++) vector.push(readVarSlice())\n    return vector\n  }\n\n  const tx = new Transaction()\n  tx.version = readInt32()\n\n  const marker = buffer.readUInt8(offset)\n  const flag = buffer.readUInt8(offset + 1)\n\n  let hasWitnesses = false\n  if (marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG) {\n    offset += 2\n    hasWitnesses = true\n  }\n\n  const vinLen = readVarInt()\n  for (var i = 0; i < vinLen; ++i) {\n    tx.ins.push({\n      hash: readSlice(32),\n      index: readUInt32(),\n      script: readVarSlice(),\n      sequence: readUInt32(),\n      witness: EMPTY_WITNESS\n    })\n  }\n\n  const voutLen = readVarInt()\n  for (i = 0; i < voutLen; ++i) {\n    tx.outs.push({\n      value: readUInt64(),\n      script: readVarSlice()\n    })\n  }\n\n  if (hasWitnesses) {\n    for (i = 0; i < vinLen; ++i) {\n      tx.ins[i].witness = readVector()\n    }\n\n    // was this pointless?\n    if (!tx.hasWitnesses()) throw new Error('Transaction has superfluous witness data')\n  }\n\n  tx.locktime = readUInt32()\n\n  if (__noStrict) return tx\n  if (offset !== buffer.length) throw new Error('Transaction has unexpected data')\n\n  return tx\n}\n\nTransaction.fromHex = function (hex) {\n  return Transaction.fromBuffer(Buffer.from(hex, 'hex'))\n}\n\nTransaction.isCoinbaseHash = function (buffer) {\n  typeforce(types.Hash256bit, buffer)\n  for (var i = 0; i < 32; ++i) {\n    if (buffer[i] !== 0) return false\n  }\n  return true\n}\n\nTransaction.prototype.isCoinbase = function () {\n  return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n}\n\nTransaction.prototype.addInput = function (hash, index, sequence, scriptSig) {\n  typeforce(types.tuple(\n    types.Hash256bit,\n    types.UInt32,\n    types.maybe(types.UInt32),\n    types.maybe(types.Buffer)\n  ), arguments)\n\n  if (types.Null(sequence)) {\n    sequence = Transaction.DEFAULT_SEQUENCE\n  }\n\n  // Add the input and return the input's index\n  return (this.ins.push({\n    hash: hash,\n    index: index,\n    script: scriptSig || EMPTY_SCRIPT,\n    sequence: sequence,\n    witness: EMPTY_WITNESS\n  }) - 1)\n}\n\nTransaction.prototype.addOutput = function (scriptPubKey, value) {\n  typeforce(types.tuple(types.Buffer, types.Satoshi), arguments)\n\n  // Add the output and return the output's index\n  return (this.outs.push({\n    script: scriptPubKey,\n    value: value\n  }) - 1)\n}\n\nTransaction.prototype.hasWitnesses = function () {\n  return this.ins.some(function (x) {\n    return x.witness.length !== 0\n  })\n}\n\nTransaction.prototype.weight = function () {\n  const base = this.__byteLength(false)\n  const total = this.__byteLength(true)\n  return base * 3 + total\n}\n\nTransaction.prototype.virtualSize = function () {\n  return Math.ceil(this.weight() / 4)\n}\n\nTransaction.prototype.byteLength = function () {\n  return this.__byteLength(true)\n}\n\nTransaction.prototype.__byteLength = function (__allowWitness) {\n  const hasWitnesses = __allowWitness && this.hasWitnesses()\n\n  return (\n    (hasWitnesses ? 10 : 8) +\n    varuint.encodingLength(this.ins.length) +\n    varuint.encodingLength(this.outs.length) +\n    this.ins.reduce(function (sum, input) { return sum + 40 + varSliceSize(input.script) }, 0) +\n    this.outs.reduce(function (sum, output) { return sum + 8 + varSliceSize(output.script) }, 0) +\n    (hasWitnesses ? this.ins.reduce(function (sum, input) { return sum + vectorSize(input.witness) }, 0) : 0)\n  )\n}\n\nTransaction.prototype.clone = function () {\n  const newTx = new Transaction()\n  newTx.version = this.version\n  newTx.locktime = this.locktime\n\n  newTx.ins = this.ins.map(function (txIn) {\n    return {\n      hash: txIn.hash,\n      index: txIn.index,\n      script: txIn.script,\n      sequence: txIn.sequence,\n      witness: txIn.witness\n    }\n  })\n\n  newTx.outs = this.outs.map(function (txOut) {\n    return {\n      script: txOut.script,\n      value: txOut.value\n    }\n  })\n\n  return newTx\n}\n\n/**\n * Hash transaction for signing a specific input.\n *\n * Bitcoin uses a different hash for each signed transaction input.\n * This method copies the transaction, makes the necessary changes based on the\n * hashType, and then hashes the result.\n * This hash can then be used to sign the provided transaction input.\n */\nTransaction.prototype.hashForSignature = function (inIndex, prevOutScript, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number), arguments)\n\n  // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n  if (inIndex >= this.ins.length) return ONE\n\n  // ignore OP_CODESEPARATOR\n  const ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(function (x) {\n    return x !== opcodes.OP_CODESEPARATOR\n  }))\n\n  const txTmp = this.clone()\n\n  // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n  if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n    txTmp.outs = []\n\n    // ignore sequence numbers (except at inIndex)\n    txTmp.ins.forEach(function (input, i) {\n      if (i === inIndex) return\n\n      input.sequence = 0\n    })\n\n  // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n    if (inIndex >= this.outs.length) return ONE\n\n    // truncate outputs after\n    txTmp.outs.length = inIndex + 1\n\n    // \"blank\" outputs before\n    for (var i = 0; i < inIndex; i++) {\n      txTmp.outs[i] = BLANK_OUTPUT\n    }\n\n    // ignore sequence numbers (except at inIndex)\n    txTmp.ins.forEach(function (input, y) {\n      if (y === inIndex) return\n\n      input.sequence = 0\n    })\n  }\n\n  // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n  if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n    txTmp.ins = [txTmp.ins[inIndex]]\n    txTmp.ins[0].script = ourScript\n\n  // SIGHASH_ALL: only ignore input scripts\n  } else {\n    // \"blank\" others input scripts\n    txTmp.ins.forEach(function (input) { input.script = EMPTY_SCRIPT })\n    txTmp.ins[inIndex].script = ourScript\n  }\n\n  // serialize and hash\n  const buffer = Buffer.allocUnsafe(txTmp.__byteLength(false) + 4)\n  buffer.writeInt32LE(hashType, buffer.length - 4)\n  txTmp.__toBuffer(buffer, 0, false)\n\n  return bcrypto.hash256(buffer)\n}\n\nTransaction.prototype.hashForWitnessV0 = function (inIndex, prevOutScript, value, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments)\n\n  let tbuffer, toffset\n  function writeSlice (slice) { toffset += slice.copy(tbuffer, toffset) }\n  function writeUInt32 (i) { toffset = tbuffer.writeUInt32LE(i, toffset) }\n  function writeUInt64 (i) { toffset = bufferutils.writeUInt64LE(tbuffer, i, toffset) }\n  function writeVarInt (i) {\n    varuint.encode(i, tbuffer, toffset)\n    toffset += varuint.encode.bytes\n  }\n  function writeVarSlice (slice) { writeVarInt(slice.length); writeSlice(slice) }\n\n  let hashOutputs = ZERO\n  let hashPrevouts = ZERO\n  let hashSequence = ZERO\n\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n    tbuffer = Buffer.allocUnsafe(36 * this.ins.length)\n    toffset = 0\n\n    this.ins.forEach(function (txIn) {\n      writeSlice(txIn.hash)\n      writeUInt32(txIn.index)\n    })\n\n    hashPrevouts = bcrypto.hash256(tbuffer)\n  }\n\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n       (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n       (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    tbuffer = Buffer.allocUnsafe(4 * this.ins.length)\n    toffset = 0\n\n    this.ins.forEach(function (txIn) {\n      writeUInt32(txIn.sequence)\n    })\n\n    hashSequence = bcrypto.hash256(tbuffer)\n  }\n\n  if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    const txOutsSize = this.outs.reduce(function (sum, output) {\n      return sum + 8 + varSliceSize(output.script)\n    }, 0)\n\n    tbuffer = Buffer.allocUnsafe(txOutsSize)\n    toffset = 0\n\n    this.outs.forEach(function (out) {\n      writeUInt64(out.value)\n      writeVarSlice(out.script)\n    })\n\n    hashOutputs = bcrypto.hash256(tbuffer)\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {\n    const output = this.outs[inIndex]\n\n    tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script))\n    toffset = 0\n    writeUInt64(output.value)\n    writeVarSlice(output.script)\n\n    hashOutputs = bcrypto.hash256(tbuffer)\n  }\n\n  tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript))\n  toffset = 0\n\n  const input = this.ins[inIndex]\n  writeUInt32(this.version)\n  writeSlice(hashPrevouts)\n  writeSlice(hashSequence)\n  writeSlice(input.hash)\n  writeUInt32(input.index)\n  writeVarSlice(prevOutScript)\n  writeUInt64(value)\n  writeUInt32(input.sequence)\n  writeSlice(hashOutputs)\n  writeUInt32(this.locktime)\n  writeUInt32(hashType)\n  return bcrypto.hash256(tbuffer)\n}\n\nTransaction.prototype.getHash = function () {\n  return bcrypto.hash256(this.__toBuffer(undefined, undefined, false))\n}\n\nTransaction.prototype.getId = function () {\n  // transaction hash's are displayed in reverse order\n  return this.getHash().reverse().toString('hex')\n}\n\nTransaction.prototype.toBuffer = function (buffer, initialOffset) {\n  return this.__toBuffer(buffer, initialOffset, true)\n}\n\nTransaction.prototype.__toBuffer = function (buffer, initialOffset, __allowWitness) {\n  if (!buffer) buffer = Buffer.allocUnsafe(this.__byteLength(__allowWitness))\n\n  let offset = initialOffset || 0\n  function writeSlice (slice) { offset += slice.copy(buffer, offset) }\n  function writeUInt8 (i) { offset = buffer.writeUInt8(i, offset) }\n  function writeUInt32 (i) { offset = buffer.writeUInt32LE(i, offset) }\n  function writeInt32 (i) { offset = buffer.writeInt32LE(i, offset) }\n  function writeUInt64 (i) { offset = bufferutils.writeUInt64LE(buffer, i, offset) }\n  function writeVarInt (i) {\n    varuint.encode(i, buffer, offset)\n    offset += varuint.encode.bytes\n  }\n  function writeVarSlice (slice) { writeVarInt(slice.length); writeSlice(slice) }\n  function writeVector (vector) { writeVarInt(vector.length); vector.forEach(writeVarSlice) }\n\n  writeInt32(this.version)\n\n  const hasWitnesses = __allowWitness && this.hasWitnesses()\n\n  if (hasWitnesses) {\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER)\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)\n  }\n\n  writeVarInt(this.ins.length)\n\n  this.ins.forEach(function (txIn) {\n    writeSlice(txIn.hash)\n    writeUInt32(txIn.index)\n    writeVarSlice(txIn.script)\n    writeUInt32(txIn.sequence)\n  })\n\n  writeVarInt(this.outs.length)\n  this.outs.forEach(function (txOut) {\n    if (!txOut.valueBuffer) {\n      writeUInt64(txOut.value)\n    } else {\n      writeSlice(txOut.valueBuffer)\n    }\n\n    writeVarSlice(txOut.script)\n  })\n\n  if (hasWitnesses) {\n    this.ins.forEach(function (input) {\n      writeVector(input.witness)\n    })\n  }\n\n  writeUInt32(this.locktime)\n\n  // avoid slicing unless necessary\n  if (initialOffset !== undefined) return buffer.slice(initialOffset, offset)\n  return buffer\n}\n\nTransaction.prototype.toHex = function () {\n  return this.toBuffer().toString('hex')\n}\n\nTransaction.prototype.setInputScript = function (index, scriptSig) {\n  typeforce(types.tuple(types.Number, types.Buffer), arguments)\n\n  this.ins[index].script = scriptSig\n}\n\nTransaction.prototype.setWitness = function (index, witness) {\n  typeforce(types.tuple(types.Number, [types.Buffer]), arguments)\n\n  this.ins[index].witness = witness\n}\n\nmodule.exports = Transaction\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/transaction.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/transaction_builder.js":
/*!***************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/transaction_builder.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nconst baddress = __webpack_require__(/*! ./address */ \"./node_modules/bitcoinjs-lib/src/address.js\")\nconst bcrypto = __webpack_require__(/*! ./crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\")\nconst bscript = __webpack_require__(/*! ./script */ \"./node_modules/bitcoinjs-lib/src/script.js\")\nconst networks = __webpack_require__(/*! ./networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\")\nconst ops = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\nconst payments = __webpack_require__(/*! ./payments */ \"./node_modules/bitcoinjs-lib/src/payments/index.js\")\nconst typeforce = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\")\nconst classify = __webpack_require__(/*! ./classify */ \"./node_modules/bitcoinjs-lib/src/classify.js\")\nconst SCRIPT_TYPES = classify.types\n\nconst ECPair = __webpack_require__(/*! ./ecpair */ \"./node_modules/bitcoinjs-lib/src/ecpair.js\")\nconst Transaction = __webpack_require__(/*! ./transaction */ \"./node_modules/bitcoinjs-lib/src/transaction.js\")\n\nfunction expandInput (scriptSig, witnessStack, type, scriptPubKey) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {}\n  if (!type) {\n    let ssType = classify.input(scriptSig, true)\n    let wsType = classify.witness(witnessStack, true)\n    if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined\n    if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined\n    type = ssType || wsType\n  }\n\n  switch (type) {\n    case SCRIPT_TYPES.P2WPKH: {\n      const { output, pubkey, signature } = payments.p2wpkh({ witness: witnessStack })\n\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2WPKH,\n        pubkeys: [pubkey],\n        signatures: [signature]\n      }\n    }\n\n    case SCRIPT_TYPES.P2PKH: {\n      const { output, pubkey, signature } = payments.p2pkh({ input: scriptSig })\n\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2PKH,\n        pubkeys: [pubkey],\n        signatures: [signature]\n      }\n    }\n\n    case SCRIPT_TYPES.P2PK: {\n      const { signature } = payments.p2pk({ input: scriptSig })\n\n      return {\n        prevOutType: SCRIPT_TYPES.P2PK,\n        pubkeys: [undefined],\n        signatures: [signature]\n      }\n    }\n\n    case SCRIPT_TYPES.P2MS: {\n      const { m, pubkeys, signatures } = payments.p2ms({\n        input: scriptSig,\n        output: scriptPubKey\n      }, { allowIncomplete: true })\n\n      return {\n        prevOutType: SCRIPT_TYPES.P2MS,\n        pubkeys: pubkeys,\n        signatures: signatures,\n        maxSignatures: m\n      }\n    }\n  }\n\n  if (type === SCRIPT_TYPES.P2SH) {\n    const { output, redeem } = payments.p2sh({\n      input: scriptSig,\n      witness: witnessStack\n    })\n\n    const outputType = classify.output(redeem.output)\n    const expanded = expandInput(redeem.input, redeem.witness, outputType, redeem.output)\n    if (!expanded.prevOutType) return {}\n\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      redeemScript: redeem.output,\n      redeemScriptType: expanded.prevOutType,\n      witnessScript: expanded.witnessScript,\n      witnessScriptType: expanded.witnessScriptType,\n\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures\n    }\n  }\n\n  if (type === SCRIPT_TYPES.P2WSH) {\n    const { output, redeem } = payments.p2wsh({\n      input: scriptSig,\n      witness: witnessStack\n    })\n    const outputType = classify.output(redeem.output)\n    let expanded\n    if (outputType === SCRIPT_TYPES.P2WPKH) {\n      expanded = expandInput(redeem.input, redeem.witness, outputType)\n    } else {\n      expanded = expandInput(bscript.compile(redeem.witness), [], outputType, redeem.output)\n    }\n    if (!expanded.prevOutType) return {}\n\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      witnessScript: redeem.output,\n      witnessScriptType: expanded.prevOutType,\n\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures\n    }\n  }\n\n  return {\n    prevOutType: SCRIPT_TYPES.NONSTANDARD,\n    prevOutScript: scriptSig\n  }\n}\n\n// could be done in expandInput, but requires the original Transaction for hashForSignature\nfunction fixMultisigOrder (input, transaction, vin) {\n  if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript) return\n  if (input.pubkeys.length === input.signatures.length) return\n\n  const unmatched = input.signatures.concat()\n\n  input.signatures = input.pubkeys.map(function (pubKey) {\n    const keyPair = ECPair.fromPublicKey(pubKey)\n    let match\n\n    // check for a signature\n    unmatched.some(function (signature, i) {\n      // skip if undefined || OP_0\n      if (!signature) return false\n\n      // TODO: avoid O(n) hashForSignature\n      const parsed = bscript.signature.decode(signature)\n      const hash = transaction.hashForSignature(vin, input.redeemScript, parsed.hashType)\n\n      // skip if signature does not match pubKey\n      if (!keyPair.verify(hash, parsed.signature)) return false\n\n      // remove matched signature from unmatched\n      unmatched[i] = undefined\n      match = signature\n\n      return true\n    })\n\n    return match\n  })\n}\n\nfunction expandOutput (script, ourPubKey) {\n  typeforce(types.Buffer, script)\n  const type = classify.output(script)\n\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (!ourPubKey) return { type }\n\n      // does our hash160(pubKey) match the output scripts?\n      const pkh1 = payments.p2pkh({ output: script }).hash\n      const pkh2 = bcrypto.hash160(ourPubKey)\n      if (!pkh1.equals(pkh2)) return { type }\n\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined]\n      }\n    }\n\n    case SCRIPT_TYPES.P2WPKH: {\n      if (!ourPubKey) return { type }\n\n      // does our hash160(pubKey) match the output scripts?\n      const wpkh1 = payments.p2wpkh({ output: script }).hash\n      const wpkh2 = bcrypto.hash160(ourPubKey)\n      if (!wpkh1.equals(wpkh2)) return { type }\n\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined]\n      }\n    }\n\n    case SCRIPT_TYPES.P2PK: {\n      const p2pk = payments.p2pk({ output: script })\n      return {\n        type,\n        pubkeys: [p2pk.pubkey],\n        signatures: [undefined]\n      }\n    }\n\n    case SCRIPT_TYPES.P2MS: {\n      const p2ms = payments.p2ms({ output: script })\n      return {\n        type,\n        pubkeys: p2ms.pubkeys,\n        signatures: p2ms.pubkeys.map(() => undefined),\n        maxSignatures: p2ms.m\n      }\n    }\n  }\n\n  return { type }\n}\n\nfunction prepareInput (input, ourPubKey, redeemScript, witnessScript) {\n  if (redeemScript && witnessScript) {\n    const p2wsh = payments.p2wsh({ redeem: { output: witnessScript } })\n    const p2wshAlt = payments.p2wsh({ output: redeemScript })\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } })\n    const p2shAlt = payments.p2sh({ redeem: p2wsh })\n\n    // enforces P2SH(P2WSH(...))\n    if (!p2wsh.hash.equals(p2wshAlt.hash)) throw new Error('Witness script inconsistent with prevOutScript')\n    if (!p2sh.hash.equals(p2shAlt.hash)) throw new Error('Redeem script inconsistent with prevOutScript')\n\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey)\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported as witnessScript (' + bscript.toASM(witnessScript) + ')')\n    if (input.signatures && input.signatures.some(x => x)) {\n      expanded.signatures = input.signatures\n    }\n\n    let signScript = witnessScript\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure')\n\n    return {\n      redeemScript,\n      redeemScriptType: SCRIPT_TYPES.P2WSH,\n\n      witnessScript,\n      witnessScriptType: expanded.type,\n\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    }\n  }\n\n  if (redeemScript) {\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } })\n\n    if (input.prevOutScript) {\n      let p2shAlt\n      try {\n        p2shAlt = payments.p2sh({ output: input.prevOutScript })\n      } catch (e) { throw new Error('PrevOutScript must be P2SH') }\n      if (!p2sh.hash.equals(p2shAlt.hash)) throw new Error('Redeem script inconsistent with prevOutScript')\n    }\n\n    const expanded = expandOutput(p2sh.redeem.output, ourPubKey)\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported as redeemScript (' + bscript.toASM(redeemScript) + ')')\n    if (input.signatures && input.signatures.some(x => x)) {\n      expanded.signatures = input.signatures\n    }\n\n    let signScript = redeemScript\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output\n    }\n\n    return {\n      redeemScript,\n      redeemScriptType: expanded.type,\n\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    }\n  }\n\n  if (witnessScript) {\n    const p2wsh = payments.p2wsh({ redeem: { output: witnessScript } })\n\n    if (input.prevOutScript) {\n      const p2wshAlt = payments.p2wsh({ output: input.prevOutScript })\n      if (!p2wsh.hash.equals(p2wshAlt.hash)) throw new Error('Witness script inconsistent with prevOutScript')\n    }\n\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey)\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported as witnessScript (' + bscript.toASM(witnessScript) + ')')\n    if (input.signatures && input.signatures.some(x => x)) {\n      expanded.signatures = input.signatures\n    }\n\n    let signScript = witnessScript\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) throw new Error('P2WSH(P2WPKH) is a consensus failure')\n\n    return {\n      witnessScript,\n      witnessScriptType: expanded.type,\n\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      prevOutScript: p2wsh.output,\n\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    }\n  }\n\n  if (input.prevOutType && input.prevOutScript) {\n    // embedded scripts are not possible without extra information\n    if (input.prevOutType === SCRIPT_TYPES.P2SH) throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript')\n    if (input.prevOutType === SCRIPT_TYPES.P2WSH) throw new Error('PrevOutScript is ' + input.prevOutType + ', requires witnessScript')\n    if (!input.prevOutScript) throw new Error('PrevOutScript is missing')\n\n    const expanded = expandOutput(input.prevOutScript, ourPubKey)\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported (' + bscript.toASM(input.prevOutScript) + ')')\n    if (input.signatures && input.signatures.some(x => x)) {\n      expanded.signatures = input.signatures\n    }\n\n    let signScript = input.prevOutScript\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output\n    }\n\n    return {\n      prevOutType: expanded.type,\n      prevOutScript: input.prevOutScript,\n\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    }\n  }\n\n  const prevOutScript = payments.p2pkh({ pubkey: ourPubKey }).output\n  return {\n    prevOutType: SCRIPT_TYPES.P2PKH,\n    prevOutScript: prevOutScript,\n\n    hasWitness: false,\n    signScript: prevOutScript,\n    signType: SCRIPT_TYPES.P2PKH,\n\n    pubkeys: [ourPubKey],\n    signatures: [undefined]\n  }\n}\n\nfunction build (type, input, allowIncomplete) {\n  const pubkeys = input.pubkeys || []\n  let signatures = input.signatures || []\n\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (pubkeys.length === 0) break\n      if (signatures.length === 0) break\n\n      return payments.p2pkh({ pubkey: pubkeys[0], signature: signatures[0] })\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (pubkeys.length === 0) break\n      if (signatures.length === 0) break\n\n      return payments.p2wpkh({ pubkey: pubkeys[0], signature: signatures[0] })\n    }\n    case SCRIPT_TYPES.P2PK: {\n      if (pubkeys.length === 0) break\n      if (signatures.length === 0) break\n\n      return payments.p2pk({ signature: signatures[0] })\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const m = input.maxSignatures\n      if (allowIncomplete) {\n        signatures = signatures.map(x => x || ops.OP_0)\n      } else {\n        signatures = signatures.filter(x => x)\n      }\n\n      // if the transaction is not not complete (complete), or if signatures.length === m, validate\n      // otherwise, the number of OP_0's may be >= m, so don't validate (boo)\n      const validate = !allowIncomplete || (m === signatures.length)\n      return payments.p2ms({ m, pubkeys, signatures }, { allowIncomplete, validate })\n    }\n    case SCRIPT_TYPES.P2SH: {\n      const redeem = build(input.redeemScriptType, input, allowIncomplete)\n      if (!redeem) return\n\n      return payments.p2sh({\n        redeem: {\n          output: redeem.output || input.redeemScript,\n          input: redeem.input,\n          witness: redeem.witness\n        }\n      })\n    }\n    case SCRIPT_TYPES.P2WSH: {\n      const redeem = build(input.witnessScriptType, input, allowIncomplete)\n      if (!redeem) return\n\n      return payments.p2wsh({\n        redeem: {\n          output: input.witnessScript,\n          input: redeem.input,\n          witness: redeem.witness\n        }\n      })\n    }\n  }\n}\n\nfunction TransactionBuilder (network, maximumFeeRate) {\n  this.__prevTxSet = {}\n  this.network = network || networks.bitcoin\n\n  // WARNING: This is __NOT__ to be relied on, its just another potential safety mechanism (safety in-depth)\n  this.maximumFeeRate = maximumFeeRate || 2500\n\n  this.__inputs = []\n  this.__tx = new Transaction()\n  this.__tx.version = 2\n}\n\nTransactionBuilder.prototype.setLockTime = function (locktime) {\n  typeforce(types.UInt32, locktime)\n\n  // if any signatures exist, throw\n  if (this.__inputs.some(function (input) {\n    if (!input.signatures) return false\n\n    return input.signatures.some(function (s) { return s })\n  })) {\n    throw new Error('No, this would invalidate signatures')\n  }\n\n  this.__tx.locktime = locktime\n}\n\nTransactionBuilder.prototype.setVersion = function (version) {\n  typeforce(types.UInt32, version)\n\n  // XXX: this might eventually become more complex depending on what the versions represent\n  this.__tx.version = version\n}\n\nTransactionBuilder.fromTransaction = function (transaction, network) {\n  const txb = new TransactionBuilder(network)\n\n  // Copy transaction fields\n  txb.setVersion(transaction.version)\n  txb.setLockTime(transaction.locktime)\n\n  // Copy outputs (done first to avoid signature invalidation)\n  transaction.outs.forEach(function (txOut) {\n    txb.addOutput(txOut.script, txOut.value)\n  })\n\n  // Copy inputs\n  transaction.ins.forEach(function (txIn) {\n    txb.__addInputUnsafe(txIn.hash, txIn.index, {\n      sequence: txIn.sequence,\n      script: txIn.script,\n      witness: txIn.witness\n    })\n  })\n\n  // fix some things not possible through the public API\n  txb.__inputs.forEach(function (input, i) {\n    fixMultisigOrder(input, transaction, i)\n  })\n\n  return txb\n}\n\nTransactionBuilder.prototype.addInput = function (txHash, vout, sequence, prevOutScript) {\n  if (!this.__canModifyInputs()) {\n    throw new Error('No, this would invalidate signatures')\n  }\n\n  let value\n\n  // is it a hex string?\n  if (typeof txHash === 'string') {\n    // transaction hashs's are displayed in reverse order, un-reverse it\n    txHash = Buffer.from(txHash, 'hex').reverse()\n\n  // is it a Transaction object?\n  } else if (txHash instanceof Transaction) {\n    const txOut = txHash.outs[vout]\n    prevOutScript = txOut.script\n    value = txOut.value\n\n    txHash = txHash.getHash()\n  }\n\n  return this.__addInputUnsafe(txHash, vout, {\n    sequence: sequence,\n    prevOutScript: prevOutScript,\n    value: value\n  })\n}\n\nTransactionBuilder.prototype.__addInputUnsafe = function (txHash, vout, options) {\n  if (Transaction.isCoinbaseHash(txHash)) {\n    throw new Error('coinbase inputs not supported')\n  }\n\n  const prevTxOut = txHash.toString('hex') + ':' + vout\n  if (this.__prevTxSet[prevTxOut] !== undefined) throw new Error('Duplicate TxOut: ' + prevTxOut)\n\n  let input = {}\n\n  // derive what we can from the scriptSig\n  if (options.script !== undefined) {\n    input = expandInput(options.script, options.witness || [])\n  }\n\n  // if an input value was given, retain it\n  if (options.value !== undefined) {\n    input.value = options.value\n  }\n\n  // derive what we can from the previous transactions output script\n  if (!input.prevOutScript && options.prevOutScript) {\n    let prevOutType\n\n    if (!input.pubkeys && !input.signatures) {\n      const expanded = expandOutput(options.prevOutScript)\n      if (expanded.pubkeys) {\n        input.pubkeys = expanded.pubkeys\n        input.signatures = expanded.signatures\n      }\n\n      prevOutType = expanded.type\n    }\n\n    input.prevOutScript = options.prevOutScript\n    input.prevOutType = prevOutType || classify.output(options.prevOutScript)\n  }\n\n  const vin = this.__tx.addInput(txHash, vout, options.sequence, options.scriptSig)\n  this.__inputs[vin] = input\n  this.__prevTxSet[prevTxOut] = true\n  return vin\n}\n\nTransactionBuilder.prototype.addOutput = function (scriptPubKey, value) {\n  if (!this.__canModifyOutputs()) {\n    throw new Error('No, this would invalidate signatures')\n  }\n\n  // Attempt to get a script if it's a base58 or bech32 address string\n  if (typeof scriptPubKey === 'string') {\n    scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network)\n  }\n\n  return this.__tx.addOutput(scriptPubKey, value)\n}\n\nTransactionBuilder.prototype.build = function () {\n  return this.__build(false)\n}\nTransactionBuilder.prototype.buildIncomplete = function () {\n  return this.__build(true)\n}\n\nTransactionBuilder.prototype.__build = function (allowIncomplete) {\n  if (!allowIncomplete) {\n    if (!this.__tx.ins.length) throw new Error('Transaction has no inputs')\n    if (!this.__tx.outs.length) throw new Error('Transaction has no outputs')\n  }\n\n  const tx = this.__tx.clone()\n\n  // create script signatures from inputs\n  this.__inputs.forEach(function (input, i) {\n    if (!input.prevOutType && !allowIncomplete) throw new Error('Transaction is not complete')\n\n    const result = build(input.prevOutType, input, allowIncomplete)\n    if (!result) {\n      if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD) throw new Error('Unknown input type')\n      if (!allowIncomplete) throw new Error('Not enough information')\n      return\n    }\n\n    tx.setInputScript(i, result.input)\n    tx.setWitness(i, result.witness)\n  })\n\n  if (!allowIncomplete) {\n    // do not rely on this, its merely a last resort\n    if (this.__overMaximumFees(tx.virtualSize())) {\n      throw new Error('Transaction has absurd fees')\n    }\n  }\n\n  return tx\n}\n\nfunction canSign (input) {\n  return input.signScript !== undefined &&\n    input.signType !== undefined &&\n    input.pubkeys !== undefined &&\n    input.signatures !== undefined &&\n    input.signatures.length === input.pubkeys.length &&\n    input.pubkeys.length > 0 &&\n    (\n      input.hasWitness === false ||\n      input.value !== undefined\n    )\n}\n\nTransactionBuilder.prototype.sign = function (vin, keyPair, redeemScript, hashType, witnessValue, witnessScript) {\n  // TODO: remove keyPair.network matching in 4.0.0\n  if (keyPair.network && keyPair.network !== this.network) throw new TypeError('Inconsistent network')\n  if (!this.__inputs[vin]) throw new Error('No input at index: ' + vin)\n\n  hashType = hashType || Transaction.SIGHASH_ALL\n  if (this.__needsOutputs(hashType)) throw new Error('Transaction needs outputs')\n\n  const input = this.__inputs[vin]\n\n  // if redeemScript was previously provided, enforce consistency\n  if (input.redeemScript !== undefined &&\n      redeemScript &&\n      !input.redeemScript.equals(redeemScript)) {\n    throw new Error('Inconsistent redeemScript')\n  }\n\n  const ourPubKey = keyPair.publicKey || keyPair.getPublicKey()\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue) throw new Error('Input didn\\'t match witnessValue')\n      typeforce(types.Satoshi, witnessValue)\n      input.value = witnessValue\n    }\n\n    if (!canSign(input)) {\n      const prepared = prepareInput(input, ourPubKey, redeemScript, witnessScript)\n\n      // updates inline\n      Object.assign(input, prepared)\n    }\n\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported')\n  }\n\n  // ready to sign\n  let signatureHash\n  if (input.hasWitness) {\n    signatureHash = this.__tx.hashForWitnessV0(vin, input.signScript, input.value, hashType)\n  } else {\n    signatureHash = this.__tx.hashForSignature(vin, input.signScript, hashType)\n  }\n\n  // enforce in order signing of public keys\n  const signed = input.pubkeys.some(function (pubKey, i) {\n    if (!ourPubKey.equals(pubKey)) return false\n    if (input.signatures[i]) throw new Error('Signature already exists')\n\n    // TODO: add tests\n    if (ourPubKey.length !== 33 && input.hasWitness) {\n      throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH')\n    }\n\n    const signature = keyPair.sign(signatureHash)\n    input.signatures[i] = bscript.signature.encode(signature, hashType)\n    return true\n  })\n\n  if (!signed) throw new Error('Key pair cannot sign for this input')\n}\n\nfunction signatureHashType (buffer) {\n  return buffer.readUInt8(buffer.length - 1)\n}\n\nTransactionBuilder.prototype.__canModifyInputs = function () {\n  return this.__inputs.every(function (input) {\n    if (!input.signatures) return true\n\n    return input.signatures.every(function (signature) {\n      if (!signature) return true\n      const hashType = signatureHashType(signature)\n\n      // if SIGHASH_ANYONECANPAY is set, signatures would not\n      // be invalidated by more inputs\n      return hashType & Transaction.SIGHASH_ANYONECANPAY\n    })\n  })\n}\n\nTransactionBuilder.prototype.__needsOutputs = function (signingHashType) {\n  if (signingHashType === Transaction.SIGHASH_ALL) {\n    return this.__tx.outs.length === 0\n  }\n\n  // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs\n  // .build() will fail, but .buildIncomplete() is OK\n  return (this.__tx.outs.length === 0) && this.__inputs.some((input) => {\n    if (!input.signatures) return false\n\n    return input.signatures.some((signature) => {\n      if (!signature) return false // no signature, no issue\n      const hashType = signatureHashType(signature)\n      if (hashType & Transaction.SIGHASH_NONE) return false // SIGHASH_NONE doesn't care about outputs\n      return true // SIGHASH_* does care\n    })\n  })\n}\n\nTransactionBuilder.prototype.__canModifyOutputs = function () {\n  const nInputs = this.__tx.ins.length\n  const nOutputs = this.__tx.outs.length\n\n  return this.__inputs.every(function (input) {\n    if (input.signatures === undefined) return true\n\n    return input.signatures.every(function (signature) {\n      if (!signature) return true\n      const hashType = signatureHashType(signature)\n\n      const hashTypeMod = hashType & 0x1f\n      if (hashTypeMod === Transaction.SIGHASH_NONE) return true\n      if (hashTypeMod === Transaction.SIGHASH_SINGLE) {\n        // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n        // some signatures would be invalidated by the addition\n        // of more outputs\n        return nInputs <= nOutputs\n      }\n    })\n  })\n}\n\nTransactionBuilder.prototype.__overMaximumFees = function (bytes) {\n  // not all inputs will have .value defined\n  const incoming = this.__inputs.reduce(function (a, x) { return a + (x.value >>> 0) }, 0)\n\n  // but all outputs do, and if we have any input value\n  // we can immediately determine if the outputs are too small\n  const outgoing = this.__tx.outs.reduce(function (a, x) { return a + x.value }, 0)\n  const fee = incoming - outgoing\n  const feeRate = fee / bytes\n\n  return feeRate > this.maximumFeeRate\n}\n\nmodule.exports = TransactionBuilder\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/transaction_builder.js?");

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/types.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/types.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const typeforce = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\")\n\nconst UINT31_MAX = Math.pow(2, 31) - 1\nfunction UInt31 (value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX\n}\n\nfunction BIP32Path (value) {\n  return typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/)\n}\nBIP32Path.toJSON = function () { return 'BIP32 derivation path' }\n\nconst SATOSHI_MAX = 21 * 1e14\nfunction Satoshi (value) {\n  return typeforce.UInt53(value) && value <= SATOSHI_MAX\n}\n\n// external dependent types\nconst ECPoint = typeforce.quacksLike('Point')\n\n// exposed, external API\nconst Network = typeforce.compile({\n  messagePrefix: typeforce.oneOf(typeforce.Buffer, typeforce.String),\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32\n  },\n  pubKeyHash: typeforce.UInt8,\n  scriptHash: typeforce.UInt8,\n  wif: typeforce.UInt8\n})\n\n// extend typeforce types with ours\nconst types = {\n  BIP32Path: BIP32Path,\n  Buffer256bit: typeforce.BufferN(32),\n  ECPoint: ECPoint,\n  Hash160bit: typeforce.BufferN(20),\n  Hash256bit: typeforce.BufferN(32),\n  Network: Network,\n  Satoshi: Satoshi,\n  UInt31: UInt31\n}\n\nfor (var typeName in typeforce) {\n  types[typeName] = typeforce[typeName]\n}\n\nmodule.exports = types\n\n\n//# sourceURL=webpack:///./node_modules/bitcoinjs-lib/src/types.js?");

/***/ }),

/***/ "./node_modules/create-hash/md5.js":
/*!*****************************************!*\
  !*** ./node_modules/create-hash/md5.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var MD5 = __webpack_require__(/*! md5.js */ \"./node_modules/md5.js/index.js\")\n\nmodule.exports = function (buffer) {\n  return new MD5().update(buffer).digest()\n}\n\n\n//# sourceURL=webpack:///./node_modules/create-hash/md5.js?");

/***/ }),

/***/ "./node_modules/create-hmac/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hmac/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Legacy = __webpack_require__(/*! ./legacy */ \"./node_modules/create-hmac/legacy.js\")\nvar Base = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar md5 = __webpack_require__(/*! create-hash/md5 */ \"./node_modules/create-hash/md5.js\")\nvar RIPEMD160 = __webpack_require__(/*! ripemd160 */ \"./node_modules/ripemd160/index.js\")\n\nvar sha = __webpack_require__(/*! sha.js */ \"./node_modules/sha.js/index.js\")\n\nvar ZEROS = Buffer.alloc(128)\n\nfunction Hmac (alg, key) {\n  Base.call(this, 'digest')\n  if (typeof key === 'string') {\n    key = Buffer.from(key)\n  }\n\n  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64\n\n  this._alg = alg\n  this._key = key\n  if (key.length > blocksize) {\n    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)\n    key = hash.update(key).digest()\n  } else if (key.length < blocksize) {\n    key = Buffer.concat([key, ZEROS], blocksize)\n  }\n\n  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)\n  var opad = this._opad = Buffer.allocUnsafe(blocksize)\n\n  for (var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)\n  this._hash.update(ipad)\n}\n\ninherits(Hmac, Base)\n\nHmac.prototype._update = function (data) {\n  this._hash.update(data)\n}\n\nHmac.prototype._final = function () {\n  var h = this._hash.digest()\n  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)\n  return hash.update(this._opad).update(h).digest()\n}\n\nmodule.exports = function createHmac (alg, key) {\n  alg = alg.toLowerCase()\n  if (alg === 'rmd160' || alg === 'ripemd160') {\n    return new Hmac('rmd160', key)\n  }\n  if (alg === 'md5') {\n    return new Legacy(md5, key)\n  }\n  return new Hmac(alg, key)\n}\n\n\n//# sourceURL=webpack:///./node_modules/create-hmac/browser.js?");

/***/ }),

/***/ "./node_modules/create-hmac/legacy.js":
/*!********************************************!*\
  !*** ./node_modules/create-hmac/legacy.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar Base = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\n\nvar ZEROS = Buffer.alloc(128)\nvar blocksize = 64\n\nfunction Hmac (alg, key) {\n  Base.call(this, 'digest')\n  if (typeof key === 'string') {\n    key = Buffer.from(key)\n  }\n\n  this._alg = alg\n  this._key = key\n\n  if (key.length > blocksize) {\n    key = alg(key)\n  } else if (key.length < blocksize) {\n    key = Buffer.concat([key, ZEROS], blocksize)\n  }\n\n  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)\n  var opad = this._opad = Buffer.allocUnsafe(blocksize)\n\n  for (var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  this._hash = [ipad]\n}\n\ninherits(Hmac, Base)\n\nHmac.prototype._update = function (data) {\n  this._hash.push(data)\n}\n\nHmac.prototype._final = function () {\n  var h = this._alg(Buffer.concat(this._hash))\n  return this._alg(Buffer.concat([this._opad, h]))\n}\nmodule.exports = Hmac\n\n\n//# sourceURL=webpack:///./node_modules/create-hmac/legacy.js?");

/***/ }),

/***/ "./node_modules/merkle-lib/fastRoot.js":
/*!*********************************************!*\
  !*** ./node_modules/merkle-lib/fastRoot.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// constant-space merkle root calculation algorithm\nmodule.exports = function fastRoot (values, digestFn) {\n  if (!Array.isArray(values)) throw TypeError('Expected values Array')\n  if (typeof digestFn !== 'function') throw TypeError('Expected digest Function')\n\n  var length = values.length\n  var results = values.concat()\n\n  while (length > 1) {\n    var j = 0\n\n    for (var i = 0; i < length; i += 2, ++j) {\n      var left = results[i]\n      var right = i + 1 === length ? left : results[i + 1]\n      var data = Buffer.concat([left, right])\n\n      results[j] = digestFn(data)\n    }\n\n    length = j\n  }\n\n  return results[0]\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/merkle-lib/fastRoot.js?");

/***/ }),

/***/ "./node_modules/pushdata-bitcoin/index.js":
/*!************************************************!*\
  !*** ./node_modules/pushdata-bitcoin/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var OPS = __webpack_require__(/*! bitcoin-ops */ \"./node_modules/bitcoin-ops/index.json\")\n\nfunction encodingLength (i) {\n  return i < OPS.OP_PUSHDATA1 ? 1\n  : i <= 0xff ? 2\n  : i <= 0xffff ? 3\n  : 5\n}\n\nfunction encode (buffer, number, offset) {\n  var size = encodingLength(number)\n\n  // ~6 bit\n  if (size === 1) {\n    buffer.writeUInt8(number, offset)\n\n  // 8 bit\n  } else if (size === 2) {\n    buffer.writeUInt8(OPS.OP_PUSHDATA1, offset)\n    buffer.writeUInt8(number, offset + 1)\n\n  // 16 bit\n  } else if (size === 3) {\n    buffer.writeUInt8(OPS.OP_PUSHDATA2, offset)\n    buffer.writeUInt16LE(number, offset + 1)\n\n  // 32 bit\n  } else {\n    buffer.writeUInt8(OPS.OP_PUSHDATA4, offset)\n    buffer.writeUInt32LE(number, offset + 1)\n  }\n\n  return size\n}\n\nfunction decode (buffer, offset) {\n  var opcode = buffer.readUInt8(offset)\n  var number, size\n\n  // ~6 bit\n  if (opcode < OPS.OP_PUSHDATA1) {\n    number = opcode\n    size = 1\n\n  // 8 bit\n  } else if (opcode === OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null\n    number = buffer.readUInt8(offset + 1)\n    size = 2\n\n  // 16 bit\n  } else if (opcode === OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null\n    number = buffer.readUInt16LE(offset + 1)\n    size = 3\n\n  // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null\n    if (opcode !== OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode')\n\n    number = buffer.readUInt32LE(offset + 1)\n    size = 5\n  }\n\n  return {\n    opcode: opcode,\n    number: number,\n    size: size\n  }\n}\n\nmodule.exports = {\n  encodingLength: encodingLength,\n  encode: encode,\n  decode: decode\n}\n\n\n//# sourceURL=webpack:///./node_modules/pushdata-bitcoin/index.js?");

/***/ }),

/***/ "./node_modules/randombytes/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\n\n// limit of Crypto.getRandomValues()\n// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\nvar MAX_BYTES = 65536\n\n// Node supports requesting up to this number of bytes\n// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48\nvar MAX_UINT32 = 4294967295\n\nfunction oldBrowser () {\n  throw new Error('Secure random number generation is not supported by this browser.\\nUse Chrome, Firefox or Internet Explorer 11')\n}\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar crypto = global.crypto || global.msCrypto\n\nif (crypto && crypto.getRandomValues) {\n  module.exports = randomBytes\n} else {\n  module.exports = oldBrowser\n}\n\nfunction randomBytes (size, cb) {\n  // phantomjs needs to throw\n  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')\n\n  var bytes = Buffer.allocUnsafe(size)\n\n  if (size > 0) {  // getRandomValues fails on IE if size == 0\n    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues\n      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\n      for (var generated = 0; generated < size; generated += MAX_BYTES) {\n        // buffer.slice automatically checks if the end is past the end of\n        // the buffer so we don't have to here\n        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))\n      }\n    } else {\n      crypto.getRandomValues(bytes)\n    }\n  }\n\n  if (typeof cb === 'function') {\n    return process.nextTick(function () {\n      cb(null, bytes)\n    })\n  }\n\n  return bytes\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/randombytes/browser.js?");

/***/ }),

/***/ "./node_modules/tiny-secp256k1/js.js":
/*!*******************************************!*\
  !*** ./node_modules/tiny-secp256k1/js.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {const BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\")\nconst EC = __webpack_require__(/*! elliptic */ \"./node_modules/elliptic/lib/elliptic.js\").ec\nconst secp256k1 = new EC('secp256k1')\nconst deterministicGenerateK = __webpack_require__(/*! ./rfc6979 */ \"./node_modules/tiny-secp256k1/rfc6979.js\")\n\nconst ZERO32 = Buffer.alloc(32, 0)\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex')\nconst EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex')\n\nconst n = secp256k1.curve.n\nconst nDiv2 = n.shrn(1)\nconst G = secp256k1.curve.g\n\nconst THROW_BAD_PRIVATE = 'Expected Private'\nconst THROW_BAD_POINT = 'Expected Point'\nconst THROW_BAD_TWEAK = 'Expected Tweak'\nconst THROW_BAD_HASH = 'Expected Hash'\nconst THROW_BAD_SIGNATURE = 'Expected Signature'\nconst THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)'\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32\n}\n\nfunction isOrderScalar (x) {\n  if (!isScalar(x)) return false\n  return x.compare(EC_GROUP_ORDER) < 0 // < G\n}\n\nfunction isPoint (p) {\n  if (!Buffer.isBuffer(p)) return false\n  if (p.length < 33) return false\n\n  const t = p[0]\n  const x = p.slice(1, 33)\n  if (x.compare(ZERO32) === 0) return false\n  if (x.compare(EC_P) >= 0) return false\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    try { decodeFrom(p) } catch (e) { return false } // TODO: temporary\n    return true\n  }\n\n  const y = p.slice(33)\n  if (y.compare(ZERO32) === 0) return false\n  if (y.compare(EC_P) >= 0) return false\n  if (t === 0x04 && p.length === 65) return true\n  return false\n}\n\nfunction __isPointCompressed (p) {\n  return p[0] !== 0x04\n}\n\nfunction isPointCompressed (p) {\n  if (!isPoint(p)) return false\n  return __isPointCompressed(p)\n}\n\nfunction isPrivate (x) {\n  if (!isScalar(x)) return false\n  return x.compare(ZERO32) > 0 && // > 0\n    x.compare(EC_GROUP_ORDER) < 0 // < G\n}\n\nfunction isSignature (value) {\n  const r = value.slice(0, 32)\n  const s = value.slice(32, 64)\n  return Buffer.isBuffer(value) && value.length === 64 &&\n    r.compare(EC_GROUP_ORDER) < 0 &&\n    s.compare(EC_GROUP_ORDER) < 0\n}\n\nfunction assumeCompression (value, pubkey) {\n  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey)\n  if (value === undefined) return true\n  return value\n}\n\nfunction fromBuffer (d) { return new BN(d) }\nfunction toBuffer (d) { return d.toArrayLike(Buffer, 'be', 32) }\nfunction decodeFrom (P) { return secp256k1.curve.decodePoint(P) }\nfunction getEncoded (P, compressed) { return Buffer.from(P._encode(compressed)) }\n\nfunction pointAdd (pA, pB, __compressed) {\n  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT)\n  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT)\n\n  const a = decodeFrom(pA)\n  const b = decodeFrom(pB)\n  const pp = a.add(b)\n  if (pp.isInfinity()) return null\n\n  const compressed = assumeCompression(__compressed, pA)\n  return getEncoded(pp, compressed)\n}\n\nfunction pointAddScalar (p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const compressed = assumeCompression(__compressed, p)\n  const pp = decodeFrom(p)\n  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed)\n\n  const tt = fromBuffer(tweak)\n  const qq = G.mul(tt)\n  const uu = pp.add(qq)\n  if (uu.isInfinity()) return null\n\n  return getEncoded(uu, compressed)\n}\n\nfunction pointCompress (p, compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n\n  const pp = decodeFrom(p)\n  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT)\n\n  return getEncoded(pp, compressed)\n}\n\nfunction pointFromScalar (d, __compressed) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n\n  const dd = fromBuffer(d)\n  const pp = G.mul(dd)\n  if (pp.isInfinity()) return null\n\n  const compressed = assumeCompression(__compressed)\n  return getEncoded(pp, compressed)\n}\n\nfunction pointMultiply (p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const compressed = assumeCompression(__compressed, p)\n  const pp = decodeFrom(p)\n  const tt = fromBuffer(tweak)\n  const qq = pp.mul(tt)\n  if (qq.isInfinity()) return null\n\n  return getEncoded(qq, compressed)\n}\n\nfunction privateAdd (d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const dd = fromBuffer(d)\n  const tt = fromBuffer(tweak)\n  const dt = toBuffer(dd.add(tt).umod(n))\n  if (!isPrivate(dt)) return null\n\n  return dt\n}\n\nfunction privateSub (d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const dd = fromBuffer(d)\n  const tt = fromBuffer(tweak)\n  const dt = toBuffer(dd.sub(tt).umod(n))\n  if (!isPrivate(dt)) return null\n\n  return dt\n}\n\nfunction sign (hash, x) {\n  return __sign(hash, x)\n}\n\nfunction signWithEntropy (hash, x, addData) {\n  return __sign(hash, x, addData)\n}\n\nfunction __sign (hash, x, addData) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)\n  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA)\n\n  const d = fromBuffer(x)\n  const e = fromBuffer(hash)\n\n  let r, s\n  const checkSig = function (k) {\n    const kI = fromBuffer(k)\n    const Q = G.mul(kI)\n\n    if (Q.isInfinity()) return false\n\n    r = Q.x.umod(n)\n    if (r.isZero() === 0) return false\n\n    s = kI\n      .invm(n)\n      .mul(e.add(d.mul(r)))\n      .umod(n)\n    if (s.isZero() === 0) return false\n\n    return true\n  }\n\n  deterministicGenerateK(hash, x, checkSig, isPrivate, addData)\n\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.cmp(nDiv2) > 0) {\n    s = n.sub(s)\n  }\n\n  const buffer = Buffer.allocUnsafe(64)\n  toBuffer(r).copy(buffer, 0)\n  toBuffer(s).copy(buffer, 32)\n  return buffer\n}\n\nfunction verify (hash, q, signature) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)\n  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT)\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (1, isSignature enforces '< n - 1')\n  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE)\n\n  const Q = decodeFrom(q)\n  const r = fromBuffer(signature.slice(0, 32))\n  const s = fromBuffer(signature.slice(32, 64))\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (2, enforces '> 0')\n  if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false\n  if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false\n\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  const e = fromBuffer(hash)\n\n  // Compute s^-1\n  const sInv = s.invm(n)\n\n  // 1.4.4 Compute u1 = es^1 mod n\n  //               u2 = rs^1 mod n\n  const u1 = e.mul(sInv).umod(n)\n  const u2 = r.mul(sInv).umod(n)\n\n  // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n  const R = G.mulAdd(u1, Q, u2)\n\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (R.isInfinity()) return false\n\n  // 1.4.6 Convert the field element R.x to an integer\n  const xR = R.x\n\n  // 1.4.7 Set v = xR mod n\n  const v = xR.umod(n)\n\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.eq(r)\n}\n\nmodule.exports = {\n  isPoint,\n  isPointCompressed,\n  isPrivate,\n  pointAdd,\n  pointAddScalar,\n  pointCompress,\n  pointFromScalar,\n  pointMultiply,\n  privateAdd,\n  privateSub,\n  sign,\n  signWithEntropy,\n  verify\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/tiny-secp256k1/js.js?");

/***/ }),

/***/ "./node_modules/tiny-secp256k1/rfc6979.js":
/*!************************************************!*\
  !*** ./node_modules/tiny-secp256k1/rfc6979.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {const createHmac = __webpack_require__(/*! create-hmac */ \"./node_modules/create-hmac/browser.js\")\n\nconst ONE1 = Buffer.alloc(1, 1)\nconst ZERO1 = Buffer.alloc(1, 0)\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK (hash, x, checkSig, isPrivate, extraEntropy) {\n  // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n  let k = Buffer.alloc(32, 0)\n  let v = Buffer.alloc(32, 1)\n\n  // Step D\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ZERO1)\n    .update(x)\n    .update(hash)\n    .update(extraEntropy || '')\n    .digest()\n\n  // Step E\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step F\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ONE1)\n    .update(x)\n    .update(hash)\n    .update(extraEntropy || '')\n    .digest()\n\n  // Step G\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n  v = createHmac('sha256', k).update(v).digest()\n\n  let T = v\n\n  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n  while (!isPrivate(T) || !checkSig(T)) {\n    k = createHmac('sha256', k)\n      .update(v)\n      .update(ZERO1)\n      .digest()\n\n    v = createHmac('sha256', k).update(v).digest()\n\n    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n    v = createHmac('sha256', k).update(v).digest()\n    T = v\n  }\n\n  return T\n}\n\nmodule.exports = deterministicGenerateK\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/tiny-secp256k1/rfc6979.js?");

/***/ }),

/***/ "./node_modules/typeforce/errors.js":
/*!******************************************!*\
  !*** ./node_modules/typeforce/errors.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var native = __webpack_require__(/*! ./native */ \"./node_modules/typeforce/native.js\")\n\nfunction getTypeName (fn) {\n  return fn.name || fn.toString().match(/function (.*?)\\s*\\(/)[1]\n}\n\nfunction getValueTypeName (value) {\n  return native.Nil(value) ? '' : getTypeName(value.constructor)\n}\n\nfunction getValue (value) {\n  if (native.Function(value)) return ''\n  if (native.String(value)) return JSON.stringify(value)\n  if (value && native.Object(value)) return ''\n  return value\n}\n\nfunction captureStackTrace (e, t) {\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(e, t)\n  }\n}\n\nfunction tfJSON (type) {\n  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)\n  if (native.Array(type)) return 'Array'\n  if (type && native.Object(type)) return 'Object'\n\n  return type !== undefined ? type : ''\n}\n\nfunction tfErrorString (type, value, valueTypeName) {\n  var valueJson = getValue(value)\n\n  return 'Expected ' + tfJSON(type) + ', got' +\n    (valueTypeName !== '' ? ' ' + valueTypeName : '') +\n    (valueJson !== '' ? ' ' + valueJson : '')\n}\n\nfunction TfTypeError (type, value, valueTypeName) {\n  valueTypeName = valueTypeName || getValueTypeName(value)\n  this.message = tfErrorString(type, value, valueTypeName)\n\n  captureStackTrace(this, TfTypeError)\n  this.__type = type\n  this.__value = value\n  this.__valueTypeName = valueTypeName\n}\n\nTfTypeError.prototype = Object.create(Error.prototype)\nTfTypeError.prototype.constructor = TfTypeError\n\nfunction tfPropertyErrorString (type, label, name, value, valueTypeName) {\n  var description = '\" of type '\n  if (label === 'key') description = '\" with key type '\n\n  return tfErrorString('property \"' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)\n}\n\nfunction TfPropertyTypeError (type, property, label, value, valueTypeName) {\n  if (type) {\n    valueTypeName = valueTypeName || getValueTypeName(value)\n    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)\n  } else {\n    this.message = 'Unexpected property \"' + property + '\"'\n  }\n\n  captureStackTrace(this, TfTypeError)\n  this.__label = label\n  this.__property = property\n  this.__type = type\n  this.__value = value\n  this.__valueTypeName = valueTypeName\n}\n\nTfPropertyTypeError.prototype = Object.create(Error.prototype)\nTfPropertyTypeError.prototype.constructor = TfTypeError\n\nfunction tfCustomError (expected, actual) {\n  return new TfTypeError(expected, {}, actual)\n}\n\nfunction tfSubError (e, property, label) {\n  // sub child?\n  if (e instanceof TfPropertyTypeError) {\n    property = property + '.' + e.__property\n\n    e = new TfPropertyTypeError(\n      e.__type, property, e.__label, e.__value, e.__valueTypeName\n    )\n\n  // child?\n  } else if (e instanceof TfTypeError) {\n    e = new TfPropertyTypeError(\n      e.__type, property, label, e.__value, e.__valueTypeName\n    )\n  }\n\n  captureStackTrace(e)\n  return e\n}\n\nmodule.exports = {\n  TfTypeError: TfTypeError,\n  TfPropertyTypeError: TfPropertyTypeError,\n  tfCustomError: tfCustomError,\n  tfSubError: tfSubError,\n  tfJSON: tfJSON,\n  getValueTypeName: getValueTypeName\n}\n\n\n//# sourceURL=webpack:///./node_modules/typeforce/errors.js?");

/***/ }),

/***/ "./node_modules/typeforce/extra.js":
/*!*****************************************!*\
  !*** ./node_modules/typeforce/extra.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var NATIVE = __webpack_require__(/*! ./native */ \"./node_modules/typeforce/native.js\")\nvar ERRORS = __webpack_require__(/*! ./errors */ \"./node_modules/typeforce/errors.js\")\n\nfunction _Buffer (value) {\n  return Buffer.isBuffer(value)\n}\n\nfunction Hex (value) {\n  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)\n}\n\nfunction _LengthN (type, length) {\n  var name = type.toJSON()\n\n  function Length (value) {\n    if (!type(value)) return false\n    if (value.length === length) return true\n\n    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')\n  }\n  Length.toJSON = function () { return name }\n\n  return Length\n}\n\nvar _ArrayN = _LengthN.bind(null, NATIVE.Array)\nvar _BufferN = _LengthN.bind(null, _Buffer)\nvar _HexN = _LengthN.bind(null, Hex)\nvar _StringN = _LengthN.bind(null, NATIVE.String)\n\nfunction Range (a, b, f) {\n  f = f || NATIVE.Number\n  function _range (value, strict) {\n    return f(value, strict) && (value > a) && (value < b)\n  }\n  _range.toJSON = function () {\n    return `${f.toJSON()} between [${a}, ${b}]`\n  }\n  return _range\n}\n\nvar INT53_MAX = Math.pow(2, 53) - 1\n\nfunction Finite (value) {\n  return typeof value === 'number' && isFinite(value)\n}\nfunction Int8 (value) { return ((value << 24) >> 24) === value }\nfunction Int16 (value) { return ((value << 16) >> 16) === value }\nfunction Int32 (value) { return (value | 0) === value }\nfunction Int53 (value) {\n  return typeof value === 'number' &&\n    value >= -INT53_MAX &&\n    value <= INT53_MAX &&\n    Math.floor(value) === value\n}\nfunction UInt8 (value) { return (value & 0xff) === value }\nfunction UInt16 (value) { return (value & 0xffff) === value }\nfunction UInt32 (value) { return (value >>> 0) === value }\nfunction UInt53 (value) {\n  return typeof value === 'number' &&\n    value >= 0 &&\n    value <= INT53_MAX &&\n    Math.floor(value) === value\n}\n\nvar types = {\n  ArrayN: _ArrayN,\n  Buffer: _Buffer,\n  BufferN: _BufferN,\n  Finite: Finite,\n  Hex: Hex,\n  HexN: _HexN,\n  Int8: Int8,\n  Int16: Int16,\n  Int32: Int32,\n  Int53: Int53,\n  Range: Range,\n  StringN: _StringN,\n  UInt8: UInt8,\n  UInt16: UInt16,\n  UInt32: UInt32,\n  UInt53: UInt53\n}\n\nfor (var typeName in types) {\n  types[typeName].toJSON = function (t) {\n    return t\n  }.bind(null, typeName)\n}\n\nmodule.exports = types\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/typeforce/extra.js?");

/***/ }),

/***/ "./node_modules/typeforce/index.js":
/*!*****************************************!*\
  !*** ./node_modules/typeforce/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var ERRORS = __webpack_require__(/*! ./errors */ \"./node_modules/typeforce/errors.js\")\nvar NATIVE = __webpack_require__(/*! ./native */ \"./node_modules/typeforce/native.js\")\n\n// short-hand\nvar tfJSON = ERRORS.tfJSON\nvar TfTypeError = ERRORS.TfTypeError\nvar TfPropertyTypeError = ERRORS.TfPropertyTypeError\nvar tfSubError = ERRORS.tfSubError\nvar getValueTypeName = ERRORS.getValueTypeName\n\nvar TYPES = {\n  arrayOf: function arrayOf (type, options) {\n    type = compile(type)\n    options = options || {}\n\n    function _arrayOf (array, strict) {\n      if (!NATIVE.Array(array)) return false\n      if (NATIVE.Nil(array)) return false\n      if (options.minLength !== undefined && array.length < options.minLength) return false\n      if (options.maxLength !== undefined && array.length > options.maxLength) return false\n      if (options.length !== undefined && array.length !== options.length) return false\n\n      return array.every(function (value, i) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _arrayOf.toJSON = function () {\n      var str = '[' + tfJSON(type) + ']'\n      if (options.length !== undefined) {\n        str += '{' + options.length + '}'\n      } else if (options.minLength !== undefined || options.maxLength !== undefined) {\n        str += '{' +\n          (options.minLength === undefined ? 0 : options.minLength) + ',' +\n          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'\n      }\n      return str\n    }\n\n    return _arrayOf\n  },\n\n  maybe: function maybe (type) {\n    type = compile(type)\n\n    function _maybe (value, strict) {\n      return NATIVE.Nil(value) || type(value, strict, maybe)\n    }\n    _maybe.toJSON = function () { return '?' + tfJSON(type) }\n\n    return _maybe\n  },\n\n  map: function map (propertyType, propertyKeyType) {\n    propertyType = compile(propertyType)\n    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)\n\n    function _map (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      for (var propertyName in value) {\n        try {\n          if (propertyKeyType) {\n            typeforce(propertyKeyType, propertyName, strict)\n          }\n        } catch (e) {\n          throw tfSubError(e, propertyName, 'key')\n        }\n\n        try {\n          var propertyValue = value[propertyName]\n          typeforce(propertyType, propertyValue, strict)\n        } catch (e) {\n          throw tfSubError(e, propertyName)\n        }\n      }\n\n      return true\n    }\n\n    if (propertyKeyType) {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'\n      }\n    } else {\n      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }\n    }\n\n    return _map\n  },\n\n  object: function object (uncompiled) {\n    var type = {}\n\n    for (var typePropertyName in uncompiled) {\n      type[typePropertyName] = compile(uncompiled[typePropertyName])\n    }\n\n    function _object (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      var propertyName\n\n      try {\n        for (propertyName in type) {\n          var propertyType = type[propertyName]\n          var propertyValue = value[propertyName]\n\n          typeforce(propertyType, propertyValue, strict)\n        }\n      } catch (e) {\n        throw tfSubError(e, propertyName)\n      }\n\n      if (strict) {\n        for (propertyName in value) {\n          if (type[propertyName]) continue\n\n          throw new TfPropertyTypeError(undefined, propertyName)\n        }\n      }\n\n      return true\n    }\n    _object.toJSON = function () { return tfJSON(type) }\n\n    return _object\n  },\n\n  anyOf: function anyOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _anyOf (value, strict) {\n      return types.some(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }\n\n    return _anyOf\n  },\n\n  allOf: function allOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _allOf (value, strict) {\n      return types.every(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }\n\n    return _allOf\n  },\n\n  quacksLike: function quacksLike (type) {\n    function _quacksLike (value) {\n      return type === getValueTypeName(value)\n    }\n    _quacksLike.toJSON = function () { return type }\n\n    return _quacksLike\n  },\n\n  tuple: function tuple () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _tuple (values, strict) {\n      if (NATIVE.Nil(values)) return false\n      if (NATIVE.Nil(values.length)) return false\n      if (strict && (values.length !== types.length)) return false\n\n      return types.every(function (type, i) {\n        try {\n          return typeforce(type, values[i], strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }\n\n    return _tuple\n  },\n\n  value: function value (expected) {\n    function _value (actual) {\n      return actual === expected\n    }\n    _value.toJSON = function () { return expected }\n\n    return _value\n  }\n}\n\n// TODO: deprecate\nTYPES.oneOf = TYPES.anyOf\n\nfunction compile (type) {\n  if (NATIVE.String(type)) {\n    if (type[0] === '?') return TYPES.maybe(type.slice(1))\n\n    return NATIVE[type] || TYPES.quacksLike(type)\n  } else if (type && NATIVE.Object(type)) {\n    if (NATIVE.Array(type)) {\n      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')\n      return TYPES.arrayOf(type[0])\n    }\n\n    return TYPES.object(type)\n  } else if (NATIVE.Function(type)) {\n    return type\n  }\n\n  return TYPES.value(type)\n}\n\nfunction typeforce (type, value, strict, surrogate) {\n  if (NATIVE.Function(type)) {\n    if (type(value, strict)) return true\n\n    throw new TfTypeError(surrogate || type, value)\n  }\n\n  // JIT\n  return typeforce(compile(type), value, strict)\n}\n\n// assign types to typeforce function\nfor (var typeName in NATIVE) {\n  typeforce[typeName] = NATIVE[typeName]\n}\n\nfor (typeName in TYPES) {\n  typeforce[typeName] = TYPES[typeName]\n}\n\nvar EXTRA = __webpack_require__(/*! ./extra */ \"./node_modules/typeforce/extra.js\")\nfor (typeName in EXTRA) {\n  typeforce[typeName] = EXTRA[typeName]\n}\n\ntypeforce.compile = compile\ntypeforce.TfTypeError = TfTypeError\ntypeforce.TfPropertyTypeError = TfPropertyTypeError\n\nmodule.exports = typeforce\n\n\n//# sourceURL=webpack:///./node_modules/typeforce/index.js?");

/***/ }),

/***/ "./node_modules/typeforce/native.js":
/*!******************************************!*\
  !*** ./node_modules/typeforce/native.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var types = {\n  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },\n  Boolean: function (value) { return typeof value === 'boolean' },\n  Function: function (value) { return typeof value === 'function' },\n  Nil: function (value) { return value === undefined || value === null },\n  Number: function (value) { return typeof value === 'number' },\n  Object: function (value) { return typeof value === 'object' },\n  String: function (value) { return typeof value === 'string' },\n  '': function () { return true }\n}\n\n// TODO: deprecate\ntypes.Null = types.Nil\n\nfor (var typeName in types) {\n  types[typeName].toJSON = function (t) {\n    return t\n  }.bind(null, typeName)\n}\n\nmodule.exports = types\n\n\n//# sourceURL=webpack:///./node_modules/typeforce/native.js?");

/***/ }),

/***/ "./node_modules/wif/index.js":
/*!***********************************!*\
  !*** ./node_modules/wif/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var bs58check = __webpack_require__(/*! bs58check */ \"./node_modules/bs58check/index.js\")\n\nfunction decodeRaw (buffer, version) {\n  // check version only if defined\n  if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version')\n\n  // uncompressed\n  if (buffer.length === 33) {\n    return {\n      version: buffer[0],\n      privateKey: buffer.slice(1, 33),\n      compressed: false\n    }\n  }\n\n  // invalid length\n  if (buffer.length !== 34) throw new Error('Invalid WIF length')\n\n  // invalid compression flag\n  if (buffer[33] !== 0x01) throw new Error('Invalid compression flag')\n\n  return {\n    version: buffer[0],\n    privateKey: buffer.slice(1, 33),\n    compressed: true\n  }\n}\n\nfunction encodeRaw (version, privateKey, compressed) {\n  var result = new Buffer(compressed ? 34 : 33)\n\n  result.writeUInt8(version, 0)\n  privateKey.copy(result, 1)\n\n  if (compressed) {\n    result[33] = 0x01\n  }\n\n  return result\n}\n\nfunction decode (string, version) {\n  return decodeRaw(bs58check.decode(string), version)\n}\n\nfunction encode (version, privateKey, compressed) {\n  if (typeof version === 'number') return bs58check.encode(encodeRaw(version, privateKey, compressed))\n\n  return bs58check.encode(\n    encodeRaw(\n      version.version,\n      version.privateKey,\n      version.compressed\n    )\n  )\n}\n\nmodule.exports = {\n  decode: decode,\n  decodeRaw: decodeRaw,\n  encode: encode,\n  encodeRaw: encodeRaw\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/wif/index.js?");

/***/ })

}]);