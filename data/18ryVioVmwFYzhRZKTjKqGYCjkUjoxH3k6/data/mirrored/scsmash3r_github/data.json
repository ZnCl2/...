{"cert_user_id": "scsmash3r@github", "next_comment_id": 7, "comment": {"1604066638_mirrored_slrslr_github": [{"comment_id": 1, "body": "Having the same issue, so bumping up this topic with the question: what are the `*.piecemap.msgpack` files and why don't they delete with the parent (big) file?", "added": 1603737599, "modified": 1603737599, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/1485#issuecomment-716839187", "source_type": "github"}], "1604068030_mirrored_scsmash3r_github": [{"comment_id": 2, "body": "> It looks like I've written the patch but haven't submitted it. Please check if the patch in #2631 works for you, hopefully it'll get merged soon.\r\n\r\nYup, it works! Now to wait until it is applied. For now I can use fallback to my old method (one by one), if client's ZN version is lower than v. with applied patch, I think.", "added": 1601924635, "modified": 1601924635, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2630#issuecomment-703913794", "source_type": "github"}], "1604068131_mirrored_imachug_github": [{"comment_id": 3, "body": "> This is great but I would like to see an example why one site need stuff from a bunch of others.\r\n> It is maybe useful when you want a voluntary search engine.\r\n> \r\n> What if I have a font on one site and use the CORS plugin to grab that font and use it on all other sites?\r\n> Than I need to allow them one by one? This makes no sense.\r\n> \r\n> The plugin should have some list where you can add permissions on the bases of both incoming and outgoing.\r\n\r\nYou got it just right: for the search purposes. For now the early alpha looks like this:\r\n![image](https://user-images.githubusercontent.com/4781532/95249247-112c7000-0821-11eb-9389-ff522d20d4a2.png)\r\n\r\nFor each entity there is a CORS requests needed to be done to a bunch of zites, from which the info will be pulled.\r\nRegarding the font grabbing question: I think, it is not what CORS should be used for. You can shift the responsibility of getting the content on a client's side, but that will create an additional unnecessary step from user's side: he will need to allow the downloading of a content.\r\n\r\nInstead, you should use [as](https://zeronet.io/docs/site_development/zeroframe_api_reference/#as) cmd to do that - and this action implies that you're the owner of the zite with a font, so you are able to actually make a request and get the content.\r\n\r\n>The plugin should have some list where you can add permissions on the bases of both incoming and outgoing.\r\n\r\nThis is a good one point. When client allowed some CORS request to be made to another zite, the CORS plugin basically makes a copy of that zite with a reachable virtual directory with `cors-` prefix. I admit it would be a nice additional feature for the plugin itself to show what zite requested what other zite's contents - and to be able to 'untie' (undo the cors action) for the specific zite, if needed.", "added": 1602001374, "modified": 1602001374, "source_link": "https://github.com/HelloZeroNet/ZeroNet/pull/2631#issuecomment-704501704", "source_type": "github"}, {"comment_id": 4, "body": "> It was easy to guess that you are working on a search engine.\r\n> \r\n> Regarding the font example, CORS is built exactly for the reason I described above. 1FoNTaJHcUk1JkrcUJXxTVYTchxuhSHfp should allow hundreds of sites to load its resources.\r\n\r\n\r\n\r\n> 1FoNTaJHcUk1JkrcUJXxTVYTchxuhSHfp\r\n\r\nUnfortunately, there are no peers found on that zite. But I'll take that into consideration.\r\nFor my point of view, it is better for user interaction to NOT to ask a permission on whether to load or not to load particular font resource. If your zite is using some custom font, just serve it with zite's _own_ CSS and other _own_ resources. User will download it, and the font/resource will be 'just there, instantly used', without asking for permissions.\r\n\r\nThe possible backfire would be the content duplication... But still, if it comes to content serving, for me it is better to serve the files from your own folder - and you will be sure they are served. Rather than to hope that some another zite has peers and reachable at the moment (not saying about critical resources, that just need to be there)...\r\n\r\nAll in all, the stuff you're described, comes down to simple thing: the **control** on the client's side for what should be downloaded (CORS request with permission granted manually, by user).\r\n\r\n**Personal thoughts on CORS stuff**\r\nI'd like to see an auto-cors _(and this can be added as an option in plugin itself, if possible)_, but with manual possibility of switching that off. What I mean by saying 'auto-cors' is something like this:\r\n\r\n1) For now, CorsPlugin is triggering a request, that needs to be solved manually by user. That means each visitor should allow each zite, so the currently visited zite could access the contents of another zite by copying its contents into visitor's data.\r\n2) Visitor grants permission -> zite is copied -> zite and all of its files are accessible for the visitor by virtual path.\r\n\r\nHow would auto-cors work:\r\n\r\n1) Visitor enters the zite -> while checking for peers and content.json (preloading page with red-squared loader), there is also a process of corsed zites downloading shown -> when finished, site loads fully, where all the corsed zites' files are already available for getting/quering by virtual path.\r\n2) Visitor then can remove any cors dependencies, but here I don't really know how it will work out in a real use cases. This can lead to a situation when the visited zite won't work at all, cause it tightly relies on other's zite files - and this should not happen, imo.\r\n\r\nI suppose there is pretty low chances to make it happen, because it implies some automation - and that implies less control from client's side. But it would be much easier for the content to dissiminate and for the UX/UI to have lesser manual steps to do.", "added": 1602005711, "modified": 1602005711, "source_link": "https://github.com/HelloZeroNet/ZeroNet/pull/2631#issuecomment-704537697", "source_type": "github"}], "1604068148_mirrored_imachug_github": [{"comment_id": 5, "body": "> @imachug rage\r\n> @HelloZeroNet @shortcutme point_down\r\n> \r\n> Should never load a goddamn thing from clearnet. This is totally against the purposes of the network.\r\n> \r\n> **Clearnet stuff can disappear or change to bad and than you site will have a meltdown.**\r\n> \r\n> I'm against anything which is on clearnet. **ZeroNet is a refuge** not a place to invite the **Interpol** and other agencies.\r\n> \r\n> Lastly, any attempt to make **connections to clearnet should be avoided in order to preserve anonymity**. Even if you use Tor with ZeroNet cloudflare or any other American captcha protected \"service\" (which mainly makes profit on selling personal data) would seriously make your life very difficult. They, **all blocking Tor**. Maintaining anonymity with clearnet requests from ZeroNet for any purpose is irresponsible, dangerous and many people would end up in jail!\r\n\r\nYou downloaded ZeroNet client from clearnet, and you're now posting comments on GitHub, being on clearnet. Yet, you're against resource loading from clearnet. I think it is a good thing to allow to communicate with resources from all over the places on the net (zeronet to clearnet resource request). But it should be a matter of choice for any particular user: it is up to them to allow or to block such requests.\r\n\r\nI think, such requests should be blocked by default, and only allowed per zite (if the zite depends on clearnet resource and want to request it) by the client, who is visiting the zite. \r\n\r\nFor now, requesting clearnet libraries or chunks of data is a great aid for data to spread, cause inside ZN network itself, in its current state, there often can be 0 peers. With initially blocked access to outer resources, more and more devs will count that moment and will try to migrate their resources fully into ZN network instead just linking them directly (cause it may not work).", "added": 1602786683, "modified": 1602786683, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2643#issuecomment-709601882", "source_type": "github"}], "1604068055_mirrored_gukandrew_github": [{"comment_id": 6, "body": "@gukandrew Not regarding the topic and discussion about the actual subject, but I think that this Jabba person is just an ordinary troll, whose aim is to insult other people and to enjoy his self-affirmation (I was insulted by him too). Just ignore him and report the tech stuff.", "added": 1603806197, "modified": 1603806197, "source_link": "https://github.com/HelloZeroNet/ZeroNet/pull/2652#issuecomment-717374285", "source_type": "github"}]}, "next_topic_id": 3, "topic": [{"topic_id": 1604068023, "title": "[CorsPlugin] Internal error: AttributeError: 'NoneType' object has no attribute 'replace'", "body": "### Step 1: Please describe your environment\r\n\r\n  * ZeroNet version: 0.7.1 r4206, Python 3.7.3\r\n  * Operating system: Ubuntu 18.04.5 LTS\r\n  * Web browser: FF 81.0\r\n  * Tor status: always\r\n  * Opened port: yes\r\n\r\n### Step 2: Describe the problem:\r\n\r\nWhile doing `cmd` for `corsPermission` on certain zites, wrapper notification error is shown with message:\r\n```\r\nInternal error: AttributeError: 'NoneType' object has no attribute 'replace'\r\nUiWebsocket.py line 79 > UiWebsocket.py line 234 > Cors/CorsPlugin.py line 90 > __init__.py line 19\r\n```\r\n \r\n#### Steps to reproduce:\r\n\r\n  1. Clone new default zite template.\r\n  2. Make sure `Cors` plugin is enabled (it should be enabled by default)\r\n  3. Do: `ZeroFrame.cmd(\"corsPermission\", \"17a8dbHs6vTp2HcSgocUe3QKaXMJz9YkD4\")`\r\n\r\n#### Observed/Expected Results:\r\n\r\nResult is observed while at `localhost` with 0 active peers, and zite was published only for yourself (but I doubt it matters).\r\nWhile most of `corsPermission` requests are working as expected, some of them throwing an error described above.\r\n\r\nI am trying to implement some kind of search between pretty big list of zites. Each zite, in order to be available for reading its files, needs to be requested with a cors permission. For tests, I went with popular zites addresses (and they were already on my local machine) and some unpopular ones, from [ZeroNet domain name registry](http://127.0.0.1:43110/1Name2NXVi1RDPDgf5617UoW7xA6YrhM9F/).\r\n\r\nI.e. there are three addresses on the list<sup>1</sup>:\r\n```\r\nkin.bloc.bit | 1Ako7M79KEGSdntHD53ycnRmUuzhyNxuuM\r\ntest.bloc.bit | 17a8dbHs6vTp2HcSgocUe3QKaXMJz9YkD4\r\nblocbit.bit | 12PdTeR8FagmHbysqnViPxYAEXXpvUy2SA\r\n```\r\n\r\nWhile `corsPermission` command fires just fine with first or last address in the list<sup>1</sup>, it fails to fire with this one: `17a8dbHs6vTp2HcSgocUe3QKaXMJz9YkD4`.", "parent_topic_uri": "1604062980_users_1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di", "added": 1601634961, "modified": 1601985241, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2625", "source_type": "github"}, {"topic_id": 1604068030, "title": "[CorsPlugin] Multicors: is it possible?", "body": "Currently, there is a [CorsPlugin](https://github.com/HelloZeroNet/ZeroNet/blob/py3/plugins/Cors/CorsPlugin.py), which allows you to use a `cmd` for granting cross-site access. As far as I can see, it works this way:\r\n\r\n1) You request for access by doing `page.cmd(\"corsPermission\", ziteAddress)`\r\n2) `wrapperConfirm` is fired to confirm Cors request, where user can \"Grant&add\" (if zite was not downloaded locally yet), \"Grant\" (if zite exists in local data) or user can close the wrapper toast.\r\n3) Zite is copied to your local data (or permission is granted, if already there)\r\n4) You then have an option to reach `\"inner_path\"` (directory/file) with `cors-` prefix to work with other zite's contents.\r\n\r\nThe inconvenient part comes up when you have a bunch of zites to grant cors to. \r\nI.e. if I have 20 or more zites to be cors'ed, I will need to do something like:\r\n\r\n```js\r\nfor (let key in zitesList) {\r\n  page.cmd(\"corsPermission\", zitesList[key]);\r\n}\r\n```\r\n\r\nBut it will fire up only 2 active toast messages at a time (two last ones) - other messages will disappear.\r\nI've came up with a workaround, relying on promises:\r\n\r\n```js\r\n// Sends a cmdp, waits for resolving and then self-calls this func again without queued element\r\n  getCorsPermissionsOneByOne(zitesList = ['zite1', 'zite2', ... , 'zite20']) {\r\n    console.info(\"Waiting for \" + zitesList[0]);\r\n    page.cmdp(\"corsPermission\", zitesList[0]).then(\r\n      (resolve) => {\r\n        inactiveZites.splice(0, 1);\r\n        if (inactiveZites.length !== 0) this.getCorsPermissionsOneByOne(zitesList);\r\n      }\r\n    );\r\n  }\r\n```\r\n\r\nWhile this works as I need to, the user still will need to click \"Grant&add\" button 20 or more times. \r\n\r\n**The solution I would like to see**\r\nWould it be possible to add some sort of multiple cors request to a bunch of zites in one call? I.e., you can pass an array of zites in arg `page.cmdp(\"corsPermission\", arg)`, and user will be alerted with just one toast message with something like: \"This site requests read permission to **20 sites**\" (where **20 sites** could be a link -> when clicked, slides down the div with all the addresses to see).\r\n\r\n_The main aim for me is to make it easier for user to grant cors for a bunch of resources. From the point of UI/UX, it is better for user to click just once to grant required permissions instead of clicking them one by one for a (possible) long period of time._\r\n\r\nMisc questions: what possible pitfalls can there be? How will it download/hang some of unreachable zites and how to track their downloading/copying process?", "parent_topic_uri": "1604062980_users_1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di", "added": 1601912615, "modified": 1602489641, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2630", "source_type": "github"}]}