{"cert_user_id": "unrealwill@github", "next_topic_id": 2, "topic": [{"topic_id": 1604064925, "title": "Can you clarify how Same Origin Policy applies ?", "body": "Usually the security model of most site is heavily relying on browser same origin policy protection mechanism. It seems that from the viewpoint of the browser every site is served locally. What mechanism do you have to prevent XSS vulnerabilities ?\n", "parent_topic_uri": "1604062980_users_1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di", "added": 1441617391, "modified": 1535061870, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/157", "source_type": "github"}], "next_comment_id": 10, "comment": {"1604064925_mirrored_unrealwill_github": [{"comment_id": 1, "body": "I believe this is not good enough. \nSandboxed iframe can be escaped from when you allow top-navigation with simple frame busting. (We can there try to attack the local webserver to compromise the host if there are security holes in the webserver but this is not the point I want to make here).\n\nAs same origin policy is not guaranteed because everything is served locally, the only remaining protection is the \"referer\" filtering when wrapper=False. But if you create a popup window to another zeronet site (without wrapper=False), the referer is not checked and from the viewpoint of the browser it is from the same origin so you can freely inject and access html code of this new window. The \"referer\" of this new page is the new site, so we can use this popup window as a trampoline to send request to the wrapper=False page to get the inner Frame). \nWhich means it can steal anything the user could type on another zeronet site. Exfiltrating the infos can then easily be done by a get image request to an evil server.\n\nBelow is a working proof of concept. Correct the missing \"<>\" and serve the file using zeronet. It works (not always on the first try but then always) on firefox and chrome when popups are not blocked. It should display the html code of another site. (But we could also reinject our own code in the other site)\n\nhtml\nhead\n/head\nbody\ndiv id=\"myDiv\">mydiv\n/div\n\nSCRIPT language=\"javascript\"\n//frame busting\nif(top != self) top.location.replace(location);\nvar novoForm = window.open(\"/1AvF5TpcaamRNtqvN1cnDEWzNmUtD47Npg/index.html\", \"wFormx\", \"width=1 height=1\");\nvar id = setTimeout(  function(){document.getElementById(\"myDiv\").textContent=novoForm.document.documentElement.outerHTML;novoForm.close()}, 1000);\n/SCRIPT\n/body\n/html\n", "added": 1441657128, "modified": 1441657128, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/157#issuecomment-138392127", "source_type": "github"}, {"comment_id": 2, "body": "Your idea of adding one-time keys might work but one time-keys and \"nonces\" don't usually work well with browsers (they are not user friendly because of history navigation, reload, caching behaviors,inner iframes, ajax? ). It also introduces complex filtering code server side which should ideally be as small as possible to prevent critical vulnerabilities.\nIt would also be hard to prevent JavaScript to obtain some one-time keys because you can't really tell for sure whether it is some JavaScript script or the user interacting with you (the \"referer\" filtering hack is just a hack that is subject to future browser change, normally it shouldn't be relied upon (The referer rfc spec isn't properly defined, (the reasoning behind is because this is set from client side so it could be anything so we can't rely on it for security purposes so we don't care about precise browser spec as it isn't a security feature) ).  \n\nI don't believe there are clean fixes without profound changes but I'm not a web expert. Sure you can find workarounds but relying on browser quirks (subdomain on localhost??(which may work with SOP) ). It's basically doing security with javascript in the browser. \nServing from localhost is also a bad idea because it opens security flaws because the local host network interface is kind of special. So it may be listened to by other processes running on the machine.\n\nCurrent browsers are not made for a decentralized web, and rfc are not going this way. Serving everything from local means the user preference like allow popups, always allow **\\* for 127.0.0.1, (always allow access to camera and mic ? and other nasty html5 features) propagate between zeronet sites. The attack surface, once you open javascript, anonymity (no dns central authority to blacklist sites), local server (with eventual open ports) is huge. Combine this with a bad updating procedure (no autoupdate or served centrally) in case of bugs and this is a recipe for disaster. (What about key revocation GPG style?)\n\nThe main reason people use \"browsers\", is to not have to trust any website, but only have to trust their browser to keep them safe. People already need to trust you (or use sandboxes which btw you should recommend your users to use) to run your server locally so they could instead trust you for running a custom browser (which will give you more control not depending on browser interaction hell). \n\nThe clean solution, I fear but I may be wrong, is to implement your custom browser (the same choice Tor made), (or forbid JavaScript but this is ZeroNet main feature). This is not as hard as it seems to be, because you can leverage on many open source browsers, but it is hard nevertheless specially when you allow JavaScript. \n", "added": 1441695762, "modified": 1441695762, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/157#issuecomment-138501976", "source_type": "github"}, {"comment_id": 3, "body": "I personally feel that the custom DNS server (although would work) is a bad solution. It is not user friendly at all and if there is a hiccup you got yourself with an angry user without internet to get help from.\nIt messes up with the whole system of the user and thus require the user to sudo your custom dns server. \n\nProxying is also hard to configure for the user (browser dependent -> no automated scripts) and persist after browser closing which means at next reboot when the custom http proxy is not running one user out of two won't be able to reset the proxy configuration to connect back online. \n\nSo what usually happens is that quickly, some random internet hacker surf your hype and tell the users they can avoid the configuration issues by connecting through his \"custom proxy\", and one user out of two get MIMed.\n\nImplementing a custom DNS server is hard. Configuring it is nightmarish (because you may need to open and configure the dns ports on your routers) (forwarding the request on is not as easy because once you change your dns settings to a custom one(yours) you can't do dns requests the normal way, so you must implement full DNS protocol). \n\nIt kinds of defeat the point of building a decentralized internet if you got back to relying on the authoritative DNS servers.\n\nDNS itself presents lots of vulnerabilities and that's why there should be DNSSEC but it didn't really catch.\n\nThis will also be instantly categorized as 'virus' by any windows antivirus.\n\nIt opens a whole range of other attacks with even worse consequences. Bad cases scenario may result in transparent MIM of any website (and not only zeronet websites).\n\nDidn't I mention that when you start messing with DNS protocol, ISP really don't like it at all and are very prompt to blacklist you. (Personal anecdote here : I once wrote a web crawler so I had configured my own bind9 cache for host names and everything worked fine until I downloaded an unrelated github project which silently messed up my configuration (it resetted my DNS to default instead of my bind9 server) The next time I crawled, my ISP suspended me for a day ;) .)\n\nWe also have an unusual behavior here  for example : When you got a request for an non-existing \".bit\" address the customdns can't say anything regarding whether the domain is valid or not (where as normally it should) (only your zeronet local server has this info), so it must tell you this domain is valid (in fact it may not be) and route you to localhost. (An attacker could for example try to use up your ram by filling up the customdns tables with random invalid .bit names which would then be cached because they are in fact valid (then your customdns process crash and you got yourself with an angry user without internet)).\n", "added": 1441742981, "modified": 1441743730, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/157#issuecomment-138727784", "source_type": "github"}, {"comment_id": 4, "body": "Glad there is an update mechanism. Those are usually tricky to do correctly and usually are a security risk. I may give it a look if when I have some time to spare.\n\nI quickly look at it but the quick fix looks like security done client side in javascript (and as a malicious js script we are the client). \nWouldn't (I didn't try) it be totally bypassed by:\n\nvar myWindow = window.open(thetargetWebsiteAddressToObtainCorrectReferrer, \"MsgWindow\", \"width=200, height=100\");\n//actually we don't care about anything the server send us back just that we can trick the browser to send the correct referrer \nmyWindow.document.write(\"you write any script here to trampoline with a correct referrer so we can grap the wrapper=False document\");\n//If this doesn't work we can try to access the html before the scripts in it gets executed with a tight setInterval loop we may (depending on browser) get lucky.\n\nIt also doesn't solve the user preference by domain that propagate for all zeronet sites (always do **\\* for 127.0.0.1:xxx (see previous message) ) problem.\n\nBy twiddling you may succeed in having a secure solution but it's going to be hard to convince this is really solid (the same kind of difference there are between white list and black list security). There is a sword of Damocles that hangs over this issue, and it's not a comfortable position to be in.\n", "added": 1441784014, "modified": 1441784337, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/157#issuecomment-138867992", "source_type": "github"}, {"comment_id": 5, "body": "I haven't tested the below idea but I still think the fix doesn't do what it's intending to do : \nFor example if we open a popup (for referer filtering bypassing) we then add in it a sandboxed iframe with the no-script attribute which loads your wrapper frame so it won't execute the script but load the wrapper DOM. Your safety client side javascript security measures (frame busting and opener check) don't get called (so no document.write) and because we are on Same Origin, parent can access iframe content. \nYou may also try with some popup.onload or popup.document.ready (jquery) to access the DOM of the wrapper before it's overwritten by the document.write.\nI am quite confident creative minds could find other ways in.\n", "added": 1441825795, "modified": 1441825795, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/157#issuecomment-139059658", "source_type": "github"}, {"comment_id": 6, "body": "You are getting the spirit of it, and that's what matter :). \nSecurity is all about identifying simple principles with strong security guarantees, and build upon them.  \"Security measures client side are not reliable\" is one of these principles. \n\"SOP\" is one of these cornerstone principles in browsing security (that's why relaxing this assumption is hard).\n\"The user will do stupid things if he can\" is another famous one.\n\"There is no such thing as a secure system\" principle allows us to sleep at night.\n", "added": 1441865709, "modified": 1441865709, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/157#issuecomment-139178384", "source_type": "github"}, {"comment_id": 7, "body": "I haven't tried your nonce-based security. Those are quite tricky to get right. In part because it's all relying on some pseudo random number generator (see below), and also because it's hard to tell user from script apart so it will be hard to convince you secure all possible pathways in, and even if you manage to get it safe it will also be hard to be convince that a browser new feature won't later break your security. \n\nBut a quick look at the source of your fix reveal that in it's current form it's weak. \nwrapper_nonce = ''.join(\n            random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(24)\n        )\n\nAt least use some one-way hash function. Because here you are handling a sequence of 24 remainders generated by a weak (low entropy congruential?) rng. So your are basically handling (Chinese remainder theorem trick? or brute force) the state of the generator if we can get any nonce (even a past one). And with the state of the rng we can predict any future nonces. Random number generator attacks is a whole non-trivial area in computer security (how to seed them properly? how to prevent the state to leak?(->one-way crypto hash)).\n", "added": 1441955102, "modified": 1441955102, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/157#issuecomment-139505606", "source_type": "github"}, {"comment_id": 8, "body": "About the random number generator you get the spirit. \nAbout modifying the HOST file, I wouldn't recommend it either mainly for the sudo requirements, and the fact that modifying the HOST file is a trick usually spywares and viruses like to do, so any decent antivirus (who uses those anyway?) should classify you as malware. I also don't know how often the HOST file is reloaded after modification. And there is also the issue you raise. \nModifying domain (either with dns or HOST file) isn't also a solution because dns may be bypassed by directly specifying the ipaddress (127.0.0.1 (but then you have your 'referer filtering' which may save you)).\n\nI haven't tested your nonce based implementation but normally usually it shouldn't be compatible with all navigation features (Like things with multiple open new-tabs, open in new window, navigation after a history.back move, and so on...)(as it has introduce a \"state\" into what's usually built upon the stateless http procotol) (And this will usually leave the user think, the software doesn't work, or worse he may think it's not safe). \n", "added": 1442133098, "modified": 1442133098, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/157#issuecomment-139862426", "source_type": "github"}], "1604064956_mirrored_risoul_github": [{"comment_id": 9, "body": "@risoul  : Sort of a decentralized \"commentanything.com\" upon zeronet ?\n", "added": 1444466594, "modified": 1444466594, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/180#issuecomment-147078255", "source_type": "github"}]}}