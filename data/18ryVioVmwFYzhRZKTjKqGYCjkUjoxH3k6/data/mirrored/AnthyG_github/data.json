{"cert_user_id": "AnthyG@github", "next_comment_id": 13, "comment": {"1604065379_mirrored_mcl1234_github": [{"comment_id": 1, "body": "[ThunderWave](https://github.com/AnthyG/ThunderWave) has public chat (based on ZeroChat), and private chat (based on ZeroMail, but more secure), and I'll be adding group chat ASAP!", "added": 1512245258, "modified": 1512245258, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/509#issuecomment-348726937", "source_type": "github"}], "1604066004_mirrored_nametoolong_github": [{"comment_id": 2, "body": "I know, this is closed, but don't service workers need https anyways?!\n\nPS.: This can be achieved through visiting zeronet via _localhost_ instead of _127.0.0.1_ (at least as far as I remember (at least in chrome)). ", "added": 1499572189, "modified": 1499573216, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/1010#issuecomment-313902737", "source_type": "github"}, {"comment_id": 3, "body": "@HelloZeroNet Ah wow, I did so much research on workers, but till now, I didn't quite understand the differences \ud83d\ude05", "added": 1499574354, "modified": 1499574354, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/1010#issuecomment-313904111", "source_type": "github"}], "1604066044_mirrored_1443_github": [{"comment_id": 4, "body": "This rather seems to be a CORS-related issue, as I'm getting this error: `XMLHttpRequest cannot load http://127.0.0.1:43110/eris.bit/data/usa.json. Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'null' is therefore not allowed access.`", "added": 1500873615, "modified": 1500873615, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/1041#issuecomment-317352085", "source_type": "github"}], "1604066073_mirrored_krixano_github": [{"comment_id": 5, "body": "Implementing a Service-worker could also provide _real_ offline access for zites, as the ZeroNet-client wouldn't need to run.\r\n\r\nBut it's kind of a bad thing if the Service-worker would cache all the stuff _again_ in the browser.\r\n\r\nAnd AFAIK, the PWA-function does only work in Chrome for Android.", "added": 1501587496, "modified": 1501587496, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/1065#issuecomment-319389972", "source_type": "github"}], "1604066176_mirrored_cxgreat2014_github": [{"comment_id": 6, "body": "I'm also experiencing this error.\r\nIt just happens, after some time, restarting the client helps, though, only for limited time until you have to repeat the process.", "added": 1507448826, "modified": 1507448859, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/1136#issuecomment-334998072", "source_type": "github"}], "1604066264_mirrored_ZeroTube_github": [{"comment_id": 7, "body": "Yes, you have to use the `wrapperOpenWindow`-command, for example like follows:\r\n```\r\nfunction openNewTab(url) {\r\n    page.cmd(\"wrapperOpenWindow\", [url, \"_blank\", \"\"]);\r\n    return false;\r\n}\r\n```\r\n`page` being your ZeroFrame-extend.\r\n\r\nThis is also documented in the docs: http://zeronet.readthedocs.io/en/latest/site_development/zeroframe_api_reference/#wrapperopenwindow-url-target-specs", "added": 1514009853, "modified": 1514009950, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/1217#issuecomment-353715863", "source_type": "github"}], "1604066678_mirrored_DaniellMesquita_github": [{"comment_id": 8, "body": "I guess the [MediaDevices interface](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices) (from the [Media Capture and Streams API](https://developer.mozilla.org/en-US/docs/Web/API/Media_Streams_API)) can only really work when zites are served via https (at least this applies to Chrome), which is, as far as I'm aware, not the case.\r\nThough using \"localhost\" in Chrome allows to use https-only features, so that might be a solution (I'm not sure if this works in other browsers).\r\n\r\nYou could just use a python-module to serve via http2 (which allows SSL/TSL connections or whatever (lol, I honestly don't know what exactly I'm talking about right now, but I've done this before.. so I believe it's correct)). Then you would only need a self-signed certificate or so, which could probably be generated as well.\r\n\r\nI'm not even sure if this needs to be added to the ZeroFrame-API or not (though I guess it has to, because of the iFrame?).\r\n\r\nPS.: I've not experimented with anything yet, because schools starting again tomorrow, and I don't have any much time, but what a zite should be able to do in the end is basically the code in this comment: https://github.com/AnthyG/ThunderWave/issues/111#issuecomment-413531460", "added": 1534691436, "modified": 1534691478, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/1514#issuecomment-414145009", "source_type": "github"}], "1604066972_mirrored_styromaniac_github": [{"comment_id": 9, "body": "I'm using `cmd(\"wrapperOpenWindow\", [url, \"_blank\", \"\"])` (bound to `a`-tags) to open urls in new tabs. And I mean it's working just fine for every browser except as it seems, for the way @styromaniac described, so it's either got to be ZeroFrame not working in this case for web apps, or I don't understand something very trivial xD", "added": 1541698823, "modified": 1541698823, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/1772#issuecomment-437147833", "source_type": "github"}, {"comment_id": 10, "body": "I'm kinda wondering, why `_blank` wouldn't just ask if you want to open it in another browser, instead of somehow breaking the url completely.", "added": 1541934981, "modified": 1541934981, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/1772#issuecomment-437673816", "source_type": "github"}], "1604067340_mirrored_imachug_github": [{"comment_id": 11, "body": "I agree with @imachug.\r\nThis plugin is a great addition functionality wise, but that ofc doesn't mean it can't be disabled by default (I guess it would rather mean that it _should_ be disabled by default).", "added": 1562264412, "modified": 1562264412, "source_link": "https://github.com/HelloZeroNet/ZeroNet/pull/2024#issuecomment-508578449", "source_type": "github"}], "1604067496_mirrored_slrslr_github": [{"comment_id": 12, "body": "One issue with this tho is (AFAIK), that the zite could just have all the files without any file type ending. And even any built-in mimetypes could be removed and added back in through javascript. Thus, the client can't just \"know\" which files are of type image or video or whatever.\r\n\r\nSo this function would have to be much more diverse / modular as to the selection of file \"types\" you want to seed.\r\nAlso, the ZeroNet client / ZeroFrame doesn't really have anything to say about placeholders for files. This has to be handled be the zite's code itself, that is if my knowledge of iframes is sufficient (maybe there is a trick tho, or something might open up with #2169? \ud83e\udd37\u200d\u2640).\r\n\r\nOther than that, I do think that a more fine-grained control over which content to download and seed is a good idea.", "added": 1566365240, "modified": 1566365240, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2138#issuecomment-523353853", "source_type": "github"}]}, "next_topic_id": 2, "topic": [{"topic_id": 1604067271, "title": "Extended CORS Permission AKA Should Zites be Allowed to Download/Modify/Delete Optional Files with CORS?", "body": "**Is your feature request related to a problem? Please describe.**\r\nThe problem as of now is that even tho the `fileNeed` cmd is not CORS enabled, `fileGet` with the `required` argument set to `true` acts just the same way as `fileNeed` does.\r\nFirst of all, I completely join the opinion [that the user is at risk when allowing a zite to basically download all optional files of another zite](https://github.com/HelloZeroNet/ZeroNet/issues/1014#issuecomment-314519444), so that functionality should be limited, thus with this _I propose to always set the `required` argument to `false` in the CORS plugin code_.\r\nWith that in mind tho, I'd still like to discuss on whether there might be a different solution to the problem which is that a zite might want to download or change files of another zite.\r\n\r\n**Describe the solution you'd like**\r\nAs the user currently has to accept the CORS permission for a zite, and to recap this allows the requesting zite to use all CORS enabled cmds just as if they were from-and-to the executing zite, I'd additionally like to propose the implementation of a \"CORS extended\" request cmd, which also enables downloading files as well as [writing to files](https://github.com/HelloZeroNet/ZeroNet/issues/1811) through the CORS system (download and write could also be split up into two separate requests, considering the user should have full power over what they allow and what not).\r\nWith the \"CORS extended\" permission, a zite could potentially then be given full cmd operability in the context of another zite. Of course, this should be thought through thoroughly, but I think quite a few zites would profit from this. If this \"CORS extended\" permission is implemented, one expected behaviour would be as follows:\r\n\r\n- No CORS -> `fileGet` returns \"No permission\"\r\n- Basic CORS -> `fileGet` can only return the data of the file (but `required=true` will have no effect)\r\n- Extended CORS -> `fileGet` can return the data of the file, and if `required` is `true`, then download of the file may be initialized\r\n\r\nThrough this permission, the optional file system could be largely widened out to also function cross-zite (and would thus make optional file management possible without a workaround, as I describe it as an alternative below).\r\n\r\n**Describe alternatives you've considered**\r\nAn alternative workaround which I am also using right now (see the ZeroTalk topic linked below) for the `optionalFileDelete` cmd, is to redirect to a \"API\" page of the zite where the optional file lies (passing the specific file via the query string), delete the optional file there, and then redirect back to the zite that requested deletion.\r\n\r\n**Additional context**\r\nYou can find more on how I came to create this issue here: http://127.0.0.1:43110/Talk.ZeroNetwork.bit/?Topic:1556467817_1Mi7rUdBpQc99kfuvippGxgEbM7ZKdSXUD\r\n\r\nI have basically created three zites (of which one is not that relevant to this issue, but is still a good example):\r\n1. The zite where the optional files are stored:\r\n\thttp://127.0.0.1:43110/1D2xzWx2oG8oUiMpKvygeoyYL7uJXFMp8k\r\n\thttps://gitlab.com/AnthyG/sample-image-data-zite\r\n2. The zite where the data from the previous zite can be viewed:\r\n\thttp://127.0.0.1:43110/1NHXyHdJimWTCcYByRSM7RGVfUkixwjf41\r\n\thttps://gitlab.com/AnthyG/sample-image-view-zite\r\n3. Also a zite where the data from the previous zite can be viewed (but it uses a library I created for this whole thing):\r\n\thttp://127.0.0.1:43110/1PmkreYrHALCPaPQx3h9Ht8oQzjCKpA3n\r\n\thttps://gitlab.com/AnthyG/sample-image-view-js-library\r\n\r\nI think it should also be made clearer, on what the difference is between using CORS through prefixing the `inner_path` of a file with `cors-ziteaddress` and using CORS through the `as` cmd. In my experimentation I have e.g. found out that I can use `optionalFileInfo` through `as` but not with `cors-ziteaddress` even tho I thought that that should be the opposite after reading this line https://github.com/HelloZeroNet/ZeroNet/blob/e687d5db69d5466b06a88b49d9a569ef7855b468/plugins/Cors/CorsPlugin.py#L30", "parent_topic_uri": "1604062980_users_1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di", "added": 1557079994, "modified": 1557923461, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2012", "source_type": "github"}]}