{"cert_user_id": "pexo-zn@github", "next_topic_id": 8, "topic": [{"topic_id": 1604067703, "title": "Allow blocklists to block files.", "body": "**Is your feature request related to a problem? Please describe.**\r\nPeople shy away from some zites because they suspect/fear illegal content. While it is possible for blocklists to block user(-id)s and entire zites, it is not possible to block specific files on zites which can be an issue depending on the architecture of the zite in question. An example for that would be millchan(the non merger version) and avatar images on ZeroMe(because they will be marked as required and thus be downloaded onto everyone computer in the case of CP this can be devastating).\r\n\r\n**Describe the solution you'd like**\r\nIntroduce the ability to block files from specific websites as an ZeroFrame api command. One way of doing that would be to have ziteAddress, date_added, inner_path, name and reason in a filters/files.json. If the user then tries to download a muted file, a notification will appear, which informs him of the reason why that file is blocked, asks if he wants to get it anyways and an option to not show that notification again. Since the user should always be able to tell which files are blocked on his end, blocking files based only on its hash should not be the implemented.\r\n\r\n**Describe alternatives you've considered**\r\nBlocking users and/or zites in the case of millchan (and the theoretical case of ZeroMe). Both don't work satisfactory or at all.\r\n\r\n**Additional context**\r\nThis issue is mirrored from the [GitCenter ZeroNet repository](http://127.0.0.1:43110/1GitLiXB6t5r8vuU2zC6a8GYj9ME6HMQ4t/repo/issues/view/?1P4w4Rvh4vS9r6G5xTiSh8qEW87EKZtnJB/5@1DfrA2M9Qra6stqT6tzwNMYNweswY54KAC)(you need to install ZeroNet to visit this link)\r\n", "parent_topic_uri": "1604062980_users_1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di", "added": 1575817347, "modified": 1576161439, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2348", "source_type": "github"}, {"topic_id": 1604067705, "title": "Certificates are not checked, before they are added.", "body": "### Step 1: Please describe your environment\r\n\r\n  * ZeroNet version: 0.6.5 (rev3853)\r\n  * Operating system: Fedora 29\r\n  * Web browser: Tor Browser\r\n  * Tor status: always\r\n  * Opened port: no\r\n  * Special configuration: -\r\n\r\n### Step 2: Describe the problem:\r\n\r\nLike the title says, certificates are not checked, before they are added.\r\n\r\n#### Steps to reproduce:\r\n\r\n1. Make a new zite.\r\n2. Call `this.cmd(\"certAdd\", [\"anon.mysite\", \"web\", \"1QKzd48LZUA8p4s\", \"Totally-a-valid-signature=lol\"])`\r\n\r\n#### Observed Results:\r\n\r\nZeroNet will just accept this obviously wrong certificate. This is the entry in users.json:\r\n```\r\n      \"anon.mysite\": {\r\n        \"auth_address\": \"14BcMpfJzrhieAHcyj3YvkqYkpKGvNwsP8\", \r\n        \"auth_privatekey\": \"5[redacted]\", \r\n        \"auth_type\": \"web\", \r\n        \"auth_user_name\": \"1QKzd48LZUA8p4s\", \r\n        \"cert_sign\": \"Totally-a-valid-signature=lol\"\r\n      }\r\n```\r\n\r\n#### Expected Results:\r\n\r\nZeroNet should not accept certificates with wrong/invalid signatures.\r\n\r\n\r\n**Additional context**\r\nThis issue is mirrored from the [GitCenter ZeroNet repository](http://127.0.0.1:43110/1GitLiXB6t5r8vuU2zC6a8GYj9ME6HMQ4t/repo/issues/view/?1P4w4Rvh4vS9r6G5xTiSh8qEW87EKZtnJB/7@1DfrA2M9Qra6stqT6tzwNMYNweswY54KAC)(you need to install ZeroNet to visit this link)", "parent_topic_uri": "1604062980_users_1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di", "added": 1575817842, "modified": 1577973896, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2349", "source_type": "github"}, {"topic_id": 1604067707, "title": "Allow zites to overwrite, overrule or set an custom auth_address.", "body": "**Is your feature request related to a problem? Please describe.**\r\n To the best of my knowledge, for a zite developer it is currently impossible to change the auth_address at all. Because of this, added certificates will in the eyes of ZeroNet always be intended to be for the current auth_address(which, per zite, cannot change), and also accepted regardless of the signature contents (see this issue). This makes not only anonymous posting impossible but also the ability to have multiple accounts on one zite, since `fileWrite` will only write files, if the current auth_address is in the valid signers list. With no way to change auth_address this is only true for one directory path(which ends in that auth_address). Possible applications for multiple accounts could be a moderation system(possibly even autonomous ones, through election algorithms), where you would have differently privileged user types, as example:\r\n\r\n- Owner\r\n- Moderator\r\n- Volunteer\r\n- User As things currently are, a moderator, for example, must always post with his moderator account.\r\n\r\n\r\n**Describe the solution you'd like**\r\nAn api command to either:\r\n\r\n- overwrite: Replace the generated auth_address with custom one, but always default to generated one, if the zite developer for example tried to add an invalid privatekey (only either of them is readable at every point in time)\r\n- overrule: Add the custom auth_address as an new field(both are readable at any point in time).\r\n- set: Replace the generated auth_address permanently with the custom one.\r\n\r\nAn alternative way to implement this would be to allow have an commend like `setAuthIndex` where that will change the auth_address to the subkey of the specified index, similar to the way `userPublickey` from `CryptMessage` plugin does it. But this would be way less flexible than the solutions mentioned above.\r\n\r\nIn addition to that, in `certAdd` the ability to specify what privatekey the new certificate, actually belongs to and only to assume the current auth_address as default. Something like: `@cmd \"certAdd\", [\"zeroid.bit\", auth_type, auth_privkey, user_name, cert_sign], (res) =>{/**Stuff*/}` Where auth_privkey is, if not specified, the private key of the current auth_address.\r\n\r\n**Describe alternatives you've considered**\r\nUsing current api commands, trying different zite structures and digging through ZeroNet source code to find a way to alter/change the auth_address. None of these I had success with.\r\n\r\n**Additional context**\r\nThis issue is mirrored from the [GitCenter ZeroNet repository](http://127.0.0.1:43110/1GitLiXB6t5r8vuU2zC6a8GYj9ME6HMQ4t/repo/issues/view/?1P4w4Rvh4vS9r6G5xTiSh8qEW87EKZtnJB/8@1DfrA2M9Qra6stqT6tzwNMYNweswY54KAC)(you need to install ZeroNet to visit this link)\r\n", "parent_topic_uri": "1604062980_users_1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di", "added": 1575818026, "modified": 1582600617, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2350", "source_type": "github"}, {"topic_id": 1604067709, "title": "Use v3 hidden services for tor.", "body": "Tor 0.3.5.x has been out for quite a while now and since onion services in version 3 are superior in basically every aspect, in comparison with the 'normal' .onion addresses, ZeroNet should probably use the v3 hidden services by default(or at least support them) in Tor enabled/tor always-mode.\r\n\r\n**Additional context**\r\nThis issue is mirrored from the [GitCenter ZeroNet repository](http://127.0.0.1:43110/1GitLiXB6t5r8vuU2zC6a8GYj9ME6HMQ4t/repo/issues/view/?1P4w4Rvh4vS9r6G5xTiSh8qEW87EKZtnJB/9@1DfrA2M9Qra6stqT6tzwNMYNweswY54KAC)(you need to install ZeroNet to visit this link)", "parent_topic_uri": "1604062980_users_1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di", "added": 1575818326, "modified": 1576161447, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2351", "source_type": "github"}, {"topic_id": 1604067711, "title": "'file_done' event may be fired before new data is not yet added to the database.", "body": "### Step 1: Please describe your environment\r\n\r\n  * ZeroNet version: 0.7.0 (rev4188)\r\n  * Operating system: Fedora 30\r\n  * Web browser: Tor Browser\r\n  * Tor status: always\r\n  * Opened port: no\r\n  * Special configuration: -\r\n\r\n### Step 2: Describe the problem:\r\n\r\nThe only way to check for a zite whether or not new content is available to render is to listen to the `file_done` event/channel, however that event will be fired before the sqlite database as added the new data if a large `data.json`(~10MB) update happened. Essentially the database lags behind in adding all of the entries, such that an sql query that would be done in response to updated data(the `file_done` event) happens (and is carried out) before all of the data is in the database, resulting in some data that is not displayed until a new `file_done` event updates the page.\r\n\r\n#### Steps to reproduce:\r\n\r\n1. Make a test zite, where data is displayed by an sqlite query.\r\n2. The zite listens on `file_done` in the `siteChanged` channel for updates to the zite and updates the display with the results of a sql query.\r\n3. Update the zite with a large data file (10MB ~150 medium sized entries).\r\n\r\n#### Observed Results:\r\n\r\nDepending on hardware speed, of 150 entries that should've been displayed only 120 are displayed. After the zite is updated with another (even unrelated) data the number of displayed entries is 150.\r\n\r\n#### Expected Results:\r\n\r\n150 displayed entries after the file update\r\n\r\n#### Proposed solutions:\r\n\r\nIn order of most logical to least logical(in my opinion):\r\n1. Add a `databaseChanged` channel to listen to\r\n2. Add a `database_done` to `siteChanged`\r\n3. Only fire `file_done` if the database is done adding the new data.\r\n\r\n\r\n**Additional context**\r\nThis issue is mirrored from the [GitCenter ZeroNet repository](http://127.0.0.1:43110/1GitLiXB6t5r8vuU2zC6a8GYj9ME6HMQ4t/repo/issues/view/?1P4w4Rvh4vS9r6G5xTiSh8qEW87EKZtnJB/10@1DfrA2M9Qra6stqT6tzwNMYNweswY54KAC)(you need to install ZeroNet to visit this link)", "parent_topic_uri": "1604062980_users_1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di", "added": 1575818587, "modified": 1576680504, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2352", "source_type": "github"}, {"topic_id": 1604067714, "title": "Nested content.jsons are not in sidebar.", "body": "### Step 1: Please describe your environment\r\n\r\n  * ZeroNet version: 0.7.1 (rev4253)\r\n  * Operating system: Fedora 30\r\n  * Web browser: Tor Browser\r\n  * Tor status: always\r\n  * Opened port: no\r\n  * Special configuration: -\r\n\r\n### Step 2: Describe the problem:\r\n\r\nNested `content.json`s are not listed in the sidebar. under the `CHOOSE` section. \r\n#### Steps to reproduce:\r\n\r\nA new blank zite, the root `content.json` includes `data/content.json` with `includes_allowed` set to true.\r\n`data/content.json` includes `L_admin/content.json`.\r\n\r\n#### Observed Results:\r\n\r\nThe sidebar will not show `L_admin/content.json` or any other nested `content.json` that is not explicitly in the includes entry of the root content.json.\r\n\r\nThe problematic line is in [SidebarPlugin.py line 504](https://github.com/HelloZeroNet/ZeroNet/blob/py3/plugins/Sidebar/SidebarPlugin.py#L504):\r\n\r\n```\r\ncontents += list(site.content_manager.contents.get(\"content.json\", {}).get(\"includes\", {}).keys())\r\n```\r\nIt does not consider nested includes.\r\n\r\n\r\n\r\n**Additional context**\r\nThis issue is mirrored from the [GitCenter ZeroNet repository](http://127.0.0.1:43110/1GitLiXB6t5r8vuU2zC6a8GYj9ME6HMQ4t/repo/issues/view/?1P4w4Rvh4vS9r6G5xTiSh8qEW87EKZtnJB/11@1DfrA2M9Qra6stqT6tzwNMYNweswY54KAC)(you need to install ZeroNet to visit this link)", "parent_topic_uri": "1604062980_users_1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di", "added": 1575819080, "modified": 1576161660, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2353", "source_type": "github"}, {"topic_id": 1604067715, "title": "Consider nested includes when checking for valid signers of a file.", "body": "**Is your feature request related to a problem? Please describe.**\r\nThe valid signers check does not consider nested includes when looking for signer addresses for a file.\r\n\r\n**Describe the solution you'd like**\r\nIf a file is included by a content.json file and an address is in the signers field of its parent content.json file (or its parent or the parent of the parent and so on), that address should be considered a valid signer of the file, without having to mention it explicitly in the signers field(similar to how the zite address is always a valid signer).\r\n**Reasoning:**\r\nIf a address is in the signers field on any node(=content.json) in the 'includes tree'(so to speak), it can always just 1) add itself to the next child node, 2) sign it, goto 1 and repeat until a leaf node is reached. This will achieve the same effect.\r\nHowever, if things stay as they are now, any second address that is in a signers field along the tree below the first address, can remove the first address from any part of the tree that is below the second address. This is not possible when ZeroNet traces the 'includes tree' upwards and adds the addresses it finds in the signers field to the valid signers automatically, since the second address would have to remove the entry at a node higher up in the ' includes tree', which it can't do, because it is not a valid signer of that upper node.\r\n\r\n**Describe alternatives you've considered**\r\nDifferent data structures. It is (to the best of my knowledge) impossible to have moderation with different permission levels, without the lower level permission level moderators being able to sabotage the higher level ones (excluding the owner, of course). See Additional context for more detail.\r\n\r\n**Additional context**\r\nI was working on a moderation system for hubs, which does not rely on trusting that every privileged user(admin, mod or volunteer) is never malicious, while in power.\r\n\r\nThese are the proposed moderation levels:\r\n\r\n- Owner: Can change anything(including html/js + root content.json + editing user data), appoints admins, mods, volunteers\r\n- Admin: Can change anything(including data json + editing user data + hub config), appoints mods, volunteers\r\n- Mod: Can change user content(editing user data), appoints volunteers\r\n- Volunteer: Can change nothing, only clientside overwrite and prioritized reporting to mods/admin/owners\r\n- User: Can change nothing, has ability to report things to volunteers/mods/admins/owners\r\n\r\nThis is the data layout I used(`-` annotates files `+` folders):\r\n```\r\n-content.json [1]\r\n+data/\r\n  -content.json [2]\r\n  +owner/\r\n    -content.json [3]\r\n  +admins/\r\n    -content.json [4]\r\n  +L_admin/\r\n    -content.json [5]\r\n    +config/\r\n      -HubConfig.json\r\n    +mods/\r\n      -content.json [6]\r\n    +L_mod/\r\n      -content.json [7]\r\n      +users/\r\n        -content.json [8]\r\n```\r\nWhere:\r\n\r\n- [1]{root content.json} includes [2]\r\n- [2] includes [3]{includes allowed}, [4]{includes not allowed} and [5]{includes allowed}\r\n- [3] includes nothing\r\n- [4] includes nothing and is a user_content content.json, where everyone can't post by default(using permission_rules `\".*\":** {files_allowed: \"\", max_size:0}`) and new admins are added by the owner using the permissions field.\r\n- [5] includes [6]{includes not allowed} and [7]{includes allowed}\r\n- [6] same as [4] only that mods will be added here, by either the owner or an admin.\r\n- [7] includes [8]\r\n- [8] includes nothing and is a user_content content.json, where everyone can post by default but is not allowed to write to a file that the database will recognize as 'moderation action'. The owner, an admin or a mod can grant a user the ability to perform mod actions, by adding them to the permissions field.\r\n\r\nThe idea was to:\r\n\r\n- Add every admin address to the signers field in the include in [2] for [5] and to the permissions field in [4]\r\n- Add every mod address to the signers field in the include in [5] for [7] and to the permissions field in [6]\r\n- Add every volunteer address to the permissions field in [8]\r\n\r\nThis has a few nice properties embedded into its structure:\r\n\r\n- posts of the owner cannot be altered by anybody.\r\n- posts of admins (in `data/admins/[address]/`) cannot be altered by mods\r\n- posts of mods can be altered by admins, but not by volunteers\r\n- posts by users and volunteers can be altered by admins and mods, but not by either volunteers or users.\r\n- The owner can alter everything.\r\n- Owners can't appoint owners(because there only ever is one), admins can't appoint admins, mods can't appoint mods and volunteers can't appoint volunteers.\r\n- Only users with a higher permission level are able to remove the extra permission of a privileged user. (Owner > admins > mods > volunteers)\r\n- Very little complexity in JS: Owner, admins, mods, volunteers and users can use the same code for mod actions and posts, the only thing that changes is the path and a few extra checks.\r\n\r\nIf permissions were inherited by includes, an admin would be able to sign everything that the content.json, that has the admin in the signers field, signs. For example an admin would be able to sign the data.json file of any user, the content.json file of the mods([7]) and so on, basically everything within the `L_admin` folder.\r\n\r\nBecause this is not the case, each admin needs to be mentioned in every signers field of every content.json separately to be able to sign it, which an admin would be able to do on his own anyways(see reasoning above).\r\nThe problem with that is that a malicious mod could just remove an admins address from the signers field of [7], sign and publish [7] and with that, invalidate all user files that that admin edited in the past. They will remain invalid until the admin comes back and adds themselves back into [7]. During that time the data of the edited user(and in fact every user that had their content edited by that admin) is, at best, unavailable to newcomers and at worst deleted from existing peers.\r\n\r\n\r\nThis issue is mirrored from the [GitCenter ZeroNet repository](http://127.0.0.1:43110/1GitLiXB6t5r8vuU2zC6a8GYj9ME6HMQ4t/repo/issues/view/?1P4w4Rvh4vS9r6G5xTiSh8qEW87EKZtnJB/12@1DfrA2M9Qra6stqT6tzwNMYNweswY54KAC)(you need to install ZeroNet to visit this link)", "parent_topic_uri": "1604062980_users_1Cy3ntkN2GN9MH6EaW6eHpi4YoRS2nK5Di", "added": 1575819404, "modified": 1575819404, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2354", "source_type": "github"}], "next_comment_id": 4, "comment": {"1604067703_mirrored_pexo-zn_github": [{"comment_id": 1, "body": "Previous conversation on GitCenter:\r\n- >nofish@zeroid.bit commented on Feb 11 2019\r\n    \r\n    The download notification has to done on site level, but we could create a new list (same as blocked sites/users) to filters.json and the site could use this list to check if the content is blocked.\r\n- >pexo@zeroid.bit commented on Feb 12 2019\r\n    \r\n    So would (for example) `ZeroFrame.cmd(\"fileGet\", [\"data/users/SomeBadFile.jpg\", false]) return {\"error\": \"File on blocklist\"}` or would there be an additional way to tell the zite dev that the file is blocked?\r\n- >nofish@zeroid.bit commented on Feb 13 2019\r\n    \r\n    Yeah, and probably fileblockAdd, fileblockRemove, fileblockList command that lists all blocked files on the site with the reason and the source. Probably it could also contain post/comment ids, not just files.", "added": 1575817641, "modified": 1575817641, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2348#issuecomment-562975786", "source_type": "github"}], "1604067707_mirrored_pexo-zn_github": [{"comment_id": 2, "body": "Previous conversation on GitCenter:\r\n- >nofish@zeroid.bit commented on Mar 9 2019\r\n    \r\n    I would prefer the setAuthIndex -like solution as it would make it possible to recover it from the master seed\r\n- >pexo@zeroid.bit commented on Mar 10 2019\r\n    \r\n    >make it possible to recover it from the master seed\r\n    \r\n    If one can remember the index, at least.\r\n    \r\n    Anyway, both are good options in my book, although something to have in mind is that `setAuthIndex` will lock you into, at most, 2,147,483,647(signed integer max value) unique addresses, compared to basically infinite unique addresses you get with the other option. But 2.1 Billion addresses are more then enough anyways.\r\n    \r\n    Also there is a security consideration to be made here, as the option to recover the addresses from the master seed will cause all generated addresses to be compromised should the master seed ever be stolen. Maybe an api command to create a temporary throwaway address would solve that, in case that becomes necessary for a zite developer?\r\n    \r\n    Do you have a rough estimate when you are able to implement this?\r\n", "added": 1575818247, "modified": 1575818247, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2350#issuecomment-562976902", "source_type": "github"}], "1604067711_mirrored_pexo-zn_github": [{"comment_id": 3, "body": "Previous conversation on GitCenter:\r\n- >nofish@zeroid.bit commented on Sep 1 2019\r\n    \r\n    Yes, file_done should only get fired after it's got inserted to the database. I also found similar bug some days ago (not sure if it's related), but I wasn't able to reproduce it since then. I will try to do a test site with bigger data file.\r\n", "added": 1575818670, "modified": 1575818670, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/2352#issuecomment-562977577", "source_type": "github"}]}}