{"cert_user_id": "kentonv@github", "next_comment_id": 2, "comment": {"1604067252_mirrored_vRobM_github": [{"comment_id": 1, "body": "Yeah there's a few reasons why this test turns out to favor msgpack:\r\n\r\n* Normally msgpack suffers from the fact that field names are encoded on the wire. However, the bulk of the data in this test is ip/port pairs, which you've chosen to encode as two-element lists rather than as objects with named fields. This seems to be a hand-rolled optimization for msgpack that makes the code less readable (admittedly not hugely so in this particular case). Without this optimization, msgpack would be closer to Cap'n Proto, maybe larger.\r\n* Meanwhile, the data contains lots of small strings (IP addresses). This is particularly bad for Cap'n Proto, because any variable-width value needs to be represented as an 8-byte pointer pointing to a separate object whose size is itself rounded up to a multiple of 8. The IP address \"127.0.0.1\" is 10 bytes (with NUL terminator) which rounds up to 16. The Peer struct itself appears to contain the 8-byte pointer plus a UInt16 port number which again rounds up to 16 bytes. So you end up with 32 bytes for each ip/port pair, compared with a theoretical best of 12.\r\n* OTOH, if you were to encode the IPv4 address as a 32-bit integer rather than a string, then the ip/port pair would be only 8 bytes under Cap'n Proto, probably beating msgpack by a decent margin.\r\n* With regards to speed, the Cap'n Proto Python implementation is not as heavily optimized as the C++ implementation. In C++, Cap'n Proto would almost certainly be faster (even with the larger encoding). But that doesn't help you, obviously, if your project is Python. :/", "added": 1556143008, "modified": 1556143008, "source_link": "https://github.com/HelloZeroNet/ZeroNet/issues/1997#issuecomment-486479878", "source_type": "github"}]}}