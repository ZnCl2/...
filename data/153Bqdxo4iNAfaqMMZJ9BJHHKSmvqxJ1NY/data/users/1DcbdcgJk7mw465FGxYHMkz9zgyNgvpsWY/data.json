{
	"next_topic_id": 5,
	"topic": [
		{
			"topic_id": 1577266958,
			"title": "Linux专区",
			"body": "讨论Linux的使用",
			"added": 1577266957,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9",
			"type": "group"
		},
		{
			"topic_id": 1577266994,
			"title": "Linux讨论",
			"body": "游戏\n软件使用\n软件编译方法",
			"added": 1577266992,
			"parent_topic_uri": "1577266958_1DcbdcgJk7mw465FGxYHMkz9zgyNgvpsWY"
		},
		{
			"topic_id": 1577283367,
			"title": "以lfs为日常系统是怎样一种体验？",
			"body": "我来说说吧,做lfs多年了,用lfs做主系统也一年了,应该还是有些发言权的.\n一年前自己组装了个家用台式机,然后根据lfs 7.9和blfs7.9做的日常系统\n\n先说下制作系统的思路:\nlfs阶段完全按照手册来做.blfs阶段对图形界面进行了非常大的简化,\n采用了xorg + fvwm + conky + gtk2的组合.(ps:选这个组合,就没打算后续升级)\n\n用conky显示下时间,日期,内存占用情况.\n用fvwm显示壁纸,并虚拟9个桌面.\n软件窗口使用gtk2主题(无标题栏,无边框)\n然后桌面上没有其它东西(没面板,没dock,连右键菜单都没有)\n\n应用软件:firefox + rox + mplayer + vim等       \n对qq,微信等软件不较劲,用qemu虚拟xp,然后用fvwm绑定快捷键.       \n只按两个键就可以打开全屏登录状态的xp.也挺方便的.\n不过不到十分有必要的情况,也不会用windows的\n\n下面是正文,以lfs为日常系统是一种怎么样的体验:\n一.有安全感.\n1.系统稳定,除非出动'rm -rf'这种级别的大杀器,不然随便作,系统始终屹立不倒.\n\n2.能在更新与稳定之间找到很好的平衡.不用总担心系统升级的问题  \n2.1 fcitx,gtk2,fvwm,conky等日常软件可以保持在经典版本,不会有包管理器来告诉我这些应该更新.      还有更基础的软件gcc,glibc,binutils等,从我从一开始制作lfs的时候压根就没想过要更新. \n2.2 部分软件能始终保持最新版本.比如linux kernel,我选择追着linus更新.这样麻烦吗?不麻烦!      对于kernel,也是进行极简化,完全不要模块,以最新的4.12来说,编译好的vmlinz有5.1M大小.编译用时10分钟左右,升级起来方便快捷.  \n2.3 部分软件有选择的更新.例如firefox,系统用了快一年,只是从42升级到了45.      \n这个软件属于依赖非常多的软件,不会一直升级下去的.否则最后的结果就是前面那位说的:      '如果，你想升级某个日用软件，那么，你可能需要从200个lib开始………'\n\n二.自由简单\n3.彻底没有了gnome,kde,unity等图形界面孰优孰劣的争论,在我的系统里,fvwm一统江湖.\n4.彻底摆脱了systemd,wayland,pulseaudio等'先进'的子系统.我宁可和时代脱节,也不接受这些东西.\n5.彻底告别了pulseaudio,jack,gstreamer,xine,oss,sdl等等一大堆名词,声音系统由alsa一统江湖,至此我总算长舒一口所,以后声音系统再出问题,直接就去找alsa算帐准没错,因为系统里也没有别的声音软件了.\n6.库的路径标准化.   ld.so.conf,LD_LIBRARY_PATH,LDFLAGS这些库搜索路径参数被我彻底弃用了.  连/usr/local目录都被我去掉了.天知道我以前编译软件被这些路径参数折腾的多惨.现在世界终于安静了.\n7.编译软件标准化.  安装软件,升级软件,直接./configure --prefix=/usr &make &make install,要多省心有多省心.\n\n三.灵活方便. \n8.桌面操作  根据自己操作习惯,利用fvwm灵活的快捷键设置,把键盘,鼠标上的键都充分利用起来.启动常用软件,关机重启,调节声音等都由快捷键来做.\n9.根据自己喜好选择软件,根据自己需要的功能增减编译选项.既能精简系统,有能增加运行效率和稳定性.虽然有观点认为打包好的软件一样稳定高效.但那只是相对于单个软件来说.对于整个系统来说,在自己机器上编译的还是比打包的好.\n10.备份还原  找个闲置的硬盘,一股脑把/下的文件全都拷贝过去.若是哪天系统挂了,再把备份一股脑拷贝回来.  简单粗暴实用,不过除非出现特别极端的情况,正常情况下是用不到的.  隐约听说有些arch用户经常用到这个办法,用来对付滚动更新系统滚挂的情况还真是不错.\n11.硬件更新方便.  即以后换了新电脑,把系统拷贝到新硬盘上,直接就能用.或者干脆直接把存有系统备份的闲置硬盘插到新电脑上去.\n\n最后:以一句邪教风格的话作结语吧:lfs能避免很多发行版的弊病,lfs所谓的自身的'弊病'也能找到合理的解决办法.",
			"added": 1577283666,
			"parent_topic_uri": "1577266958_1DcbdcgJk7mw465FGxYHMkz9zgyNgvpsWY"
		},
		{
			"topic_id": 1577284003,
			"title": "为什么你觉得 Lisp 难学?",
			"body": "作为一个深爱 Lisp 的 Common Lisp 用户，当年刚接触的时候，觉得语法特别简单，甚至可以说是没有语法。因为总结起来 Lisp 的语法就只有两个规则（不考虑 Reader Macro）\n\n没括号的，直接返回变量值\n有括号的，要么是个函数，要么是宏，要么是特殊操作符。然后就执行这个函数/宏/特殊操作符就行了。宏跟特殊操作符虽然不是函数，但跟函数还挺像的。\n\n所以上手巨快，只要你变量名、函数名没写错，参数提供对了，你写的代码基本上永远是可以执行的。语言标准还提供了很多好用的函数，比如 mapcar 这种命令。\n\n但等我用了一段时间之后，开始发现 CL 里面难学的东西。CL 是一门面向生产实践的语言，经过千锤百炼，有很多高效、有用但很复杂的系统。而且这些系统的思想跟主流语言不太像，不熟悉导致上手困难。以下几点是令我印象比较深刻的\n\n1.Condition System，以前从没见过。这玩意儿类似于 C++ 的 Exception，但要复杂很多，也灵活很多，它的一个用处是做异常处理。我看了好几天文档才大致明白。相比于 Exception，Condition System 在遇到状况的时候可以把整个运行环境暂停，然后让你选择下一步该怎么办，相当于有个上帝视角，而你的调用栈里面的所有状态都是保留的。这玩意儿实在是有点强啊。\n\n2.CLOS (Common Lisp Object System)，也就是 Common Lisp 里面的 OOP，它采取的方式跟我之前熟悉的 C++ 那种对象完全不同。CLOS 的核心不是 Class，而是 Generic Method。Class 不负责行为，只有数据结构。然后又是研究了好几天，各种复杂的机制一开始显得非常吓人，但当我大概理解之后觉得 CLOS 非常优美。这个难学主要也是因为复杂，然后不太熟悉这套思路。\n\n3.宏（Macro），一开始的练手的那些宏还是比较轻松简单的。但后面看了大神们的各种宏，每次第一反应就是，卧槽，还能有这种操作？Let Over Lambda 这本书有大量的例子。宏的难度在于，它的语义抽象是无限的，所以难度不在语言层面，而在你的抽象和理解能力层面，类似于解数学问题。\n\n4.Reader Macro。这个实际上就是个 Parser，你可以把自己的语言定制的面目全非。。。\n\n5.Symbol System. CL 里面，Symbol 是一种可以操作的数据结构，跟其他编程语言的变量名什么的行为都还不太一样，由此引出的 Package System 也跟主流有明显差异，一开始还是容易绕进去的。还有一点，CL 是 Lisp-2，意思就是变量跟函数的命名空间是分开的，也就是说可以存在一个函数和一个变量是同一个名字，interesting。虽然困难，但理解之后觉得都非常美妙。\n\n2017.10.1 更新一个对于初学者来说，学习 Common Lisp 有一个巨大的门槛就是 Emacs 和 Slime。最主流的实现 sbcl 的 repl 单拎出来简直没法用，连括号自动匹配都没有。所以不想出钱又想好好用 CL 基本上必须用 Emacs，但 Emacs 还是很难学的，关键是你得同时学两个你很不熟悉的东西，没有足够的动力的情况下很少有人愿意客服这种困难。",
			"added": 1577284148,
			"parent_topic_uri": "1577266958_1DcbdcgJk7mw465FGxYHMkz9zgyNgvpsWY"
		}
	],
	"topic_vote": {},
	"next_comment_id": 9,
	"comment": {
		"1577266994_1DcbdcgJk7mw465FGxYHMkz9zgyNgvpsWY": [
			{
				"comment_id": 1,
				"body": "Linux发行版 GuixSD 1.0.0 发布\n\nGuix System Distribution（GuixSD）是一个基于Linux的无状态操作系统，它是围绕GNU Guix包管理器构建的。 操作系统提供高级包管理功能，例如事务升级和回滚，可重现的构建环境。 该项目的新版本是GuixSD 1.0.0，它引入了一个新的系统安装程序，更简单的键盘和X.Org配置，并在分发的存储库中添加了1,000多个新软件包。",
				"added": 1577267619
			},
			{
				"comment_id": 4,
				"body": "一个好的包管理器，要做到能正确处理依赖关系（这点 pacman 就比较差），节约升级时间（Sabayon 的 entropy 包管理器甚至可以做到更新二进制包也只需要补丁），软件高度定制性（比如可以细致调节编译参数），优秀的版本管理（能让不同版本的软件同时存在而不产生冲突，比如 nix, guix），易扩展性（用户可以自己添加官方仓库里面没有的软件），更新出错时具有补救手段，安全性（利用沙盒编译，验证软件包），极少的依赖。\n\n然而目前没有包管理器能同时做到以上所有特性。",
				"added": 1577282705
			},
			{
				"comment_id": 5,
				"body": "包管理器有哪些?\napt、dnf、pacman、zypper、emerge、pkgsrc、nix、guix、entropy、pkgtools",
				"added": 1577283138
			},
			{
				"comment_id": 6,
				"body": "archlinux和gentoo、slackware软件通用吗？",
				"added": 1577318927
			},
			{
				"comment_id": 8,
				"body": "Notepadqq是一套纯文字编辑器，与Notepad++非常相似。Notepadqq除了可以用来制作一般的纯文字说明文件，也十分适合当作编写电脑程序的编辑器。Notepadqq支持语法高亮显示，具有搜索、查找/替换、分屏、书签、代码折叠等功能。",
				"added": 1577495184
			}
		],
		"1576633084_1BWwq5edPNmp1XBtRQEw9S5YHCek2hs1P8": [
			{
				"comment_id": 2,
				"body": "编程随想",
				"added": 1577268722
			},
			{
				"comment_id": 7,
				"body": "友情：妹调教日记\n成长与守护：遥仰凰华",
				"added": 1577319376
			}
		],
		"1570336325_13YgNcPcm39uoP32ntpnekJ3dD8stdg1qH": [
			{
				"comment_id": 3,
				"body": "站点自动更新 V1[Update ZeroSites automatically]\nhttp://127.0.0.1:43110/1G7jmLghk4h3RiBy4QLGnR4rih7zj7QkMV/?Post:12:%E7%AB%99%E7%82%B9%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0+V1%5BUpdate+ZeroSites+automatically%5D\n\n需要一个Windows版的脚本",
				"added": 1577275784
			}
		]
	},
	"comment_vote": {}
}