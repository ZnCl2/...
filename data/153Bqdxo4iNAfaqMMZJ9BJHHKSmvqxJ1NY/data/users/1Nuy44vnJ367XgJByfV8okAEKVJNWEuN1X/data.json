{
	"next_topic_id": 43,
	"topic": [
		{
			"topic_id": 1580516650,
			"title": "10个颜值较高的 Linux 发行版（2018年）",
			"body": "",
			"added": 1580516649,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580517434,
			"title": "linux各种桌面的优缺点",
			"body": "",
			"added": 1580517432,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580523665,
			"title": "xfce怎么关闭收起窗口功能？",
			"body": "收起窗口按钮很容易误点",
			"added": 1580567927,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580536149,
			"title": "有没有好用的自带桌面的gentoo？",
			"body": "安装桌面太费时间了",
			"added": 1580536145,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580536894,
			"title": "linux入门 - 专业术语学习",
			"body": "图标\n快捷方式\n软链接\n硬链接\n命令\n设备文件\n挂载、卸载\n弹出U盘\n换源、刷新源、更新系统\n环境变量\nalias\n\n编译时依赖\n运行时依赖",
			"added": 1580544406,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580547931,
			"title": "linux使用技巧",
			"body": "",
			"added": 1580547925,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580611627,
			"title": "archlinux 辅助发行版",
			"body": "适合觉得archlinux安装难的人",
			"added": 1580611620,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580612519,
			"title": "gentoo 辅助发行版",
			"body": "适合觉得 gentoo安装难的人",
			"added": 1580612511,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580626503,
			"title": "linux纯小白是什么样的？",
			"body": "",
			"added": 1580626494,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580626532,
			"title": "第一次使用 Linux 的纯小白应该了解哪些东西",
			"body": "",
			"added": 1580626522,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580627942,
			"title": "编程语言介绍",
			"body": "",
			"added": 1580627931,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580627995,
			"title": "通过使用LFS系统学会了什么？",
			"body": "经常听到大佬说LFS，什么是LFS？\n\n既然要带大家一起去看看Linux的世界，那么后面就会慢慢给大家介绍一些Linux操作系统相关的东西，普及一些基础知识。今天我带大家一起来了解一下LFS这个东西。\n\nLFS的全称是Linux From Scratch，Scratch翻译成中文的意思是划、抓、刮。就我自己来理解，就是你自己亲自划出来的Linux，再简单点说，就是你自己做出来的Linux。\n\n听到这里，你肯定很惊讶，什么，我自己也能做Linux？确实可以，但是在你自己做之前，必须得有一定的基础，比如你必须要会一些Linux的基本操作，像LFS里面必须的编译安装软件你得会吧。这样说可能有点复杂，那么我今天就来尝试一下，通过举例子来向大家说明，啥是Linux，啥是LFS。\n\n在大众的眼里，Linux似乎是很神秘的东西，比如经常说到的，网上的黑客用的都是Linux，对着黑色的框框敲几条命令，就能够控制很多电脑，控制网络。这个时候，Linux像是游戏里的神器，无所不能。稍微懂一点计算机知识的人来说，知道Linux是一个操作系统，但是是个什么样的操作系统，也不太了解。\n\n就我自己来说，Linux，它分为内核和外面的组件。有人又说了，啥叫内核，啥叫组件啊。\n\n我以平时开的车子为例，对于汽车，大家都很熟悉了。Linux内核就是汽车的发动机，用来驱动汽车工作的。但是光有发动机不行啊，我总不能坐在发动机上跑吧。\n\n好的，没问题，给你加上四个轮。诶，这下车子可以跑了。但是光会跑不行啊，总不能到处乱撞吧，出了车祸咋办，得嘞，给你加个方向盘，就是一台原始的汽车了，有轮儿可以跑，有方向盘可以控制方向。这里的轮子和方向盘，加起来就是Linux里的shell，就是大家看电影里，黑客对着电脑敲的那个框框。\n\n车子能跑以后，这么简陋可不行啊，我希望的我车外形比较好看，也行，给你外面加上汽车外壳，里面配上真皮座椅，这下开车就舒服了吧，汽车外壳和座椅就是大家平时看到的电脑桌面。\n\n开车这么难，对于我这个小白，有钱的话，什么倒车雷达啊，自动泊车啊，感应式空调啊都统统给我加上，这些在Linux上就是需要使用的基本软件。\n\n不同的车子有不同的功能，例如载货车是拉货的，客车是拉人的。那么Linux也有不同的用途啊，比如做网站给你访问的，手机上的安卓系统等等。\n\n最后，我们总结一下就是，发动机（内核）+轮子和方向盘（shell）+车架子和座椅（桌面）+倒车雷达/自动泊车（基础软件）= 汽车（Linux发行版）\n\n所谓的Linux发行版，就是不同厂商发布的Linux系统，也就是我们普通人理解的操作系统。就像宝马和奔驰发布的汽车，虽然配置什么的可能不一样，但是用途是一样的。\n\n解释完了Linux，那什么是LFS呢？看完了以后，其实LFS我们也知道是什么了，LFS就是教你怎么把发动机装到轮子上，怎么给发动机装上控制的方向盘和刹车，怎么把车架子装到车子底座上，怎么给车子装座椅、装雷达、装空调，以及你需要的任何部件。对，它就是做这个工作的。有想法的小伙伴们，可以打开百度，搜索一下LFS，跟着官方文档尝试一下。",
			"added": 1580628096,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580629574,
			"title": "Lisp神化之路",
			"body": "程序员在谈论不同编程语言的相对优劣时，其口吻就像是在说别在工具腰带上的不同工具——这个适合系统编程，另一个更适合用于胶合其他程序来完成一些临时任务。这是理所当然的，编程语言各有所长，在脱离具体应用场景的情况下声称一个语言优于其他只会引起无益和恶意的争吵。\n\n然而有一个语言会引发普遍的尊崇：Lisp。要是有人胆敢声称某些语言优于其他语言，键盘侠们定然会开始攻击，如果说的是Lisp那就不同了。Lisp超越了所有用于评价其他语言的功利性标准，因为相当部分的程序员都没有用Lisp构建过实用的东西，很可能也永远不会用，然而对Lisp的尊崇依然深植于心并且认为Lisp有神秘的属性。深受喜爱的网络漫画，xkcd，至少有两次这样描画了Lisp：在其中一个漫画中，主人公在顿悟了Lisp后仿佛洞悉了宇宙的基本结构。在另一个漫画中，身着长袍的老程序员将一堆圆括号交给他的学徒，说圆括号是“文明时代的优雅武器”，暗示了Lisp具有神秘的原力。\n\n另有一个好玩的示例，就是Bob Kanefsky在1990年代中期戏仿歌曲“上帝生活在大地之上”，创作了“永恒的火焰”，描述了上帝是如何用Lisp创造世界的。下面是选段，完整的歌词可以在GNU幽默集中找到：\n\n\n    上帝在使用Lisp\n    当他用绿色填充树叶。\n    分形的花朵和递归的树根：\n    是我见过的最有趣的hack。\n    当我思考雪花时，\n    每一片都不同，\n    我知道上帝喜欢\n    这有四字符名字的语言。\n\n我认为，这种觉得“Lisp是神秘的魔法”的文化基因是非常奇特和有趣的事情。Lisp是作为一个人工智能研究的工具在象牙塔里构建出来的，因而对于外行来说显得不熟悉和神秘。然而现在的程序员奉劝别人在死之前尝试一下Lisp，仿佛那是一种让人脑洞大开的致幻剂。事实上Lisp是当今还在广泛使用的第二古老的编程语言了，仅仅比Fortran年轻一岁。试想如果你的工作推广新的编程语言，能让人相信该语言具备神秘力量岂不是很棒。怎么做到呢？一个编程语言如何能成为一种隐秘知识被大家熟知？\n\nLisp是如何走到这一步的呢？\n\n理论A：公理语言\n\nJohn McCarthy，Lisp的创造者，起初没有刻意使得Lisp成为计算原理的一个优雅馏化物。然而在经历了一系列的精炼后，Lisp就成型了。Paul Graham——后面会提到他——这样写道，使用Lisp，McCarthy“对编程做的事情就好像是欧几里得对几何学做的事情”。人们能在Lisp中发现深层的含义，原因就是McCarthy使用了最基本的部件构建了Lisp，这些基本部件与其说是他发明还不如说是他发现的。\n\nMcCarthy在1956年关于人工智能的达特茅斯夏季研究项目期间开始考虑创建一个编程语言。夏季研究项目是一个持续多周的学术会议，人工智能领域的先驱。McCarthy当时是达特茅斯的数学助理教授，事实上“人工智能”这一词汇也是他首次提出的。有十个人左右参与了会议。其中有Allen Newell和Herbert Simon，两位研究员分别隶属于RAND公司和卡内基梅隆大学，后者刚设计了一个语言叫IPL。\n\nNewwell和Simon已经开始着手创建一个能从命题逻辑中生成证明的系统。他们意识到在计算机原始指令的层次开展工作是很困难的，于是决定创建一个语言——或者按照他们称呼的那样“伪代码”——可以帮助他们更自然的表达关于“逻辑理论机”的工作成果。IPL代表“Information Processing Language”，即“信息处理语言”，该语言相比如今的编程语言来说更像是一个高级汇编方言。Newwell和Simon，可能是参照了Fortran，留意到其他正在开发的“伪代码”语言都想用标准的数学符号表示等式。他们的语言则专注于使用符号化的表达式列表来表示命题逻辑中的句子。IPL程序基本是使用一系列的汇编语言宏来操作和求值这些列表中的表达式。\n\nMcCarthy认为在语言中添加Fortran类型的代数表达式是很有用的。所以他不是很喜欢IPL。然而他认为符号列表是建模人工智能领域问题的好方法，特别是涉及到推导的问题。这启发了McCarthy创建一个代数列表处理语言的想法，该语言既像Fortran同时又能像IPL处理符号列表。\n\n当然，今天的Lisp不像Fortran。在接下来的几年里，McCarthy关于理想的符号处理语言的想法在演化。他的想法在1957年开始改变，当时他开始用Fortran编写棋类程序的子例程。长期使用Fortran的经验使他意识到其设计中存在很多错误，最主要的就是笨拙的IF语言。McCarthy发明了替代品，那就是真值条件表达式，如果条件测试成功返回子表达式A反之则返回子表达式B并且仅仅对返回的子表达式求值。1958年夏天，当McCarthy在设计一个微分程序时，他意识到真值条件表达式使得编写递归函数更简单更自然。微分问题也促使McCarthy设计了maplist函数，该函数接受另一个函数作为参数并将其应用于列表中的每个元素。This was useful for differentiating sums of arbitrarily many terms.\n\n这些事情都不能用Fortran来表达，所以在1958年秋天，McCarthy分配一些学生来实现Lisp。这个时候McCarthy已经是MIT的助理教授了，所以这些都是MIT的学生。在McCarthy和学生们将他的想法转变为代码的时候，他们又进一步简化了语言。最大的改变就是Lisp的语法。在McCarthy最初的想法中，该语言包含了一种称为“M表达式”的东西，这是一个使得Lisp的语法像Fortran的语法糖层。即使M表达式可以被转化为S表达式——Lisp闻名的圆括号列表——S表达式事实上是针对机器的一种低级表示。问题是McCarthy指定M表达式使用方括号，然而当时McCarthy小组在MIT使用的键控穿孔器键盘没有方括号这个键。因此Lisp小组被迫使用S表达式来表示数据列表和函数调用。McCarthy和学生们还做出了其他一些简化，包括切换到前缀表示法和可变的内存模型，这意味着语言只有一种真实的类型。\n\n1960年，McCarthy发表了他关于Lisp的著名论文“符号表达式的递归函数及其机器计算”。当时的Lisp经过修剪使得McCarthy意识到他创造一个“优雅的数学系统”而不仅仅是另一个编程语言。他后来写道，多次简化使得Lisp成为一种描述可计算函数的方式，该方式比图灵机或者递归函数理论中使用的通用递归定义更简练。在论文中，他展示了Lisp可以同时作为一种工作的编程语言和研究递归函数行为的形式工具。\n\nMcCarthy向读者阐述Lisp的方式是使用一个很小的规则集合来构建一个Lisp系统。Paul Graham后来在他的文章“Lisp之根”中重复了McCarthy的步骤，不过使用了可读性更高的语言。Graham可以仅仅使用七个基本运算符，两个函数的表示法，以及半打根据基本运算符定义的高阶函数来解释Lisp。Lisp可以使用一系列很少的基本规则来定义的特点无疑加深了其神秘性。Graham认为McCarthy的论文目的是使“计算公理化”。这的确可以认为是Lisp具有吸引力重要原因。其他语言中有明显的由关键字指示的人造构件，例如while或typedef或public static void，而Lisp的设计完全来自运算的逻辑需求。系统的质量再加上和“递归函数理论”等深奥领域的原始连接无疑使得Lisp在今天如此有声望。\n理论B：未来的机器\n\n在Lisp诞生后二十年，著名的黑客字典说Lisp已经成为了人工智能研究的“母语”。前期Lisp迅速流行大概是因为其规整的语法很容易在新的机器上实现。后来的研究者继续使用Lisp是因为在人工智能的符号时期能很好的处理符号表达式是很重要的。Lisp被用在了一些开创性的人工智能项目，如SHRDLU自然语言程序，Macsyma代数系统以及ACL2逻辑系统。\n\n在1970年代中期，人工智能研究已经开始耗尽计算机的运算能力了。PDP-10机器——人工智能领域工作人员的最爱——具有18位的寻址空间，已经不再能满足Lisp的AI程序的需求了。许多AI程序需要的交互性对于分时系统来说也是个挑战。MIT的Peter Deutsch开始提出解决方案，那就是专门为Lisp程序制造计算机。这些Lisp机器，正如我在上一篇文章中描述的，可以给每个用户分配一个针对Lisp优化过的处理器。这样对于硬核Lisp程序员来说，他的工作环境就全部是Lisp写成的。在小型机时代末尾和全面开花微型机革命之前的尴尬时机设计的Lisp机器，当时成为了编程精英们的高性能个人计算机。\n\n当时看来Lisp机器可能是未来的潮流。出现了好几个公司竞相对其进行商业化。这些公司中最成功的当属由MIT的AI实验室成立的Symbolics。1980年代，Symbolics生产了3600系列的计算机，在AI领域和其他需要高性能计算的产业广受欢迎。3600系列计算机具有这些特性，大屏幕，位图图形，鼠标接口，强大的图形和动画软件。的确是强大的机器才能支持强大的程序。例如，从事机器人研究的Bob Culley通过Twitter联系我，说可以在1985年的Symbolics 3650上实现并可视化寻路算法。他向我解释道，位图图形和面向对象编程（Lisp机器通过Flavors扩展实现）在1980年代是很新的技术。Symbolics走在时代前沿。\n\n结果是Symbolics机器出奇的贵。1983的Symbolics 3600要花费110000美元。因此大部分的人对强大的Lisp机器只有羡慕的份。Byte杂志在1979年到1980年代末尾都在报道Lisp和Lisp机器。在1979年8月的Lisp特刊中，杂志编辑大力吹捧说MIT的新机器拥有“惊人的内存”和“先进的操作系统”。该机器如此有前途，以致Apple II，Commodore PET和TRS-80相形见绌。5年后的1985年，Byte杂志的一位作者描述了如何给“超级计算机Symbolics 3670”编写Lisp程序并且敦促读者学习Lisp，他还宣称Lisp不仅仅是“AI领域人士的语言”而且很快会成为一个通用编程语言。\n\n关于人们是从何时开始觉得Lisp是天赐之物的问题，我向山景城的计算机历史博物馆的Paul McJones讨教，他做了很多Lisp相关的保存工作。他认为语言的固有属性无疑与之有关，然而他同时表示Lisp和1960s到1970s强大的人工智能应用的紧密联系也促成了这点。当1980年代Lisp机器可以购买了的时候，MIT和斯坦福之外的一些人也能领略到Lisp的强大了，因而传奇继续。Lisp机器和Symbolics在今天已经很少有人知道了，但是他们将Lisp的神秘延续到了1980年代尾声。\n\n理论C：如何编程\n\n在1985年，MIT的教授Harold Abelson和Gerald Sussman联同Sussman的妻子，Julie Sussman，出版了一本书“计算机程序的构造和解释”。该书使用一个Lisp方言Scheme教导读者编程。这本书在MIT的编程导论课上使用了20年。我觉得SICP（书名简称）加深了Lisp的“神秘因子”。SICP使用Lisp阐述了计算机编程艺术中的一些深邃甚至充满哲学意味的概念。这些概念是通用的，其实使用任何语言都可以，然而SICP的作者选择了Lisp。结果就是Lisp的声望随着这本优秀的书进一步增强，迷住了一代代的程序员。Lisp原本一直是“McCarthy优雅的形式论”；如今“这个语言也可以向你传达编程的奥义”。\n\n仔细想想SICP其实是很怪异的，因为我觉得该书的怪异和Lisp的怪异在今天已经融合了。首先这本书的封面就很怪异。上面描画了一个男巫或炼金术士靠近一个桌子，准备施展法术。他的一个手里拿着卡尺或是罗盘，另一个手拿着一个刻着“eval”和“apply”字样的球状物。对面的妇女拿手指着桌子；在背景上有个希腊字母lambda漂浮在半空，发着光。\n\n谁能告诉我这是在干嘛？为什么桌子长着动物的脚？妇女为什么指着桌子？球状物上的文字是何意？男巫是否已经解开宇宙的奥秘，奥秘是否蕴含在“eval/apply”循环和lambda演算中？看起来是这样的。单单这幅图片就极大的塑造了今天人们谈论Lisp时的基调。\n\n书中的内容也很奇怪。SICP不像其他你读过的计算机科学书籍。作者在书的前言中写道，该书不仅仅是关于使用Lisp编程——它关注了三种现象，人类心智，计算机程序集合以及计算机。后面详细说明了他们的信念，那就是编程不应该被看作是计算机科学的学科而应该看作是“过程认识论”的一种新的表示方法。程序是组织思维的新方式只是恰好也可以给计算机运行。第一章简要介绍了Lisp，之后的大部分内容都是抽象的概念。里面由关于不同编程范式的讨论，关于面向对象系统中“时间”和“本体”的本质，以及通信的根本限制造成的同步问题，类似相对论中的光速限制。都是干货呀。\n\n并不是想说这本书不好。事实上这本书很棒。它从一个很高的层次讨论编程概念，这些概念我一直找不到合适的语言来描述。让人惊奇的是一本编程导论书可以很快就进入对面向对象编程根本不足的讨论，以及函数式语言最小化可变状态带来的好处。更让人叹为观止的是接着讨论了流范式，类似于当今的RxJS，该范式可以各取所长。SICP提取了高阶编程设计的本质，使人回想起McCarthy的Lisp论文。你读了这本书后也应该推荐给你的程序员朋友；如果他们看了封面就不读了，留给他们的印象就是神秘的“eval/apply”在长着兽脚的桌子前施展魔法。\n\n可能SICP最重大的贡献就是将Lisp从让人好奇的事物提升到了教育必需品。在SICP之前就有人说学习Lisp能让人在程序设计方面更优秀。1979年的Byte杂志就是证明。鼓吹MIT新Lisp机器的编辑同样也解释说这个语言值得学习，因为它“代表了一种分析问题的不同视角”。然而SICP不是将Lisp以其他语言的衬托展示出来的；SICP将Lisp用作了编程入门语言，暗示Lisp是掌握计算机编程基础的最优秀的语言。今天的程序员告诉他人在死之前尝试一下Lisp，这些都归功于SICP。毕竟Brainfuck语言按说也提供了“分析问题的不同视角”。但是人们还是会选择学习Lisp，因为二十多年来MIT都将Lisp在一开始就教授给学生，说明Lisp的视角是很有用的。\n\nLisp归来\n\n在SICP发表的同一年，Bjarne Stroustrup发表了第一版C++程序设计语言，给大伙带来了面向对象编程。几年之后，Lisp机器的市场萎缩AI寒冬来临。在接下来的十几年，C++和Java成为了未来的语言Lisp则遭到冷遇。\n\n很难说人们从什么时候开始重新对Lisp产生兴趣的。有可能是在Y-Combinator联合创始人和Hacker News创始人，Paul Graham发表了一系列有影响力的文章后，这些文章里面力推Lisp是初创公司最好的开发语言。在他的文章“拒绝平庸”中，Graham强调是Lisp宏使得Lisp比其他语言更加强大。他声称自己在创业Viaweb时使用了Lisp，因此他可以比竞争者更快的开发特性。至少有些程序员被鼓动了。但是大部分的程序员并没有切换到Lisp。\n\n如今越来越多的Lisp特性被加入到大家使用的编程语言中了。Python有了列表comprehensions。C#有了Linq。Ruby有了…，好吧，Ruby就是一种Lisp。就像Graham早在2001年的时候就提到，“嵌入到这些后续流行语言的默认语言，正在逐渐变成Lisp”。即使其他语言都是逐渐变成Lisp，Lisp本身却依然保留它专属的声望，作为一个很少人理解同时每个人都应该学的神秘语言。1980年，Lisp的20周年纪念日上，McCarthy写道Lisp已经活得够长了，它占用了“某种编程语言空间中的近似局部最优”。这真的是低估Lisp的真正影响力了。Lisp活了超过半个世纪，因为程序员不得不承认，十年又十年，Lisp依然是工作的最好工具。事实上，即便大多数的程序员根本不用它，Lisp还是活着的。得益于它的起源和在人工智能中的应用以及SICP的遗留，Lisp继续使人们着迷。直到我们能想象上帝创世使用了一种新语言，Lisp将长存。",
			"added": 1580629561,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580630141,
			"title": "Lisp与JAVA的酷毙结合——abcl",
			"body": "最近看了一本叫做《黑客与画家》的书，其中对于Lisp语言大加褒奖。自己试着用了一下，虽然确实有反人类之嫌，但是确实是一门不错的语言，New Architect杂志上有一篇介绍ITA软件公司的文章，里面说\"一行Lisp代码相当于20行C代码\"。Lisp的强大，从中就可见一斑了。另外，Lisp还有理论上最高的计算能力。还有一个笑话是这么讲的：“任何C或Fortran程序复杂到一定程度之后，都会包含一个临时开发的、不合规范的、充满程序错误的、运行速度很慢的、只有一半功能的Common Lisp实现。\"\n\n     但是Lisp是一种解释性语言，不能直接执行。所以，将其嵌入一个稳定的框架是个不错的选择。Java与Lisp就可以这样整合，其接口有很多，但我认为abcl（Armed Bear Common Lisp）是最好的选择，这个接口的性能表现是我觉得最优的。与其说它是一个接口，不如说是一个JAVA上的Common Lisp实现。本文将分两部分讲述，其一是怎么在JAVA里调用Lisp，其二是怎么在Lisp里调用JAVA，这有助于提高Lisp的扩展性。\nPart One 在JAVA里用Lisp:\n\n　　首先要安装abcl。在abcl官网下载其binary版本。解压出abcl.jar后，把它移动到jdk\\lib目录下。并在环境变量CLASSPATH后加上一段话：%JAVA_HOME%\\lib\\abcl.jar（假设JAVA_HOME已经设置，指向jdk目录）。这样，abcl就算是安装好了。（与那些需要编译的C++库，安装过程简直太简单了，--我不是在吐槽boost！）\n\n      安装完毕后，就可以使用此接口了。在JAVA里用Lisp时，通常不把Lisp源码硬编码在JAVA程序中，而是另外建一个.lisp文件，在其中写上一些函数。这样易于修改，也不会致使你的JAVA源代码又臭又长！（想象一下，把Lisp源码以行为分割，打在方法的参数里，程序实在是太美观了）要加载外部的Lisp程序，可以这么做：\n\n　　　　Interpreter interpreter = Interpreter.createInstance();\n\n　　　　interpreter.eval(\"(load \\\"my-lisp-code.lisp\\\")\");\n\n　　“my-lisp-code.lisp”是外部lisp文件的文件名。那么加载后，怎么调用这段Lisp代码中的程序呢？首先，我们要得到一个abcl的Package：\n\n　　　　org.armedbear.lisp.Package defaultPackage = Packages.findPackage(\"CL-USER\");\n\n　　在这个package里，我们要寻找Lisp代码中的函数，假设该函数叫做lispfunction，那么，代码应该这样写：\n\n　　　　Symbol myFunctionSym=defaultPackage.findAccessibleSymbol(\"LISPFUNCTION\");\n\n　　根据这个Symbol对象，我们可以创建一个Fucntion对象并且运行，这里假设目标函数没有输入参数：\n\n　　　　Function myFunction=(Function)myFunctionSym.getSymbolFunction();\n　　　　myFunction.execute();\n\n　　如果有参数呢？只要在execute中类似正常函数传参的方式，按次序写入参数即可。但要注意的是，不能直接填写，而要new一个JavaObject后传入，且Lisp代码中要用(jobject-lisp-value x)来转换。\n\n　　如果又返回值呢？execute本来返回一个LispObject，可以通过其各种成员方法转换成相应的类型。\n\n　　下面给出一个官方提供的例子，实现两个数的加法运算：点此下载\nPart Two 在Lisp里用JAVA：\n\n　　第一步依然是安装。提前声明：而且本部分的内容基于Part One。\n\n　　通常的实现模式是按上面的方法在JAVA里调用Lisp，并且传入一个类。在Lisp里，通过一系列的转换，然后就可以调用了。\n\n　　这里主要讲Lisp里的代码实现，JAVA部分只要写好函数，然后还需要在调用过程里这么写：\n\n　　　　myFunction.execute(New Class1());\n\n　　这就是传入的参数了，是一个类的实例。例如这个类有一个成员函数：addTwoNumbers(a,b)——表示两个数相加的和，a与b均为int类型，返回值也是int类型。传入后，在Lisp部分应该这么写(传入的参数为param)：\n\n  (let* ((class (jclass \"Main\"))\n\t (intclass (jclass \"int\"))\n\t (method (jmethod class \"addTwoNumbers\" intclass intclass))\n\t (result (jcall method param 2 4)))\n    (format t \"in void-function, result of calling addTwoNumbers(2, 4): ~a~%\" result)))\n\n　　其实很简单，在使用时，可以遵循此模式，先转换JAVA中的类型，再计算。\n\n　　给出官方提供的例子代码：点此下载 \n附录:\n\n　　这里讲些题外话,像abcl的运行速度,其他的Lisp->JAVA接口及如何打开abcl并把其作为一个外部独立运行的实现以学习Lisp的方法.\n\n　　速度：许多Lisp用户就是奔着它有着理论上最高的运行速度去的。根据实验测试发现，其运行时间分两部分，分别是预载和实际计算。获取解释器实例（预载）时比较慢，命令行下为5-6s，Eclipse下更长。实际计算时间倒是在可以接受的范围内。\n\n　　独立外部实现：下载了abcl.jar并且安装后，可以这样来运行它，将其作为一个外部的解释器——学习Lisp：\n\n　　　　java -jar abcl.jar\n\n　　另外的Lisp->JAVA接口现在概括如下：\n\n　　　　1.abcl不支持Android，但目前仍在持续开发中，不排除2.0版本会对Android进行支持。\n　　　　2.ecl支持Android，看github上的进度很久没有commit了，所以不建议优先考虑，但是这个接口还支持C语言。\n　　　　3.clojure的Android支持性比较好，有nightcode这个集成的IDE，而且比较流行。\n　　　　4.mocl，一个收费的common lisp的Android接口，具体性能也无法评定。",
			"added": 1580630127,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580631323,
			"title": "Smalltalk学习笔记",
			"body": "所有一切都是物体（Everything is an Object）。这是Smalltalk中最重要的一条规则。\n    一个变量没有与之关联的类型。变量仅仅指向物体\n    a := 2的真正含义不是“将a的值设置为整数2”，而是“让变量a指向一个值为2的SmallInteger(小整数)物体”\n    所有的计算都通过消息（message）来触发。你向某个物体发送消息，然后就会发生某些事情。\n    (15 * 19) + (37 squared)可以理解为：向15发送消息 * ，参数为19；向37发送消息squared；最后向15*19的结果发送消息 + ，参数为37 squared的结果。\n    Smalltalk中所有的表达式都是<接受消息的物体> <消息>\n        消息激发方法。一个消息会对应什么方法是由接受消息的物体决定的。\n        每条消息（to: do:, whileTrue:, +）都会激发方法，这些方法是Smalltalk中的代码单元，你可以认为方法就是你常用的编程语言中的函数或者过程。方法是计算发生的地方。。你不仅可以查看它们的控制结构和操作是如何实现的——而且还能改动它们！\n    每一个物体都是某类事物的一个实例。\n        由于该类（事物）中定义了此实例（物体）的行为，所以必须找到这个接受消息的物体所属于的类，然后通过类来指出应该如何解释收到的消息。这一点非常重要。 (代码的位置，高层和底层视角的切换 很微妙)\n    类是定义方法（行为）的地方，决定了物体是否有某种能力（能执行某个动作），所有代码都能在类中找到,没有魔术\n    Smalltalk中没有什么要记住的关键字（甚至没有if，你可以自己实现）！使用Smalltalk，就像用小积木，能让你搭建出你想要的任何东西。\n        在Smalltalk语言中没有条件语句，取而代之的是一些发送给对象true或者false的消息，因此它们不属于语言部分，而属于Smalltalk的类库；也没有循环重复语句（C语言中的for, while），Smalltalk用向数字对象或块对象发送消息来实现重复执行。\n    语言没有固定的语法，语法分析由类本身完成\n    Smalltalk是一种使用“晚绑定（late-binding”的语言，让相同的消息在不同的数据上执行近似的功能成为多态。当你看到一个printString消息时，你实际上并不知道将会执行什么，直到你了解这个消息被发送给哪个物体后，才能清楚到底会执行什么内容\n    从smalltalk这里学习对象，从lisp那里学习函数\n    面向对象编程的精髓在于将行为绑定在数据上\n    在结构化程序设计之中，我们将精力集中在行为（动词）上，然后弄清楚我们需要哪些数据（名词）才能执行。总而言之，我们将数据绑定在行为上。但在面向对象程序设计之中，我们将程序的中心用名词和数据表示，然后弄清楚我们要将哪些行为绑定在他们之上\n    Smalltalk和Scheme都非常优美纯粹，一致性非常好，相比之下，主流工业语言有些大杂烩，不少由于妥协导致的不一致，以及难以理解\n    严格遵照一个唯一标准机制的做法已经被证明具有惊人的威力\n    学习纯粹的语言，能让你更容易搞懂核心概念，而不会被各种枝节分神，而这些概念是大多编程语言的核心",
			"added": 1580631308,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580631827,
			"title": "我所知道的ZSH",
			"body": "1. 什么是 ZSH\n\n介绍在这里：http://macshuo.com/?p=676\n\ncat /etc/shells\n\n如果你想试试别的Shell，推荐你试一下 Fish，这里有阮一峰老师的一篇教程, 不过需要注意的是，由于 Fish 的语法与 Bash 有很大差异，Bash 脚本一般不兼容。因此，建议不要将 Fish 设为默认 Shell。\n2. 什么是 Oh-My-Zsh\n\nGithub: https://github.com/robbyrussell/oh-my-zsh\n\nWindows 下，如果你是用的是 Cygwin，那么你是无法通过 chsh -s /bin/zsh 这种方式修改默认终端的，你需要在 .bashrc 下添加一行代码：\n\nbash -c zsh\n\n当然，如果你懒得折腾，可以试试 Babun 或者 Hyper ……\n\n如果你用的 WSL，那么你把 Windows 升级到最新版本就没有问题了。\n\n如果你一直只用 Windows Git 自带的 Git Bash，就可以不用往下看了……",
			"added": 1580631811,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580633449,
			"title": "linux死机后的安全重启",
			"body": "有时系统负载过大，程序不能及时响应，很容易死机。个人用户强行关机再重启就OK。但是对于需要全天工作提供服务的服务器来说，强行关机不仅会导致服务器停止工作，同时造成未同步的数据丢失。\n解决方法\n\n    如果在图形界面下死机，可以按ctrl+alt+F2（F1－F6一般都可以）切换到文字界面，这样会切换到另外一个虚拟终端，需要一个账号来登入，进入后用top命令查看进程表，等待进程信息表刷新一两次，就可以确定占用资源比较大的进程了，然后输入q退出，回到终端内，把占用资源比较大的进程kill掉，这样可以解决相当一部分问题。最后按ctrl+alt+F7回到图形界面。\n\n    但有的时候是比较底层的软件出现问题，上面的方法就不适用了。下面介绍一下reisub方法。说具体一点，是一种系统请求，直接交给内核处理。键盘上一般都有一个键，SysRq，它和PrintScreen在一个键位上，这就是系统请求的键。这个方法可以在死机的情况下安全的重启计算机，数据不会丢失。\n\n\n使用方法\n\n按住alt和SysRq键的同时，再输入reisub,输入完b之后，系统自动重启。\n指令说明\n\n按住art和SysRq键时，输入的一切都会直接交给Linux内核来处理。\nreisub中的每一个字母都是一个独立操作，他们分别表示：\nAlt+SysRq+R 把键盘从X手中夺过来\nAlt+SysRq+E 终结所有进程\nAlt+SysRq+I 强制关闭所有进程\nAlt+SysRq+S 同步所有挂载的文件系统\nAlt+SysRq+U 重新挂载苏有的文件系统为只读\nAlt+SysRq+B 重启",
			"added": 1580633432,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580636507,
			"title": "维护一个linux发行版有多难？",
			"body": "",
			"added": 1580636489,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580637370,
			"title": "专业运维维护的linux论坛有哪些？",
			"body": "",
			"added": 1580637351,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580639429,
			"title": "linux软件推荐专贴",
			"body": "大家可以提交软件",
			"added": 1580639409,
			"parent_topic_uri": "1577266958_1DcbdcgJk7mw465FGxYHMkz9zgyNgvpsWY"
		},
		{
			"topic_id": 1580642289,
			"title": "新手编程练习",
			"body": "99乘法表\n四则运算（逆波兰表达式）",
			"added": 1580642268,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580643638,
			"title": "给LISP初学者介绍下SLIME这个好东西",
			"body": "假期抽空看了些SLIME的文档和源代码，随便写点感受，主要给LISP的初学者看的，因为这些对老鸟们来说都是老生长谈了。下面内容有些杂乱，主要是自己的学习笔记。\n\n*SLIME 是一个革命性的开发工具*。它的重要性将在未来几年内逐渐被主流开发界所认识（主流总是很迟钝）。任何其他编程语言，如果不能实现SLIME的功能，则不能称之为“高级语言”。\n\nSLIME是： The Superior Lisp Interaction Mode for Emacs 的缩写。\nSLIME 的官方网站： http://common-lisp.net/project/slime/\n各种文档，介绍在上述网站中都有。这个网站看上去很out。但，不要被外表欺骗。它里面的开发技术与理念非常的领先前卫。\n\nSLIME是 Emacs 与 Common LISP之间的桥梁，是开发环境与运行环境之间的桥梁。\n\n我个人认为SLIME最重要的一点意义在于：它强调了快速迭代式的开发方式。首先要了解这一点，然后SLIME的各种特性都是为这一点服务的。这其实一直是LISP的开发方式。\n\nSLIME支持远程开发与热升级，之前在我的blog上写过一篇文章介绍： http://www.feime.net/lisp%E5%88%A9%E5%99%A8/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E4%B8%8Ehot-update/\n\nSLIME的特性包括：\n0. Emacs 的slime-mode 包括了lisp代码的编辑支持，代码执行，编译，宏展开，等等\n1. 在线文档\n2. REPL\n3. 交叉引用\n4. 调试\n5. Inspector\n等等。。\n\n===================\nSLIME 与 Emacs， LISP 之间的关系，可以通过下图表示： \nswank 是LISP下的server，emacs中的slime模块通过tcp连接上swank服务器。使用者在emacs中编写代码，发送命令，通过网络传递给lisp进程执行，然后返回结果。\n\n比如，最典型的：我们在emacs中编写了一段函数，然后调用 slime-compile-defun 命令（一般用快捷键 C-c C-c) ， 这段函数的代码就会发送给lisp进程，lisp进程最终调用compile命令将代码编译到进程内部，并返回执行结果，emacs获得结果显示。\n\n注意，我们可以重复定义一个函数，可以定义新的函数，而LISP进程是一直在那里的。你可以随时去执行任意的命令或函数。你可以将一大坨测试数据（甚至真实数据）load到LISP的进程中，然后随便折腾他们。\n甚至，你可以连接上一个远程运行的服务程序，修改里面的函数定义，或增加新的功能，而不用重启这个进程。这就是远程调试和热升级。\n\n======================\n下面演示一些 SLIME 的特性：注意，这些特性很多在LISP环境下都可以直接做到，例如宏展开，反汇编，调试等等，使用SLIME只是更方便而已。这里不严格区分是SLIME的功能还是LISP的功能，众所周知，SLIME自古以来就是LISP不可分割的一部分了，是LISP的固有领土。\n\n0. 想一边写代码，一边测试运行？\n没错，SLIME就是这么用的。",
			"added": 1580643616,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580644097,
			"title": "如果说lisp如此优美强大，为什么它没有得到广泛应用呢？",
			"body": "RT，lisp的思想的确很简洁优美，感觉性能也不会差，为什么主流的程序中看不到它的身影？",
			"added": 1580644074,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580645486,
			"title": "为什么使用Smalltalk ？",
			"body": "是什么让Smalltalk成为一种特殊而独特的编程语言？\n\n首先，它非常小巧简单。完整的语法适用于明信片！\n\naaa\n\n其次，它纯粹是面向对象的，反映了艾伦凯关于面向对象的卓越概念，我认为它是规范的。艾伦凯说，当他构思OOP时，他没有考虑C ++。\n\n艾伦凯说：\n\nSmalltalk是一个软件互联网\n与ARPA互联网理念并行：通过虚拟网络普遍连接的虚拟计算机\n只有对象（对象由对象构成，网络由对象构成等）\n（没有应用程序，没有文件系统，只是虚拟计算机的协同作用）\n语言是对象之间消息的语言\n有些对象充当了组合对象的地方\n物体可以在一个地方被观看并且彼此整合\n\n这个想法也直接激发了Erlang语言的设计，根据艾伦凯的观点，这种语言可以被正确地称为“面向对象”。\n\n一个对象非常像一台拥有自己的私有内部状态和通信协议的计算机。通过发送消息与对象通信。你要求一个对象通过发送一条消息来为你做一些事情，它就像网络中的真实计算机服务器那样响应。就像在一台真正的电脑服务器上一样，你并不知道它的内部状态。\n\n一个对象不是一个抽象数据类型\n\n…其中Abstract Data Type是一种数据结构类型的高价值术语。\n\n像Java和C ++这样的OOP语言是Alan Kay的OOP概念的混蛋。它们使OOP比它更难，而且对许多人来说，它是一个无尽的混乱之源。正如Robert C. Martin在“OOP vs FP”中所说的那样，对象是功能包，而不是数据包。对象不是数据结构。\n\n继承在Smalltalk中不是强制性的。您可以根据自己的编程解决方案使用合成或聚合。对遗传“缺陷”的任何歇斯底里就是：歇斯底里……和无知。作为一种工具，继承在许多情况下当然是适用和适当的，例如GUI编程。特别是如果你使用继承作为专门化的手段而不是代码重用。\n\n第三，它具有支持实时编码的内置IDE，这有助于使Smalltalk成为世界上最高效的编程语言。借助实时编码，您可以在运行时轻松更改程序代码！\n\n第四，它是完全反思的，具有很好的元编程功能。阅读“Lisp，Smalltalk和对称的力量”。\n\nSmalltalk程序能够在运行时检查自己的结构和计算。这赋予了巨大的权力，允许程序用新的类和方法扩展自己，或者询问“谁把这个消息发给我？”\n\n计算反射用于实现处理错误的有效方法。当一个对象被发送了一个它并没有实现的消息时，它会收到一个doesNotUnderstand：消息，以及原始消息的一个具体化。程序可以用doNotUnderstand：消息做很多事情，包括用新功能扩展自己！\n\n第五，它是基于图像的，它赋予许多独特的优点，例如可移植性和持久执行上下文。 Smalltalk图像允许您随时保存程序的执行状态，并在稍后从停止的地方继续执行！这与VMware和VirtualBox等操作系统虚拟化软件中的系统镜像非常相似。这也与Web浏览器的DOM或Excel电子表格的工作方式类似。\n\n第六，它完全支持lambdas，这也使得Smalltalk在功能编程方面非常出色！\n\n单独来说，这些东西并不是独一无二的，但它是协同的整体，使得Smalltalk成为历史上最卓越的编程语言之一。\n\n谁使用Smalltalk？\n\n你会感到惊讶。\n\nCincom，Instantiations和GemTalk是Smalltalk的主要供应商。他们之间有许多知名企业用户：\n\n    JPMorgan\n    Desjardins\n    UBS\n    Florida Power & Light\n    Texas Instruments\n    Telecom Argentina\n    Orient Overseas Container Lines\n    BMW\n    Siemens AG\n\n仅举几个。在我的国家，Smalltalk被加拿大国家密码学机构通信安全机构（CSE）使用。\n\nPharo是二十一世纪现代化的Smalltalk，也有着名的用户，例如：\n\n    ALLSTOCKER\n    ATMs in Moscow streets\n    LAMRC\n    FINWorks\n    YesPlan\n\nSmalltalk的多功能性？\n\nSmalltalk是无尽的多才多艺：\n\n    Smalltalk对数据科学和数值计算非常有用，这要归功于PolyMath和Roassal（同时参见Pharo的Numerical Methods）\n    Smalltalk适用于物联网和机器人技术\n    Smalltalk适用于ERP（企业资源规划）\n    Smalltalk适用于机器学习和神经网络处理\n    Smalltalk适合自然语言处理\n    Smalltalk适合虚拟现实（例如3D Immersive Collaboration）\n    Smalltalk正在用来对抗埃博拉病毒！\n    Smalltalk用于16个国家的药物大规模数据可视化\n    Smalltalk可用于使用Apache Cordova编写前端Web应用程序和跨平台移动应用程序\n    由于采用了Seaside web框架和Teapot微型框架，Smalltalk对服务器端Web开发非常有用\n\n而我只是几乎没有抓到表面！\n结论\n\n那么，什么阻止你回来？给Smalltalk一个尝试。它可能永远改变你的编程观点。",
			"added": 1580645462,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580645715,
			"title": "一位Smalltalk 程序员眼中的开发和部署",
			"body": "多年前，我曾是一名 Smalltalk 程序员，这种经验让我以一种不同的视角来观察编程的世界，例如，需要花时间来适应源代码应该存储在文本文件中的这种做法。\n\n我们作为程序员通常会区分“开发”和“部署”，特别是我们在开发的地方所使用的工具不同于我们在之后部署软件时的地点和工具时。而在 Smalltalk 世界里，没有这样的区别。\n\nSmalltalk 构建于虚拟机包含了你的开发环境（IDE、调试器、文本编辑器、版本控制等）的思路之上，如果你需要修改任何一处代码，你得修改内存中运行副本。如果需要的话，你可以为运行中的机器做个快照；如果你想分发你的代码，你可以发送一个运行中的机器的镜像副本（包括 IDE、调试器、文本编辑器、版本控制等）给用户。这就是上世纪 90 年代软件开发的方式（对我们中的一些人来说）。\n\n如今，部署环境与开发环境有了很大的不同。起初，你不要期望那里（指部署环境）有任何开发工具。一旦部署，就没有版本控制、没有调试、没有开发环境。有的是记录和监视，这些在我们的开发环境中都没有，而有一个“构建管道”，它将我们的软件从开发形式转换为部署形式。作为一个例证，Docker 容器则试图重新找回上世纪 90 年代 Smalltalk 程序员部署体验的那种简单性，而避免同样的开发体验。\n\n我想如果 Smalltalk 世界是我唯一的编程方面的体验，让我无法区分开发和部署环境，我可能会偶尔回顾一下它。但是在我成为一名 Smalltalk 程序员之前，我还是一位 APL 程序员，这也是一个可修改的虚拟机镜像的世界，其中开发和部署是无法区分的。因此，我相信，在当前的时代，人们编辑单独的源代码文件，然后运行构建管道以创建在编辑代码时尚不存在的部署作品，然后将这些作品部署给用户。我们已经以某种方式将这种反模式的软件开发制度化，而不断发展的软件环境的需求正在迫使我们找回到上世纪 90 年代的更有效的技术方法。因此才会有 Docker 的成功，所以，我需要提出我的建议。\n\n我有两个建议：我们在运行时系统中实现（并使用）版本控制，以及，我们通过更改运行中的系统来开发软件，而不是用新的运行系统替换它们。这两个想法是相关的。为了安全地更改正在运行的系统，我们需要一些版本控制功能来支持“撤消”功能。也许公平地说，我只提出了一个建议。让我举例来说明。\n\n让我们开始假设一个静态网站。你要修改一些 HTML 文件。你应该如何工作？如果你像大多数开发者一样，你会有两个，也许三个网站 - 一个用于开发，一个用于 QA（或者预发布），一个用于生产。你将直接编辑开发实例中的文件。准备就绪后，你将把你的修改“部署”到预发布实例。在用户验收测试之后，你将再次部署，这次是生产环境。\n\n使用 Occam 的 Razor，让我们可以避免不必要地创建实例。我们需要多少台机器？我们可以使用一台电脑。我们需要多少台 web 服务器？我们可以使用具有多个虚拟主机的单台 web 服务器。如果不使用多个虚拟主机的话，我们可以只使用单个虚拟主机吗？那么我们就需要多个目录，并需要使用 URL 的顶级路径来区分不同的版本，而不是虚拟主机名。但是为什么我们需要多个目录？因为 web 服务器将从文件系统中提供静态文件。我们的问题是，目录有三个不同的版本，我们的解决方案是创建目录的三个不同的副本。这不是正是 Subversion 和 Git 这样的版本控制系统解决的问题吗？制作目录的多个副本以存储多个版本的策略回到了版本控制 CVS 之前的日子。为什么不使用比如说一个空的的 Git 仓库来存储文件呢？要这样做，web 服务器将需要能够从 git 仓库读取文件。\n\n这将是一个支持版本控制的运行时系统。\n\n使用这样的 web 服务器，使用的版本可以由 cookie 来标识。这样，任何人都可以推送到仓库，用户将继续看到他们发起会话时所分配的版本。版本控制系统有不可改变的提交； 一旦会话开始，开发人员可以在不影响正在运行的用户的情况下快速推送更改。开发人员可以重置其会话以跟踪他们的新提交，因此开发人员或测试人员就可能如普通用户一样查看在同台服务器上同一个 URL 上正在开发或正在测试的版本。作为偶然的副作用，A/B 测试仅仅是将不同的用户分配给不同的提交的情况。所有用于管理多个版本的 git 设施都可以在运行环境中发挥作用。当然，git reset 为我们提供了前面提到的“撤销”功能。\n\n为什么不是每个人都这样做？\n\n一种可能性是，诸如版本控制系统的工具没有被设计为在生产环境中使用。例如，给某人推送到测试分支而不是生产分支的许可是不可能的。对这个方案最常见的反对是，如果发现了一个漏洞，你会想要将某些提交标记为不可访问。这将是另一种更细粒度的权限的情况；开发人员将具有对所有提交的读取权限，但外部用户不会。我们可能需要对现有工具进行一些额外的改造以支持这种模式，但是这些功能很容易理解，并已被设计到其他软件中。例如，Linux （或 PostgreSQL）实现了对不同用户的细粒度权限的想法。\n\n随着云环境变得越来越普及，这些想法变得更加相关：云总是在运行。例如，我们可以看到，AWS 中等价的 “文件系统”（S3）实现了版本控制，所以你可能有一个不同的想法，使用一台 web 服务器提供来自 S3 的资源文件，并根据会话信息选择不同版本的资源文件。重要的并不是哪个实现是最好的，而是支持这种运行时版本控制的愿景。\n\n部署的软件环境应该是“版本感知”的原则，应该扩展到除了服务静态文件的 web 服务器之外的其他工具。在将来的文章中，我将介绍版本库，数据库和应用程序服务器的方法。",
			"added": 1580645690,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580645842,
			"title": "为什么Lisp语言值得学习？",
			"body": "Lisp通常与括号重的语法相关联，比如说\n\n（定义（！n）\n（if（= n 0）\n1\n（* n（！（ – n 1）））））\n\n虽然原始Lisp的发明者约翰麦卡锡实际上没有想到这种编程符号。 可以说这种符号发明了它 – 它实现起来要简单得多，并且比McCarthy最初想到的语法包含更少的偶然复杂性，并且其他语言如C ++或Perl引入。\n\n当然，单独实施的简易性并不是一个令人信服的论据，简单性和缺乏偶然的复杂性。 事实证明，这不仅是表达程序的一种非常好的方式，而且是一种非常好的序列化数据格式：上述程序可以看作是树结构或嵌套列表列表。\n\n我们可以使用一些其他流行的树序列化格式来表达相同的结构，例如XML，这会给我们类似的东西\n\n它肯定看起来很疯狂，或者不是吗？ 有趣的是，XML符号只给我们很多冗余，实际上很难为人类阅读（在我看来，XML的结构比Lisp的结构更难解码）。 难怪网络黑客决定使用JSON作为数据序列化格式，这将给我们提供类似的东西\n\n[“define”，[“！”，“n”]，\n[“if”，[“=”，“n”，0]，\n1，\n[“*”，“n”，[“！”，[“ – ”，“n”，1]]]]]\n\n这个阅读起来要好得多，但坦率地说，你不想用这种方式编写你的程序。 此外，这种格式没有提供Lisp变体没有的任何优点。\n\n另一方面，考虑用JavaScript表示的相同程序（这次是实际程序，而不是数据结构）：\n\nfunction factorial（n）{\nif（n == 0）\n返回1;\n其他\nreturn n * factorial（n-1）;\n}\n\n它可能比Lisp版本更容易阅读，因为我们大多数人都更习惯于这种程序。 但它确实有些令人讨厌的事情，即：它掩盖了自己的结构。\n\n可能很难看到这种行为的肮脏，因为我们已经习惯了UNIX带来的谎言，即“一切都是文件”（其中“文件”被宽泛地理解为字节序列）。 这种谎言在大多数现代系统中很普遍，例如Windows或OS X.\n\n有些计算机系统并非构建在这个谎言上。 其中一个是Smalltalk，其中**一切都是对象**（可以发送或接收消息的东西）和Lisp，其中**一切都是树**（注意，即使在UNIX中也有一个目录的概念，即不是文件的东西，它用于形成树结构）。\n\n这个谎言让人们相信你需要像解析器这样的东西（很多研究都投入了），编程语言本质上需要语法，而且在编写程序时，你需要能够产生语法错误并造成格式错误结构。 此外，它给人的印象是编写处理其他程序的程序很困难，虽然原则上它并不比编写遍历磁盘上的目录结构或爬网的程序困难（实际上就是这种情况，如果你是使用Lisp）。\n\n因此，如果我要给出学习Lisp的最重要的理由，那么它应该意识到语法并不重要，但是简单有力量。",
			"added": 1580645816,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580647998,
			"title": "什么是用户友好？",
			"body": "",
			"added": 1580647971,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580649861,
			"title": "linux桌面需要有哪些GUI 功能？",
			"body": "快捷键管理\n开机自启动管理\n换源\n切换语言\n**还原默认设置**\n**恢复默认配置文件**\n默认软件管理\n\n托盘支持",
			"added": 1580715704,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580649966,
			"title": "Linux下如何进入中文目录",
			"body": "给Linux安装图形用户界面之后，会在工作目录中生成图片, 文档, 下载........等中文目录，以前不知道如何进入这些目录，感觉也没有必要，今天在火狐上下载了一个软件，默认在下载这个目录当中，实在没办法进入到这个目录当中，后来发现可以通过复制粘贴来解决这个问题。",
			"added": 1580649937,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580651710,
			"title": "发行版是怎么管理不稳定的软件的？",
			"body": "debian：testing源\ngentoo：mask，不太好，混用源会造成依赖关系复杂\n其他：未稳定之前不会发布到仓库",
			"added": 1580651678,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580651751,
			"title": "linux需要做哪些定制？",
			"body": "[Linux下如何进入中文目录](http://127.0.0.1:43110/153Bqdxo4iNAfaqMMZJ9BJHHKSmvqxJ1NY/?Topic:1580649966_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X/Linux)\n换源\n中文语言\n中文输入法\n\n配置键盘背光\n\n配置快捷键：\nwin + E 文件管理器\nwin + D 显示桌面\n\n安装 zsh\n安装 thefuck\n安装 utools\n安装 下拉式终端\ntty 支持中文\ntty 中文输入法",
			"added": 1580715838,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580651859,
			"title": "完全生活在命令行里体验怎么样？",
			"body": "文件管理器：\nEmacs dired\nnnn 文件管理器",
			"added": 1580659388,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580659548,
			"title": "18个堪称神器的命令行工具，高效运维必备",
			"body": "thefuck\n\n命令行打错了以后，打一个fuck就会自动纠正。\n\n\n\nag\n\n比 grep、ack 更快的递归搜索文件内容\n\n\n\npm\n\n在 bash / zsh 中迅速切换项目目录\n\n\n\ntig\n\n字符模式下交互查看 git 项目，可以替代 git 命令。\n\n\n\nncdu\n\n可视化的空间分析程序。\n\n\nmycli\n\nmysql 客户端，支持语法高亮和命令补全，效果类似 ipython，可以替代 mysql 命令。\n\n\n\njq\n\njson 文件处理以及格式化显示，支持高亮，可以替换 python -m json.tool。\n\n\n\nshellcheck\n\nshell脚本静态检查工具，能够识别语法错误以及不规范的写法。\n\n\n\nyapf\n\nGoogle 开发的 Python 代码格式规范化工具，支持 pep8。\n\n\n\nmosh\n\n基于UDP的终端连接，可以替代 ssh，连接更稳定，即使 IP 变了，也能自动重连。\n\nfzf\n\n命令行下模糊搜索工具，能够交互式智能搜索并选取文件或者内容，配合终端 ctrl-r 历史命令搜索简直完美。\n\n\n\nPathPicker(fpp)\n\n在命令行输出中自动识别目录和文件，支持交互式，配合 git 非常有用。\n\n\n\nglances\n\n更强大的 htop & top 代替者。\n\n\n\naxel\n\n多线程下载工具，下载文件时可以替代 curl、wget。\n\n\n\nsz/rz\n\n交互式文件传输，在多重跳板机下传输文件非常好用，不用一级一级传输。\n\n\n\ncloc\n\n代码统计工具，能够统计代码的空行数、注释行、编程语言。\n\n\n\nccache\n\n高速C/C++编译缓存工具，反复编译内核非常有用。使用起来也非常方便.\n\n\n\nyou-get\n\n非常强大的媒体下载工具。",
			"added": 1580659513,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580660093,
			"title": "linux包管理器名字太长怎么办？",
			"body": "",
			"added": 1580660107,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580722045,
			"title": "好的操作系统应该做到什么？",
			"body": "尽量少的打扰，避免分心",
			"added": 1580722060,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580722681,
			"title": "关于操作系统一致性",
			"body": "",
			"added": 1580722643,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580722726,
			"title": "关于编程语言一致性",
			"body": "",
			"added": 1580722687,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580723332,
			"title": "你最长使用过linux多长时间?",
			"body": "",
			"added": 1580723292,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580723354,
			"title": "linux发展回忆录",
			"body": "",
			"added": 1580723313,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580723698,
			"title": "# linux软件管理",
			"body": "软件包管理器的职责\n将二进制程序，库文件，配置文件，帮助文件打包成一个文件；\n安装软件时按需将二进制文件，库文件，配置文件，帮助文件放到相应的位置；\n生成数据库，追踪所安装的每一个文件；\n软件卸载时根据安装时生成的数据库将对应的文件删除\n\n\n软件包管理器的核心功能\n制作软件包\n安装软件\n卸载软件\n升级软件\n查询软件\n校验软件\n\n\n软件包管理\n程序的组成清单（每个包独有）\n- 文件清单\n- 安装或卸载时运行的脚本\n数据库（公共）\n程序包名称及版本\n依赖关系\n功能说明\n安装生成的各文件的文件路径及校验码信息\n\n\n软件包分类\n二进制格式（编译好的，装上就可以用）\nrpm包作者下载源程序，编译配置完成后，制作成rpm包\nwhy would we do that? because：\n有些特性是编译时选定的，如果编译时未选定此特性，将无法使用\nrpm包的版本会落后于源码包，甚至落后很多\n源码格式（需要编译，也叫定制）\n命名方式：name-VERSION.tar.gz\nVERSION：major.minor.release\n\n\n软件包管理工具\n分类\n前端工具，常用的前端工具有以下这些\nyum\napt-get （ubuntu）\nzypper（suser上的rpm前端管理工具）\ndnf （Fedora 22 + rpm前端管理工具）\n后端工具，常用后端工具有以下这些：\n-rpm\ndpt\n注意：\n前端工具是依赖于后端工具的\n前端工具是为了自动解决后端工具的依赖关系而存在的\n\n软件安装方式\n通过前端工具安装\n通过后端工具安装\n编译安装\nrpm包命名规范\n包的组成\n主包：bind-9.7.1-1.el5.i586.rpm\n子包：bind-libs-9.7.1-1.el5.i586.rpm\nbind-utils-9.7.1-1.el5.i586.rpm\n包名格式\nname-version-release-arch.rpm\nbind-major.minor.release-release.arch.rpm\n包名格式说明\nmajor（主版本号）：重大改进\nminor（次版本号）：某个子功能发生重大变化\nrelease（发行号）：修正了部分bug，调整了一点功能\n常见的arch\nx86：i386，i486，i586，i686\nx86_64：x64，x86_64，amd64\n跟平台无关：noarch",
			"added": 1580723656,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		}
	],
	"topic_vote": {},
	"next_comment_id": 109,
	"comment": {
		"1580516650_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 1,
				"body": "一个主题就是一个发行版",
				"added": 1580516680
			},
			{
				"comment_id": 2,
				"body": "作为一个 Linux 老用户，自然有用得顺手的Linux发行版本。但 GNU/Linux 有太多发行版，对于新手们来说经常不知所措，有时候只是单纯地看颜值和外观设计，今天特地挑选整理了10个颜值较高的 Linux 发行版（2017-2018版）。",
				"added": 1580516702
			},
			{
				"comment_id": 3,
				"body": "1、elementary OS\n\n官方网站：https://elementary.io/\n\n上榜理由：\n\n    类macOS的外观\n    轻量级、高效的桌面环境\n    精选好用的软件集\n\n除开 Linux Mint 和 Zorin OS，elementary OS 差不多开源说是最流行的基于 Ubuntu 的发行版了，它号称是”快速和开放“版的 macOS 和 Windows，在众多的 Linux 发行版中， elementary OS 主要关注非技术用户和那些刚刚开始进入开源世界的开发者新手，也因此它的开发也是从一系列的为 Ubuntu 设计的主题和 apps 开始，这也让 elementary OS 的起点并不低。\n\n这个漂亮的 Linux 发行版从 macOS 借鉴了一些技巧和元素，给用户提供了一种很棒的体验，elementary OS 并没有搭载一些在 Ubuntu 上常见的软件，取而代之的是一些更轻量级的替代品，比如说，它使用的图形桌面环境是 Pantheon，一种轻量级桌面，保证你电脑的轻快，如果是你不习惯 GNOME 和 Unity 的桌面，那么你可以试试 elementary OS。",
				"added": 1580516728
			},
			{
				"comment_id": 4,
				"body": "2、Zorin OS\n\n官方网站：https://zorinos.com/\n\n上榜理由：\n\n    类 Windows 界面及操作，Windows 用户上手容易\n    用户基数较大，社区支持不错\n    实在是漂亮\n\nZorin OS 在2017年底刚刚庆祝它的第一百万个下载，它被大众最为熟知的特点就是拥有与 Windows 高度相似的图形界面，并且默认配置了不少桌面特效。用户对其的第一印象基本上是漂亮、符合传统 Windows 的使用习惯。对于想从 Windows 跳槽过来，应该很顺手。它的漂亮，你但看下面一个磁盘分析小工具就知道了。\n\nZorin OS 的上游发行版是 Ubuntu，它除了长得像 Windows，而且使用上也可以很 Windows，内置了 Wine，能支持很多 Windows 下的应用软件，自带了常用的办公娱乐应用。该发行版的终极目标是提供一份可作为 Windows 替代的 Linux 选择，并让 Windows 用户在避免烦琐的同时享受到 Linux 的所有优点。",
				"added": 1580516766
			},
			{
				"comment_id": 5,
				"body": "3、KDE Neon\n\n官方网站：https://neon.kde.org/\n\n上榜理由：\n\n    最新的 KDE 套件\n    稳定的 Ubuntu LTS 基版本\n    流畅、稳定、漂亮的扁平化桌面\n\n如果你是 KDE 的忠实用户，而你想找一个漂亮又好用的搭载 KDE 的 GNU/Linux 发行版，那么，不必多找，KDE Neon 就很适合你。KDE Neon 是基于 Ubuntu LTS 长期支持版打造的，得益于官方的支持，往往会提供最新的 KDE 版本以及 KDE 软件套装。KDE Neon 的开发者们的设计也非常赞，他们非常熟悉如何掌控扁平化设计的主题，大量方便好用的小控件可以添加到桌面上，还有直观的、用户友好的应用程序菜单，流畅度也是不在话下，开源工场有不少小伙伴就在使用 Neon。",
				"added": 1580516795
			},
			{
				"comment_id": 6,
				"body": "4、Deepin Linux\n\n官方网站：http://www.deepin.com\n\n上榜理由：\n\n    大量创新功能\n    对一些中国软件的良好支持\n    极佳的视觉体验\n    安装简单、方便\n\nDeepin 是一款国内的 Linux 发行版，为用户提供了一个美观易用的界面，还基于 Qt 技术开发了深度桌面环境和深度控制中心。深度操作系统有着简单好用的体验和美观的设计，也很好安装，作为普通用户，能够使用深度系统代替 Windows 系统工作与娱乐。此外，它自带的 Deepin Store 也提供了不少应用程序。\n\n深度操作系统的历史可以追溯到 2004 年，其前身是 Hiweed Linux ，在 2008 年更名为深度操作系统。目前在国内乃至全球都有了不少用户，如果你想追求美观易用又可以方便地和官方工作人员沟通，那么试试深度倒是不错。",
				"added": 1580516827
			},
			{
				"comment_id": 7,
				"body": "5、Nitrux\n\n官方网站：https://nxos.org/\n\n上榜理由：\n\n    可以自己定制应用\n    极度简约的漂亮桌面\n\nNitrux 是一个很新的系统，在很多“最漂亮的 Linux 发行版榜单”中可能都是最新的一个，你看到它的第一眼可能就会觉得这正是你脑子里想的那种设计，Nitrux 基于 Ubuntu 的不稳定开发分支来构建的，所以 Ubuntu 的所有优点一并具有，同时尽力保持一个干净简单的用户环境，它的桌面环境是 Nomed 桌面环境，一个基于 KDE Plasma 5 的桌面环境，同时也包含 KDE 软件集。",
				"added": 1580516853
			},
			{
				"comment_id": 8,
				"body": "6、feren OS\n\n官方网站：http://ferenos.weebly.com/\n\n上榜理由：\n\n    有开始菜单\n    扁平化设计\n    现代化的外观\n    对新手友好\n    提供 Wine，方便运行 Windows 程序\n\nferen OS 是一个基于 Linux Mint 的桌面 Linux 发行版，Linux Mint 本来就是公认的非常漂亮的发行版，常年位居 DistroWatch 关注榜第一名，feren OS 和 Linux Mint 就好比，林月云已经很漂亮了，她的女儿侯佩岑…比妈妈更处于蓝而胜于蓝。feren OS 定制开发的 Cinnamon 桌面环境使得它成极具视觉吸引力。在易用性上，它还提供了与 macOS 和 Windows 操作系统相似的使用体验。\n\nferen OS 的外观初看起来会感觉十分熟悉，因为它有一个类似 Windows 或者 GNOME 2 时代的“开始”按钮和任务栏，不仅仅外观相似，feren OS 还包含可运行 Windows 应用程序的 Wine 兼容层。所以 feren OS 是给用户的体验是既熟悉又创新的。",
				"added": 1580516884
			},
			{
				"comment_id": 9,
				"body": "7、Pop!_OS\n\n官方网站：https://system76.com/pop\n\n上榜理由：\n\n    新奇的外观\n    舒缓的视觉外观，眼睛舒服\n    专为计算机领域的创意工作者设计\n\nPop!_OS 同样是一个非常年轻的操作系统，它是 Linux 笔记本电脑厂商 System76 推出的 Linux 发行版，诞生在 Canonical 决定放弃 Unity 重投 GNOME 怀抱的时候。整个系统欧冠你是基于 Ubuntu 和 GNOME 桌面环境而开发，希望能为用户提供个性化且新鲜的使用体验。\n\n虽然基于 GNOME 桌面环境，但 System76 会对用户界面、驱动等内容进行个性化定制，具有现代化和简洁的外观，更好地控制用户体验。Pop!_OS 出发点和功能重点是针对专业用户，让 Linux 桌面变得更具生产力，成为工程师、开发人员以及计算机科研领域的好帮手。如果你用 GNOME，但是对 GNOME 还不够满意，并且是把 Linux 作为工作所用（办公或者编程），那么毫不犹豫值得一试。",
				"added": 1580516909
			},
			{
				"comment_id": 10,
				"body": "8、Solus OS\n\n官方网站：https://solus-project.com/\n\n上榜理由：\n\n    增长最快的新发行版之一\n    Budgie 桌面环境\n    支持 Snaps\n\n市面上有很多流行的发行版的衍生版，但是 Solus OS 似乎并不想这么做，在很短的一段时间内，Solus OS 几乎是成长最快和最酷的 Linux 发行版，它遵循着极简主义的设计理念，创造出了一种扁平化而现代化的外观。在 Budgie 桌面环境的加持下，Solus OS 甚至被评论为最令人惊叹的 Linux 发行版。Budgie 是一个构建在 GNOME 基础之上的桌面环境，但是不支持 GNOME Shell，它有一个很方便的开始菜单，同时还在桌面的右侧直接放置一些小挂件和通知等等，简单易用好上手，除此之外，Solus OS 最近还增加了对从 Ubuntu Snappy Store 派生而来的 Snaps 的支持。",
				"added": 1580516934
			},
			{
				"comment_id": 11,
				"body": "9、Maui Linux\n\n官方网站：https://mauilinux.org/\n\n上榜理由：\n\n    基于 KDE Neon 构建，也包含一些非 KDE 的优秀软件\n    够小众，用户数超少\n\nMaui Linux 诞生于 2016 年，不是一个很有名的发行版，用户数量也很少，它的 Twitter 粉丝也只有可怜巴巴的100来个，但是界面的漂亮确实有水准的，整个系统基于 KDE Neon 构建，包含了 KDE Plasma 5，KDE 软件集、Frameworks 以及 Qt 库，同时也包含了一些非 KDE 软件，比如 Frefox、VLC、Thunderbird，它的最新 release 是 Maui 17.06。",
				"added": 1580516953
			},
			{
				"comment_id": 12,
				"body": "10、openSUSE\n\n官方网站：https://www.opensuse.org\n\n上榜理由：\n\n    主流发行版，用户庞大，社区支持优异\n    来自 SUSE 公司的保障，系统稳定好用\n    历史悠久的老牌发行版，久经考验\n\n大名鼎鼎的 openSUSE 可以说是主流发行版中最好看的了，其和 KDE 深厚的渊源也确保了系统稳定可靠好用，不少 KDE 的核心开发者都是 SUSE 的员工，也都同是德国人，有种一种德式特有的严谨和科技美感。\n\n现时的 openSUSE 分为 openSUSE Leap 和 openSUSE Tubleweed；Leap 是传统的 release，而 Tubleweed 则是滚动更新的版本，可以说是分别满足了求稳和求新两种需求。加上独有的 YaST 管理工具，可以说是非常适合“系统管理员、开发者和桌面用户”了。",
				"added": 1580516973
			}
		],
		"1580517434_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 13,
				"body": "DDE\n\n优点：\nWin + E 快捷键\n\n缺点：\n控制面板和通知中心混在一起\n换源界面没有ubuntu的软件更新器好\n深度终端会丢失焦点\n",
				"added": 1580517712
			},
			{
				"comment_id": 14,
				"body": "UKUI 3.0\n\n没用过",
				"added": 1580517766
			},
			{
				"comment_id": 15,
				"body": "MATE\n\n排名第2的桌面环境是MATE。MATE是一种从现在无人维护的GNOME 2代码库派生出来的桌面环境。它以南美植物巴拉圭茶命名。使用新名称而不是使用GNOME避免了与GNOME 3组件冲突。MATE出自一名不满的用户之手，他不喜欢Gnome 2换成Gnome外壳以更新桌面。\n\nMATE让人觉得在使用旧的桌面环境，但是结合了历年来界面方面的诸多改进。MATE还非常适用于低配计算机，所以如果你有一台旧的或速度较慢的计算机，可以使用MATE。\n\nMATE还是许多流行的Linux发行版随带的，比如Ubuntu、Linux Mint、Mageia、Debian及另外更多发行版。Ubuntu MATE头一回是官方版本。\n\n“欢迎首次发布的Ubuntu MATE官方版本。现在，用户将更容易更新软件，因为所有组件现在都在Ubuntu软件库中。”\n\nMATE自带的应用程序包括：Caja（文件管理工具）、Pluma（文本编辑工具）、Atril（文档查看工具）、Eye of MATE（图像查看工具）及另外许多程序。如果用户不需要其他功能完备的桌面环境的所有额外功能，那么MATE对他们来说是一款简单的轻量级桌面环境。\n\n优点：\n\n· 与旧的/速度较慢的计算机很好地兼容\n\n· 轻量级桌面环境\n\n缺点：\n\n我不知道有啥缺点。要是你知道，欢迎留言。MATE用起来实在太棒了。",
				"added": 1580517859
			},
			{
				"comment_id": 16,
				"body": "Gnome\n\n排名第4的桌面环境是Gnome。Gnome于1999年首次发布。Gnome提供了一种简单而经典的桌面体验，没有太多的选项需要定制。不过在2011年，Gnome在GNOME 3中采用了新的设计，那种传统的桌面体验换成了GNOME外壳。而最后这让Gnome用户和许多开发人员很不满意，这种不满导致了另外许多桌面环境的问世，比如MATE和Cinnamon。\n\n但即使在那之后，Gnome大行其道，现在仍在广泛使用。Gnome含有桌面环境要简单、运行更快速的核心思想，这就是为什么Gnome仍然很简单、运行更快速。而定制可以通过安装第三方应用程序和工具来实现。\n\nGnome可能适合往往不经常调整系统的那些用户。这就是为什么Gnome甚至不包括一些简单的调整选项，比如更改主题、甚至更改字体。就这两种基本的调整而言，用户就需要安装gnome调整工具。所以，总的来说，Gnome在默认情况下不是具有很高的可定制性，但可以通过第三方应用程序/工具来实现。\n\nGnome用作Fedora中的默认桌面环境，提供在几款流行的Linux发行版中，比如Ubuntu、Debian、OpenSUSE和另外许多发行版。\n\n优点：\n\n· 简单、易于使用\n\n· 可通过插件来扩展功能\n\n缺点：\n\n· 缺少其他桌面环境拥有的许多功能\n\n· 插件管理很差",
				"added": 1580519301
			},
			{
				"comment_id": 17,
				"body": "Unity\n\nUnity是由开发Ubuntu的公司Canonical开发的一款外壳。Unity在Gnome桌面环境上运行，使用所有核心的Gnome应用程序。\n\n开发它的初衷是在上网本上运行，以便更充分地利用宝贵的屏幕空间。但是Gnome决定走自己的路，不接受Ubuntu团队提议的一些变化后，Canonical甩开步子，开发了自己的外壳，它更适合其要求。\n\nUnity的第一个版本于2010年发布；自那以后，Unity已得到了数次改进。如今，与另外几款桌面环境一样，Unity也可以安装在其他发行版上。\n\nUnity使用不同的用户界面。Unity在左边有一个启动器；位于启动器顶部的是搜索图标，又叫“Dash”。在Dash上搜索文件时，不仅会给出来自硬盘的搜索结果，还会给出来自在线来源的搜索结果，比如Google Drive、Facebook、Picasa、Flick及其他。\n\nUnity还提供了隐藏启动器、触摸侧边栏就显示的选项。用户还可以调高/调低显示启动器菜单的灵敏度。\n\nUnity很简单、运行速度快，但Unity在系统设置下却没有定制桌面的太多选项。想安装主题及定制另外不同的选项，比如说系统菜单是否应该总是可见，或者“从启动器图标一次点击最小化”，用户需要安装第三方工具。CCSM和Unity Tweak Tool是面向Unity桌面环境的非常流行的定制工具。\n\n不像KDE，用户在Unity中没有阻止/禁用通知的选项。网上搜索一下，就有许多内容介绍“如何禁用Unity通知”。虽然可以禁用通知，但是对新用户来说难度很大。\n\n加上自动隐藏菜单，又缺少各大发行版的官方支持，Unity变得反而帮了大忙。\n\n优点：\n\n· 界面直观\n\n· 使用了平视显示器（HUD）等新技术\n\n· 可以由第三方应用程序来定制\n\n缺点：\n\n· 实施的通知机制很差劲\n\n· 用于定制的默认工具少得可怜\n\n· 不一致的用户界面",
				"added": 1580519352
			},
			{
				"comment_id": 18,
				"body": "KDE 是基于大名鼎鼎的 Qt 的，最初于 1996 年作为开源项目公布，并在 1998 年发布了第一个版本，现在 KDE 几乎是排名第一的桌面环境了。\n\n许多流行的 Linux 发行版都提供了 KDE 桌面环境，比如 Ubuntu、Linux Mint、OpenSUSE、Fedora、Kubuntu、PC Linux OS 等。\n\nKDE 和 Windows 比较类似，各位初学者相信都是 Windows 的用户，所以切换到 KDE 也不会有太大的障碍。\n\nKDE 允许你把应用程序图标和文件图标放置在桌面的特定位置上。单击应用程序图标，Linux 系统就会运行该应用程序。单击文件图标，KDE 桌面就会确定使用哪种应用程序来处理该文件。\n\nKDE 是所有桌面环境中最容易定制的。在其他桌面环境中，你需要几个插件、窗口组件和调整工具才可以定制环境，KDE 将所有工具和窗口组件都塞入到系统设置中。借助先进的设置管理器，可以控制一切，不需要任何第三方工具，就可以根据用户的喜好和要求来美化及调整桌面。\n\nKDE 项目组还还发了大量的可运行在 KDE 环境中的应用程序，包括 Dolphin（文件管理工具）、Konsole（终端）、Kate（文本编辑工具）、Gwenview（图片查看工具）、Okular（文档及PDF查看工具）、Digikam（照片编辑和整理工具）、KMail（电子邮件客户软件）、Quassel（IRC客户软件）、K3b（DVD刻录程序）、Krunner（启动器）等，它们都是默认安装的。\n\n对 KDE 优缺点的总结：\n\n    优点：KDE 几乎是最先进最强大的桌面环境，它外观优美、高度可定制、兼容比较旧的硬件设备\n    缺点：Kmail 等一些组件的配置对新手来说过于复杂。\n\nKDE connect",
				"added": 1580519963
			},
			{
				"comment_id": 19,
				"body": "XFCE 是一个轻量级的桌面环境，建立在 GTK 基础之上，被广泛的运用于各种 UNIX / Linux 发行版中。XFCE 非常小巧、轻便、高效，运行程序很快，对于一些比较老旧的机器、或是很少内存的机器是理想选择。以 XFCE 作为预设桌面的发行版有 Xubuntu 和 Manjaro 等。\n\nXFCE 融合了 UNIX 开发哲学中的“模块化”和“可重用性”的重要的思想。XFCE 包含了许多组件，这些组件可以单独安装，也可以应用于其他桌面环境。用户还可以选择 GNOME 等相关软件，按照自己的需求，定制出与众不同的桌面环境。",
				"added": 1580520020
			},
			{
				"comment_id": 20,
				"body": "LXDE，全名为 Lightweight X11 Desktop Environment，旨在提供全新轻量、快速的桌面环境，可在 Unix 以及如 Linux、BSD 等 POSIX 相容平台上运行。LXDE 的主要开发者来自台湾，包括名为 PCMan 的著名开源程序设计者洪任谕。\n\n不同于 Linux 的其他桌面环境，LXDE 组件依赖性极少，大多数组件可以独立运作，无需倚赖其它组件。LXDE 使用 OpenBox 作为其预设窗口管理器，并且希望能够提供建立在互相独立组件上的轻量级快速桌面环境。相较于功能强大与伴随而来的体积膨胀、占用资源，LXDE 更重视实用性和轻巧性，并且尽力降低其所耗的系统资源。虽然 XFCE 已足够轻巧，但 LXDE 更胜一筹。\n\nLXDE 的组件包括 PCManFM 文件管理器、LXLauncher 程序启动器、LXTerminal 终端、Leafpad 文字编辑器、Xarchiver 压缩管理器等。\n\nLXDE 的缺点是界面比较简陋，不够精美。",
				"added": 1580520051
			},
			{
				"comment_id": 21,
				"body": "Pantheon是一个简单、精心设计、类Windows和MacOS界面的桌面环境，用于Elementary OS（号称最美的Linux）。它提供用户一个干净有组织的桌面体验。由于立足于简洁性，Pantheon不提供太多的视觉特效功能。",
				"added": 1580520238
			},
			{
				"comment_id": 22,
				"body": "Budgie桌面源于SoLus Linux的桌面环境。Budgie最然是从头开发的，但是和GNOME工具栈高度兼容。它的用户体验非常好（特别是在Chrome OS平台下）",
				"added": 1580520250
			}
		],
		"1580405776_18xqjuBBjsq1QBTbwuUwf2q7pJk7weAAoN": [],
		"1577836120_1MityxAx6QVFTYWjzSJFc6nCX6eyT5W5yQ": [
			{
				"comment_id": 25,
				"body": "linux发行版元数据：\n\n官方网站\n发展规划\n发布日期\n发布周期\nISO 大小\nISO md5\n安装后大小\n是否支持中文语言\n是否预装了中文输入法\n是否有镜像源\n包数量\n支持多少桌面环境\n\n内核版本\nGLIBC 版本\n包管理器\ninit 系统\n窗口管理器\n显示管理器",
				"added": 1580632974
			},
			{
				"comment_id": 26,
				"body": "使用P2P分发文件，提高网络效率",
				"added": 1580523731
			},
			{
				"comment_id": 27,
				"body": "vim-qt 项目\nspf13-vim - Vim编辑器的终极版本\nSpaceVim\nSpaceEmacs",
				"added": 1580528056
			},
			{
				"comment_id": 29,
				"body": "天下不如意之事十之八九，明白这个道理就不会那么痛苦了",
				"added": 1580535127
			},
			{
				"comment_id": 30,
				"body": "信息整理\n更有耐心一点\n靠自己的能力解决linux问题",
				"added": 1580535900
			},
			{
				"comment_id": 31,
				"body": "尽力的活下去",
				"added": 1580536741
			},
			{
				"comment_id": 32,
				"body": "胆子小的人通常胆子都很大\n有文化的人胆子更大，因为知法犯法，知道会有多大的后果\n管不那么多了",
				"added": 1580538684
			},
			{
				"comment_id": 33,
				"body": "缓慢的节奏，让人不得不冷静下来思考\n没有时间去想无聊的事",
				"added": 1580538764
			},
			{
				"comment_id": 34,
				"body": "协调管理每个人的工作进度",
				"added": 1580538827
			},
			{
				"comment_id": 35,
				"body": "使用 appimage降低系统的依赖性",
				"added": 1580538907
			},
			{
				"comment_id": 36,
				"body": "搜索引擎有一个高级搜索功能",
				"added": 1580539351
			},
			{
				"comment_id": 37,
				"body": "最好文本编辑器：evil mode",
				"added": 1580539720
			},
			{
				"comment_id": 40,
				"body": "包转换工具",
				"added": 1580543779
			},
			{
				"comment_id": 41,
				"body": "没有网络安装功能的发行版连换源都不需要学习了\n努力学习会获得回报的快乐\n知识面的广度和深度\n要有想要改变命运的心",
				"added": 1580608923
			},
			{
				"comment_id": 42,
				"body": "HIPS是什么意思？\n\n答：HIPS是英语Host-based Intrusion Prevention System的首字母缩写，是主机入侵防御系统软件的综合性称呼，HIPS是系统安全发展的一种趋势，如果具备较为专业的计算机系统知识，就可以只使用HIPS软件，电脑上不需要安装杀毒软件。\nHIPS软件的作用，就是通过可定制的规则，监控系统中的文件运行，软件对文件的调用，以及程序对注册表的修改，达到允许或禁止本地程序的运行、注册表的读写操作、以及文件读写操作。\n\nHIPS软件有什么用？\n\n答：这方面软件很多，公认效果比较好，网友使用率较高的这类HIPS软件，包括DefenseWall、AppGuard(无汉化版)、Comodo(免费网友俗称毛豆)、Malware Defender(不支持64位系统)、Safe'n'Sec (简称SNS或犀牛)、ProSecurity(国产)EQSecure for System(国产)以及SandBoxie(沙盘)等。",
				"added": 1580546847
			},
			{
				"comment_id": 48,
				"body": "流量太贵了买不起，只能靠蹭网度日了",
				"added": 1580625766
			},
			{
				"comment_id": 79,
				"body": "顺其自然\n有的时候还是得折腾折腾的",
				"added": 1580636405
			},
			{
				"comment_id": 80,
				"body": "使用linux代表着无尽的折腾\nlinux有着舒服的命令行环境\nMacOS交互反人类，不过软件一致性好\nfreebsd一致性好\nwindows使用简单，一致性好，占用空间太大，不够安全",
				"added": 1580638178
			},
			{
				"comment_id": 81,
				"body": "统一系统管理脚本",
				"added": 1580642815
			},
			{
				"comment_id": 82,
				"body": "动脑过度了，大脑超载了，得歇一会儿\n忍得住孤独，享受孤独，生活本来就是孤独的",
				"added": 1580643245
			},
			{
				"comment_id": 88,
				"body": "lisp、smalltalk、plan9挺好玩的",
				"added": 1580644430
			},
			{
				"comment_id": 90,
				"body": "珍惜每一次的翻墙机会\n百度太难用了，搜索结果不准确",
				"added": 1580645334
			},
			{
				"comment_id": 95,
				"body": "Linux使用感想：\n还是商业发行版更人性化，更省事",
				"added": 1580650222
			},
			{
				"comment_id": 96,
				"body": "高速下载服务是依赖中心化服务器的，需要有一个去中心化备份\n如果linux 没有了软件仓库会怎么样？\nwindows 还有软件管家呢",
				"added": 1580653078
			},
			{
				"comment_id": 97,
				"body": "这个界面又黑又帅",
				"added": 1580653849
			},
			{
				"comment_id": 99,
				"body": "linux 是 依赖关系 和 冗余打包 + 去重文件系统 哪个好？\nwindows的方案是： 冗余打包 + 不支持去重的文件系统",
				"added": 1580654610
			},
			{
				"comment_id": 102,
				"body": "一切东西最终都必须要放下",
				"added": 1580715630
			},
			{
				"comment_id": 105,
				"body": "Caddy – 最简单的支持 HTTP/2 的网页服务器[Win/Mac/Linux]\nMari0 – 经典游戏的神级合体",
				"added": 1580723108
			},
			{
				"comment_id": 106,
				"body": "Qubes linux不能在虚拟机运行",
				"added": 1580723757
			},
			{
				"comment_id": 108,
				"body": "不是每一个人都对电脑感兴趣",
				"added": 1580725673
			}
		],
		"1580490967_18xqjuBBjsq1QBTbwuUwf2q7pJk7weAAoN": [
			{
				"comment_id": 28,
				"body": "这时候楼主就要判断问题出在什么地方，学会看系统日志，这些都是基本的技能。",
				"added": 1580532747
			}
		],
		"1580523665_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [],
		"1577266994_1DcbdcgJk7mw465FGxYHMkz9zgyNgvpsWY": [
			{
				"comment_id": 39,
				"body": "Q：emacs 为什么不能输入文字？\nA：因为默认开启了 evil mode",
				"added": 1580542703
			}
		],
		"1580547931_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 43,
				"body": "使用cat和EOF添加多行数据\n查看目录权限：ls -ld",
				"added": 1580561347
			}
		],
		"1579169992_1FfatX3G2z43rV6nc1F3koYtn8tmD5EVb6": [
			{
				"comment_id": 44,
				"body": "2020-1月\n\nWayland 1.18 Alpha 发布， Meson支持与连接共享\nSway 1.4 Wayland合成器发布，提供VNC支持\nWine 5.0 正式发布，多显示器和Vulkan 1.1支持\nFlatpak 1.6.1 发布，修复可以访问主目录之外文件的安全问题",
				"added": 1580560303
			},
			{
				"comment_id": 103,
				"body": "2020-2月\n\nTribler 7.4.0 发布，BitTorrent 客户端\nFrostWire 6.8.4 发布，P2P 文件共享软件",
				"added": 1580715925
			}
		],
		"1580611627_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 45,
				"body": "Manjaro、Chakra、Archbang、 antergos、ArchLabs、Namib linux、blackarch、arcolinux",
				"added": 1580612435
			}
		],
		"1580612519_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 46,
				"body": "sabayon、funtoo、Calculate、redcore linux、bedrock linux",
				"added": 1580612645
			},
			{
				"comment_id": 47,
				"body": "还可以chroot安装gentoo",
				"added": 1580612680
			}
		],
		"1580626532_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 49,
				"body": "Linux的历史\nPlan 9\nlisp machine\nfreebsd\nGNU项目\n&nbsp;  \n&nbsp;  \n《Linus Torvalds自传》\n《若为自由故:自由软件之父理查德·斯托曼传》\n《大教堂和集市》\n《黑客与画家》\n电影《操作系统革命-Revolution OS》\n完全使用linux工作 （王垠）\nunix痛恨者手册\n&nbsp;  \n&nbsp;  \n《ANSI Common Lisp》中文版\n《Unix高级编程》",
				"added": 1580629651
			},
			{
				"comment_id": 50,
				"body": "\nDistroWatch\n撸linux\nhttps://www.lulinux.com\n\n薄荷开源网",
				"added": 1580627538
			},
			{
				"comment_id": 51,
				"body": "vim\nemacs",
				"added": 1580627559
			}
		],
		"1580627995_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [],
		"1580627942_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 53,
				"body": "V语言简介\n\nV语言是一种静态类型的编译型编程语言，它与Go类似，也受到 Oberon、Rust、Swift语言的影响。\n\nV语言是一种非常简单的语言，阅读此文档将花费你大约半小时的时间来学习完几乎整个V语言。\n\n尽管很简单，但它为开发人员提供了很多动力。 任何你可以用其他语言完成的事情，你都可以使用V语言来做。\n\nV语言官网地址:https://vlang.io\n\nV语言Github地址:https://github.com/vlang/v",
				"added": 1580628195
			},
			{
				"comment_id": 54,
				"body": "Nim是一个新型的静态类型、命令式编程语言，支持过程式、函数式、面向对象和泛型编程风格而保持简单和高效。Nim从Lisp继承来的一个特殊特性--抽象语法树(AST)作为语言规范的一部分，可以用作创建领域特定语言的强大宏系统",
				"added": 1580628868
			},
			{
				"comment_id": 55,
				"body": "Rust\n一门赋予每个人构建可靠且高效软件能力的语言。 \n\n为什么选择 Rust?\n高性能\n\nRust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。\n可靠性\n\nRust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。\n生产力\n\nRust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具 —— 包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。",
				"added": 1580628976
			},
			{
				"comment_id": 56,
				"body": "Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C 相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。",
				"added": 1580629015
			},
			{
				"comment_id": 57,
				"body": "Erlang 是一种多用途编程语言，主要用于开发并发和分布式系统。它最初是一种专有的编程语言，Ericsson 使用它来开发电话和通信应用程序。",
				"added": 1580629111
			},
			{
				"comment_id": 58,
				"body": "易语言（EPL）是一门以中文作为程序代码编程语言，其以“易”著称，创始人为吴涛。易语言早期版本的名字为E语言。其最早的版本的发布可追溯至2000年9月11日。创造易语言的初衷是进行用中文来编写程序的实践，方便中国人以中国人的思维编写程序，并不用再去学习西方思维。易语言的诞生极大的降低了编程的门槛和学习的难度。从2000年以来，易语言已经发展到一定的规模，功能上、用户数量上都十分可观。",
				"added": 1580629152
			},
			{
				"comment_id": 59,
				"body": "Scala 是一门多范式（multi-paradigm）的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性。\n\nScala 运行在Java虚拟机上，并兼容现有的Java程序。\n\nScala 源代码被编译成Java字节码，所以它可以运行于JVM之上，并可以调用现有的Java类库。",
				"added": 1580629213
			},
			{
				"comment_id": 60,
				"body": "Kotlin 是一个用于现代多平台应用的静态编程语言 ，由 JetBrains 开发。\nKotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。\nKotlin已正式成为Android官方支持开发语言。",
				"added": 1580629256
			},
			{
				"comment_id": 61,
				"body": "Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy 代码能够与 Java 代码很好地结合，也能用于扩展现有代码。由于其运行在 JVM 上的特性，Groovy也可以使用其他非Java语言编写的库。",
				"added": 1580629295
			},
			{
				"comment_id": 62,
				"body": "Clojure是一种运行在Java平台上的 Lisp 方言，Lisp是一种以表达性和功能强大著称的编程语言，但人们通常认为它不太适合应用于一般情况，而Clojure的出现彻底改变了这一现状。如今，在任何具备 Java 虚拟机的地方，您都可以利用 Lisp 的强大功能。\n\n作为当今最主流的运算平台JVM，把函数式编程语言引入JVM也是很多人尝试的方向，Clojure就是其中之一。Clojure是一个在JVM平台运行的动态函数式编程语言，其语法接近于LISP语言，在JVM平台运行的时候，会被编译为JVM的字节码进行运算。",
				"added": 1580629376
			},
			{
				"comment_id": 63,
				"body": "[翻译] 正式宣布 .NET 5\n今天，我们宣布 .NET Core 3.0 之后的下一个版本将是 .NET 5 。这将是 .NET 系列的下一个重要版本。\n\n将来只会有一个 .NET ，您将能够使用它来开发 Windows，Linux，macOS，iOS，Android，tvOS，watchOS 和 WebAssembly 等等。\n\n我们将在 .NET 5 中引入新的 .NET API、运行时功能和语言功能。",
				"added": 1580629821
			},
			{
				"comment_id": 64,
				"body": "C# 是一个现代的、通用的、面向对象的编程语言，它是由微软（Microsoft）开发的，由 Ecma 和 ISO 核准认可的。\n\nC# 是由 Anders Hejlsberg 和他的团队在 .Net 框架开发期间开发的。\n\nC# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。\n\n下面列出了 C# 成为一种广泛应用的专业语言的原因：\n\n    现代的、通用的编程语言。\n    面向对象。\n    面向组件。\n    容易学习。\n    结构化语言。\n    它产生高效率的程序。\n    它可以在多种计算机平台上编译。\n    .Net 框架的一部分。",
				"added": 1580629909
			},
			{
				"comment_id": 65,
				"body": "微软宣布 PowerShell 7 全平台兼容，采用新的生命周期\n\n微软希望同一版本的 PowerShell 能在所有平台运行，以实现更好的跨平台兼容性。此外，微软将为 PowerShell 采用新的生命周期，发布 LTS（长期支持版本）和非 LTS 版本的 PowerShell 7，使其与 .NET Core 支持的生命周期紧密保持一致。",
				"added": 1580630060
			},
			{
				"comment_id": 66,
				"body": "Python是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。",
				"added": 1580630170
			},
			{
				"comment_id": 67,
				"body": "Perl 是 Practical Extraction and Report Language 的缩写，可翻译为 \"实用报表提取语言\"。\n\nPerl 是高级、通用、直译式、动态的程序语言。\n\nPerl 最初的设计者为拉里·沃尔（Larry Wall），于1987年12月18日发表。\n\nPerl 借用了C、sed、awk、shell脚本以及很多其他编程语言的特性。\n\nPerl 最重要的特性是Perl内部集成了正则表达式的功能，以及巨大的第三方代码库CPAN。",
				"added": 1580630206
			},
			{
				"comment_id": 68,
				"body": "PHP即“超文本预处理器”，是一种通用开源脚本语言。PHP是在服务器端执行的脚本语言，与C语言类似，是常用的网站编程语言。PHP独特的语法混合了C、Java、Perl以及 PHP 自创的语法。利于学习，使用广泛，主要适用于Web开发领域。",
				"added": 1580630237
			},
			{
				"comment_id": 69,
				"body": "JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。",
				"added": 1580630299
			},
			{
				"comment_id": 70,
				"body": "Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。",
				"added": 1580630335
			},
			{
				"comment_id": 71,
				"body": "Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。",
				"added": 1580630378
			},
			{
				"comment_id": 72,
				"body": "LISP语言(LISP，List Processing的缩写)是一种早期开发的、具有重大意义的表处理语言。它适用于符号处理、自动推理、硬件描述和超大规模集成电路设计等。特点是，使用表结构来表达非数值计算问题，实现技术简单。LISP语言已成为最有影响，使用十分广泛的人工智能语言。",
				"added": 1580630407
			},
			{
				"comment_id": 73,
				"body": "Smalltalk，被公认为历史上第二个面向对象的程序设计语言，和第一个真正的集成开发环境（IDE）。Smalltalk由艾伦·凯，Dan Ingalls，Ted Kaehler，Adele Goldberg等于70年代初在Xerox PARC开发。\nSmalltalk对其它众多的程序设计语言的产生起到了极大的推动作用，主要有：C++，C#，Objective-C，Actor，Java和Ruby等。90年代的许多软件开发思想得利于Smalltalk，例如设计模式、敏捷编程和代码重构等。",
				"added": 1580630441
			},
			{
				"comment_id": 74,
				"body": "Ruby是一种纯粹的面向对象编程语言。它由日本的松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）创建于1993年。\n\n您可以在 www.ruby-lang.org 的 Ruby 邮件列表上找到松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）的名字。在 Ruby 社区，松本也被称为马茨（Matz）。\n\nRuby 是\"程序员的最佳朋友\"。\n\nRuby 的特性与 Smalltalk、Perl 和 Python 类似。Perl、Python 和 Smalltalk 是脚本语言。Smalltalk 是一个真正的面向对象语言。Ruby，与 Smalltalk 一样，是一个完美的面向对象语言。使用 Ruby 的语法比使用 Smalltalk 的语法要容易得多。",
				"added": 1580630745
			},
			{
				"comment_id": 75,
				"body": "Haskell（发音为/ˈhæskəl/）是一种标准化的，通用的纯函数编程语言，有非限定性语义和强静态类型。它的命名源自美国逻辑学家哈斯凯尔·加里，他在数理逻辑方面上的工作使得函数式编程语言有了广泛的基础。在Haskell中，“函数是第一类对象”。作为一门函数编程语言，主要控制结构是函数。Haskell语言是1990年在编程语言Miranda的基础上标准化的，并且以λ演算为基础发展而来。这也是为什么Haskell语言以希腊字母“λ”（Lambda）作为自己的标志。Haskell具有“证明即程序、命题为类型”的特征。",
				"added": 1580631125
			},
			{
				"comment_id": 76,
				"body": "FORTRAN语言是Formula Translation的缩写，意为“公式翻译”。它是为科学、工程问题或企事业管理中的那些能够用数学公式表达的问题而设计的，其数值计算的功能较强。\nFORTRAN语言是世界上第一个被正式推广使用的高级语言。它是1954年被提出来的，1956年开始正式使用，直到2014年已有六十年的历史，但仍历久不衰，它始终是数值计算领域所使用的主要语言。",
				"added": 1580631157
			},
			{
				"comment_id": 77,
				"body": "Prolog(Programming in logic)是一种面向演绎推理的逻辑型程序设计语言，最早于1972年由柯尔麦伦纳(Colmeraner)及其研究小组在法国马赛大学提出。",
				"added": 1580631185
			},
			{
				"comment_id": 78,
				"body": "SHELL语言是指UNIX操作系统的命令语言，同时又是该命令语言的解释程序的简称。SHELL作为语言来说，它既是终端上的用户与UNIX操作系统会话的语言，又可作为程序设计的语言，所以Shell是用户与系统之间的接口，而且是一种比较高级、易被用户理解和使用的程序设计语言，它为用户提供了使用方便、功能强、又容易扩充的程序设计环境。",
				"added": 1580631475
			}
		],
		"1580643638_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 83,
				"body": "Slime 的意思是“Emacs 下优秀的 Lisp 交互式开发模式”。\n\n通过支持 Common Lisp 的交互式编程，Slime 扩展了 Emacs。所以的特性都基于 slime-mode，一个 Emacs 的 minor-mode，它为标准的 lisp-mode 提供补充。lisp-mode 为编辑 Lisp 源文件提供支持，而 slime-mode 则提供了与一个 Lisp 进程进行交互的功能，包括编译、调试、文档查找等等。\n\nslime-mode 开发环境效仿 Emacs 原生的 Emacs Lisp 环境。我们也从某些类似的系统（例如 ILISP）那里借鉴了一些，当然也包括我们自己的想法。\n\nSlime 由两部分组成：用 Emacs Lisp 写的用户界面，和用 Common Lisp 写的服务器端。这两部分通过套接字连接在一起，并且使用一个类似于 RPC 的协议通信。\n\n服务器端的 Lisp 主要是可移植的 Commom Lisp。所需要的跟特定 Lisp 实现相关的特性都由一个接口定义好，然后由不同的 Lisp 实现提供。这使得 Slime 非常容易移植。",
				"added": 1580643960
			}
		],
		"1580644097_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 84,
				"body": "无损原值的编程，虽然可以减少偏移，但占用空间也变大，所需资源也变多。——用lisper们常说的 某某宇宙飞船为例，这样的资源消耗，必然加大成本，增加空间存储，也增加宇宙射线干扰的可能性……可以说是弱点尽显。\n\n-restart用在编程调试不错，但这是和一般的静态语言对比的，静态语言没有交互环境，所以当然无法restart——其实一般操作系统会内置程序崩溃重启机制，算是弥补吧。\n几乎所有的动态语言。比如js啥的，都必然有这机制，lisp只不过可能是最先提出而已。\n\n最后，就是生态的问题了，目前js一统江湖之势，还是去学js吧，js设计思路是来自scheme。",
				"added": 1580644118
			},
			{
				"comment_id": 85,
				"body": "再比如“在线调试”这个经常被提到的所谓优点，除非是玩玩的系统，对于重要的系统，在现实中用这招的一般都是：把该系统当废品，死马当活马医，最后一博了。\n最稳妥的做法还是关机调试。\n\n宏系统：内建语言扩展机制，这个初看起来比较先进的，但一般的语言都有虚拟机或虚拟机镜像这一层，或者是框架，也就没啥好说是优势的了，费力搞了这么一层，别人没这么复杂，让用户自己搞定了，保持了语言核心的精简。\n\n格兰姆列的那9条，靠谱的也就几条：复杂的条件结构，递归，内名位系统，统一的程序语言表达方式，代码结构层次清晰。但这几条现代语言哪个不符合？\n\n当然， 有几条是js可以学习的，比如：元操作符设计很精妙，即时运行和编译运行机制融合得比较好。",
				"added": 1580644146
			},
			{
				"comment_id": 86,
				"body": "lispworks 好！",
				"added": 1580644164
			},
			{
				"comment_id": 87,
				"body": "面相切面编程 AOP",
				"added": 1580644328
			},
			{
				"comment_id": 89,
				"body": "continuation（延续，在Scheme中有支持，在Common Lisp中可以用CPS或者特定的库来实现有限的支持）\n在19世纪70年代，一个特殊的lisp方言诞生了，这个方言的特性就是所谓的continuation。这种技术让你可以在代码中进行时间旅行，意思就是它能让你的代码回溯到以前的状态。这种特性在不确定性编程中非常有用。在不确定性编程中，你的代码可能会面对多种选择去做一件事，如果尝试了某种选择后发现不适合，那么这种技术可以让你的代码回溯到以前的状态并且尝试另一种选择。（优点：在你的代码中进行时间旅行常常是非常有吸引力的，这可以让你的代码非常易于理解。缺点：continuation是如此优秀的特性，甚至它连缺点都没有，真正的缺点是它会让语言的设计者头疼，因为这种特性太难以实现了，所以少有语言支持这种方法，而Scheme恰好是其中之一。）",
				"added": 1580645114
			}
		],
		"1580645842_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 91,
				"body": "lisp代码很容易格式化，但是 python - - -\npython是一个防止抄袭的编程语言",
				"added": 1580647437
			},
			{
				"comment_id": 92,
				"body": "领域特定语言（英语：domain-specific language、DSL）指的是专注于某个应用程序领域的计算机语言",
				"added": 1580647660
			},
			{
				"comment_id": 93,
				"body": "一、什么是AST\n\n抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。\n\n二、AST有什么作用\n\n抽象语法树在很多领域有广泛的应用，比如浏览器，智能编辑器，编译器等。在JavaScript中，虽然我们并不会常常与AST直接打交道，但却也会经常的涉及到它。例如使用UglifyJS来压缩代码，bable对代码进行转换，ts类型检查，语法高亮等，实际这背后就是在对JavaScript的抽象语法树进行操作。",
				"added": 1580647704
			}
		],
		"1580649966_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 94,
				"body": "方法一：复制粘贴\n方法二：切换中文输入法\n方法三：把目录改成英文",
				"added": 1580649950
			}
		],
		"1579577309_1FfatX3G2z43rV6nc1F3koYtn8tmD5EVb6": [
			{
				"comment_id": 98,
				"body": "既然各个Linux发行版的文件布局都不同，那么软件为什么能正常运行呢？",
				"added": 1580653990
			}
		],
		"1580651710_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 100,
				"body": "关于新版本软件和仓库依赖关系的问题",
				"added": 1580654918
			},
			{
				"comment_id": 101,
				"body": "最好的发行版\n要么全管依赖关系：NixOS、GuixSD\n要么不管依赖关系：Slackware、LFS\n或者捆绑依赖",
				"added": 1580655796
			}
		],
		"1580722726_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 104,
				"body": "lisp就没有python 2/3的区别 【因为它都没更新过】",
				"added": 1580725348
			}
		],
		"1580639429_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 107,
				"body": "Sublime Text 是一个轻量、简洁、高效、跨平台的编辑器\nVisual Studio Code - 微软出品\nNotepadqq是一套纯文字编辑器，与Notepad++非常相似。\n\n",
				"added": 1580724785
			}
		]
	},
	"comment_vote": {
		"29_1FfatX3G2z43rV6nc1F3koYtn8tmD5EVb6": 1
	}
}