{
	"next_topic_id": 109,
	"topic": [
		{
			"topic_id": 1580798434,
			"title": "编程语言专区",
			"body": "讨论编程问题",
			"added": 1580798433,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9",
			"type": "group"
		},
		{
			"topic_id": 1580798654,
			"title": "回到未来：Smalltalk 编程系统",
			"body": "Smalltalk 是19世纪70年代由 Alan Kay 设计的，第一个以面向对象（Object-Orientation）为主要范式的编程语言 1。Smalltalk 具有大量首创的特性，深刻影响了其之后的编程语言、开发环境和软件过程。\n\n \n\n由 Smalltalk 开始的面向对象的设计思想影响了后来出现的 C++，Objective-C，Python，Java，Ruby，C# 等众多编程语言，甚至在以函数式著称的 Lisp 和逻辑编程语言 Prolog 当中也演化出了功能强大的对象系统23。在所有编程范式当中，面向对象的编程范式毫无疑问取得了突出的成功。究其原因，一方面在于面向对象的设计一般易于描述和理解，而针对对象系统的建模、分析和可视化工具也得到长足的发展；其次，面向对象的诸多实践4如模块化（Modulariry）、复用（Reusability）等优化了软件行业的经济效益（Economic benefits）5。这些原因使得面向对象的设计方法和软件系统得到了从个人到企业的广泛采用（Adoption）。\n\n面向对象的核心思想之一是封装（Encapsulation），与之类似的一个概念是闭包（Closure），后者在提供一阶函数（First-class function）的编程语言内普遍存在。在对闭包与对象的比较上有很多精彩的争论67，将闭包作为底层机制来实现对象系统在函数式编程语言中屡见不鲜89，而早期的面向对象的编程语言也在发展过程中不断吸收函数式编程的诸多要素。值得一提的是，Smalltalk 从诞生之初就有块（Block）的概念，其本质就是一种语法闭包，这使得在 Smalltalk 中可以优雅地实现需要用到类似高阶函数（Higher-order function）的功能。\n\n左：Smalltalk-76 右：Pharo\n\nSmalltalk 起源于施乐帕罗奥多研究中心（Xerox PARC）的一项研究项目，旨在让人们更高效、更愉快地使用计算机系统。在这个愿景下，Smalltalk 使用一套交互式图形界面（Interactive graphical interface）作为其开发环境，它包含系统浏览器（System browser）、调试器（Debugger）、检视器（Inspector）、分析器（Profiler）等等一系列图形化的开发工具10。这也导致了 Smalltalk 的另一个重要贡献——推动了图形用户界面的发展，并且催生出了现在所谓的集成开发环境（Integrated development environment, IDE）。与今天的集成开发环境不同的是，Smalltalk 的开发环境完全由其系统自身的功能来构建，开发人员可以接触和定制开发环境的方方面面，甚至把它作为最终软件产品的一部分用来交付。\n\n得益于元类（Metaclass）和反射（Reflection）机制的存在，相较于其他编程语言中的对象系统，Smalltalk 具有十分出色的元编程（Metaprogramming）能力。由于“一切皆对象”的设计思想，在 Smalltalk 中不仅实例（Instance）具有动态特征，类（Class）和元类也可以被动态地创建和修改，这使得程序的行为可以在多个不同的层面得到调控。元类被广泛应用于对象的持久化存储（Object persistence）和对象关系映射（Object-relational mapping, ORM）等方面，它为对象系统提供了在用户层面（User-space）进行拓展的能力，为对象系统升级和演化提供了一个窗口，一些比较前沿的编程范式如 Context-oriented programming 和 Aspect-oriented programming 也可以通过元类成为现有对象系统的扩展。\n\nSmalltalk 是少数使用镜像（Image）的编程系统之一。与基于镜像的开发方式相对的是基于源代码（Source-based）的开发方式，这也是今天绝大部分编程系统所采用的开发方式。在基于镜像的开发过程中，源代码的作用只是用来改变镜像的状态，在开发阶段完成后，镜像作为一段内存区域被持久化转存（Dump）到镜像文件（Image file）中。到了部署阶段，镜像文件再被恢复到内存当中，然后以转存之前的状态继续运行。与基于源代码的方式相比，一个重要的优势在于开发人员可以将任意程序状态封装进最终交付的镜像中，而前者必须经历一个自举（Bootstrap）过程来达到特定状态，或者将这些状态定位于外部资源。基于镜像的编程系统通常具有天然的热部署（Hot deployment）能力并且非常看重运行时环境（Run time）的健壮性，这使得他们成为开发长运行（Long-running）的应用程序的理想选择。\n\n\n\n时至今日，以 Pharo 为代表的新兴 Smalltalk 平台一直处在高速的发展之中，很多早期的 Smalltalk 项目得到维护和升级，Smalltalk 编程系统的优势也得到了发挥和继承13。举例来说，Moose 构建了一个强大的可视化数据分析平台；Glamorous Toolkit 将 Smalltalk 图形开发环境更进一步，提出了 “moldable development environment” 的概念，如果你认为可视化编程（Visual programming）代表了未来的方向，那么 Smalltalk 始终走在它的前列。\n\n\n在 Smalltalk 之前有 Simula，首次实现了面向对象中的关键思想，包括类（Class）、对象（Object）、继承（Inheritance）和动态绑定（Dynamic binding）等，Smalltalk 的贡献在于其介绍了一种新的设计模式。\nCommon Lisp 在早期有 LOOPS 和 Flavors，后来演化成标准化的 Common Lisp Object System（CLOS）。\nLogtalk 为多种主流 Prolog 实现提供了面向对象的语言扩展。此外在一些商业 Prolog 实现如 SICStus 中也提供对象系统。\n在这方面比较有影响力的一本书是 Object-Oriented Software Construction 。\nSmalltalk-80: The Language and It’s Implementation 一书中称 Smalltalk 对于管理软件复杂度（Managing complexity）所采用的方法是其主要贡献。\n\nSmalltalk 提供的图形化开发工具远不止这些，值得一提的还有代码仓库管理工具 Iceberg，版本管理系统 Monticello 等。\n这方面的一个例子是 GNU Dr. Geo，一款基于 Pharo 的图形界面之上的几何软件。\n一个例子是 ContextL，它基于 Common Lisp 对象系统的元类功能实现了一套 Context-oriented",
			"added": 1580798652,
			"parent_topic_uri": "1580798434_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy"
		},
		{
			"topic_id": 1580798961,
			"title": "再见，面向对象编程",
			"body": "我从事面向对象语言的编程已有数十年了。我使用的第一种面向对象语言是 C++，然后是 Smalltalk，最后是 .NET 和 Java。\n\n我曾狂热地利用 继承、封装 和 多态 的好处。即范式的三个支柱。\n\n我也曾渴望获得复用的承诺，并借用前人在这个激动人心的新景观中所获得的智慧。\n一想到要将现实世界的对象映射到它们的类中，我就按捺不住激动的心情，希望整个世界都井然有序。\n\n我大错特错了。\n\n继承，第一个倒下的支柱\n\n乍一看，继承似乎是面向对象范式的最大好处。对于灌输这个概念的新人来说，所有简单的形状层次结构示例似乎都有逻辑意义。\n\n重用是当今的热门话题。不…… 它将永垂青史。\n\n我接受了这一切，并带着我的新发现冲向世界。\n\n香蕉猴丛林问题\n出于宗教信仰和解决问题的需要，我开始构建类层次结构并编写代码。一切都对了。\n\n我永远不会忘记那一天，我准备通过继承现有类来兑现重用的承诺。这就是我一直在等待的时刻。\n\n一个新项目出现了，我回想起我上一个项目中非常喜欢的那个类。\n\n没问题。重新使用再抢救一下。我要做的就是从另一个项目中获取该类并使用它。\n\n好吧…… 实际上…… 不只是那个类。我们也需要它的父类。但是…… 仅此而已。\n\n嗯... 等等... 看来我们也将需要父类的父类... 然后... 我们将需要所有父类。好吧好吧我会处理的没问题。\n\n太好了现在它将无法编译。为什么？？哦，我明白了...... This 对象包含 the other 对象。没问题。\n等等... 我不仅仅需要 that 对象。我需要 that 的父对象及其父对象的父对象，依此类推，包括每个包含的对象以及包含对象的所有父对象以及其父对象，父对象，父对象……\n\n啊。\n\nErlang 的创建者 Joe Armstrong 引用了一句很棒的话：\n\n面向对象语言的问题在于，它们具有随身携带的所有隐式环境。您想要香蕉，但是得到的是一只大猩猩，拿着香蕉和整个森林。\n\n香蕉猴丛林解决方案\n对于这个问题我可以通过创建简单点的层次结构来解决。但是，如果继承是重用的关键，那么我对该机制的任何限制肯定会限制重用的好处对吧？\n\n毫无疑问，是的。\n\n那么，一个糟糕的面向对象程序员经过 Kool-adi 的帮助后会怎么去做呢？\n\nContain and Delegate。稍后将对此进行详细说明。\n\n钻石问题（菱形继承问题）\n迟早，以下问题将变得很难解决，并且根据语言的不同，还会出现无法解决的问题。\n\n即使这种做法似乎合乎逻辑，但大多数 OO 语言都不支持此功能。用 OO 语言支持此功能有何困难？\n\n好吧，想象一下下面的伪代码：\n\nClass PoweredDevice {\n}\n\nClass Scanner inherits from PoweredDevice {\n    function start() {\n    }\n}\n\nClass Printer inherits from PoweredDevice {\n      function start() {\n      }\n}\n\nClass Copier inherits from Scanner, Printer {\n}\n请注意，Scanner 类和 Printer 类都实现了一个名为 start 的函数。\n\n那么 Copier 类继承哪个 start 函数？Scanner ？Printer ？不可能两者都是。\n\n钻石解决方案\n解决方案很简单。但是不要那样做\n\n是的，这是对的。大多数 OO 语言不允许您这样做。\n\n但是，但是…… 如果我必须对此建模呢？我要重用！\n\n然后您必须包含并委托。\n\nClass PoweredDevice\n{\n}\nClass Scanner inherits from PoweredDevice\n{\n      function start() \n      {\n      }\n}\nClass Printer inherits from PoweredDevice\n{\n      function start()\n      {\n      }\n}\nClass Copier \n{\n      Scanner scanner\n      Printer printer\n      function start() \n      {\n            printer.start()\n      }\n}\n请注意，Copier 类现在包含一个 Printer 和一个 Scanner 的实例。它将 start 函数的实现委派给 Printer 类。它也可以轻松地委派给 Scanner。\n\n这个问题是继承支柱中的另一个难题。\n\n脆弱的基类问题\n因此，我正在简化层次结构，以防止其具有周期性。我没有钻石。\n\n世界上的一切都是正确的。直到...\n\n有一天，我的代码可以工作，而第二天它将停止工作。这是意外。 我没有更改代码。\n\n好吧，也许是个错误... 但是等等... 某些事情确实发生了变化 ......\n\n但这不是我的代码。原来更改是在我继承的类中进行的。\n基类的更改如何破坏我的代码？\n\n额...\n\n想象一下以下基类 (它是用 Java 编写的，但是即使您不懂 Java，应该很容易理解)：\n\n就基类的所有者而言，它仍然按照通告的方式运行。\n 自动化测试仍然通过。\n\n就基类的所有者而言，它仍然按照通告的方式运行。并且派生类的所有者被粗暴的唤醒。（译者：没太理解，请帮忙修正）\n\n现在 ArrayCount 类中的 addAll() 方法调用其父类的 addAll() 方法 ， 父类 内部 调用已被 派生 类 的 add() 方法 重写 。\n\n这导致每次调用 派生 类的 add() 方法时 count 都会增加，\n然后 派生 类中的 addAll() 方法 再次增加 了元素数。\n\n计算了两次。\n\n如果有可能的话，派生类的作者必须知道如何实现基类。并且必须通知他们有关基类的每项更改，因为它可能以不可预测的方式破坏其派生类。\n\n啊！这个巨大的裂缝永远威胁着宝贵的继承支柱的稳定性。\n\n脆弱的基类解决方案\n再次包含并委托救援。\n\n通过使用 Contain 和 Delegate，我们从白盒编程转到黑盒编程。使用白盒编程，我们必须查看基类的实现。\n\n使用黑盒编程，我们可以完全不了解实现，因为我们不能通过重写基类的某个函数将代码注入基类。我们只需关注接口。\n\n这个趋势令人不安...\n\n继承被认为是重用的巨大胜利。\n\n面向对象的语言不能使 Contain 和 Delegate 易于实现。它们的设计目的是让继承变得容易。\n\n如果你像我一样，你就开始怀疑这种继承的设计了。但更重要的是，这应该动摇您对通过层次进行分类的能力的自信心了。\n\n层次结构问题\n每次换一家新公司时，我都会在创建放置公司文档的目录 (例如员工手册) 遇到难题。\n\n我是应该创建一个 Documents 的目录，然后再在里面创建一个 Company 的目录？\n\n还是先创建一个 Company 的目录，再在里面创建一个 Documents 目录呢？\n\n两者都可以。但是哪个是对的？哪个最好？\n\n类别层次结构的概念是存在更通用的基类 (父类)，而派生类 (子类) 是这些类的更专业版本。当我们沿着继承链往下走的时候，我们会变得更加专门化。(请参阅上面的形状层次结构)。\n\n但如果父对象和子对象可以任意切换位置，那么该模型显然有问题。\n\n层次结构解决方案\n问题是.....\n\n类别层次结构不工作.\n\n那么层次结构有什么好处？\n\n包容.\n\n如果你查看现实世界，你会看到到处都是包容 (或独占所有权) 层次结构。\n\n你将找不到分类层次结构。面向对象的范式是基于现实世界的，现实世界充满了对象。但后来它使用了一个破碎的模型，即类别层次结构，其中没有真实世界的类比。\n\n但现实世界充满了包容层次结构。包含层次结构的一个很好的例子就是 SOCKS。它们位于袜子抽屉中，该抽屉包含在梳妆台的一个抽屉中，该抽屉包含在卧室中，该抽屉包含在房间中，等等。\n\n硬盘驱动器上的目录是包容层次结构的另一个示例。它们包含文件。\n\n那么我们如何分类呢？\n\n如果你想到公司文档，我把它们放在哪里几乎无关紧要。我可以将它们放在 Documents 文件夹或名为 Stuff 的文件夹中。\n\n利用标记对其进行分类。可以使用以下 tags：\n\nDocument\nCompany\nHandbook\n\nTags 标记文件，没有顺序或层次结构。(这也解决了菱形问题。)\n\n标签类似于接口，这样可以将多种类型与文档关联。\n\n但有这么多裂缝，看起来继承支柱已经倒下。\n\n再见，继承。\n\n封装，第二个倒下的支柱#\n\n乍一看，封装似乎是面向对象编程的第二大优点。\n\n保护对象状态变量不受外部访问，即将他们封装在对象中。\n\n我们不再需要担心谁知道谁在访问全局变量。\n\n封装对于变量是安全的。\n\n封装这个事情是不可思议的！！\n\n封装万岁。。。\n\n直到。。。\n\n参考问题\n为了提高效率，对象不是通过它的值而是通过引用传递给函数。\n\n这意味着函数不会传递对象，而是传递一个指向对象的 reference 或指针\n\n如果将对象通过引用传递给对象构造函数，则构造函数可以将该对象引用放入受封装保护的私有变量中。\n\n但传递的对象不安全\n\n为什么呢？因为其他一些代码具有指向对象的指针，即，调用构造函数的代码。它必须具有对对象的引用，否则无法将其传递给构造函数？\n\n参考解决方案\n构造函数必须克隆传入的对象。而且不是浅层克隆，而是深层克隆，即传入的对象中包含的每个对象以及这些对象中的每个对象，以此类推。\n\n效率非常重要。\n\n也有例外。并非所有的对象都能克隆。有些具有与之相关的操作系统资源，从而使克隆在最佳或最坏的情况下也无法进行克隆。\n\n每一个 主流的 面向对象语言 都存在这个问题。\n\n再见，封装。\n\n多态性，倒下的第三个支柱\n\n多态是面向对象三位一体的红发继子。\n\n有点像是这个群体的 Larry Fine 。\n\n他们所到之处他都在，但他只是个配角。\n\n并不是说多态性不好，而是您不需要面向对象的语言就可以做到这一点。\n\n接口将会提供这一点。而且没有了面向对象的所有包袱。\n\n并且有了接口，您混入多少种不同的行为都不会有任何的限制。\n\n因此，事不宜迟，告别 面向对象的 多态，迎接 基于接口的 多态。\n\n失信\n\n嗯，OO 在早期肯定承诺了很多。这些承诺仍然是对坐在教室里、阅读博客和参加在线课程的天真程序员做出的。\n\n我花了很多年才意识到 OO 是怎么骗我的。我也是睁大眼睛，缺乏经验，轻信别人。\n\n我被烧死了。\n\n再见，面向对象编程。\n\n那又怎样？\n你好哇，函数式编程。过去几年里和你一起合作真实太棒了。\n\n但请注意，我不会把你的任何承诺当真。我要亲眼看到才能相信。\n\n一朝被蛇咬，十年怕井绳。\n\n你懂的。",
			"added": 1580798958,
			"parent_topic_uri": "1580798434_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy"
		},
		{
			"topic_id": 1580799005,
			"title": "命令行Smalltalk",
			"body": "命令行不是正途\n正如维基百科提到的:\n\nSmalltalk和许多程序设计语言不同，它不仅仅是一门语言…Smalltalk带有一个应用开发环境（ADE）：由于Smalltalk的历史原因，它具有一个非常优秀的高度集成、开放的应用开发环境。\n\nSmalltall让语言、IDE、系统这些概念变得模糊，也正是这种特性，让其保持极高的开发效率。\n\n当然Smalltall的核心，并不在表层特性，而在其设计意图。\n\nfor a research system, the intent matters most. – A few words on Doug Engelbart\n\n如果希望深入Smalltalk，基于文本的命令行并不是正途。Alan Kay的生物学背景，让Smalltalk像一个生态系统。将Smalltalk视为一个环境而不是传统的文本语言，通常是更好的视角。\n\n我希望将Smalltalk带到日常工作中，由于历史的惯性，基于命令行的技术生态已经成熟，日常工作很难离开它。彻底弃用命令行工具是不现实的，linux工具箱有海量的效率工具。\n\n我目前的想法是，在Smalltalk环境中编写事务逻辑，之后在命令行中调用它。换句话说，我想将它用作脚本语言，替代日常使用的Python。\n\n也许更好的办法是，将Smalltalk视为工作环境，只在需要时调用系统命令。但Pharo目前稳定性/鲁棒性还不好，在macOS下时常会占用占用过多CPU，或者崩溃。\n\n命令行下的Smalltalk\n乍看起来，GNU Smalltalk似乎正是我们需要的东西.\n\n与其他Smalltalk环境不同，GNU Smalltalk使用文本文件进行程序输入，并将内容解释为Smalltalk代码。这样，GNU Smalltalk更像是解释器，而不是传统的Smalltalk方式中的环境。\n\n但像我们前头论述的，命令行/文本并不是Smalltalk的正途。\n\n基于文本的环境当然有许多优点，但Smalltalk对其的诘难比今天的富文本阵营(ppt/word/excel)对其的诘难要深刻得多，(ppt/word/excel)对文本环境(Unix传统)的攻击，多数时候只是表明自己的无知。《Unix编程艺术》一书对文本环境做了很好的辩护，但我认为这种辩护并不能回避Smalltalk的攻击。\n\n加之对Alan Kay的崇敬，我偏向于使用Squeak和Pharo(Pharo是Squeak的后代)，而不是GNU Smalltalk。\n\n命令行下的Pharo\n我们可以在命令行中使用Pharo。\n\n安装\nwget -O- https://get.pharo.org/64 | bash\n\n使用\n1\n2\n3\n4\n5\n./pharo Pharo.image --help\n./pharo Pharo.image st\n    st                    Loads and executes .st source files\n    eval                  Directly evaluates passed in one line scripts\n./pharo Pharo.image eval --help\nhello world\nhello.st\n\n1\nTranscript show: 'hello world'.\n运行: ~/pharo ~/Pharo.image --quit st hello.st\n\ntips\n1\n2\nalias pst=\"~/pharo ~/Pharo.image --quit st\"\nalias pstui=\"~/pharo-ui ~/Pharo.image\"\ntodo\n接受输入输出(stdin/stdout)\n命令行参数\n接受命令行参数: name 打印 hello <name>\n结论\n类的继承很麻烦，尽可能不要做文本编程。 在Smalltlak环境编程，之后导出为st脚本。\n\n命令行下的Squeak\nsqueak -headless path/to/squeak.image /absolute/path/to/repl.st\n\n参考\nget.pharo.org\nGNU Smalltalk\nZero Configuration Scripts and Command-Line Handlers\nPharo Cool Snippets\nCLAP (COMMAND LINE ARGUMENT PARSING) IN PHARO\nsqueak CommandShell\n文章作者 Alan Russell\n\n上次更新 2019-11-28",
			"added": 1580799001,
			"parent_topic_uri": "1580798434_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy"
		},
		{
			"topic_id": 1580799079,
			"title": "从Python转向Pharo",
			"body": "Do not make end-users suffer because of your laziness or ineptness –Alan Kay\n\n前言\n过年的假期里写了篇文章: Smalltalk(Pharo)学习之旅, 提到\n\nBret让我相信smalltalk对我很重要.\n\n我在文章里信誓旦旦地说 准备使用Pharo(smalltalk的一门方言)将Scratch重新带回smalltalk(Scratch的第一个版本便是用smalltalk写的)，我甚至给这个计划起了一个好听的名字:回到未来。可惜在一个假期里习得的能力，并不足以支持我动手干这件事。一半原因也赖Pharo官方mooc教程，这实在不是一份好教程。\n\n现在差不多有能力来做这件事了，接下来对Scratch的改进，大多数会用smalltalk来做。\n\n如果你掌握了基本的编程概念（通过Scratch、或者玩20分钟Etoys足以掌握这些基础概念），UpdatedPharoByExample对你而言将是绝佳的Pharo教程。非常喜欢这份教程，它是我读过最好的编程教程之一,陪伴我渡过好几个美妙的夜晚。另一个印象深刻的编程教程是Head First Programming（这本书使用Python来讲解编程基本概念，面向毫无编程经验的新手，内容有趣又友好）\n\n我倾心于建构主义者(西摩尔·派普特、艾伦·凯、Bret Victor…)的认知论和教育理论，阅读了他们许多文章和工作成果之后，越来越难以忍受今天的编程工具和环境，你从他们那儿瞥见了未来，目光再落回现实，便开始挑剔，震惊于周遭环境的原始和逼仄。\n\n艾伦凯在smalltalk上的工作，向我们展示了未来的样子，关于什么是适合人类的创造环境，这是一个伟大的人文主义者为我们带来的伟大礼物。我认为艾伦凯首先是个人文主义者和教育者，其次才是计算机科学家。(他在Ted的自我介绍里，首先提到自己是个教育工作者，其次才说是计算机科学家)，作为教育者的艾伦凯，充满了人文关怀; 而作为计算机科学家的艾伦凯，则充满了想象力和热情。\n\n在所有哲学家中，我最喜欢伯特兰·罗素, 在所有计算机科学家中，我最喜欢艾伦凯。\n\nThree passions, simple but overwhelmingly strong, have governed my life: the longing for love, the search for knowledge, and unbearable pity for the suffering of mankind. – Bertrand Russell\n\nBret Victor在Douglas Engelbart去世的那天写了篇文章: A few words on Doug Engelbart\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nSay you bring up his 1968 demo on YouTube and watch a bit. At one point, the face of a remote collaborator, Bill Paxton, appears on screen, and Engelbart and Paxton have a conversation.\n\n\"Ah!\", you say. \"That's like Skype!\"\n\nThen, Engelbart and Paxton start simultaneously working with the document on the screen.\n\n\"Ah!\", you say. \"That's like screen sharing!\"\n\nNo. It is not like screen sharing at all.\n\nIf you look closer, you'll notice that there are two individual mouse pointers. Engelbart and Paxton are each controlling their own pointer.\n\n\"Okay,\" you say, \"so they have separate mouse pointers, and when we screen share today, we have to fight over a single pointer. That's a trivial detail; it's still basically the same thing.\"\n\nNo. It is not the same thing. At all. It misses the intent of the design, and for a research system, the intent matters most.\n很少有现代计算机编程语言不受smalltalk的影响。但正如许多伟大的事物一样（如上文Douglas Engelbart的The Mother of All Demos），人们将其断章取义地理解之后，造出无数糟糕得多的东西。\n\n这些东西因为种种原因流行起来，于是胜利者们一副胜者为王的姿态，说”我是最流行的，我当然就是最好的，你如果真的那么好，为何没有流行起来”。舞台上的C++换上了Java，最近好像又差不多换上了Python。正如柏拉图换上了卢梭，然后是黑格尔、尼采、希特勒，他们轮番站上历史的聚光灯下，拥护者们重复着存在即合理、胜者即正义的信条。\n\nPharo作为smalltalk的现代方言，它从Squeak出发，忠于smalltalk精神，继续向前。\n\nEverything is an object, and objects communicate only by sending each other message.\n\n我已经体验到Pharo带来的无尽乐趣和自由，在其中创造和表达是如此自在和舒适, 很难再回到原先使用的任何语言中了。\n\n艾伦凯精心设计了smalltalk。他将使用者摆在第一位置，他们是有情感的人类, 他们不是机器，他们不善于记住一大堆规则，他们遇到未知会疑惑，遇到困难会烦躁。正如艾伦凯在What does Alan Kay think of using either Squeak or Pharo as the first language for introducing programming?谈到的，smalltalk在设计之初就考虑了\n\n减少认知负担\n\n并致力于在用户入门时提供\n\n真正的演奏(real playing)\n\n作为设计者, 艾伦凯说:\n\n不要让用户因为你的懒惰或无能而受苦.\n\n我不知道今天主流编程语言的设计者们看到这些话，作何感想。有许多编程语言设计者对自己闲着没事，花了一周就整了个编程语言津津乐道。当这些糟糕的语言竟被推上历史舞台，受苦的便是它的用户。Bret在LearnableProgramming一文中对Programming这门语言的攻击是非常精彩的。而Programming在糟糕语言排行榜里并不靠前。\n\n更多关于smalltalk的思想来源，可以参考The Early History Of Smalltalk。\n\n缘聚缘散\nPython并不坏，在所有目前流行的编程语言中，我最喜欢它。它有友好的社区、简洁的语法、完善的生态。如那句流行的口号说的:\n\n人生苦短，我用Python.\n\n我大约大三(2012-2013年)开始使用Python，之后一直将其作为主要编程语言。Python一路从小众语言成长为今天的主流语言。\n\n与Python结缘，得从周日的一个晚上说起，当时在校园海报上，看到一个招募帖，有个技术团队在招募前端开发，我那时的兴趣完全在前端开发，它那么鲜活有趣。比php/asp可好玩多了。\n\n团队由一位口才极好的石姓学长发起，他人很有趣，演讲也富有感染力。回想起来，这应该是改变我人生轨迹的一个夜晚，如果没有加入这个4人小团队，我不大可能从事计算机行业。\n\n团队里写后端的是一位何姓学长，他使用Ubuntu/Vim/Python。看着光标在黑乎乎的命令行里移动如飞，这场景满足了我对黑客的所有幻想。这些工具被我一一记下，后来都在我的工具箱里。\n\n那时学校里使用这门语言编程的人可能是个位数，我只知道寥寥三人，何姓学长是一位，我自己是一位，我还忽悠了@ymj换用这门语言。@ymj后来去了创新工场做人工智能；何姓学长杳无踪迹，可能隐姓埋名做了黑客；我则对计算机的许多领域都很好奇，Python的胶水特性十分适合我。\n\nPython是那种理性的姑娘乐意选择一起生活的结婚对象(当然，理性的姑娘可能选择不婚)，它贴心、随和、经济实用，它有很暖的社区。Python即便有缺点，也绝非不能忍受，最多就是坐在沙发上抠抠脚之类的生活琐碎细节。许多婚姻可能因为争夺遥控器破裂，但很少因为抠脚破裂的，别小看了争夺遥控器这件事，它可能是三观不和的征兆，你们彼此不满于对方的精神食粮。\n\n遇见smalltalk，对我来说，大抵类似郭襄在风陵渡口的遭遇，你如此清楚地知道，这就是你的所有期待，无论往后岁月黯不黯淡，江山易不易主，江河干不干枯，它都熠熠生辉，如满月，如焰火，如雪夜围炉时，对方眼里倒映的光。\n\n在很长一段时间内，我还会将Python用作我的工作语言，用它写些脚本来管理系统、科学计算、异步编程…\n\n但创造和探索，或者如Scratch社区鼓励的:表达自己， 这些激动人心的活动，我都将使用smalltalk. 我将smalltalk视为一个创造友好的语言。我也将编程看作和木工、表演、绘画一样的创造性工作，它的人文属性并不弱于工程属性。个人计算机的早期推动者们 艾伦·凯、Douglas Engelbart希望它拥有人文属性。 未来计算机的探索者们艾伦·凯、Bret Victor也希望它有这种属性。\n\n增量前进\nPython在很长的一段时间里依然会是系统管理、信息安全(入侵渗透)、胶水工具、科学计算、人工智能的主力语言。\n\n我也不希望将之前在这些领域里积累起来的技能都抛弃了，我喜欢增量地前进，而不是换个工具从头再来。\n\n尽管在原则上我认同爱因斯坦说的:\n\n什么是教育？把在学校里学到的所有东西全部忘光了之后留下来的东西才叫教育。\n\n还记得基本思想和能操作自如中间的鸿沟，是需要时间来填补的。有大量细碎的细节和习惯，固化在某个具体技术框架里，要完全迁移到另一个体系中，时间成本并太低。\n\n所以，在往后的时间里，我即便使用smalltalk来构建新项目，恐怕也会混合Python代码，会用到一些基于Python的顺手工具。\n\n如何在smalltalk中运行Python代码，让他们能够混合编程？是我接下来需要面对的问题。尤其在过渡阶段，当遇到困难，会想退回到之前熟悉的安全域里。如果smalltalk能够方便调用Python，我就能够放心地增量前进。每次前进一点点，进可攻，退可守。\n\n这也正是我们之前坚持让Python与Scathch能够互操作地原因，之前在使用Python拓展Scratch的能力里讨论说:\n\n如果这种过渡是必要的，我希望它们是渐进的，而不是割裂的，否则就不叫过渡了。初学者熟悉scratch，也喜欢它，我知道大多数使用scratch的孩子，对它的好感大都胜过文本语言。你不必抛弃scratch，如果你需要一些更强大的功能，使用Python去扩展它，这个过程应该很愉快，你写了很少的Python代码，立马就能应用到你喜欢的Scratch项目上，你看到你逐渐能做更多有趣的事，你感到充满乐趣，所学的新知识，立马应用在你感兴趣的项目里。\n我们反对割裂式的教学，学习者从scratch切换到Python，很长时间内只能通过print看到输出，没有生动的反馈，于是许多人便对阶段感到沮丧，踏上一条从入门到放弃的路。\n\n技术细节\n最后记录下技术细节。在Pharo中调用Python是很简单的，所受的约束很小，可以自如地在Pharo中调用Python库，并允许采用Pharo语法来调用它们。\n\n我目前采用Python3Generator。\n\n操作方式非常简单，首先在Pharo(我目前使用Pharo 7.0.1)中安装依赖库\n\n1\n2\n3\n4\nMetacello new\n    baseline: 'Python3Generator';\n    repository: 'github://juliendelplanque/Python3Generator/repository';\n    load\n然后就可以自如调用Python啦:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\"Use and initialize the FFI interpreter.\"\nP3GInterpreter useFFIInterpreter.\nP3GInterpreter current pathToPython: '/Library/Frameworks/Python.framework/Versions/3.7/bin/python3'.\n\ninstr := P3GInstructionsList new.\n\njson := 'json' asP3GIdentifier.\nfile := 'file' asP3GIdentifier.\nos := 'os' asP3GIdentifier.\n\ninstr addAll: {\n    json import.\n    os import.\n    file <- ('open' asP3GIdentifier callWith: #('/tmp/osp3g.json' 'w')).\n    (file=>#write) callWith: { (json=>#dumps) callWith: {{\n                                                'os' -> (os=>#name).\n                                                'uname' -> (os=>#uname) call } asDictionary} }.\n    ((file=>#close) call)\n}.\n\ninstr execute.\n运行之后,查看/tmp/osp3g.json:\n\n\n\n调用强大的第三方库(如numpy、matplotlib)也是OK的！\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\"Use and initialize the FFI interpreter.\"\nP3GInterpreter useFFIInterpreter.\nP3GInterpreter current pathToPython: '/usr/bin/python3'.\n\nnumpy := 'numpy' asP3GIdentifier.\nmlab := 'matplotlib' asP3GIdentifier=>#mlab.\npyplot := 'matplotlib' asP3GIdentifier=>#pyplot.\n\ninstr := P3GInstructionsList new.\n\ninstr addAll: {\n    \"Import modules.\"\n    numpy import.\n    mlab import.\n    pyplot import.\n\n    \"Set seed for random.\"\n    (numpy=>#random=>#seed) callWith: #(0).\n\n    \"Example data\"\n    #mu asP3GIdentifier <- 100.\n    #sigma asP3GIdentifier <- 15.\n    #x asP3GIdentifier <- (#mu asP3GIdentifier + (#sigma asP3GIdentifier * ((numpy=>#random=>#randn) callWith: #(437)))).\n\n    #num_bin asP3GIdentifier <- 50.\n\n    #res asP3GIdentifier <- (pyplot=>#subplots) call.\n    #fig asP3GIdentifier <- (#res asP3GIdentifier at: 0).\n    #ax asP3GIdentifier <- (#res asP3GIdentifier at: 1).\n\n    \"Plot histogram of data.\"\n    #res asP3GIdentifier <- ((#ax asP3GIdentifier=>#hist) callWith: {#x asP3GIdentifier.#num_bin asP3GIdentifier} with: {'normed' -> 1 } asDictionary).\n    #bins asP3GIdentifier <- (#res asP3GIdentifier at: 1).\n\n    \"Add a 'best fit line'\"\n    #y asP3GIdentifier <- ((mlab=>#normpdf) callWith: {#bins asP3GIdentifier . #mu asP3GIdentifier . #sigma asP3GIdentifier}).\n    (#ax asP3GIdentifier=>#plot) callWith: { #bins asP3GIdentifier . #y asP3GIdentifier . '--' }.\n\n    (pyplot=>#show) call\n }.\n\ninstr execute\n效果如下:\n\n\n\n第三方库\n尽管Pharo社区没有Python社区壮大，但社区里已经有很多高质量的第三方库，我整理了一些我喜欢的。 其中gtoolkit、Moose和Dr Geo令我大吃一惊。整个Pharo社区充满了人文主义精神，这种精神体现在软件本身里，体现在软件的设计原则里，体现在软件的介绍里。他们秉承艾伦凯在smalltalk中展现的理念，继续做着令人震惊和振奋的工作。\n\ngtoolkit: We want the environment to fit the context of the current system and when it does not, we want to mold it seamlessly. This change is transformational.\nProgramming is the coolest job on the planet, and it should feel like that all the time.\ngtoolkit\nMoose: Moose is a platform for software and data analysis.\ngithub.com/moosetechnology/Moose\nRoassal2\nRoassal3\nWinter: Winter is a 2D game engine for Pharo Smalltalk\nPharoJS\nPython3Generator\nScale: Pharo in the shell\nPTerm\nPTerm: yet another Terminal Emulator for Pharo\nOSSubprocess\nSeaside\nston\nTelePharo: Tools to manage and develop remote Pharo images\nPharoThings:Live programming platform for IoT projects based on Pharo\nRaspberry driven by WiringPi library\na demo about low level board model\nArduino driven by Firmata, soon\nBeaglebone, soon\nEnterprisePharo: A new book describing Pharo librairies to make business.\npharo-wiki\nBloc: Low-level UI infrastructure & framework for Pharo\nzinc: Zinc HTTP Components is an open-source Smalltalk framework to deal with the HTTP networking protocol.\nP3: A lean and mean PostgreSQL client for Pharo\nwoden: World Dynamic Engine - A 3D graphics engine for Pharo\nTeapot: Teapot micro web framework for Pharo Smalltalk\nCruiser: A Pharo Tool to package applications\nvoyage: an object persistence abstraction layer for Pharo.\nJupyterTalk: Pharo Smaltalk kernel for Jupyter: It uses ZeroMQ ported from zeromq project to uFFI！！！\nzeromq: ZeroMQ bindings for Pharo. Currently uses FFI interface. Supports ZeroMQ versions 2 and 3 (2.2 and 3.2 at least)\nSmalltalkVimMode: Vim Mode for Playground, System Browser, Debugger in Pharo.\npi:Pharo Install - A CLI tool for installing Pharo Smalltalk packages (pip-like)\nNeoJSON: read and write JSON converting to or from Smalltalk objects.\nterminal:Pseudoterminal emulator for Pharo\nmongotalk: A Pharo driver for MongoDB\nPharo-Chrome: Pharo support for Google Chrome\nKerasWrapper: Keras bindings for Pharo\nExperience in Bridging Keras for Python with Pharo\nJRPC: JSON-RPC 2.0 implementation for Pharo Smalltalk\nDr Geo: A software to design & manipulate interactive geometric sketches. It helps kids to explore geometry.\nturtles: A turtle implementation in Pharo Smalltalk\nPetitParser\n参考\nWhy does Smalltalk not become a commonly used platform for learning presentations and video lecture constructors? Squeak looks great as an interactive presentation platform for college lecturers.\nWhat book(s) would you recommend to a computer science student?\nIs there a programming language that’s effectively a successor to Smalltalk?\nWhat does Alan Kay use in lieu of PowerPoint?\nAs a beginner, what are the best ways to approach Computer Science?\nSqueak Etoys, Children & Learning\nWhat does Alan Kay think of using either Squeak or Pharo as the first language for introducing programming?\nThe Early History Of Smalltalk\nDesign Principles Behind Smalltalk\nSmalltalk and Raspberry Pi\nBehold Pharo: The Modern Smalltalk\nBack to the Future with Smalltalk\nawesome-pharo\nhunter: a JavaScript reengineering platform.\namber: A new language and live environment made for the web.\nPharo Track\nTinyLogger:A really small logger for Pharo applications.\nipfs-pharo: IPFS interface for Pharo\n文章作者 Alan Russell\n\n上次更新 2019-03-19",
			"added": 1580799074,
			"parent_topic_uri": "1580798434_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy"
		},
		{
			"topic_id": 1580799110,
			"title": "[译]Smalltalk背后的设计原则",
			"body": "前言\nDesign Principles Behind Smalltalk是我最喜欢的两篇Smalltalk文章之一，另一篇是The Early History Of Smalltalk。\n\n前者来自Daniel Ingalls，后者来自Alan Kay, 两人都是Smalltalk的核心贡献者。\n\nDaniel Ingalls是Alan Kay在施乐(Xerox Palo Alto)的老搭档。《The Early History Of Smalltalk》里提到:\n\n我们所有人都同意，在Smalltalk的大部分开发中，Daniel是核心人物…Daniel不仅仅是一个出色的实现者，随着Smalltalk进入到现实世界，Daniel逐渐承担越来越多设计师的职责，不仅是语言设计师，还包括用户界面设计师。\n\n第三次阅读这篇文章，随手做个翻译。以下是译文。\n\nps: 我将这篇文章视为Smalltalk的认识论和世界观。\n\nSmalltalk项目的目标是为所有人的创新精神提供计算机支持。我们的工作源于这样一个愿景: 其中包括一个富有创造力的人和尽可能好的计算硬件。我们专注于两个主要的研究领域：一种描述性语言（编程语言），它充当人类大脑模型与计算硬件模型之间的接口，以及一种交互式语言（用户界面）。充当人与计算机之间的通信系统。我们的工作遵循了两到四年的周期，这可与科学方法相提并论：\n\n在当前系统内构建一个应用程序（进行观察）\n根据经验，重新设计语言（形成一种理论）\n基于新设计构建新系统（做出可测试的预测）\nSmalltalk-80系统标志着我们第五次处于这种周期中。在本文中，我将介绍我们在工作过程中观察到的一些一般原则。尽管演示文稿经常涉及Smalltalk的”母性”(motherhood))，但这些原则本身却更为通用，被证明对评估其他系统和指导未来的工作都很有用。\n\n为了热身，我将从一个比技术更加社会化的原则开始，并且该原则在很大程度上归因于Smalltalk项目的特殊倾向：\n\n个人精通：如果一个系统要发挥创造精神，那么个体必须完全可以理解该系统。\n\n这里的重点是人类的潜能在个体中体现出来。为了实现这种潜能，我们必须提供一种可以由个体掌握的媒体。用户和系统某些部分之间存在的任何障碍， 最终都会成为创造性表达的障碍。系统中任何无法更改或通用性不足的部分都可能是障碍。如果系统的一部分工作方式与所有其他部分不同，该部分将需要付出更多的努力来掌握。这样增加的负担可能会损害最终结果，并会阻碍将来在这方面的尝试。因此，我们可以推断出设计的一般原则：\n\n良好的设计：系统应以最少的不可变零件组成；这些部分应尽可能通用；系统的所有部分都应聚拢在一个统一的框架中。\n\n语言\n在设计计算机语言时，不必费劲就能找到有用的提示。我们所知道的有关人们如何思考和交流的一切都适用。思考和交流的机制已被设计了数百万年，我们应该将其视为合理的设计。而且，由于我们必须在未来的一百万年中继续使用这种设计，如果我们使计算机模型与思维(mind)兼容，将节省时间。\n\n图1 说明了我们讨论中的主要组成部分。一个人被认为具有身体和思想。身体是大多数经验发生的场所，它是感知宇宙和实现意图的物理渠道。经验(Experience)是在思维(mind)中记忆和处理的。创造性思维（无需深入探讨其机制）可以看作是思维中信息的自发出现。语言是获取这些信息的关键：\n\n语言的目的： 提供交流的框架。\n\n两个人之间的互动在 图1 中表示为两条弧线。实线代表明确的交流：发出和感知的实际单词与动作。虚线弧表示隐式交流：形成显式交流的上下文的共享文化和经验。在人类交流中，许多实际的交流是通过引用共享上下文来实现的，而人类语言就是围绕这种影射(allusion)而建立的。计算机也是如此。\n\n可以将计算机视为 图1 中的参与者之一并非偶然, 在这种情况下，”身体”(body)提供信息的视觉显示并感知来自人类用户的输入。计算机的”思维”(mind)包括内部存储器和处理元件及其内容。图1 显示了计算机语言的设计涉及几个不同的问题：\n\n范围：使用计算机的语言的设计必须处理内部模型、外部媒体，以及发生在人与计算机之间的交互作用。\n\n这个事实导致了难以向这些人解释Smalltalk: 他们站在更受限的意义上去看待计算机语言。Smalltalk不仅是组织过程的更好方法，还是存储管理的另一种技术；它不仅是数据类型的可扩展层次结构，还是图形用户界面。它是为了让 图1 中所示的交互作用能够发生，所需的所有东西。\n\n\n\n图1：语言设计的范围。两个人之间（或一个人和一台计算机之间）的通信包括两个级别的通信。显式通信包括在给定消息中发送的信息。隐式交流包括两个人共有的相关假设。\n\n交流对象\n思维(mind)观察着广泛的经验(experience)，包括眼前的和记忆的。只要让这种经历保持原样，就可以与宇宙产生一种整体感。但是，如果有人希望参与(字面上参与)到宇宙中，则必须对两者的区别加以区分。此时，人们将辨识宇宙中的一个具体物体，其余所有物体都不是这个物体。区分本身是一个开始，但是区分的过程并没那么容易。每当你要谈论那把椅子时，你必须重复辨别那把椅子的整个过程。这就是引用(reference)行为的来源：我们可以将唯一标识符与对象相关联，从那时起，只有提及该标识符才需要引用原始对象。\n\n我们已经说过，计算机系统应该提供与思维一致的模型。因此：\n\n对象：计算机语言应支持对象的概念，并提供一种统一的方式来引用其宇宙中的对象。\n\nSmalltalk存储管理器为整个系统提供了一个面向对象的内存模型。只需将唯一的整数与系统中的每个对象相关联，即可实现一致的引用。这种一致性很重要，因为这意味着系统中的变量可以采用差别很大的值，并且可以实现为简单的存储单元。在对表达式求值时会创建对象，并且可以通过一致的引用传递对象，因此在操作它们的过程中无需提供存储对象的条件。当所有对它的引用都从系统中消失后，该对象本身将消失，并回收其存储。此类行为对于完全支持对象隐喻至关重要：\n\n存储管理：要真正做到面向对象，计算机系统必须提供自动存储管理。\n\n找出一种语言是否运行良好的一种方法是: 查看程序的样子是否像他们正在做的事情。如果充斥着与存储管理有关的陈述，那么它们的内部模型与人类的模型就不太匹配。想象一下你平时的做法: 分别处理别人交代你的事情，当你完成时告知他们，之后忘记它。\n\n我们宇宙中的每个物体都有自己的生命周期。类似地，大脑为每个心理对象提供独立的处理和存储预算。这表明了设计的第三条原则：\n\n消息：应将计算视为对象的固有功能，可以通过发送消息统一调用它们。\n\n正如显式处理对象存储时程序会变得混乱一样，如果在外部执行处理，系统中的控制也会变得复杂。让我们考虑将一个数字+5的过程。在大多数计算机系统中，编译器会弄清楚数字是什么类型，并生成将其+5的代码。这对于面向对象的系统来说还不够好，因为编译器无法确定确切的数字类型（稍后将对此进行详细介绍）。一种可能的解决方案是调用常规加法例程，该例程检查参数的类型以确定近似动作。这不是一个好办法，因为这意味着这个关键例程必须由只想尝试自己的数字类别的新手来编辑。这也是一个糟糕的设计，因为在整个系统中都散布着关于对象内部的深入信息。\n\nSmalltalk提供了一种更为简洁的解决方案：它将所需操作的名称及其参数作为消息发送给那么数字（接收者），接收者最了解如何执行所需的操作。我们拥有一个行为良好的对象世界，它们礼貌地要求对方执行其各种愿望(译者注:realtalk受这个观念影响)，而不是用比特研磨机蹂躏和掠夺数据结构。消息的传输是唯一在对象外部进行的过程，理当如此，因为消息在对象之间传播。可以对语言重新定义良好设计的原则：\n\n统一隐喻: 应该围绕一种强大的隐喻设计一种语言，该隐喻可以统一应用于所有领域。\n\n在这方面成功的例子包括:\n\nLISP，它建立在链接结构模型的基础上。\nAPL，它建立在数组模型上；\nSmalltalk，它建立在通信对象模型的基础上。\n在上述每种情形中，都采用与构建系统的基本单元相同的方式构建大型应用程序(译者注: 递归)。特别是在Smalltalk中，采用与计算机和用户之间的最高级别的交互相同的方式来构建最原始对象之间的交互。Smalltalk中的每个对象，甚至是一个小小的整数，都有一组消息，一个协议，定义了该对象可以响应的显式通信。在内部，对象可以具有本地存储能力并可以访问其他共享信息，这些信息包括所有通信的隐式上下文。例如，消息+ 5带有一个隐含的假设: 消息发给一个被加数。\n\n组织\n统一的隐喻提供了一个框架，可以在其中构建复杂的系统。几个相关的组织原则有助于成功管理复杂性。首先：\n\n模块化：复杂系统中的任何组件都不应依赖于其他组件的内部细节。\n\n\n\n图2： 系统复杂度。随着系统中组件数量的增加，进行不必要的交互的机会也会迅速增加。因此，应设计一种计算机语言以最小化这种相互依赖的可能性。\n\n该原理在 图2 中显示。如果系统中有N个组件，则它们之间大约有N平方的潜在依存关系。如果要在复杂的人工任务中使用计算机系统，则必须将计算机系统设计为最小化这种相互依赖性。消息发送隐喻通过将消息的意图（以消息的名称体现）与接收者执行意图的方法脱钩，从而提供了模块化。由于对对象内部状态的所有访问都是通过统一的消息接口进行的，因此结构信息受到类似的保护。\n\n通常可以通过将相似的组件分组来降低系统的复杂性。通过常规编程语言中的数据键入以及Smalltalk中的类可以实现这种分组。一个类描述其他对象–它们的内部状态，它们识别的消息协议以及响应这些消息的内部方法。这些被描述的对象称为该类的实例。甚至类本身也适合这个框架。它们只是Class类的实例，它描述了用于对象描述的适当协议和实现。\n\n分类： 语言必须提供一种用于对相似对象进行分类的方法，添加新的对象类时，应当与系统内核类的基础相同。\n\n分类是意识的客观化。换句话说，当人们看到椅子时，体验到的既是字面上的那个东西，又是抽象的那个椅子样的东西(译者注: 柏拉图在《理想国》中谈论理念时，有类似言论)。这种抽象是由于思维具有融合相似体验的出色能力而产生的，这种抽象将自身表现为思维中的另一个对象，柏拉图式的椅子或椅子性。\n\n类是Smalltalk中主要的扩展机制。例如，通过添加新的类来创建音乐系统，这些类描述Note、Melody、Score、Timbre、Player的表示形式和交互协议，等等。上述原则的相同基础(equal footing)条款很重要，因为它确保了系统将按设计使用。换句话说，melody可以表示为音高、持续时间和其他参数的整数临时集合，但是如果该语言可以像Integers一样容易地处理Notes，那么用户自然会将旋律描述为Notes集合。在设计的每个阶段，如果系统能够提供最有效的表示形式，则人们自然会选择它。模块化原则对系统中的程序组件具有有趣的含义：\n\n多态性： 程序应当仅指定对象的行为，而不指定对象的表示。\n\n关于此原则的传统说法是，程序永远不要声明给定对象是SmallInteger还是LargeInteger，而只能声明它响应整数协议。这种通用描述对于现实世界的模型至关重要。\n\n考虑汽车交通模拟。这种系统中的许多程序将涉及各种车辆。假设有人希望添加一个清洁车。如果代码依赖于它所操纵的对象，那么进行这种简单的扩展将涉及大量的计算量（以重新编译的形式）和可能的错误。消息接口为这种扩展建立了理想的框架。假设清洁车与所有其他车辆都支持相同的协议，则无需更改即可将其包括在系统中：\n\n分解：系统中的每个独立组件都只会出现在一个地方。\n\n此原则有很多原因。首先，如果只需要在一个地方添加系统，就可以节省时间、精力和存储空间。其次，用户可以更轻松地找到满足给定需求的组件。第三，在缺乏适当分解的情况下，同步更改并确保所有相互依赖的组件保持一致时会出现问题。实际上，分解的失败就等于违反了模块化。\n\nSmalltalk通过继承鼓励了精心分解的设计。每个类都从其超类继承行为。这种继承追溯到越来越通用的类，最终以Object类结束，该类描述了系统中所有对象的默认行为。在上面的车辆模拟系统中，清洁车（和所有其他车辆类别）将被描述为通用车辆类别的子类，从而继承了适当的默认行为并避免了在许多不同地方重复相同的概念。继承说明了分解的另一个实用的好处：\n\n杠杆：当一个系统被充分分解，用户和实施者均可充分利用。\n\n以排序对象的有序集合为例。在Smalltalk中，用户将在OrderedCollection 类中定义一条称为sort的消息。完成此操作后，系统中的所有形式的有序集合都将通过继承立即获得这项新功能。顺便说一句，值得注意的是，相同的方法可以按字母顺序排列文本也可用于排序数字，因为sort协议被支持文本和数字的类所识别。\n\n结构化对于实施者(implementers)的好处是显而易见的。首先，将要实现的原语更少。例如，Smalltalk中的所有图形都是通过单个基本操作执行的。由于只需完成一项任务，实施者就可以在每条指令上给予极大的关注，因为他们知道效率的每一个小提高都会在整个系统中得到放大。很自然地要问哪一组基本操作足以支持整个计算系统。这个问题的答案称为虚拟机规范：\n\n虚拟机：虚拟机规范为技术应用建立了框架。\n\nSmalltalk虚拟机建立用于存储的面向对象模型，用于处理(processing)的面向消息模型以及用于可视化显示信息的位图模型。通过使用microcode以及最终使用硬件，可以显着提高系统性能，而不会影响系统的其他优点。\n\n用户界面\n用户界面只是一种语言，其中大多数通信都是可视的。由于视觉表现与人类文化深度交叠，因此美学在这一领域起着非常重要的作用。由于计算机系统的所有功能最终都是通过用户界面提供的，因此灵活性在这里也至关重要。用户界面的足够灵活性的得以实现的条件之一是以下一条面向对象原则：\n\n反应性原则：用户可访问的每个组件都应能够以有意义的方式展示自己，以进行观察和操作。\n\n通信对象模型很好地支持了该标准。根据定义，每个对象都为交互提供了适当的消息协议。该协议本质上是特定于该类对象的微语言(microlanguage)。在用户界面的级别上，屏幕上每个对象的适当语言以可视方式呈现（如文本，菜单，图片），并通过键盘活动和使用指点设备(鼠标等)进行感测。\n\n应当指出，操作系统似乎违反了这一原则。在这里，程序员必须脱离原本一致的描述框架，离开已建立的任何上下文，并处理完全不同且通常非常原始的环境。实际上，不必这样：\n\n操作系统：操作系统是不适合于纳入语言的事物的集合。不应如此。\n\n以下是一些已自然地合并到Smalltalk语言中的常规操作系统组件的示例：\n\n存储管理–完全自动化。对象通过发送给它的类的消息创建，并在不存在对它们的引用时回收。通过虚拟内存扩展地址空间同样是透明的。\n文件系统–通过对象（例如具有支持文件访问的消息协议的文件和目录）包含在常规框架中。\n显示处理–显示只是Form类的一个实例，该类是连续可见的，并且该类中定义的图形操作消息用于更改可见图像。\n键盘输入–类似地，用户输入设备被建模为带有适当消息的对象，用于确定其状态或将其历史记录作为事件序列。\n子系统的访问–子系统自然地作为Smalltalk中的独立对象并入：它们可以利用现有的大量描述空间，涉及与用户交互的子系统可以作为组件参与用户界面。\n调试器–Smalltalk处理器的状态可以作为拥有堆栈链的Process类的实例进行访问。调试器只是Smalltalk子系统，可以访问已暂停进程的状态。应该注意的是，Smalltalk中几乎唯一发生的运行时错误是消息无法被其接收者识别。\nSmalltalk本身没有操作系统。通过响应其他常规的Smalltalk消息，将诸如从磁盘读取页面之类的必要基本操作合并为基本方法。\n\n未来的工作\n可以预料到，在Smalltalk上仍有工作要做。最简单的部分是继续应用本文中的原理。例如，Smalltalk-80系统的分解不足，因为它仅支持层次继承。未来的Smalltalk系统会将此模型推广到多继承。此外，消息协议尚未正式化。目前虽有协议，但当前协议从一个类到另一个类保持一致只是风格问题。通过提供可以一致共享的正确协议对象，可以轻松地解决此问题。然后，这将允许通过协议对变量进行正式键入而不会丢失多态性的优点。\n\n其他剩余的工作不太容易表达。显然，人类思想中还有其他方面尚未解决。这些必须被识别为可以补充现有语言模型的隐喻。\n\n有时，计算机系统的进步似乎缓慢得令人沮丧。我们忘记了蒸汽机对我们的祖父母而言是高科技的。我对这种情况持乐观态度。实际上，计算机系统变得越来越简单，因此也变得越来越有用。我想以指导这一过程的一般原则来结束本文：\n\n自然选择：合理设计的语言和系统将继续存在，只有更好的语言和系统才能取代它们。\n\n随着时间的流逝，计算机对创新精神的支持正变得越来越好。\n\n参考\nDesign Principles Behind Smalltalk\nDanie Ingalls\nThe Early History Of Smalltalk\n文章作者 Alan Russell\n\n上次更新 2019-11-29",
			"added": 1580799104,
			"parent_topic_uri": "1580798434_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy"
		},
		{
			"topic_id": 1580799876,
			"title": "linux小白交流基地",
			"body": "",
			"added": 1580799869,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580810002,
			"title": "linux日常生活需求收集",
			"body": "",
			"added": 1580809994,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580811117,
			"title": "零网使用心得",
			"body": "",
			"added": 1580811108,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580814240,
			"title": "linux 使用流程",
			"body": "https://github.com/yangyangwithgnu/the_new_world_linux",
			"added": 1580814306,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580815716,
			"title": "学习LFS 有用处吗？",
			"body": "",
			"added": 1580815705,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580816256,
			"title": "Common Lisp学习心得",
			"body": "叫“lisp”的语言已经死了几十年了。“lisp”在现代不过是一堆毫无共性语言的自称。在学习Lisp之前请先了解你要学的是哪个lisp。\n\nLisp分类： common lisp、scheme、clojure、visual lisp、\n\n--------------------------------------------------------------------------------------------------\n\n之前在一个Lisp群公告看到一句话 “ 嘛，lisp不难，但反正你基本上是学不会的，啊哈哈哈 ”。不过并没有打击我的信心，反而更加地激发了我的好奇心。\n\n现在的我对Lisp的好奇心正在不断地在增加，越看到说lisp难学的话，我就越想学会lisp！！不管它多难。\n\n-----------------------------------------------------------------------------------------------------\n\n《ANSI Common Lisp》学到第七章了，还是一头雾水。嗯，看来真的是不容易。\n\n刘未鹏说 —— 写博客这件事情给我最大的体会就是，一件事情如果你能够坚持做8年，那么不管效率和频率多低，最终总能取得一些很可观的收益。而另一个体会就是，一件事情只要你坚持得足够久，“坚持”就会慢慢变成“习惯”。原本需要费力去驱动的事情便成了家常便饭，云淡风轻。\n\n不管多难，继续学，加油！",
			"added": 1580816244,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580865494,
			"title": "linux教程计划",
			"body": "每次发行版更新版本的时候，都写一个htttp服务器、ftp服务器、samba、ssh等教程，即使内容没变化也没关系，大家有兴趣做吗？",
			"added": 1580865499,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580875629,
			"title": "苏苏の小窝",
			"body": "http://127.0.0.1:43110/1LGsCqRdYrVYgGEzQzJZJg71C1m5VHMsCr/",
			"added": 1580875615,
			"parent_topic_uri": "1571115911_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580876326,
			"title": "linux小白的使用经历",
			"body": "",
			"added": 1580876311,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580891805,
			"title": "极简主义，减少欲望，避免浪费时间",
			"body": "我已经把所有的电影、音乐都删除了，减少管理成本",
			"added": 1581393381,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580892230,
			"title": "OpenGenera 使用体验是什么样的？",
			"body": "",
			"added": 1580892213,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580892733,
			"title": "linux生存日记",
			"body": "",
			"added": 1580892715,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580893670,
			"title": "linux实用脚本",
			"body": "",
			"added": 1580893650,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580893799,
			"title": "linux桌面的变化",
			"body": "net-tools 包已经弃用，现在使用ip addr命令查询IP地址",
			"added": 1580893778,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580893879,
			"title": "linux和windows的区别",
			"body": "windows使用的是软件名，linux使用的是包名",
			"added": 1580893857,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580894294,
			"title": "linux文件管理器不刷新问题",
			"body": "",
			"added": 1580894271,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580894699,
			"title": "Linux 文件打开过多 (Too many open files)",
			"body": "如图是程序运行了一段时间后抛出来的一个bug, 刚开始看这个bug的时候各种网上找答案, 无外乎教你怎么改ulimit(就是linux最大打开文件数), 当然不是说改这个没有用, 作为程序开发者来说, 如果程序运行出现了bug则必然是程序的问题, 毕竟linux系统已经相当成熟, 它不会欺骗你(作为小菜鸟的我也是刚认识到这一点).\n\n    今天遇到的这种bug, 的确是程序上的原因. 具体什么原因, 下面开始我的表演.\n\n 我们知道linux中对于某个进程打开的文件句柄是有限制的, 这里的意识不是指简单new一个File对象.其实你new 一亿个文件对象放在那边, linux都不会来警告你. 这里的限制是我们new 了一个FIle, 并且使用了这个句柄搞事情. 如下面的代码\n\n    \n\nimport org.testng.annotations.Test;\n\nimport java.io.*;\n\n/**\n * Created by fire on 2018-03-02 14:45:02.\n */\npublic class File_new {\n\n    @Test\n    public void test1(){\n        File f1 = new File(\"G:/state/a.txt\");\n        File f2 = new File(\"G:/state/b.txt\");\n        File f3 = new File(\"G:/state/c.txt\");\n        File f4 = new File(\"G:/state/d.txt\");\n\n        String line = null;\n        BufferedReader br = null;\n        try{\n            br = new BufferedReader(new InputStreamReader(new FileInputStream(f1)));\n            f1.delete();  //\n            while ((line = br.readLine()) != null){\n                System.out.println(line);\n            }\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(br != null){\n                try {\n                    br.close();\n                    br = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n    上面代码new了很多File对象, 但是真正打开的只有f1. linux限制的就是这个f1句柄.  然饿, 如果, 像上面的代码这样写个10000遍, 则一定会被linux限制到, 因为这里就存在了一个句柄泄漏的问题.  当我们把打开的句柄删除的时候, 一定要记得把用到它的所有资源都要关闭掉, 不然一定会造成句柄泄漏. 不信可以在linux 用 lsof -p + 进程的PID 查看. \n\n    所以, 我们在对文件操作是, 一定要记得, 先关资源后删文件, 否则一定会造成句柄泄漏!!!  谨记~~~~",
			"added": 1580894675,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580898260,
			"title": "linux普通用户都使用哪些软件？",
			"body": "智能输入法、专业输入法\nP2P软件\n浏览器等\n文件管理器\n截图、录屏、录制gif\n压缩软件\n刻录软件\n备份软件\n系统修复软件\n在线音乐播放器、视频播放器\n网盘客户端\n加密软件\n创建热点\nVPN 支持\nhttp服务器、ftp服务器、samba\n远程控制\n聊天软件\nPDF 阅读器、小说阅读器、小说下载器\n下载工具\n翻译软件\n游戏\n翻墙软件客户端",
			"added": 1580898382,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580899802,
			"title": "linux能正常使用了，还需要进阶学习什么？",
			"body": "",
			"added": 1580899776,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580959641,
			"title": "把linux用于日常使用系统的人有你吗 ?",
			"body": "有啊，而且很多，但有几个普通人的偏见要说一下。\n1，并不是使用了Linux就会变得牛逼，也是不是所有使用Linux的人都很牛逼，其实很多像我这种普通人也会用Linux，很多开发都是用windows；\n\n2，使用Linux并不是为了装逼，我们是为了真是需要这个系统而已，比如简单的rsync和git，在日常使用和工作中，这些基础的命令是windows无法提供的；\n\n3，如果有更多的人使用Linux我们会欣喜，但我们从不硬性向别人推销Linux，用Linux是我们自己的事情，所以每当看到别人列出那些Linux使用原因的时候，我们这些真正的用户都觉得有点逗，那些列出来的原因大多和实际情况无关。 其实你可以用安卓和苹果的两个手机系统做例子，苹果封死了很多东西，所以苹果很多事情都无法做，但苹果的手机的确是不错。 但是，如果你想要自己的手机能做更多东西，那就必须用安卓，但是，你也看到了，用安卓的人也并不都是大神，真正的大神用安卓，也不会向别人推销安卓，自己想用就用，没那么多意见的",
			"added": 1580959614,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580959815,
			"title": "哪个linux系统的教程多？",
			"body": "游戏\n美化\nwine软件\n专业软件等",
			"added": 1580959787,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580961541,
			"title": "linux菜鸟是如何使用linux的？",
			"body": "",
			"added": 1580961512,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580961888,
			"title": "关于多系统的处理",
			"body": "方案一：访问win和其他linux需要root密码（可能是opensuse)\n方案二：可以直接访问win和其他linux，不需要密码\n方案三：使用管理员打开",
			"added": 1580961897,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580964457,
			"title": "linux 发行版制作经验",
			"body": "",
			"added": 1580964425,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580964547,
			"title": "手动安装的Linux可以当作日常使用的系统吗？",
			"body": "LFS或类似的都可(不包括Arch, Gentoo, Ubuntu等发行版)",
			"added": 1580964514,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580967239,
			"title": "社区事务",
			"body": "",
			"added": 1580967205,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580972056,
			"title": "海盗湾怎么使用？",
			"body": "",
			"added": 1580972021,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580973602,
			"title": "在linux中使用powershell",
			"body": "",
			"added": 1580973566,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580975021,
			"title": "普通用户怎么管理系统？",
			"body": "空间耗尽警告\n硬件信息查看\n驱动管理器\n备份系统\n快速文件搜索\n全文搜索软件",
			"added": 1580975098,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580975719,
			"title": "命令行比图形操作方便的地方",
			"body": "创建多级目录\n批量创建目录",
			"added": 1580975681,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580975946,
			"title": "国内linux用户有多少？",
			"body": "",
			"added": 1580975906,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580979060,
			"title": "关于 gentoo编译内核",
			"body": "Gentoo 的安装，大概很多人会卡在内核配置上。当时由于看不懂内核的配置选项，一条一条地查翻译，到后面都没耐心了，就这样还花了好几个小时才把内核配置好，然后又花了一个小时编译，结果重启一看，Kernel Panic 。\n\nKernel Panic只能强制关机，台式机还行，笔记本经常强制关机是会损坏的",
			"added": 1580979019,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580979809,
			"title": "为傻子准备的操作系统（低学习成本）",
			"body": "要抗折腾：\n不弹出U盘直接拔\n突然断电\n强制关机",
			"added": 1580979767,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580980394,
			"title": "哪种 linux包管理器最好用？",
			"body": "不管哪一种，准备一个梯子是有必要的",
			"added": 1580980440,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580983012,
			"title": "资源有哪些？",
			"body": "娱乐资源\n教育资源\n技术资料",
			"added": 1580982968,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580983096,
			"title": "linux 对普通人有多难？",
			"body": "隔行如隔山",
			"added": 1581329177,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580984972,
			"title": "关于spam投票机制",
			"body": "新注册的帐号短时间内不拥有投票权",
			"added": 1580984926,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580996610,
			"title": "编译之美——谈Gentoo的灵魂",
			"body": "Good good emerge, day day update.\nGentoo Linux fans的每一天就这样度过。\nemerge (update)一天又一天，日复一日，这就算掌握Gentoo了么？\n\n我要说，Gentoo的关键，在编译。向前再走一步，就是要掌握crossdev。\ncrossdev的下一步，不是catalyst，而应该是Cross build environment。\nEmbedded Handbook就是讲解crossdev的wiki页。\n\nEmbedded Handbook\nCross build environment\n共同构成了Gentoo区别于MS Windows最闪耀的两个闪光点。就像一盘大棋的两个活眼，一栋大厦的两块基石，支撑起Gentoo Linux的整个大厦。\n\nCatalyst仅仅是一个Gentoo Installer的构造程序。它需要seed tarball。seed tarball就是由Cross build environment构造的。\n\nlegacy UNIX -> GNU gcc+glibc+binutils -> LFS -> portage -> crossdev -> Cross build environment\n\n任何支持POSIX内核的系统，在上面布署 GNU toolchain，就可以编译LFS，\n任何LFS或其他Linux发行版，在上面布署 portage，就可以编译出crossdev，进而制作Cross build environment。\n而这一切，只需要提供足够的ASCII纯文本写成的源代码和构建脚本的tarball软件包，再有一个现有的可以用的POSIX系统就行了。\n这就展示了，二进制，其实都是来源于ASCII纯文本的。这样一条被MS Windows紧紧掩藏的规律。现代软件、硬件系统都是来源于ASCII纯文本的。",
			"added": 1580996563,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580996684,
			"title": "gentoo 玩坏之后怎么修复？",
			"body": "",
			"added": 1580996636,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580997387,
			"title": "Gentoo的精髓——Portage",
			"body": "虽然其实这是一个标题党式的title…portage来自于BSD上大名鼎鼎的ports\n\n比较全面系统的介绍请参考portage的官方介绍。\n\n按照官方的说法，portage是gentoo在软件管理上最值得称道的革新功能。\n\n由于portage相关的内容非常的多，也可以说是gentoo的精髓所在，所以涉及篇幅也会比较长，打算分篇来写。将会包含以下一些部分\n\n    emerge的介绍\n    make.conf和portage的一些配置文件和其他杂项\n    USE flag详解\n    slot、virtual、meta等包\n    常用portage工具\n    使用二进制包\n    日常维护系统的经验和技巧\n    有趣的社会化编译gentwoo\n    打包格式ebuild\n    使用第三方仓库的工具layman\n\n可能的话还想来介绍分析一下portage的实现分析等等。\n认识包管理器emerge\n\n对于大部分情况来说，用户和portage打交道最常用的就是emerge这个命令了，你可以认为它就是gentoo下的包管理器，不过准确来说是portage啦。\n\n对于刚刚安装完gentoo的用户来说，由于stage3只提供了最基本的toolchains和必要的lib外几乎没其他工具和软件，所以第一时间想了解的就是如何安装软件，这一节我们先介绍一下emerge的常用方法。\n\n更加全面完整的信息请认真man emerge\n\n安装软件\n\nemerge pkg_name\n\n \n\n不出意外的话你会看到emerge开始拉取源代码包、自动进行configure和make等操作，顺利的话在执行完毕后，软件便已安装上去了。大体上和其他二进制的发行版似乎没多大区别，和ports一样，它会自动获取源代码、配置后安装。\n\n注意，emerge直接安装的包都会进入一个叫做world的集合里，以便批量操作，下面会使用到。\n\n同步软件信息\n\nemerge --sync\n\n \n\ngentoo把软件信息叫做portage tree，这条命令会让emerge从配置好的地址去rsync同步最新的信息。\n\n如果是首次同步，或者距离上次同步很久再进行操作，可以使用emerge-websync，它采用下载器直接通过http获取portage tree的压缩包，速度上比rsync更快。\n\n搜索包\n\nemerge --search kernel # 搜索包名含有`kernel`emerge --searchdesc kernel # 搜索包描述信息含有`kernel`\n\n常用参数，要注意大小写哦XD\n\n[ -1 | --oneshot ]   安装，并不计入`world`集合里\n[ -a | --ask ]       在执行emerge操作前询问\n[ -c | --depclean ]  自动检查、清理不再被依赖的包\n[ -f | --fetchonly ] 仅下载源代码，不进行安装\n[ -j | --jobs ]      相当于`make -j`参数，并行编译进程数量；可以覆盖`make.conf`里的配置\n[ -p | --pretend ]   模拟安装，显示会安装哪些包，一般用来确认依赖和配置情况\n[ -t | --tree ]      让emerge显示依赖的缩进过的树形结构，配合`-e`或者`-Du`使用\n[ -u | --update ]    让emerge检查目标的版本是否更新，若无更新则无操作\n[ -v | --verbose ]   显示详细的USE flag信息\n[ -C | --unmerge ]   不检查依赖，直接删除\n[ -D | --deep ]      查询被目标直接依赖以外的包，会获取更多、更准确的信息\n[ -N | --newuse ]    让emerge检查目标和依赖的USE flag是否更新，若有更新也一并emerge\n[ --with-bdeps=y|n ] 一并emerge本来不严格依赖的编译依赖\n\n# 检查包安装的USE flag详细情况emerge -pv# 因为有时候检查会时间比较长，可以用这个组合先检查是否有问题，OK就直接确认emerge -av\n# 一次性升级整个系统的包，包括system集合和world集合emerge -DNuav --with-bdeps=y @system @world\n# 自动清理不再需要的依赖emerge -ac\n\n \nportage的主要配置make.conf\n\n从名字上可以看出，portage差不多就可以替代原来人肉编译安装软件的自动化工具make，代为处理软件包的管理工作。\n\n比较新的版本都已经建议把make.conf的位置放到/etc/portage里去；比较早的版本是在/etc/里。\n\n记得在安装与启动里在安装前需要配置这个文件。比较全面的配置说明依然可以在man make.conf里找到。我们看看一些比较关键和有趣的选项吧\n\n# gcc编译时的参数，和主机的架构有关CFLAGS   \n# C编译时的优化参数，比如常见的`-march`，`-O`等，可以参考gentoo safe cflags里的条目CXXFLAGS \n# C++编译时的优化参数，同理，一般设置的和CFLAGS一致MAKEOPTS \n# make的参数，一般可以在这里指定`-j`等SYNC     \n# portage tree同步的地址，格式一般是`rsync://example.com/path/to/gentoo-portage`GENTOO_MIRRORS  \n# 获取distfiles，也就是源代码和补丁的tarball时下载的地址，可以指定多个哦，用空格分开FEATURES        \n# 指定porage一些操作时的默认动作，比如利用distcc、ccache，打包二进制文件、不安装文档等USE             \n# 全局的USE flag设置，一些设置还来自于系统profile的设定\n# 比较有趣的设置...让portage把一些警告信息关闭掉...嗯，我知道自己在干吗啦，不用你多嘴XDDDI_KNOW_WHAT_I_AM_DOING=yes\n\n至此，相信大家已经会使用emerge来安装、管理软件包了，安装完系统更多的请阅读手册哦XD\n\n下期将为带来portage最重要的功能之一——USE flag和相关配置文件。\n\n__END__",
			"added": 1580997338,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580998223,
			"title": "关于包格式",
			"body": "slackware：tar.xz\narchlinux：pkg.tar.xz\ngentoo：未知",
			"added": 1580998173,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1580999201,
			"title": "小众linux讨论专区",
			"body": "",
			"added": 1580999150,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9",
			"type": "group"
		},
		{
			"topic_id": 1580999263,
			"title": "Exherbo",
			"body": "Exherbo是基于源代码的Linux发行，它于2008年从Gentoo Linux分支出来。该发行主要是为开发人员和高级用户设计，他们被期望于能在此发行的开发中扮演积极角色。Exherbo提供一份非集中式的开发模型和原始代码，以及一套名为Paludis的快捷且灵活的包管理器。",
			"added": 1580999211,
			"parent_topic_uri": "1580999201_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy"
		},
		{
			"topic_id": 1581000083,
			"title": "原汁原味的 Linux 发行版 有哪些？",
			"body": "archlinux、gentoo、slackware、LFS",
			"added": 1581080715,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581034647,
			"title": "manjaro相比archlinux魔改了哪些东西？",
			"body": "",
			"added": 1581034593,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581034677,
			"title": "ubuntu相比debian魔改了哪些东西？",
			"body": "",
			"added": 1581034622,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581034833,
			"title": "各个发行版对软件包是怎么分类的（精细化程度）？",
			"body": "",
			"added": 1581034777,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581035014,
			"title": "你对包管理器了解程度有多么深？",
			"body": "",
			"added": 1581034979,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581035627,
			"title": "NuTyX",
			"body": "NuTyX是一份法语Linux发行，它从Linux From Scratch和Beyond Linux From Scratch而创建，并带有一份定制的包管理系统叫做cards。该包管理器能安装单独的二进制软件包，也能安装一组相关联的二进制包（例如KDE或Xfce这样的桌面软件包），还能从ports编译源代码包。该发行面向中级和高级Linux用户而设计。",
			"added": 1581035569,
			"parent_topic_uri": "1580999201_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy"
		},
		{
			"topic_id": 1581035695,
			"title": "AryaLinux",
			"body": "AryaLinux 是一个独立的基于源码（Source-based）的 Linux 发行版暨平台。其由可用于构建一个完整的 GNU/Linux 系统的诸多构建脚本组成，这些构建脚本参照了 LFS 及 BLFS 编写，AryaLinux 既是一个平台，也是一个 Linux 发行版。\n\nAryaLinux 平台包含构建脚本，可用于利用自由分发的源码构建完整的 GNU/Linux 系统。这些构建脚本根据 LFS 和 BLFS 书籍中提供的说明编写。虽然 AryaLinux 构建脚本有些偏离了规范并且超出了 LFS 和 BLFS 中的规定，但其基本的思想相同。除了构建脚本之外，该平台还包括 ALPS、AryaLinux 安装程序和一组帮助脚本，可以帮助个人构建完整的 Linux 发行版。ALPS 是 AryaLinux Packaging System 的首字母缩写。尽管名称表明 ALPS 是一个包管理器，但并非如此。它只是一个名字。实际上，ALPS 是一个简单的 python 脚本，及一些辅助的 bash 脚本，可以通过执行构建脚本来解析软件包的依赖并安装软件包。AryaLinux 安装器是 Live Disc 附带的图形安装程序。该平台其余部分的帮助脚本是简单的工具脚本，可帮助人们执行简单的发行版构建任务，如 chroot、创建 Live ISOs 下载基本系统源代码 tarball 等。AryaLinux 发行版是利用这些脚本构建的。",
			"added": 1581035636,
			"parent_topic_uri": "1580999201_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy"
		},
		{
			"topic_id": 1581036232,
			"title": "linux 网站",
			"body": "V0id Linux unofficial forum\nhttp://127.0.0.1:43110/1PRoZrJ9jENHsUT7BMJsgV8g2bFSGF1B4o/",
			"added": 1581036172,
			"parent_topic_uri": "1571115911_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581057173,
			"title": "linux 必须有的文件有哪些？",
			"body": "fstab",
			"added": 1581057112,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581059450,
			"title": "深入理解linux",
			"body": "",
			"added": 1581059388,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581065298,
			"title": "打造软件生态需要多才时间？",
			"body": "",
			"added": 1581065234,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581078840,
			"title": "如何理解虚拟机的change?",
			"body": "虚拟机是只保存改动的",
			"added": 1581078829,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581082416,
			"title": "包管理器数据库损坏了怎么办？",
			"body": "",
			"added": 1581082350,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581134120,
			"title": "CI/CD持续集成/持续部署 敏捷开发",
			"body": "敏捷软件开发（英语：Agile software development），又称敏捷开发，是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。\n\n1，CI/CD持续集成/持续部署\n\n       持续集成(Continuous integration)是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。\n\n       持续部署（continuous deployment）是通过自动化的构建、测试和部署循环来快速交付高质量的产品。某种程度上代表了一个开发团队工程化的程度，毕竟快速运转的互联网公司人力成本会高于机器，投资机器优化开发流程化相对也提高了人的效率，让 engineering productivity 最大化。\n\n       持续交付（英语：Continuous delivery，缩写为 CD），是一种软件工程手法，让软件产品的产出过程在一个短周期内完成，以保证软件可以稳定、持续的保持在随时可以释出的状况。它的目标在于让软件的建置、测试与释出变得更快以及更频繁。这种方式可以减少软件开发的成本与时间，减少风险。\n\n       与DevOps的关系\n\n       持续交付与DevOps的含义很相似，所以经常被混淆。但是它们是不同的两个概念。DevOps的范围更广，它以文化变迁为中心，特别是软件交付过程所涉及的多个团队之间的合作（开发、运维、QA、管理部门等），并且将软件交付的过程自动化。另壹方面，持续交付是壹种自动化交付的手段，关注点在于将不同的过程集中起来，并且更快、更频繁地执行这些过程。因此，DevOps可以是持续交付的壹个产物，持续交付直接汇入DevOps；\n\n       与持续部署的关系\n\n        有时候，持续交付也与持续部署混淆。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。\n\n1.1、jenkins是什么？\n\nJenkins是一个可扩展的持续集成引擎。\n\n主要用用途：\n\n持续、自动的构建/测试软件项目。\n\n监控一些定时执行的任务。、\n\n特点：\n\n易于安装，只要把jenkins.war部署到servlet容器\n\n易于配置-所有配置都通过其提供的web界面实现。\n\n集成RSS/E-mail通过RSS发布构建结果或当构件完成是通过e-mail通知。\n\n生成JUnit/TestNG测试报告。\n\n分布式构建支持Jenkins能够让多台计算机一起构建/测试。\n\n文件识别：Jenkins能够跟踪那次构建生成哪些jar，那次构建使用哪个版本的jar\n\n插入支持：支持扩展插件，可以开发适合自己团队的使用的工具。\n\nJenkins的目标是监控软件的开发流程，快速显示问题。所以能保证开发人员省事又省力提高开发效率。\n\n2、项目版本迭代控制:、\n\n现有的版本控制工具，如 Github、GitLab、SVN、CVS 等主流工具..\n\n构建及测试:通过 Jenkins 实现自动构建和测试,还有商业软件BAMBOO来持续集成。这个收费的。免费就用Jenkins..\n\n交付:以Docker镜像形式进行交付，提交至镜像仓库；\n\n2.1 SVN服务器：\n\nSubversion是一个版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上免费的版本控制服务多基于Subversion。\n\nSubversion的版本库可以通过网络访问，从而使用户可以在不同的电脑上进行操作。从某种程度上来说，允许用户在各自的空间里修改和管理同一组数据可以促进团队协作。因为修改不再是单线进行（单线进行也就是必须一个一个进行），开发进度会进展迅速。此外，由于所有的工作都已版本化，也就不必担心由于错误的更改而影响软件质量—如果出现不正确的更改，只要撤销那一次更改操作即可。某些版本控制系统本身也是软件配置管理系统（SCM），这种系统经过精巧的设计，专门用来管理源代码树，并且具备许多与软件开发有关的特性——比如对编程语言的支持或者提供程序构建工具。不过Subversion并不是这样的系统，它是一个通用系统，可以管理任何类型的文件集。\n\n2.2 CVS服务器：\n\nCVS（Concurrent Versions System）版本控制系统是一种GNU软件包，主要用于在多人开发环境下源码的维护。Concurrent有并发的、协作的、一致的等含义。实际上CVS可以维护任意文档的开发和使用，例如共享文件的编辑修改，而不仅仅局限于程序设计。CVS维护的文件类型可以是文本类型也可以是二进制类型。CVS用Copy-Modify-Merge（拷贝、修改、合并）变化表支持对文件的同时访问和修改。它明确地将源文件的存储和用户的工作空间独立开来，并使其并行操作。CVS基于客户端/服务器的行为使其可容纳多个用户。这一特性使得CVS成为位于不同地点的人同时处理数据文件（特别是程序的源代码）时的首选。\n\n所有重要的免费软件项目都使用CVS作为其程序员之间的中心点，以便能够综合各程序员的改进和更改。这些项目包括GNOME、KDE、THE GIMP和Wine等。\n\n2.3 GIt/github：\n\n    GIT （分布式版本控制系统）\n\nGit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。\n\nGit是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是 Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 很多 Freedesktop 的项目迁移到了 Git 上。\n\ngitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。\n\ngitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。",
			"added": 1581134053,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581134250,
			"title": "k8s简介",
			"body": "一、为什么需要 k8s？\n1. 应用部署模式的演进\n\n相比虚拟机和容器\n\n    容器更加轻量级，启动更快（秒级）\n    容器可移植性更好\n\n2. 管理大量的容器带来了新的挑战\n\n容器编排调度引擎 —— k8s 的好处\n\n    简化应用部署\n    提高硬件资源利用率\n    健康检查和自修复\n    自动扩容缩容\n    服务发现和负载均衡\n\n二、k8s 的集群架构\n\n    主节点，承载 k8s 的控制和管理整个集群系统的控制面板\n\n    工作节点，运行用户实际的应用\n\n三、pod —— k8s 调度的最小单元\n1. 一个 pod 包含一组容器，一个 pod 不会跨越多个工作节点\n\n2. 了解 pod\n\n    pod 相当与逻辑主机，每个 pod 都有自己的 IP 地址\n    pod 内的容器共享相同的 IP 和端口空间\n    默认情况下，每个容器的文件系统与其他容器完全隔离",
			"added": 1581134182,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581229519,
			"title": "普通人使用linux都干什么？",
			"body": "",
			"added": 1581229450,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581231691,
			"title": "关于linux使用的分类",
			"body": "游戏\n办公\n折腾\n开发\n软件交流群\nfor 在校学生\nfor 傻瓜用户\n小众linux",
			"added": 1581232037,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581232269,
			"title": "gentoo使用记录",
			"body": "1 gentoo的mask不太理解，软件不稳定至少也应该提供一个能用的低版本\n2 仓库里没有的软件应该怎么安装？\n3 portage输出很准确，apt会搜索到一堆无关的包\n4 gentoo的学习成本很高",
			"added": 1581393660,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581235991,
			"title": "一般人用 Linux 算是找虐吗？",
			"body": "Linux是一个开源操作系统的内核名称。严格地说这里的“Linux”是指“GNU/Linux”。\n\n这里所说的“一般人”是指在日常的工作/学习生活中完全不、也无需与Linux有任何接触的人群，但不包括出于职业要求或研究、学习需要或其他目的而在物理机、虚拟机内安装并使用Linux操作系统的人群。",
			"added": 1581235919,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581236712,
			"title": "COPR 仓库中 4 个很酷的新项目（2020.01）",
			"body": "COPR 是个人软件仓库集合，它不在 Fedora 中。这是因为某些软件不符合轻松打包的标准；或者它可能不符合其他 Fedora 标准，尽管它是自由而开源的。COPR 可以在 Fedora 套件之外提供这些项目。COPR 中的软件不受 Fedora 基础设施的支持，或者是由项目自己背书的。但是，这是一种尝试新的或实验性的软件的一种巧妙的方式。\n\n本文介绍了 COPR 中一些有趣的新项目。如果你第一次使用 COPR，请参阅 COPR 用户文档。",
			"added": 1581236639,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581315734,
			"title": "linux 进阶方向",
			"body": "1 编译打包\n2 安装slackware\n3 安装 LFS\n4 日常使用\n5 问题定位\n6 能看懂help和man手册",
			"added": 1581315840,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581316324,
			"title": "有没有关于 linux包管理器的实现方面的文章？",
			"body": "相关问题：[linux包管理器是怎么工作的？](http://127.0.0.1:43110/153Bqdxo4iNAfaqMMZJ9BJHHKSmvqxJ1NY/?Topic:1581316790_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy/linux)",
			"added": 1581316767,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581316790,
			"title": "linux包管理器是怎么工作的？",
			"body": "",
			"added": 1581316714,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581317489,
			"title": "论起diy，linux才是天堂，附T1 mk2听感",
			"body": "楼主穷烧，米不起咸菜，只能在免费的东西上作文章......\n\n耳机：T1 MK2，Soulnote SD300平衡口直推，笔记本USB连接，播放软件：deadbeef、hqplayer。\n\n系统：gontoo linix\n  整个系统从一个200多M的压缩包逐步构造，所有软件从源码编译安装，通过设置编译参数针对本机CPU指令集进行优化；另外，gentoo没有现成的内核，内核也是自己配置、编译，追求的是高度的可定制性和极致的性能发挥。\n\n内核: rt-source，传说中的实时内核\n（真正打了rt patch的实时内核，不是ubuntu studio那种low laytency低延迟内核）；\n  从系统最底层精简优化，包括但不限于为桌面系统挑选更合适的CPU及IO调度算法，精简不需要的功能和驱动，用ubuntu默认的内核配置文件来编译内核需要接近2小时，而精简后只需要编译10分钟。\n\n软件优化精简：\n  得益于gentoo强大的USE机制，通过配置USE，在软件编译时直接去掉不需要的功能。比如系统默认配置下编译出来的deadbeef播放器是不带eq调节功能的，需要的话添加USE=supereq，然后重新编译安装。装了lxde桌面，开机内存占用300M左右。\n\n划分CPU集合，避免无关进程占用过多CPU资源：\n  双核四线程的CPU，在系统内体现为CPU0到CPU3，将所有非音频的用户进程限制在CPU3上，无关痛痒的内核进程限制在CPU0和CPU3上，从而避免音频无关的进程占用过多CPU资源，以至于开个firefox发帖都有点卡了......\n\n为USB DAC选取CUP中断干扰最小的USB口，并优化驱动加载参数\n\n优化进程调度：\n  提高计时器和USB设备的中断响应优先级；\n  将播放软件的进程从分时调度改为FIFO的实时调度，并提高进程优先级，从而能够直接抢占普通进程的资源，得到最快的响应。\n\n音频输出：\n本来是用专业级的Jack-Audio-Connectkit的，面向音频工作站，致力于低延迟的音频回放，最有趣的是可以把网页上播放的音频流导入到录音软件里直接内录下来；无奈deadbeef和hqplayer都不支持jack输出，将alsa导入jack的话，又不可避免的经过混音，只能滚回直接用alsa输出了。\n不要急着吐槽linux的src，通过更改alsa配置文件或者让播放软件独占声卡，是不会有src的。\n\n这套系统下的T1 MK2 听感：\n1. 相比win下的foobar，最明显的感觉，背景更加干净，声音更细腻、低频起伏连贯自然，弹性十足，背景乐器声音起落清晰可闻，让人感觉声音是有形有状的，相比之下，win下foobar的声音就没有那种滴水般清晰完整的感觉，如同下雨天听歌，背景和声音边缘都糊了，一些音源较差的歌曲，foobar下听不出的破音，linux下就给暴露出来了。\n2. 缺点：deadbeef中频没foobar突出，听人声感觉差些，4倍提升采样率后会有很大提升，hqplayer没这问题，只是试用模式下半小时后会自动关闭，操作也不太友好。",
			"added": 1581317412,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581325179,
			"title": "操作系统前沿技术",
			"body": "2020-2月\n\nwayland 和sway\nbtrfs 和zfs、IPFS\nsmartos\nfreebsd\nexherbo\n极客专用操作系统：plan9和lisp machine\nWSL2\nWine\nRetroShare （F2F 软件）",
			"added": 1581326336,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581325641,
			"title": "Plan-9效应：不作死就不会死",
			"body": "# 概述\n\nPlan-9是一个很棒的、很先进的，而且完全是全新实现的Unix系统，它的目的就是要最终解决Unix最初的诺言：一切皆为文件。你听说过这套系统吗？没有？那好，下面就是为什么。\n\n我十分确信你不知道Plan-9是什么东西，并且很有可能你还是第一次听说这个名字。\n\nPlan-9是一款神奇的新版Unix，几乎是由70年代当初开发Unix系统的同一个团队开发的。它的确是一款非常酷的操作系统。它跟Unix非常相似，但它不是Unix，它纠正了Unix系统里很多不一致的、古怪的、至今仍然存在的特性。\n\nUnix在当初立项时有个这样的许诺：系统里任何的东西都是‘文件’——根据某些文件的定义。例如，sockets，也许称作网络连接更合适，它们就不是文件，进程也不是文件。\n\n在Plan-9中，所有的这些问题都解决了！先进的9P虚拟文件系统协议最终让所有东西都成为了文件。目录变成了“命名空间”，资源被映射成了文件。多么神奇！现在，你可以通过对/proc目录(现在应该成其为一个命名空间)里的一个文件使用“cat”命令来查看进程的情况。同样，打开一个网络连接的方式变成了打开/net/tcp目录里的一个文件，这就是它。”iotcl”系统调用在这个系统里完全被根除了，因为基于操作系统上的现代文件形式中的这种怪胎已经不再需要了。\n\n# 那么，为什么你从来没有听说过这样一款神奇的操作系统呢？\n\n你从来没有听说过它的原因是，它并不是一款成功的操作系统。这怎么可能呢？是这样的，是因为Plan-9实际上没有解决任何问题。在Unix世界里，从来没有人抱怨说Unix没有兑现当初关于文件抽象的诺言。\n\n在随后的日子里，Plan-9里的/proc文件系统概念被人移植到到了Solaris等很多其他商业版Unix系统里(Linux也采用了它)。 Plan-9里另外一个非常著名的首创——UTF-8——被迅速的被众多其它操作系统采用，不仅仅是Unix家族。在所有的操作系统里，即使存在一些由于各种原因没有采用UTF-8的，它们也开发出来将UTF-8和本地编码转换的程序库。\n\nPlan-9的对于网络通信的特殊的处理方式需要在这里特别的说明一下。虽然用基于命名空间/文件系统的方式来代替专用API来处理网络操作，听起来很吸引人，但是整个Unix世界，不仅所有人都已经接受了使用伯克利Socket API做为标准方式来进行网络编程，甚至Windows平台也实现了几乎相同的API里简化各种网络应用向Windows上移植——虽然存在一些小问题。\n\n更重要的是，Plan-9发明的这种与众不同的网络编程编程方式在诞生之日就注定了毫无用处。因为在当时，大部分做网络编程的人都已经转向了更高的网络抽象层。RPC和Corba已经诞生，所有的需要跟远程服务器通信的应用全都转向了它们。程序员为了跟远程服务通信时需要打开sockets的机会越来越少，所有的他们都已经习惯了使用Berkeley API。(旁注：曾经有一个POSIX模拟层，叫做APE“ANSI/POSIX Environment”，试图将Plan-9上的某些功能映射到POSIX对应的功能上。这个模拟层一直都没实现，因为一些应用——例如X11——的迁移过于复杂，不可能完成。“维持它正确运行的工作量太过巨大”——维基百科[1]。)\n\nPlan-9的一个最主要的问题出在AT&T和Unix幕后的这群人身上，尽管他们都是才华横溢的科学家和程序员，但他们不懂得如何去开发商业软件，而AT&T也从来没打算进入软件业。这些，我承认听起来有些大不敬，但事实就是这样。他们使用软件，他们喜欢开发内部软件来运行他们的高端网络设备，但是他们却从来不去开发要卖给别人的软件，而且跟Sun，IBM，微软等商业公司不一样，这从来不是他们的资金的主要来源。这就意味着他们不需要有外部世界需要什么样的软件的意识。举个例子，Sun公司就需要这样的意识，所以他们开发出了RPC。他们认识到人们在进行网络编程时很痛苦，他们看到了创建一个网络抽象层的商业机会：“嗨，大伙们，SunOS有一个很酷的东西，让我们能够不直接跟sockets打交道就可以开发出网络应用！你绝对应该使用SunOS”。\n\n还有，在Plan-9中，很多“好的老的东西”被删除了，大量的跟其它Unix不兼容的东西被加入了系统。这几乎打消了众多公司试图将他们的应用迁移到Plan-9的念头。如果你不知道这样一个新系统是否能够获得成功，那为什么要耗费了大量的工作把自己的应用迁移到这个新平台上呢？这就是典型的鸡生蛋蛋生鸡问题：一个操作系统的价值就在于上面有大量应用可运行，无它。如果一个系统很新，你要做的是必须发展一个能够支持各种应用的生态系统，通过它们让这个系统变得有价值。只有两条路能做到这样。第一个就是让这个系统跟目前现存的系统保持最大的兼容，也就是Unix， POSIX 和 Motif 这些系统。第二个就是创建自己的生态系统，以此来提升新系统的价值，微软Windows和Office办公系统软件就是典型例子。\n\n# 我们应该从Plan-9的历史教训中总结出一些经验吗？\n\n当然，我们至少可以获得下面这些：\n\n    首先是，不要试图去修改那些没有坏或你认为不够好的东西，如果要修，只去修改出问题的部分，不要去修改看起来很笨——但事实上是在按要求工作的东西。例如，UTF-8是个非常棒的创意，你需要它，但你可以用程序库或子系统实现它，这样其它系统也能使用它，而不是去基于这个编码开发出一套全新的操作系统。\n    第二个是，在开发一个你的系统前，先去搞清楚它是否有市场，或者人们是否需要这个东西。例如，/net/tcp文件系统绝对是一个精彩的纯学术课题，如果是早几年，它一定能完胜Berkeley sockets，但不应该是在直接使用Socket的人群已经没剩几个的时候。\n    第三，要么完全的独立自主，要么跟现有的系统保持最大兼容。但Plan-9却处在它完全不应该的位置：中间。这套系统既不跟现有的所有Unix系统兼容，同时也不提供其它Unix系统中都有的、必要的工具。没有高级文本编辑器、表格软件、CAD程序和服务器软件。它就是一个神奇的空盒子，却没有提供任何方法让人们容易的把东西放进去。\n\n这些看起来都是一些非常高层的东西，并不是特别跟程序员的日常开发相关。看起来是这样，但事实远非如此。现如今，你可以很容易的开创自己的事业，开始向用户提供某种的服务。然而，你的服务是一个有价值的产品？还是变成了另外一个Plan-9传奇？这并不是很容易判断的事。例如，你的打算开发一个报表系统，来展现监控数据或其它任何可视的状态，如果你没有提供用它将这些报表导入到Excel的功能，那你在写第一行代码前就输了。如果你打算开发一个新的Web社交应用，而你没有提供使用Fackbook、Twitter或LinkedIn登录的方式，那你在搭建WEB服务器前就输了。如果你web服务中信息的导出方式没有采用RSS或ATOM，而是采用了一种全新的格式，猜会怎么样？你在吸引到第一个用户前就输了。但是，比着一切更重要的是：你的产品真正的解决了一个现实存在的问题吗？\n\n[英文原文：The Plan-9 Effect or why you should not fix it if it ain't broken[2] ]\n\n原译文标题：Plan-9效应：为什么东西不坏就不要去修它\n\nvia : http://www.aqee.net/the-plan-9-effect-or-why-you-should-not-fix-it-if-it-aint-broken/",
			"added": 1581325679,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581326614,
			"title": "设计优秀的软件有哪些？",
			"body": "Lisp\nSmallTalk\nGit\nPlan9\nIPFS",
			"added": 1581326534,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581327763,
			"title": "有人玩桌面BSD 吗？",
			"body": "FuryBSD\nMidnightBSD",
			"added": 1581329507,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581328107,
			"title": "一个人的BSD——MidnightBSD",
			"body": "MidnightBSD（官方主页在这里：http://www.midnightbsd.org） 是一个“小众版”的BSD系统，作者是Lucas Holt。尽管MidnightBSD目前只有Lucas一个人维护，但是它却诞生在2005年，也算是“历史悠久”了。而Midnight是Lucas养的第一只猫的名字。\n\nMidnightBSD的初衷是要做一个对普通用户更友好的“桌面版”FreeBSD。我并没有使用过MidnightBSD，所以无法对其用户体验做出评价。但是Lucas一个人来做维护一个操作系统的发行版的所有工作：改代码，搭建cvs服务器，创建mport等等，还是很令我佩服的。不过也正如Lucas自己所说的：\n\n    Learning how to work on MidnightBSD has been the most rewarding project I’ve ever done.\n\n尽管工作艰难，但是整个过程也让Lucas收获颇丰，学到了很多知识，这也的确是“回报丰富”。\n\n坦率地讲，我个人很羡慕Lucas，也希望有朝一日能拥有自己的操作系统发行版。",
			"added": 1581328025,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581345955,
			"title": "在家庭生活中装一个linux系统都可以做什么？",
			"body": "近想学linux，但linux系统的强大的网络服务器功能都是在企业有用，家庭生活中几乎很少用到，所以学习比较盲目。所以想问下在家庭生活中装个linux都可以做哪些实用的或是有意思的功能？",
			"added": 1581345872,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581346452,
			"title": "我使用linux都干什么？",
			"body": "数据收集\n数据整理\n软件收集\n教程整理\n资源整合",
			"added": 1581390930,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581346754,
			"title": "使用linux遇到了哪些问题？",
			"body": "",
			"added": 1581346669,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581346881,
			"title": "脚本语言哪个好？",
			"body": "",
			"added": 1581346795,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581378158,
			"title": "玩Linux碰到的问题以及使用技巧总结",
			"body": "1、问题\n\n    问题一：解压JDK报错：gzip:stdin:not in gzip format。\n    问题二：在Linux下ping不通外网\n    问题三：解决虚拟机克隆后网卡eth0不见的问题\n    问题四：执行脚本报错：syntax error: unexpected end of file或syntax error near unexpected token `fi'或-bash bad interpreter: No such file or directory\n    问题五：Authentication refused:bad ownership or modes for dircetory /root，ssh免密错误\n\n文章总体分为两部分：问题和使用技巧。\n\n1、问题\n问题一：解压JDK报错：gzip:stdin:not in gzip format。\n\n情景：\n我先是通过命令:\n\nwget http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz\n\n    1\n\n从oracle官网下载jdk。\n然后执行解压命令：tar -zxvfjdk-8u144-linux-x64.tar.gz，却报错：\n\ngzip: stdin: not in gzip format \ntar: Child returned status 1 \ntar: Error is not recoverable: exiting now\n\n解决方法：\n执行以下命令（将下载地址改为自己需要的版本）\n\nwget --no-check-certificate --no-cookies --header \"Cookie: oraclelicense=accept-securebackup-cookie\" http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-linux-x64.tar.gz\n\n报错原因：\n通过file命令辨识一下压缩文件的类型：\n\nfile jdk-8u144-linux-x64.tar.gz\n\n结果却是jdk-8u144-linux-x64.tar.gz:HTML document text…\n原来这个压缩文件是html\n\n这个文件之所以是html，是因为是：文件的下载链接不是直接指向文件，而是先指向一个页面，在这个页面里才是真的下载链接，所以我们通过wget下载的其实是一个页面。通过以上的命令就OK了。\n\n其他解决方法：\n有些是因为解压缩方式不正确，更改对应的解压缩指令即可。\n————————————————\n问题二：在Linux下ping不通外网 \n\n在linux中ping www.baidu.com 无法ping通，可能原因是DNS没配置好\n\n方法一：修改vi /etc/resolv.conf\n\n增加如下内容:\n\nnameserver 114.114.114.114 (电信的DNS)\n\nnameserver 8.8.8.8（googel的DNS）\n\n就可以实现ping通外网了\n\n",
			"added": 1581378090,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581378370,
			"title": "[FAQ] Linux常见问题",
			"body": "关于linux下面的ctrl+s和windows下面ctrl+s.\n\n \n\nlinux下面的ctrl+s是停止整个终端的响应，如同死机，但是这种状态可以按ctrl+q退出这种状态，个人感觉很实用~~~\n\nwindows下面的ctrl+s是保存意思，时没有发现别的用途。",
			"added": 1581378282,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581379542,
			"title": "如何评价 AI 少女？",
			"body": "沉迷在种田阶段的玩家不在少数。如果在社交媒体上搜索“AI少女”，得到的第一印象不是这游戏的小姑娘多么好看动作模组多么腐朽，而是“种田真好玩！”某种程度上来说，《AI少女》丰富的经营建造玩法完成了一个对男性玩家的闭环生态链——进游戏，和美少女约会啪啪啪，贤者时间开始种田，玩家两方面的欲望都得到了极大的满足。\n",
			"added": 1581379495,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581379755,
			"title": "你玩过什么的有趣/奇葩的工口游戏吗？",
			"body": "",
			"added": 1581379665,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581380935,
			"title": "电脑有哪些有趣的玩法？",
			"body": "",
			"added": 1581380843,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581383780,
			"title": "Linux 好用的软件",
			"body": "太长了自己看\nLinux下的开源软件有哪些有趣的玩法? - 阿铭linux-猿课的回答 - 知乎\nhttps://www.zhihu.com/question/21654251/answer/256855060\n\nRemarkable\n\nRemarkable, Linux 下的 markdown 文档编辑器。\n\nbrackets\n\nWeb 前端编辑器\n\nterminology\n\n万能的终端工具terminix\n\nGTK3 终端模拟器\n\nTermKit\n\nTermKit 是由 Steven Wittens 为 MacOS X 编写的一个很有趣的项目，可以称之为下一代的富媒体终端。\n\nTmux\n\nTmux 是一个优秀的终端复用软件。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。\n\nterminator\n\n一个不错的终端工具nmon\n\nNmon（nigel’s monitor 的简写）是一个显示系统性能信息的工具,可以显示与 netwrok，cpu, memory 和磁盘使用情况的信息。\n\nncdu\n\n是一个支持光标的 du 程序，这个命令是用来分析各种目录占用的磁盘空间。按 n 则通过文件名来排序，按 s 则按文件大小来排序（默认的）。\n\ndstat\n\n一种灵活的组合工具，它可用于监控内存，进程，网络和磁盘性能，它可以用来取代 ifstat, iostat, dmstat 等。\n\n\nslurm\n\n一个网卡带宽监控命令行实用程序，它会自动生成 ASCII 图形输出。安装:\n\napt-get install slurm\n\n使用：\n\nslurm -i <网卡名称>\n\nranwhen.py\n\n一种基于 Python 的终端工具，它可以用来以图形方式显示系统活动状态\n\nplymouth-manager\n\n修改开机登录界面。可以美化你Ubuntu的启动主题Plymouth，下载：https://launchpad.net/plymouth-manager/+download\n\nkazam\n\n屏幕录制软件\n\nfirebug\n\n火狐插件，Web开发者调试工具\nokular\n\n阅读器，可用于阅读pdf，也可用于阅读epub电子书。\n\nranger\n\n基于终端的文件浏览器\n\nlolcat输入彩色文本，例如 cat “hello world”lolcatcmatrix\n\n终端打印矩阵\n\nWeather Indicator Applet (天气预报)\n\n安装命令：\n\nsudo apt-get install indicator-weather\n\nClassicMenu\n\n经典的 GNOME2 菜单, 安装命令：\n\nsudo apt-add-repository ppa:diesch/testing\n\nsudo apt-get update\n\nsudo apt-get install classicmenu-indicator\n\nCaffeine（咖啡因）\n你怎样确保你的电脑不会在放一部精彩的电影中途突然休眠呢？Caffeine 会帮助你解决这个问题。当然，你并不需要为你的电脑泡一杯咖啡。你只需要安装一个轻量级的指示器 —— Caffeine。只要当前你是全屏模式，它就会禁用你的屏幕保护程序、锁屏程序，让你的电脑不会因为没有在任务中而进入睡眠模式。\n\ncheat\n\nLinux 命令备忘清单，https://github.com/chrisallenlane/cheat\n\nhtop\n\nhtop 是一个更加先进的交互式的实时监控工具。htop 与 top 命令非常相似，但是他有一些非常丰富的功能，如用户友好界面管理进程、快捷键、横向和纵向进程等更多的。htop 是一个第三方工具并不包括在 Linux 系统中，你需要使用包管理工具进行安装。\n\nTickeys\n\nTickeys是一款很强大的键盘音效软件。Tickeys 自带多种声音效果方案，有打字机、冒泡、机械键盘、剑气等。每天都听着键盘声音是不是很烦闷，现在有了这款神器你就可以瞬间帮助自己的键盘加上逼格特效。https://github.com/BillBillBillBill/Tickeys-linux/\n\n\nfestival\n\n语音合成软件,安装使用参考:https://linuxtoy.org/archives/festival_on_ubuntu.html\n\nautossh\n\n自动重连 ssh\n\nSysPeek\n\n系统指示器\n\n\nlnav\n\nlnav 工具是在终端界面看日志的神器\n\n\nFabric\n\nFabric 是一个用 Python 编写的命令行工具库，它可以帮助系统管理员高效地执行某些任务，比如通过 SSH 到多台机器上执行某些命令，远程布署应用等。",
			"added": 1581383683,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581383828,
			"title": "Linux 中大而全的软件有哪些？",
			"body": "Emacs\nSystemd",
			"added": 1581383730,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581383861,
			"title": "如何推广 linux？",
			"body": "多写教程",
			"added": 1581383762,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581383933,
			"title": "2020年 linux还缺少哪些软件？",
			"body": "",
			"added": 1581383833,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581384116,
			"title": "资源求助专贴",
			"body": "",
			"added": 1581384015,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581384333,
			"title": "有比 Telegram 更适合发布资源的地方吗？",
			"body": "要去中心、能稳定连接、支持频道功能",
			"added": 1581384231,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581391194,
			"title": "我的linux之路",
			"body": "我是自学的，很少问过他人",
			"added": 1581391091,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581398302,
			"title": "打开电脑却不知道干什么，怎么办？",
			"body": "朋友突然问一句:有没有一个更优的选择让他不至于在电脑面前看着爆炸的信息陷入无尽的空虚，但是又不得不依赖，互联网个人大抵是这样一种相互撕扯的关系。\n我更想知道这是一种什么样的心理。",
			"added": 1581398198,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581398733,
			"title": "linux 没事干了怎么办？",
			"body": "",
			"added": 1581398628,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581400493,
			"title": "你认为哪个终端复用器最好用，为什么？",
			"body": "终端复用器(Terminal Multiplexer)是用于复用多个虚拟终端的应用软件，允许用户在一个终端窗口中访问多个单独的登陆会话，或者从终端分离和重新连接会话。\n\n常用的终端复用器应该有这些: Emacs, Vim, Byobu, DVTM, mtm, Neercs, Terminator, Tmux, Tmuxinator, Twin, Screen\n\n你认为哪个终端复用器最好用，为什么？（不限于上述这些）\n\n如果是使用Emacs或Vim，请说明一下你是如何配置的",
			"added": 1581400387,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581403351,
			"title": "有没有类似listary的linux软件？",
			"body": "功能：快速切换目录",
			"added": 1581403244,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1581405024,
			"title": "曾经也装过各种发行版，各种桌面环境，各种工具",
			"body": "因为世界这么大，我想去看看",
			"added": 1581404916,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		}
	],
	"topic_vote": {
		"1580983096_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": 1,
		"1580891805_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": 1
	},
	"next_comment_id": 146,
	"comment": {
		"1579165212_1FfatX3G2z43rV6nc1F3koYtn8tmD5EVb6": [
			{
				"comment_id": 1,
				"body": "SmartOS 是一个unix-like的操作系统，它主要集成了opensolaris的技术以及Linux KVM：ZFS + DTrace + Zones + KVM。",
				"added": 1580798344
			},
			{
				"comment_id": 110,
				"body": "CRUX是面向经验丰富的Linux用户的x86-64体系结构的轻量级Linux发行版。这种分发的主要重点是保持简单，这体现在一个简单的基于tar.gz的软件包系统，BSD样式的初始化脚本以及一个相对较小的修剪过的软件包集合中。次要重点是利用新的Linux功能以及最新的工具和库。CRUX还具有端口系统，可以轻松安装和升级应用程序。",
				"added": 1581251519
			}
		],
		"1580799876_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 2,
				"body": "windows画图很好用，可以wine 吗 ？",
				"added": 1580799900
			}
		],
		"1577836120_1MityxAx6QVFTYWjzSJFc6nCX6eyT5W5yQ": [
			{
				"comment_id": 3,
				"body": "feren OS 安装失败\n吸引普通人使用linux\n学习解决问题，努力\n没有梯子网站打不开，不让下载东西，真麻烦\n养成长期翻墙的习惯",
				"added": 1580816735
			},
			{
				"comment_id": 5,
				"body": "信息收集，信息整理\n使用时间做有用的事\n零网，被人遗忘的网络\n分享我的思考过程\n我也有能力写教程了",
				"added": 1580816394
			},
			{
				"comment_id": 7,
				"body": "让您完全掌控的浏览器 | Vivaldi\n您的浏览器很重要。Vivaldi 是一款超级可控与可配置的浏览器。快速、安全且灵活——这是专为您打造的浏览器。",
				"added": 1580817100
			},
			{
				"comment_id": 8,
				"body": "术语：自媒体，天天写一堆没用的东西",
				"added": 1580823975
			},
			{
				"comment_id": 10,
				"body": "在windows上预装一个没有界面、开机启动的ZeroNet，给别人装系统，迅雷就是这么干的",
				"added": 1580895216
			},
			{
				"comment_id": 15,
				"body": "无限分散化",
				"added": 1580898985
			},
			{
				"comment_id": 16,
				"body": "linux就是这样，要么自己动手，要么慢慢等上几年，不一定有人帮助你\n丰富linux下的游戏教程",
				"added": 1580899696
			},
			{
				"comment_id": 17,
				"body": "这么小众的东西也没有人有心情制作假文件\n小众的地方肯定有好东西",
				"added": 1580907510
			},
			{
				"comment_id": 18,
				"body": "隐含条件",
				"added": 1580908110
			},
			{
				"comment_id": 19,
				"body": "忍住\n平平淡淡才是真\n没有时间亲自去解答问题了",
				"added": 1580946528
			},
			{
				"comment_id": 20,
				"body": "自从使用了linux，整个人都变懒了\n使用linux需要一点点的学习成本，不过大多数人都是懒的，不愿意学习\n经常在论坛看到新人有一些奇妙的操作\n写教程的时候要严格声明，禁止看那些过时的教程，准备一个新手学习区，保证教程都是最新的",
				"added": 1580962232
			},
			{
				"comment_id": 21,
				"body": "忘了在哪看到的：\nwin10 好不容易稳定了，强制更新又变成测试版了，永远的BUG 10",
				"added": 1580960986
			},
			{
				"comment_id": 22,
				"body": "软件知名度\n网站知名度",
				"added": 1580963804
			},
			{
				"comment_id": 23,
				"body": "已经沉迷玩防沉迷系统了",
				"added": 1580964043
			},
			{
				"comment_id": 24,
				"body": "零网都是各聊各的，完全没有主题",
				"added": 1580968666
			},
			{
				"comment_id": 25,
				"body": "软件的中断恢复处理",
				"added": 1580977373
			},
			{
				"comment_id": 26,
				"body": "为他人服务（不是免费的）\n帮助他人\n更有耐心一点",
				"added": 1580982451
			},
			{
				"comment_id": 27,
				"body": "日常使用的软件并不会太多，下载慢的软件就挂在那慢慢下吧\n珍惜现有的一切，等到没了就晚了（时间、自由、家人）\n分享资源不是为了去让迅雷、网盘赚钱的",
				"added": 1580982346
			},
			{
				"comment_id": 28,
				"body": "认真的研究一下\n尽我所能\n自求多福\n努力的活着\n付出更多的努力",
				"added": 1580985769
			},
			{
				"comment_id": 29,
				"body": "这是认真思考后的想法",
				"added": 1580983083
			},
			{
				"comment_id": 30,
				"body": "安静的社区\n人机交互优化\n不想说了",
				"added": 1580984110
			},
			{
				"comment_id": 31,
				"body": "不看电视剧那种理想剧本，只看现实",
				"added": 1580984725
			},
			{
				"comment_id": 32,
				"body": "P2P的魅力：\n\nBitTorrent简称BT，一种P2P网络。什么是P2P网络呢，就是对等网络，用户之间互相分享数据。\n\n再通俗一点，你从别人那里得到文件，又把文件分享给别人。\n\n读到这里，你可能认为这样会很慢。\n\n其实不然，一旦某个文件下载的人较多，即使每个人的上传速度很小，加起来也比一般下载方式快很多。\n\n（辛辛苦苦的把文件下载下来了）",
				"added": 1580985550
			},
			{
				"comment_id": 33,
				"body": "管理学",
				"added": 1580985141
			},
			{
				"comment_id": 34,
				"body": "看内蒙古电视剧好像不错的样子（放牧生活？草原生活？）（或者拉萨？）",
				"added": 1580985456
			},
			{
				"comment_id": 35,
				"body": "知者善行",
				"added": 1580988032
			},
			{
				"comment_id": 36,
				"body": "圈内人和圈外人\n使用被人遗忘的技术",
				"added": 1581048818
			},
			{
				"comment_id": 39,
				"body": "排除杂念，专心做事\n简单胜于花哨\n太绝对了不好\n人太懒还更新什么？真的懒人都不更新系统的，陈旧的系统一用就是好几年不更新。",
				"added": 1581062334
			},
			{
				"comment_id": 41,
				"body": "linux和windows差不多，都有图形界面\nlinux 对于我这种需求低的人还是挺好用的",
				"added": 1581120350
			},
			{
				"comment_id": 44,
				"body": "强化练习，加深记忆",
				"added": 1581090817
			},
			{
				"comment_id": 47,
				"body": "我给你们讲个笑话 微软制作 linux发行版了\n我给你们讲个笑话 Windows开源了",
				"added": 1581123075
			},
			{
				"comment_id": 48,
				"body": "有的英文零网博客使用IPFS显示图片",
				"added": 1581123368
			},
			{
				"comment_id": 49,
				"body": "灵魂被困在身体之中，不能自由的行动，有了身体，就有了生老病死\n世界的本质是意识海，世界是由众人的意识产生的\n事物不是实有的，是空有的\n生活是一个不断更改状态的过程，过去的经历只存在于记忆之中\n时间会淡忘一切，事情会消失在人们的记忆之中",
				"added": 1581125219
			},
			{
				"comment_id": 50,
				"body": "OCaml （ML家族语言）很好很强大\n\n理由如下：\n\n1. 强类型，写着放心\n\n2. 函数式。 且不是pure functional， 不用像 Haskell 那样极端。。\n\n3. Algebric Data Types 的模式匹配 实在太爽了\n\n4. modules 很强大\n\n5. 语法很简洁。\n\n \n\n=================== 缺点\n\n冷门，库好像很少。\n\n文档更少\n\n中文书籍：目前只有一本中文教材：《真实世界的OCaml》 ( Real World OCaml )",
				"added": 1581131630
			},
			{
				"comment_id": 52,
				"body": "Linux 所有发行版玩完一遍，你的人生转瞬即逝",
				"added": 1581133467
			},
			{
				"comment_id": 54,
				"body": "出色且小众的语言数不胜数， 一个语言的流行需要它自己的契机。unix成就c， 人们对更高一级抽象的需求使ｃ＋＋走上主流的舞台。　cgi和对文本处理的需求成就了perl, 对perl的憎恨成就了python,　rails促成了ruby的流行。OCaml有什么？",
				"added": 1581132696
			},
			{
				"comment_id": 55,
				"body": "这问题同样可以用于Erlang，Common Lisp，作为主力用Erlang，辅助的使用OCaml和 Common Lisp，日常js恰饭的工程员，很多时候感觉，为什么一定要流行呢？ 自己用着舒服就行，能不加班，能快速完成工作就行了。用这些语言，快速完成一些小工具，减少重复工作，快乐的看别人秀996，这不很好嘛。这类语言，总体来说要求略高，生态一般，缺少一些轮子，企业管理不便，不流行是必然的。Ruby都没流行起来，这些语言就更难了。 Worse is better.",
				"added": 1581132741
			},
			{
				"comment_id": 56,
				"body": ":= 语法叫什么？\n在定义一个变量却并不显式指定其类型时（使用:=语法或者var =表达式语法）（Go语法指南）",
				"added": 1581134443
			},
			{
				"comment_id": 59,
				"body": "某人曾说过，你看看那些入了lisp邪教的人：某河，某垠，啧啧啧（逃\n怎么能漏了某杀",
				"added": 1581135444
			},
			{
				"comment_id": 75,
				"body": "不再研究 exherbo和编程语言了",
				"added": 1581145469
			},
			{
				"comment_id": 76,
				"body": "不要用对自己的要求去要求别人\n痛苦的学习过程，不断的重复，不断的练习才能学会",
				"added": 1581152364
			},
			{
				"comment_id": 77,
				"body": "打击新手这个游戏非常有打击感\n能屈能伸=圆滑",
				"added": 1581222216
			},
			{
				"comment_id": 79,
				"body": "完全傻瓜版的linux",
				"added": 1581230262
			},
			{
				"comment_id": 111,
				"body": "tar是最好的包管理器\nredcore安装失败\nsnap 和flatpak 虽然下载的慢，起码是能下载的，不会破坏系统的依赖关系",
				"added": 1581327449
			},
			{
				"comment_id": 112,
				"body": "Q：mastodon 和 https://github.com/diaspora/diaspora 有啥差别？\nA：类似的，一个是 facebook，一个是 twitter。",
				"added": 1581307323
			},
			{
				"comment_id": 131,
				"body": "撸猫爱好者专属游戏：巧克力与香子兰\n异星工厂和Linux是自动化的代表作\n辅助工具：帮助自己做重复的事或麻烦的事\nLinux ISO 定制\n资源保源计划：多宣传、多分享、互相保源",
				"added": 1581385434
			},
			{
				"comment_id": 133,
				"body": "零网的人流量是相当的低",
				"added": 1581385412
			},
			{
				"comment_id": 134,
				"body": "csdn  下载东西要钱，非常垃圾\n想到一个方法，发贴字数需要消耗积分，用来控制帖子的质量，使用积分和容量进行双重限制\n信息交流\nP2P 世界本来就是动态的，耐心等待吧\n有的时候不想翻帖子，想看看别人闲聊，看看前沿动态\n需要用到的软件已经稳定了，不想天天更新了",
				"added": 1581391602
			},
			{
				"comment_id": 136,
				"body": "系统太稳定了，完全没有重装的欲望\n自己用着好就行了，没有时间管别人了\n小众发行版很难找到资料",
				"added": 1581407214
			},
			{
				"comment_id": 137,
				"body": "Q：没事干怎么办？\nA：看书、干活、去上班，出去锻炼身体",
				"added": 1581397894
			},
			{
				"comment_id": 138,
				"body": "Q：没有方向了怎么办？\nA：看看大神在做什么，向大神学习",
				"added": 1581397963
			},
			{
				"comment_id": 139,
				"body": "什么信息能赚钱？",
				"added": 1581397986
			},
			{
				"comment_id": 141,
				"body": "程序员三大美德:懒惰 骄傲 不耐烦",
				"added": 1581399876
			},
			{
				"comment_id": 142,
				"body": "还是喜欢纯净版的系统，我不需要的东西为什么要占用空间，不过一旦忙起来就没功夫管这么多了\narchlinux 变得彻底纯净了",
				"added": 1581407250
			},
			{
				"comment_id": 145,
				"body": "计算机技术是不是很难？\n坚持使用古老的聊天方式",
				"added": 1581414943
			}
		],
		"1580810002_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 4,
				"body": "关于linux软件的使用教程：GIMP、 krita、inkscape",
				"added": 1580810667
			}
		],
		"1579824583_1FfatX3G2z43rV6nc1F3koYtn8tmD5EVb6": [
			{
				"comment_id": 6,
				"body": "安装 Flash插件",
				"added": 1580813889
			},
			{
				"comment_id": 127,
				"body": "slackware很好，很简洁，不支持那些高级功能，高级功能会带来过多的复杂性",
				"added": 1581379861
			}
		],
		"1580894294_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 9,
				"body": "修改ulimit(就是linux最大打开文件数)",
				"added": 1580894738
			}
		],
		"1580898260_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 11,
				"body": "UEFI支持\n多屏支持\n高分屏支持",
				"added": 1580898477
			},
			{
				"comment_id": 12,
				"body": "资源搜索引擎\nAutoHotKey",
				"added": 1580898775
			},
			{
				"comment_id": 13,
				"body": "丰富的教程",
				"added": 1580898581
			},
			{
				"comment_id": 14,
				"body": "离线安装软件",
				"added": 1580898647
			}
		],
		"1579577309_1FfatX3G2z43rV6nc1F3koYtn8tmD5EVb6": [
			{
				"comment_id": 38,
				"body": "如果没有包管理器，那么各个Linux发行版的文件布局会一样吗？",
				"added": 1581035182
			}
		],
		"1580999263_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 40,
				"body": "听说这个系统很厉害，有没有人玩过？",
				"added": 1581064080
			}
		],
		"1581000083_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 42,
				"body": "Slackware是基于源码的发行版吗？\n与LinuxFromScratch或Gentoo不同，你不必编译整个系统。上述版本的支持者相信可以通过例如针对CPU的优化得到速度的大幅提高。实际上，速度的提高很小，除了几个程序(例如MPEG-2解码器，也可能是KDE之类的桌面环境)，你可能感受不到(速度的提高)。Slackware一般是编译好的，但假如你需要你也可以自行用Slackware的源码和编译脚本编译各个部分。与源码发行版相比，Slackware的优点在于你不必编译整个系统，这样有更多的灵活性，并很可能得到一个更稳定的系统(因为有些优化会坏事)。",
				"added": 1581082492
			}
		],
		"1580484667_18xqjuBBjsq1QBTbwuUwf2q7pJk7weAAoN": [
			{
				"comment_id": 43,
				"body": "slackware家族\nslax\narchlinux家族\ngentoo家族\npuppy家族\nalpine\n",
				"added": 1581229395
			}
		],
		"1577266994_1DcbdcgJk7mw465FGxYHMkz9zgyNgvpsWY": [
			{
				"comment_id": 45,
				"body": "关于 chroot 安装linux忘记复制 resolv.conf的问题，可以再开一个终端复制，不需要退出chroot",
				"added": 1581121805
			},
			{
				"comment_id": 46,
				"body": "网友是linux爱好者，而不是售后\n有的 linux社区很奇怪",
				"added": 1581126722
			},
			{
				"comment_id": 143,
				"body": "> [18xqjuBBjsq1Q@kaffie.bit](#comment_77_18xqjuBBjsq1QBTbwuUwf2q7pJk7weAAoN): Q：包管理器是什么时候开始运行的？A： [...]\n\n或者用的是安装盘上的包管理器",
				"added": 1581407724
			}
		],
		"1580627942_1Nuy44vnJ367XgJByfV8okAEKVJNWEuN1X": [
			{
				"comment_id": 51,
				"body": "OCaml是一种快速、简洁、而强大的应用程序开发语言－－我想大家也许已经知道这一点了，而且已经安装了OCaml。",
				"added": 1581131671
			},
			{
				"comment_id": 53,
				"body": "Shen语言是函数编程语言Qi的继承者，由 Mark Tarver博士开发，首个版本是在2011年释出，其名字意思是“精神”。Qi采用的是GPL和私有许可证，而Shen没有使用GPL，而是作者自己制定的一个许可证，允许自由开发和分享但必须遵守语言规格。\n\nShen 提供的功能包括：\n\n    模式匹配\n\n    lambda 表达式\n\n    宏\n\n    可选的惰性求值\n\n    静态类型检查\n\n    集成全功能的 Prolog\n\n    内建编译器",
				"added": 1581132147
			},
			{
				"comment_id": 57,
				"body": "Elixir是一种函数式动态语言，用于构建可伸缩、易维护的应用程序。\n\nElixir是基于Erlang VM的，其广为人知的特点是运行低延时、分布式、可容错的系统，并成功用于Web开发与嵌入式软件领域。\n\n使用 Elixir 可以长生不老",
				"added": 1581133740
			},
			{
				"comment_id": 58,
				"body": "Racket，原名PLT Scheme   ，是一种计算机程序设计语言   ，在Lisp和Scheme基础上增加了对象、类型、惰性求值等，也是一个程序设计环境，可以让人们设计自己的程序语言。同时自带丰富的第三方库，如web服务器、数据库、GUI、图像处理等。\nRacket是自由软件，授权为LGPL。\nWindows版本的Racket6.0.1（最新版本于2014年2月26日发布）里有Racket、GRacket、DrRacket三个主程序。Racket是一个cmd下的命令行程序，GRacket和DrRacket则是Windows窗口程序，前者是后者的简化版本，后者功能更为强大。\nRacket是Lisp语言的一种方言。LISP(LISt Processor)语言，即列表处理解析语言，由约翰·麦卡锡（John McCarthy）于1960年左右发明。",
				"added": 1581135849
			},
			{
				"comment_id": 60,
				"body": "NewLISP是一种类似于LISP的通用脚本语言。它特别适合在AI、模拟、自然语言处理、大数据、机器学习和统计中的应用。由于其较小的资源需求，NewLISP对于嵌入式系统应用是极好的。您将需要的大部分功能已经内置。这包括联网功能、分布式和多核处理的支持和贝叶斯统计。",
				"added": 1581135831
			},
			{
				"comment_id": 61,
				"body": "Arc 语言是 Graham 设计的一种全新的 Lisp 方言，被实现为一个对 MzScheme 的扩展程序。与其它方言不同，这个语言具有十分清晰和“现代化”的语法，以至于无法被直接实现为一组 Scheme 的卫生宏。按照作者的话说，Arc 是一种适合“探索性编程”(exploratory programming)的语言，适合乐于思考但不想被现有语言的语法、特性等不足限制思考的程序员使用，在构建大型程序方面并无很大优势。 语法方面，使用了整合 cond 能力的 if，类似 Lua 的 for 语句，省略了转换函数（相对于 Lisp）的宏定义 mac，被替换为方括号的 lambda，字符串、列表、散列的取值语法即函数调用语法。并简化了大量常用语法。 语义方面，增加了对于 Lisp 来说不存在的算符这一概念。示例： (map odd:car ' ((1 2) (4 5) (7 9))) 返回 (t nil t)\n&nbsp;  \n发明方言是lisp高手独有的乐趣, 很多狂热分子都热衷这样做。比如Paul Graham就发明了ARC, 许多记号比传统的Lisp简洁得多, 显得比较现代)\n&nbsp;  \n我知道一家AVOS CLOUD这家公司是用clojure（lisp dialect）的。\n要说国外成熟的应用，你应该知道HN （Hacker News）吧，那个就是arc lisp写出来的。还有一个商业的音乐软件也是用lisp写的。",
				"added": 1581136217
			},
			{
				"comment_id": 62,
				"body": "Emacs Lisp。自带很多处理文本、缓冲区、命令循环、键绑定等很有用的功能。即使你不用 Emacs，Emacs Lisp 也是一门很值得学习的语言，你可以用emacs --script和emacs --batch来执行程序。实现的话，还是用 GNU Emacs 吧，其他的 implementation 也都大同小异。",
				"added": 1581136260
			},
			{
				"comment_id": 63,
				"body": "Hy是嵌入在Python中的Lisp方言。 由于Hy将其Lisp代码转换为Python抽象语法树（AST）对象，因此您可以轻而易举地以Lisp形式拥有Python的整个美丽世界。",
				"added": 1581136608
			},
			{
				"comment_id": 64,
				"body": "F#是由微软发展的为微软.NET语言提供运行环境的程序设计语言。它是基于Ocaml的，而Ocaml是基于ML函数程序设计语言的。 这是一个用于显示·NET在不同编程语言间互通的程序设计",
				"added": 1581136722
			},
			{
				"comment_id": 65,
				"body": "CHICKEN是Scheme编程语言的编译器。 它产生可移植且高效的C语言，并支持R5RS和R7RS（进行中的）标准以及许多扩展。 它可以在Linux，OS X，Windows和许多Unix操作系统上运行。",
				"added": 1581137239
			},
			{
				"comment_id": 66,
				"body": "Lisp 家族迎来新成员，函数式语言 Lux 是什么？ \n\n代码世界即将加入一门新成员：Lux。你没看错，它不是洗发水，而是古老的 Lisp 家族中新诞生的函数式语言。\n\n目前 Lux 还在研发之中，最新版本是 0.5.0。它可被用来编写一系列在 JVM （Java 虚拟机）上运行的程序。但它的语义并不是与 JVM 绑定的，因此，Lux 应该被理解为是一门通用语言，被设计用来尽可能多平台地进行程序表示。但同时，它要能够深入每一个特定平台，实现后者的丰富功能。",
				"added": 1581137397
			},
			{
				"comment_id": 67,
				"body": "R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。",
				"added": 1581137931
			},
			{
				"comment_id": 68,
				"body": "Julia 是一个面向科学计算的高性能动态高级程序设计语言。其语法与其他科学计算语言相似。在许多情况下拥有能与编译型语言相媲美的性能。Julia 是个灵活的动态语言，适合科学和数值计算，性能可与传统静态类型语言媲美。",
				"added": 1581137966
			},
			{
				"comment_id": 69,
				"body": "Hack是Facebook发布的一种编程语言。\n\nHack是HHVM的编程语言。Hack将动态类型语言的快速开发周期与静态类型提供的学科相结合，同时增加了其他现代编程语言中常见的许多功能。\n\nHack通过在编辑文件时逐步检查文件来提供即时类型检查。它通常运行在不到200毫秒的时间内，使其易于集成到开发工作流程中，而不会引起明显的延迟。",
				"added": 1581138180
			},
			{
				"comment_id": 70,
				"body": "Ada是一种表现能力很强的通用程序设计语言，它是美国国防部为克服软件开发危机，耗费巨资，历时近20年研制成功的。它被誉为第四代计算机语言的成功代表。与其他流行的程序设计语言不同，它不仅体现了许多现代软件的开发原理，而且将这些原理付诸实现。因此，Ada语言的使用可大大改善软件系统的 清晰性， 可靠性， 有效性， 可维护性。",
				"added": 1581138230
			},
			{
				"comment_id": 71,
				"body": "Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准   。它被用于web、服务器、移动应用 和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。\n&nbsp;  \nDart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system",
				"added": 1581138534
			},
			{
				"comment_id": 72,
				"body": "D语言，一种通用计算机程序语言，威力强大、功能丰富，支持多种编程范式，例如面向对象。\n&nbsp;  \nD语言最初由Digital Mars公司就职的Walter Bright于2001年发布，意图改进C++语言。目前最新D语言被简称为D2。最主要的D语言的实现是DMD。\n&nbsp;  \nD 语言源自C/C++，借鉴了众多编程语言的特色和现代编译器技术，融会贯通了设计者丰富的实践经验，使之具备了非凡的威力－－既有 C/C++ 语言的强大威力，又有 Python 和 Ruby 的开发效率。它集众多系统级编程所需的功能于一身，例如垃圾回收、手工内存操作、契约式设计、高级模板技术、内嵌汇编、内置单元测试、Mixin 风格多继承、类 Java 包管理机制、内置同步机制、内建基本运行时信息。",
				"added": 1581138518
			},
			{
				"comment_id": 74,
				"body": "《七周七语言》",
				"added": 1581145321
			}
		],
		"1580979060_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 73,
				"body": "经常按关机按钮对笔记本不好，可以直接抠电池",
				"added": 1581145292
			}
		],
		"1581229519_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 78,
				"body": "看电视直播\n看小说\n玩游戏\n玩 Hi-Fi\nQQ、微信\n写日记\n记笔记\n文献管理\n淘宝卖家、阿里旺旺\n网盘\n听歌\n远程控制\n邮件客户端",
				"added": 1581347353
			},
			{
				"comment_id": 80,
				"body": "windows后台进程太多了",
				"added": 1581235738
			},
			{
				"comment_id": 122,
				"body": "高级需求：\n图片编辑\nGIF 录制\n视频处理\n调音师",
				"added": 1581345602
			}
		],
		"1581235991_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 82,
				"body": "再补充两句。这个回答只是想说一个观点，即如今的Linux没那么虐。儿童都能简单的用起来。这里只有个习惯问题，不存在使用难度上的差别。\n\n绝不是鼓动任何人用Linux。如果产生这种错误观念是你自己的问题，不要试图在评论区证明Linux不好使。我家夫人觉得Windows好使，我很佩服，并支持她继续用。然而仅限于她的平板，想反过来以Windows对她来讲好使为理由让我把我的台式机换成Windows，那是不可能成功的。对我来讲，Windows才是那个用不明白的高难度系统。",
				"added": 1581236298
			},
			{
				"comment_id": 83,
				"body": "其实，现在的Ubuntu，linuxmint，deepin等桌面发行版几乎都做到了开机即用，不用配置什么东西的。\n\n一般人，我对一般人的定义就是看视频，办公，逛淘宝，微信，Tim，阿里旺旺等简单的桌面软件应用而已。如果只是这样，你的Linux只是需要装一个flash插件罢了，这个过程很简单，全程鼠标操作就OK了。\n\n我真觉得，现在的桌面版Linux真的用鼠标点点就可以了……",
				"added": 1581236407
			},
			{
				"comment_id": 88,
				"body": "常见的思维误区是“已经有很好用的XX了，我为什么要去学YY”，其弊端在于很容易培养出不求甚解的思维习惯",
				"added": 1581236892
			},
			{
				"comment_id": 90,
				"body": "建议先考虑用它来做什么，有一个目的后再开始动手，才会有解决问题的动力，否则又是安装20分钟后发现“这也不行、那也没有”然后就要么一边愧疚一边放弃要么开始抱怨Linux是个垃圾。这种情况，从定义上，就是找虐。我个人的话最早是因为电脑配置太低，不能装Win97，结果才去尝试，但没有坚持，因为装完了不知道干嘛……但自从开始写代码后，就开始觉得Windows上做开发各种找虐，比如字符集、类库、文件锁定、软件安装特别麻烦（这个估计很多人都不理解，一试便知）等等。于是就被逼到了Linux。开始也各种虐，但Windows上的没法解决，Linux下的逐渐学会了就不虐了。回到问题，如果是日用的话……只能说Linux大部分事情也能做，但想不出来非要用的理由。在这个层面上，非工作需要的话，还是找虐。虽然Steam现在出手了，但大多数游戏还是在Windows上不是么？最后分享一个案例，9年前，因为同事都分不清楚操作系统之类的概念，我当时滥用职权，把一个文员的电脑硬是换成了Fedora（也有可能是Redhat），结果那个文员工作也糊里糊涂坚持下来了，直到两个月后IT的VP来视察工作……",
				"added": 1581237231
			},
			{
				"comment_id": 92,
				"body": "两个月前就在知乎看见一个很扯的观点，说的是一个美国的教授认为随着社会分工进一步细化和知识的打包很多知识会被遗忘并造成严重后果。造成什么后果我不知道，但是编程领域的知识隔代丢失是很严重的。年纪稍微老一点的大牛，在智力上毫无疑问是很突出的。但是更重要的一点就是，很多操作的知识在他们那里是默认的。对于他们来说了解这个东西本身就是一个循序渐进的过程，或者说，linux也好其他编程知识也好本身就是在他们前半生出现并完善的。而普通人去学习这些东西自然感觉杂乱无章很困难。基本学习路径就只能试错并google了。学会了当然不是找虐，但是问题就是学不会。",
				"added": 1581237489
			},
			{
				"comment_id": 93,
				"body": "不，比Windows方便\nWindows找冷门软件要一点点翻搜索引擎，说不定还会下到病毒\nLinux可就方便了，一行命令，直接安装下来，而且永远下到的都是船新版本，不会下到老版本",
				"added": 1581237533
			},
			{
				"comment_id": 94,
				"body": "算是，但是Windows里面找个像xfce-terminal一样好用的terminal都难。\n\n只好去魔改mintty了。那你们说我用Windows是不是找虐？\n\n工作起来只需要ssh客户端和gcc，然后切到Linux里一天不用回微信爽丫丫。",
				"added": 1581237669
			},
			{
				"comment_id": 95,
				"body": "当然不是，你要明白你是在“学习使用”一个东西，你当然得看书、看文档、看 Wiki 和查资料了。你这些都不做，并且在没有任何相关基础的情况下企图直接上手，才是找虐，这对于其它 IT 相关的领域都是通用的。假设你定义的“一般用户”是指的通过 Windows 的最常规操作方式“直接使用”Linux，那么现阶段的 Linux 其实已经做到了：例如窗口的管理方式相同、双击安装软件、商店浏览应用、桌面快捷方式等。如果你觉得仍然在其它地方会更加麻烦，那范围就已经超出你设定的“一般用户”了。实际上大多数人无形之中也折腾过很多 Windows 问题，只不过使用 Widnows 的周期太长了，所以导致折腾频率较低印象不深。要是你想进行一些相对“高级”的用法，但是仍然以 Windows 那一套来做为标准不针对系统差异化进行学习，那么就不适做 Linux 用户，甚至也不适合当 macOS 的用户。\n\n有很多人是怎么使用 Linux 的？就是遇到任何东西都靠百度解决。例如说我想安装软件，那么我搜索关键字“Ubuntu 安装软件”，知道了安装软件的命令的用法：apt install [package] 第二天，我要删除一个软件，然后我又靠搜索找到了第二条命令：apt remove [package]第三天，我想清理软件（移除不用的包）。第四天我要更新软件……这种人，一直在舍近求远。明明你稍微看一下文档（man）或者加一个 --help 参数就能在极短的时间内了解 apt 这个工具的所有核心用法，并且掌握其规律。但是你懒，懒得看这种系统化的东西，以为自己针对目标搜索就是“走捷径”，实际上你做了多少无用功心理没点数？\n\n上面只是个非常初级可能对于很多人而言是并不符合实际的例子，但我想表达的是这类人更多的是不想通过系统化的学习一件事物，没有循序渐进的一个过程。导致对系统总体认知极其的零散，更别提对任何一个方面有稍微深入的理解了。这样的人即使有几年的 Linux 使用经验，也不如看书入门的几个月的初级用户。以我接触过的 Linux 用户来看，网络上是比比皆是的，甚至一部分“运维”都是这样的人（我曾经遇到过不会写 Shell 的 Linux 运维）。很多事情走捷径的方法就是看一本好点的书，系统化的入门。而不是像无头苍蝇一样自行胡乱摸索，处处碰壁，最后玩不下去了反而怪这怪哪。当你有了一定基础，看到问题自然就知道原因，即使不知道也掌握了迅速排查原因的方法。并且你系统化的入门会规避掉新手常见的绝大多数低级问题，普通用户能遇到的问题有相当多都是错误的用法或者不当的操作/配置方式导致的，即使真是遇上 BUG 了你也不会是第一个发现的这点你放心（所以网上一定有解决办法）……\n\n像这类想法的人，就属于对开源软件有莫名其妙的“奢望”的人。你给我钱我给你定制一个傻瓜 Linux 发行版出来，否则你就应该明白免费&开源软件就是这样。如果一个普通用户明白这一点，花一些时间看看有用的“内容”的话，玩转 Linux 完全不是什么问题，我初中就在使用 Linux 了请问那时候我不是普通用户吗？",
				"added": 1581237915
			},
			{
				"comment_id": 96,
				"body": "不过当初入坑linux原因可无关码代码。当时装着win系统的硬盘有些问题，也在那个时候点亮了重装系统这个技能，用起了跑在内存里的pe系统，也意外的接触到了另一个跑在内存里的国产linux发行版veket，之后这个系统陪着我度过了等待新硬盘的一段时间。让我惊讶的是veket很好用。1 这么小的体积，没有打驱动，但所有硬件都正常用起来了，当时还是xp,win7当道，不装驱动无线都连不了，而win8刚面世被喷呢。2 有浏览器，播放器，正常上网，刷贴吧，看ab站，看视频听音乐。网银不支持，但是可以淘宝走支付宝，想想看，那怕是现在的win10，不装个第三方播放器，能好好听歌看视频文件么。当然现在流行在线看了和特定的客户端了。3 没有垃圾，没有什么杀毒软件/卫士，也没有什么病毒。那个时候ie就像个靶子，上上网下载下载东西，然后，突然冒出来的搜索栏插件，什么主页被改，什么莫名被装上xxx浏览器，装上什么页游之类的破事都来了。",
				"added": 1581238091
			},
			{
				"comment_id": 97,
				"body": "最近准备写一个连载，如果对这部分喜欢的同学可以关注一下~\n\n找虐不是找虐，要看你用Linux 做什么事情，如果你是做开发的同学，用windows，装个cygwin后面也是会有各种权限的问题。如果在Linux下，各种命令，一直用一直爽~一直用一直爽\n\n如果你不是程序员，是一个普通的用户，就平时编辑下文档，谢谢文案ppt，那就比较尴尬了~假设你在ubuntu下要用个微信，用个qq,那就需要用其他东西了，比如下面有人说的\n\ndeepin 15.5（国内深度团队基于debain（更正：应该是debian）开发的Linux系统）\n\n就比较适合你了，但是不管怎么适合，应该也没有windows来得爽。",
				"added": 1581238182
			},
			{
				"comment_id": 98,
				"body": "很多东西的难易程度，不在于事物自身，而是人的“习惯”；举些例子，外国人眼里的“中国筷子”、“中国功夫”、“中国话” and “中国的乒乓球”... 嗯，上述的问题在我们眼里只是小儿科，而对于99%的歪果仁来说，最低难度都是“噩梦”级别，所以一般人使用Linux or Windows，不是“装不装”，“行不行”，只是习惯不习惯。如果科技知识就和姥姥教你管“麻雀”叫“家巧”一样简单的可以传授，Linux是绝对作为系统中的霸主：",
				"added": 1581238281
			},
			{
				"comment_id": 99,
				"body": "也不算找虐，只是入门更难些，有问题时大多是在网上找答案或自己折腾解决，周围用的人少。而且很多软件用不顺手或需要的软件找不到，所以还是有小部分时间会用到虚拟机里的 Windows 系统。我用基于 Linux 的桌面系统一部分原因是兴趣，另一部分是被当时的 Windows 系统下的弹窗、病毒虐怕了，还有不舒服的字体渲染。Linux 桌面系统不适合大部分人使用，Windows、Mac 也不会让所有人满意。",
				"added": 1581238369
			},
			{
				"comment_id": 100,
				"body": "我教会了很多无基础的用户用上Linux事先我都会问他们：\n\n1、你喜不喜欢玩流行的且Windows Only的（快餐）游戏\n\n2、能不能擅用搜索引擎，查wiki\n\n3、有没有从Windows那些习惯颠覆过来的耐心\n\n4、有没有因为工作且Windows Only的软件，如果有且数量不多，我会帮忙判断有没有替代品\n\n5、英语基础怎么样（能否看懂一般的语句）这样看来确实不适合一般人\n\n当然这些条件即使不满足也能用：\n\n1、Linux也有很多可玩性高的游戏，还有个steam，至于wine和crossover什么的我还是不推荐（不清真\n\n2、这个可以慢慢学，养成习惯\n\n3、也有很多Linux就是模仿Windows（zorin，mint）也有模仿OS X的（elementary）\n\n4、就算有很多工作需要的软件，如果有俩台电脑或双系统最好，自己慢慢摸索替代方案\n\n5、Linux也有比较完善的汉化（如果你英语不错，请帮忙翻译）\n\n所以适合不适合一般用户只是个伪命题，全在于遇到的是什么样的用户我觉得吧，Linux让我觉得有电脑的完全控制权，而不是Windows那不完整的使用权。",
				"added": 1581238997
			},
			{
				"comment_id": 101,
				"body": "如果不了解Linux，上来就用Windows思维，然后搞出毛病了怪系统，那就折腾。我就不信看完鸟哥顺便知道怎么翻wiki的人会觉得Linux折腾，可是不理解就跑来用Linux的人太多了，什么我就做个服务器，我就跑个机器学习，花点时间了解一下系统，能省不少事情，世界上又不是只有你微软爸爸，拿Windows思维处理Linux，你不折腾谁折腾？",
				"added": 1581239055
			},
			{
				"comment_id": 102,
				"body": "普通用户 一般人  linux 呵呵.......别没事给普通人安利linux，自己玩就好了，要安利，先想想自己有没有足够的时间帮这些人解决问题，尤其是别安利给年轻人，年轻人啥不懂不学习还爱装逼，容易作死，作死了就来找你，别问为什么，我经历过，耗费大半天，恶心从来都不考虑给普通用户安利linux看看各个linux群，一个个命令行都不熟，能指望干什么？别说什么linux打打命令，win点鼠标麻烦，对于常人来说，动鼠标反而是最简单最直观的事情。最起码软件名称和软件是一致的。linux上的软件名能和中文意思在一块的有多少？微信真的叫中文微信吗？搜狗真的叫搜狗吗？直观吗？不百度你知道什么名吗？安装完知道安装在哪吗？配置文件在那吗？有几个不修改配置文件的？这些操作你让普通人去研究？去干活？崩溃了白干了进不去桌面了驱动挂了算谁的？算你的吗？",
				"added": 1581239234
			},
			{
				"comment_id": 103,
				"body": "一般人要想做到快速上手Linux是不可能的，就算是macOS也没做到。十几年前大家接触windows的时候不也是这样吗？唯一有区别的是，习惯了windows之后，再用Linux会在潜意识中时刻与Win做对比，认为在在某些功能在win下很方便，但其实只是暂时没有找到更好的解决方法而已，这与自身的认知有关系。其次，为什么机动车和电动车要设计得一样？为什么QQ和微信要设计得一样？不都要为了要用户更好的迁移，而做到最大的商业价值吗？但大多数人最后还不是发现，QQ比微信好用？但灵活性与简易性不可兼得。东西要做好，做灵活，操作起来越不容易。就好比手动挡与自动挡一样，不熟悉其内部原理、运行机制，又如何能想将车发挥出极限的性能？ps1:Windows 越来越爱把用户当傻子了，开机一个圈圈转半天，不知道干了些什么，，转半天没桌面出来才知道是死机了。整个Win10把ui改成乱七八遭。关机就关机，休眠就休眠乱搞概念。",
				"added": 1581239303
			},
			{
				"comment_id": 104,
				"body": "需要用的人自然会去用，不需要用的人没必要去用，不存在什么找虐。",
				"added": 1581239402
			},
			{
				"comment_id": 105,
				"body": "用惯了linux后，你也会发现，M$ Windows也很粗糙。纯本人感觉，勿喷。",
				"added": 1581239428
			},
			{
				"comment_id": 106,
				"body": "知乎有一个论调：WINDOWS垃圾一无是处，LINUX大法好玩不好的都是小白，MAC是feature。\n\n然而……我因为工作原因遇到一些客户，其电脑小白程度到了难以言喻的地步，甚至有一种这人是不是没用过电脑的错觉，然而实际上我那客户十几年前就在用电脑了，当然没用过什么高端操作。但实际上这类小白，确实占了不少数量，这类用户不在乎什么系统原理，什么类UNIX的血统，他们只在乎直观、易用，知道点这个按钮是什么意思，点那个按钮是干嘛用的，背后的原理才懒得了解。你让这类一般人去用难用的LINUX桌面，呵呵……\n\n什么？没桌面的系统？然后他们就用一种关爱沙比的眼神看着你，这都2018年了，你还在用上古时代的电脑，对，很多一般人眼中对操作系统没概念，电脑=操作系统。\n\n我们再来看看在WINDOWS下，一个软件是怎么用的，双击安装包，一直下一步，等待安装完成，点击桌面图标就直接用了，没了，一般用户最最常用的也就这操作，你还想让他们敲一个命令行？于是他们就用一种关爱沙比的眼神看着你，这都2018年了，你还在用上古时代的电脑。\n\n所以这也是为什么MAC在国内越来越流行的原因，因为MAC下的很多基础操作确实很傻瓜，而且界面美观舒适（我觉得这才是重点），就适合这类懒得去学习用电脑的用户，你让这类用户去买一本书专门学习怎么用linux？\n\n骚年，别的国家我就不提了，至少在中国，用电脑和懂电脑是两码事，你们折腾linux，有可能是个人兴趣，有可能也是工作需要，但是一般人都没有这两方面的需求，那么就是哪个操作系统越简单越傻瓜就越好，考虑到windows深入人心的印象，足够直白的点按点按，这点是linux不论怎么赶超也超不了车的。\n\n再说，在易用性方面，命令行一直都是反人类的，你让一般人入门前背指令？相比之下很多windows用户都不知道CMD是干嘛的，至少在这一点，足以体现windows的伟大。\n\nPS：LINUX之下玩游戏和装驱动，足以劝退绝大多数普通用户，反正都是一般使用，为何不用更傻逼更熟悉的windows？",
				"added": 1581239603
			},
			{
				"comment_id": 107,
				"body": "你没有资格评价别人的选择。\n\n对于一般人而言，追求的大概是能用、不折腾、软件多、用户友好。在这些方面Windows或者Mac已经做得够好了。\n\n但也有人喜欢Linux的桌面风格，或者觉得手敲命令更习惯更方便，且他们又没有那么多软件的需求，又或者单纯觉得用Linux很coooool，那就用Linux好了。\n\n使用什么系统，本来就是自己的选择，他们不会觉得自己是在找虐的。\n而你只是不懂他们的乐趣所在而已。",
				"added": 1581239691
			},
			{
				"comment_id": 108,
				"body": "Linux这玩意吧，在你把它玩坏之前是很有用的....但是初生牛犊不怕虎啊，命令没认全几个就开始照着网上的帖子上sudo，然后就妥妥地玩坏了。\n\n\n对于求知欲强的人来说，只要谨慎使用，是会有很多乐趣的。用Linux有两个关键词，权力和责任。Linux赋予用户远高于windows的自由度/权力，但与此同时用户也要承担远高于使用windows的风险。\n\n对于对风险毫无把握而且毫无责任感的新手来说，三天两头遭灾是再经常不过的了。但一旦学会了把握风险，Linux的自由度是windows不能望其项背的。当然，被枷锁束缚久了的人是不需要关心自由度这个问题的。再退一步讲，自由度并不总是一件好事，有时候牺牲自由换稳定性也未尝不可。",
				"added": 1581239784
			}
		],
		"1581236712_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 84,
				"body": "Contrast 是一款小应用，用于检查两种颜色之间的对比度并确定其是否满足 WCAG 中指定的要求。可以使用十六进制 RGB 代码或使用颜色选择器选择颜色。除了显示对比度之外，Contrast 还以选定的颜色为背景上显示短文本来显示比较。",
				"added": 1581236663
			},
			{
				"comment_id": 85,
				"body": "Pamixer 是一个使用 PulseAudio 调整和监控声音设备音量的命令行工具。你可以显示设备的当前音量并直接增加/减小它，或静音/取消静音。Pamixer 可以列出所有源和接收器。",
				"added": 1581236674
			},
			{
				"comment_id": 86,
				"body": "PhotoFlare 是一款图像编辑器。它有简单且布局合理的用户界面，其中的大多数功能都可在工具栏中使用。尽管它不支持使用图层，但 PhotoFlare 提供了诸如各种颜色调整、图像变换、滤镜、画笔和自动裁剪等功能。此外，PhotoFlare 可以批量编辑图片，来对所有图片应用相同的滤镜和转换，并将结果保存在指定目录中。",
				"added": 1581236696
			},
			{
				"comment_id": 87,
				"body": "Tdiff 是用于比较两个文件树的命令行工具。除了显示某些文件或目录仅存在于一棵树中之外，tdiff 还显示文件大小、类型和内容，所有者用户和组 ID、权限、修改时间等方面的差异。",
				"added": 1581236708
			}
		],
		"1581231691_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 109,
				"body": "实用功能",
				"added": 1581241974
			}
		],
		"1581315734_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 113,
				"body": "LINUX 是个实战出真知的，你不做专业运维也没有太多必要那么深入。",
				"added": 1581315921
			},
			{
				"comment_id": 114,
				"body": "感觉 linux 使用分两个方向吧，桌面和服务器，不做运维服务器方向学无所用，桌面方向就是各种折腾，但是其实没鸡二用阿。。最后我用 fedora+i3wm 办公 3 年多了，只是习惯了。。",
				"added": 1581315971
			},
			{
				"comment_id": 115,
				"body": "看你学些什么东西。如果只是学习桌面环境如何使用，其实跟 windows 差不多。",
				"added": 1581316044
			},
			{
				"comment_id": 116,
				"body": "进阶的？那就是已经有一定的能力了？那就去看官方文档和 Linux 中国开源社区上的一些文章。。。挺全面的。",
				"added": 1581316076
			}
		],
		"1581232269_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 117,
				"body": "解决方案：被mask了就当作源里没有这个软件",
				"added": 1581318016
			},
			{
				"comment_id": 118,
				"body": "操作系统的组成部分：\n1 图形界面和命令行\n2 二进制和编译环境\n\n这些东西都是必须要有的，必须面对的问题，所以选择gentoo",
				"added": 1581324994
			}
		],
		"1581326614_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 119,
				"body": "Plan-9 可以安装到树莓派上",
				"added": 1581326926
			}
		],
		"1580983096_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 120,
				"body": "普通人一点命令都不想学习，对命令行感到畏惧\n软件一次安装，永不更新",
				"added": 1581341972
			}
		],
		"1581345955_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 123,
				"body": "比如你出门在外正好看到一个东西（磁力链）想下载。\n\nWindows的话你要用手机连接RDP/Teamviewer，打开迅雷/utorrent，然后下载。由于分辨率的问题操作会很坑爹。\n\nLinux的话，复制磁力链然后微信发给自己的小号就行了，晚上回家你就能在共享文件夹里找到你想下载的东西了。\n\n制作过程：大概就是\n\napt-get install rtorrent samba\n\n然后把samba和rtorrent配好。再去github找个微信机器人，一找一大堆，选个喜欢的。\n\n稍微改改，接收到指定消息就扔给rtorrent，估计都用不了10行。\n\n简单吧？",
				"added": 1581346022
			}
		],
		"1581346754_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 124,
				"body": "软件问题：\n解压win下的文件乱码\n不能连接无线同时开热点，这是驱动问题\n离线安装软件不方便\n翻墙软件没有GUI\n命令行不会使用\n不会修复引导\n\n硬件问题：\n电脑不能睡眠",
				"added": 1581378892
			}
		],
		"1579594735_1FfatX3G2z43rV6nc1F3koYtn8tmD5EVb6": [
			{
				"comment_id": 125,
				"body": "真-多桌面",
				"added": 1581376796
			}
		],
		"1581378158_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [],
		"1576633084_1BWwq5edPNmp1XBtRQEw9S5YHCek2hs1P8": [
			{
				"comment_id": 128,
				"body": "> [panz@zeroid.bit](#comment_9_1BWwq5edPNmp1XBtRQEw9S5YHCek2hs1P8): 《绝望的回忆》narcissu《AI少 [...]\n\n《片轮少女》\n《片轮少女》（按字面意思翻译即为“残疾少女”）是一款由来自各个国家人员组成的非商业化同人游戏制作组--四叶工作室（Four Leaf Studios），耗费5年时间，零资金赞助，独立开发的18禁美少女恋爱游戏（视觉小说），并在海外同人游戏界引起了很大的反响。",
				"added": 1581379421
			}
		],
		"1581380121_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [],
		"1581380935_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 130,
				"body": "研究 Linux包管理器的实现\n安装 i3桌面\n完全生活在命令行\nfuck 命令\n对于喜欢折腾/etc的同学们，还是用git来保险吧\n挂着P2P软件",
				"added": 1581383469
			},
			{
				"comment_id": 132,
				"body": "树莓派或类似的微型电脑上感觉很有意思。可以当一个下载器",
				"added": 1581383218
			}
		],
		"1581391194_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 135,
				"body": "我要去做自己的事情了\n使用软件、技术解决自己的需求",
				"added": 1581391336
			}
		],
		"1581398733_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 140,
				"body": "宣传 ZeroNet\n桌面环境=显示管理器+窗口管理器+一堆软件\n安装 lfs + i3 \n学习使用 google，stackoverflow",
				"added": 1581399270
			}
		],
		"1580998223_151eeKX8P9StVJE4SWuenHgLQb3Vae4avy": [
			{
				"comment_id": 144,
				"body": "正如邮件列表中宣布的那样，在2019年12月27日星期五，我们的软件包压缩方案已从xz（.pkg.tar.xz）更改为zstd（.pkg.tar.zst）。",
				"added": 1581408473
			}
		]
	},
	"comment_vote": {
		"29_1FfatX3G2z43rV6nc1F3koYtn8tmD5EVb6": 1,
		"40_1FfatX3G2z43rV6nc1F3koYtn8tmD5EVb6": 1
	}
}