{
	"next_topic_id": 19,
	"topic": [
		{
			"topic_id": 1582311991,
			"title": "快乐的Linux命令行",
			"body": "ncdu\nranger\ntop",
			"added": 1582312175,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582325330,
			"title": "小众软件",
			"body": "",
			"added": 1582325328,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582401256,
			"title": "Debian和Gentoo包管理机制比较及延伸",
			"body": "如果你现在想安装一套Linux，又不想随着Linux发行版本的版本号，不停的格式化系统，重新安装，或者升级安装。那么，最适合你的只有LFS、Debian和Gentoo。\n\n本文尝试对Debian、Gentoo的包管理机制进行比较，并由此得出了几个有趣的结论。本文对于Debian、Gentoo的包管理，主要谈缺陷和不足，并且尝试提出解决方法。最后，本人水平有限，失误、不足之处在所难免，还望大家批评指正。\n\nDebian是老牌的发行版本，有人甚至认为Debian就是GNU/Linux本身，但是，据Debian自己的了解。它只是碰巧通过Linux实现了而已。（Debian，似乎是一种思想？一种生活方式？）\n\nGentoo是新生的，成长迅速的发行版本。说他成长迅速，不仅在于它提供了主流和非主流的基于各种硬件的Linux的实现，更在于，它还同时提供*bsd、MacOSX、Sun Solaris（就在Sun开放Solaris之后不久）版本的portage。（最初认识Gentoo，是在QQ上与OpenQ的创始人PuzzleBird聊天，他把Gentoo形容成是下一代的Debian。于是偶相信了，开始了艰难的安装。 不过，还是感谢PuzzleBird，是他让我看到rpm之外的世界，之前偶都是用基于rpm版本的发行版的）\n\n典型的Debian提供一种基于i386编译的二进制deb包，采用了一套完整有效的工具指令集来保证整个系统软件包的完整、清洁和有效。\n\nGentoo的传统上，虽然也提供二进制包，但是，大家意义上的Gentoo，更在于通过源码编译属于自己的系统。通过USE的各个级别（配置文件级别、命令行级别）的设置，Gentoo能够让你轻松得到完全属于自己的，独一无二的Linux系统。 \n\n比较：由于软件包提供的格式不同（一种是二进制文件，一种是源码）。Debian与Gentoo相比，有着更快的系统安装效率。同样的网络情况下，安装Debian要比Gentoo节省更多的时间，通常只需要几个小时，你就可以得到一套完成的Debian系统（包含KDE等等完整的桌面环境）。但是，在我看来，Debian的缺点在于，Debian基于deb的依赖性审查过于严格。也许是因为直接提供的二进制包的缘故。Debian对于同一套软件的细微不同版，也认为是完全不同的。\n\nibqt3-mt-dev对下面两个有依赖，可是下面两个已经有firefly补丁的版本了。\n\n提示： \n>libfreetype6-dev: Depends: libfreetype6 (= 2.1.7-2.3) \n\n>but 2.1.7-2.3firefly is to be installed\n\n>libxft-dev: Depends: libxft2 (= 2.1.2-6) \n\n>but 2.1.2-6firefly is to be installed\n\n>Depends: libfontconfig1-dev but it is not going to be installed\n\n同样的一个软件包，只是由于编译时的小补丁的不同，就完全不能满足Debian要求的依赖关系。只能推倒，重建系统。\n\n同样的情况，在Gentoo中完全可以通过同一套源码，配置不同USE来实现。也就是说，在Gentoo中，由于个人USE的设置的不同，上面的Debian的两个包，在Gentoo看来就是一个包，只是配置时候的打了不同的补丁。因此，没有所谓的因为依赖而不能安装的问题。\n\n举例：假设该软件包有两个不同USE，一个是common，一个是firefly，那么对于Gentoo，只要你设定了是采用USE=\"common\"编译，还是采用USE=\"common, firefly\"编译，系统在编译软件包的时候，就会自动决定究竟是否打上firefly的patch。也就是说，在Gentoo中，允许同时存在来自同一源码的，编译时配置不同的二进制文件的存在，而Gentoo在处理依赖时候，除非是的确找不到依赖的文件。否则，Gentoo不会提示出依赖错误（因为确实没有错误）。而Debian在这一点上是过于严格了。\n\nGentoo的包管理的主要缺点在于采用源码编译，不能够满足快速安装系统的需要。同时，一旦系统的基准USE发生了变化（这经常发生，尤其是你还是Gentoo新手的时候，你很可能因为不知道哪个软件包采用那种USE才好，而在基准中加入了过多的USE），虽然可以采用emerge --new-use world进行对新USE的编译，但是，这时的Gentoo的依赖的包的编译顺序有时会有问题，而导致编译失败。（这个其实是一个依赖的问题，明明正常是1、2、3的顺序可以编译成功的，但是--new-use之后，emerge可能会错误的安排成了2、1、3的顺序，而导致编译失败）。 \n\n综上，Debian的问题在于依赖的过于严格。对于依赖的问题，可以采用的方法主要有。\n\n1 强制安装。这是最下策，也是最麻烦的方法。（因为下次遇到同类的问题，还得强制安装，尤其是升级的时候）。\n\n2 修改依赖关系。虽然我不知道debian的依赖要在哪里改，但是这的确是一条路。不过，这个也不轻松，因为每次都需要手工修改依赖关系。\n\n3 欺骗Debian，直接将修改过的软件包，以debian原名的形式发布，这样可以解决依赖问题。但是，如果采用了debian的source.list中，如果开启了安全站点检验，这一步就无法通过。\n\n4 系统推倒重建，安装Debian的官方版本。OK，如果你对中文显示要求不高，可以采用这个办法。不过，这样的话，就没有中文的粗体和斜体，同时，我觉得看起来也不怎么舒服。\n\n5 就用非官方的版本，不轻易升级。本着够用就好的原则，期待别人解决问题。我，无语。（Hiweed用户适用。向Hiweed致敬）。\n\n6 构建一套大系统，包含了所有由于补丁的问题所造成的问题的补丁。也就是大量的非官方的补丁。例如构建一套超大的，可以解决所有依赖问题的中文Debian，不妨叫大Hiweed。费时，费力，难与官方发布同步。\n\n7 为什么不直接将中文补丁提交到Debian官方，或者对应软件开发的官方，这样软件就是Native Chinese Support。岂不是很好？（强烈赞同这个观点，这个应该是最终的解决之道）。 \n\n8 当然，也可以建议Debian修改它的依赖的检测方式。提供一些的灵活的，tiny的版本号，认为也是同样兼容的。\n\nGentoo的解决之道：\n\nGentoo虽然依赖的问题解决得很好，但是，Gentoo编译时间太长。虽然，你可以采用某些方法（比如，设定最简单的系统，设定复杂的USE，去除编译多余的Locale）来确保系统不编译多余的东西。也可以采用打开ccache的方法，建立数据库来加速c程序的编译。但是，Gentoo的安装时间长（通常桌面是几天，采用kde或gnome的情况），频繁升级的话，更是费时费力。\n\n虽然我们不能解决升级时的编译问题。但是，我们至少可以解决安装的时间过长的问题。我们的希望来自教主的homeking的ibox，ibox采用livecd的方式，提供给大家一套完整的Gentoo中文解决方案。新版本的ibox将采用kde做为默认，同时提供迅速的安装到硬盘功能。\n\nGentoo的未来，在于随着计算机系统性能的不断提高，从源码编译软件的时间成本将会原来越低。同时，如果你有多台电脑，gentoo支持多台电脑采用并行的方式为同一台电脑编译软件。这也可以大大加快编译的时间。\n\n有人认为Gentoo编译的系统，要比Debian要快。我觉得这不是一个事实。因为大多数的Gentoo的用户不懂得如何去最优化自己的系统。因此，编译出来的系统，优化也是有限的。这就给了Debian很大的机会。另外，USE参数设置的过多，也使得自己的系统多了好多自己不需要的功能。这也是一个原因。 \n\nDebian还有一个缺点，就是虽然Debian安装之后很小。但是如果你需要编译程序的时候，你就会发现Debian还要安装各种各样的headers或source，这些，对于Gentoo则是不需要的，因为Gentoo本身就是从源码编译过来的。不缺少那些东西。",
			"added": 1582401320,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582478162,
			"title": "Debian，从安装到喜欢",
			"body": "**前言**\n\n经历了「Fedora，从安装到放弃」之后，我对那些所谓「开箱即用」的 Linux 桌面彻底失去了信心。它们的确是开箱即用的，只不过对于我而言，它们开箱后很难用。\n\n我想念 Gentoo。虽然它就在我身边的工作站里运行着，但是这台笔记本里却没有。在这台十年前的笔记本上安装 Gentoo，会显得我太变态，更何况这台笔记本是我自己出资买的，敝本自珍。我想试试 Debian。\n\n多年以前，曾用过 Debian，浅尝辙止。可能是因为那时 too young, too simple, 理解不了** Debian 的厚重与沉淀**。现在有机会尝试一下。如果还是不觉得它的好，就准备与 Gentoo 终老相伴了。\n\n将 U 盘作为安装介质\n写此文时，Debian 最新的稳定版是 8.5，代号 Jessie。没看过《玩具总动员》，所以也不知道 Jessie 是谁。Debian 矢志不渝的使用《玩具总动员》中的角色的名字作为稳定版的代号，它是个玩具级的 Linux 发行版吗？\n\n一开始就遇到了一个障碍。为了追求自由软件血统的纯正，Debian 官方提供的系统安装光盘镜像文件未包含无线网卡的固件部分。如果我坚持使用无线网络安装的方式安装 Debian，事情会变得有些麻烦。\n\n一筹莫展之时，搜到一篇文章。作者也跟我差不多情况，他指出最省事的办法是下载非 Debian 官方制作的含有无线网卡固件的光盘镜像文件，亦即：\n\n>$ wget http://cdimage.debian.org/cdimage/unofficial/non-free/cd-including->firmware/8.5.0+nonfree/amd64/iso-cd/firmware-8.5.0-amd64-netinst.iso\n\n虽然这份光盘镜像文件不到 300 MB，但是下载速度堪称龟速。找了好大一会，发现了对岸有一台服务器，下载速度很快：\n\n>$ wget http://debian.nctu.edu.tw/debian-cd-unofficial/cd-including-firmware/current/amd64/iso->cd/firmware-8.5.0-amd64-netinst.iso\n将光盘镜像文件拖下来之后，将其写入 FAT32 分区的 U 盘（假设它是 /dev/sdb）：\n\n>$ sudo dd if=firmware-8.5.0-amd64-netinst.iso of=/dev/sdb\n如果非要跟着 Debian 官方的步子走，需要手动向 U 盘中写 syslinux，然后再找到非 Debian 官方提供固件文件，将它们放到 U 盘的根目录下，而这个过程，本质上就是在制作 firmware-8.5.0-amd64-netinst.iso……因此，并没有什么 Debian 官方的步子。\n\n**安装**\n折腾好了 U 盘，开始安装了。一路很太平，没再出幺蛾子，只有几个我觉得是要点的要点需要强调一下。\n\n语言和键盘，选择英文，而国别或地区选择中国大陆。\n\n硬盘分区，选择手动分区。由于我的硬盘只有 80GB，LVM 与 RAID 之类的高端技术，我不了解，但也用不着，省了点事。为 / 分区（EXT4）分配了 40GB，为 /boot 分区（EXT2）分配了 500 MB EXT2，为 swap 分配了 4.5 GB，剩下的都给了 /home 分区（BTRFS）。\n\n只安装基本系统。也就是在让你选择软件包的时候，什么都不选，直接 Continue。\n\n**配置无线网络**\n系统安装完毕后，重启机器。因为没有装桌面，所以系统会进入终端环境。\n\n如果使用基于 firmware-8.5.0-amd64-netinst.iso 制作的 U 盘，在安装 Debian 基本系统的过程中，无线网络可正常使用，那么系统装好后，无线网卡的驱动部分不会有什么问题，但是网络设定还需要自己动手。\n\n可参考 Debian Wiki 提供的「无线网络配置」文档的「WPA-PSK and WPA2-PSK」一节所述方法配置无线网络。\n\n**更新系统**\n所安装的基本系统是 Debian 8.5 的稳定版本。虽然它够稳定，但是软件包太老了。接下来，我还要在这个基本系统上安装桌面，还要在桌面环境中写一些程序。太老的系统，适合做服务器，不适合桌面用户。\n\nDebian 8.5 稳定版本提供的软件包，大概是 2 年前的版本。想想 Windows XP 现在依然有很多用户，所以 Debian 8.5 稳定版本还是很年轻的。新的版本未必好，虽然它们可能修复了老版本的一些 Bug，但是也可能引入了新的不为人知的 Bug。\n\nDebian 提供了非稳定版本软件包的源，要使用它们，需要修改 /etc/apt/source.list 文件：\n\n># cat << EOF > /etc/apt/source.list\n>deb http://ftp.cn.debian.org/debian/ sid main non-free contrib\n>deb-src http://ftp.cn.debian.org/debian/ sid main non-free contrib\n>EOF\n注：上述命令使用了 Bash 的「Here Document」语法。也可以用可在终端中运行的文本编辑器 nano 或 vi 进行文件编辑。\n\n然后将系统由稳定版本升级为非稳定版本（Sid）：\n\n> apt-get update # 更新软件包列表\n> apt-get dist-upgrade # 系统升级\n\nDebian 的稳定版与非稳定版本，类似于 Gentoo 的 amd64 与 ~amd64。不过，Debian 在稳定版本与非稳定版本之间还有一个过渡版本，叫测试版本（Testing）。我想先试试一段时间的 Sid，频繁遇到问题，就切换到测试版本。\n\n**sudo**\n >apt-get install sudo\n >echo \"[用户名] ALL=(ALL:ALL) ALL\" >> /etc/sudoers\n添加中文 Locale\n装系统的时候，语言与键盘皆为英文。此时，系统只支持英文环境。有些程序，譬如 Emacs，要想在其中输入中文，前提是需要系统中具备中文 Locale。\n\n使用以下命令增加中文 Loclae：\n\n>$ sudo dpkg-reconfigure locales\n将 Locale 列表滚动到底部，选择 zh_CN.UTF-8 UTF-8，然后 Ok 确认。\n\n这样一来，系统就有了两个 Locale 环境，en_US.UTF-8 与 zh_CN.UTF-8。我建议继续使用 en_US.UTF-8 作为默认的 Locale，中文 Locale 可以在需要的时候临时启用。\n\n**安装 LXDE**\n\n>$ sudo apt-get install lxde\n>$ sudo reboot\n不建议为了追求精简而只安装 lxde-core。因为 lxde 本身已经是非常小型的桌面系统了，将它的相关组件全都装上，也占用不了太多的系统资源。不需要的一些软件包，安装结束后，可酌情删减。\n\n**快捷键**\nLXDE 未提供设置桌面快捷键的 GUI 程序。要设置快捷键，需要修改桌面配置文件。\n\n可在 $HOME/.config/openbox/lxde-rc.xml 文件的 <keyboard> ... </keyboard> 部分添加以下内容\n\n```\n<!-- run terminal -->\n    <keybind key=\"F12\">\n      <action name=\"Execute\">\n        <command>lxterminal</command>\n      </action>\n    </keybind>\n    <!-- Vertical tiling -->\n    <keybind key=\"C-W-v\">\n      <action name=\"UnmaximizeFull\"/>\n      <action name=\"MoveResizeTo\">\n        <width>50%</width>\n      </action>\n      <action name=\"MaximizeVert\"/>\n      <action name=\"MoveResizeTo\">\n        <x>0</x>\n        <y>0</y>\n      </action>\n      <action name=\"NextWindow\">\n        <interactive>no</interactive>\n        <dialog>none</dialog>\n        <finalactions>\n          <action name=\"UnmaximizeFull\"/>\n          <action name=\"MoveResizeTo\">\n            <width>50%</width>\n          </action>\n          <action name=\"MaximizeVert\"/>\n          <action name=\"MoveResizeTo\">\n            <x>-0</x>\n            <y>0</y>\n          </action>\n        </finalactions>\n      </action>\n    </keybind>\n    <!-- Horizontal tiling -->\n    <keybind key=\"C-W-h\">\n      <action name=\"UnmaximizeFull\"/>\n      <action name=\"MoveResizeTo\">\n        <height>50%</height>\n      </action>\n      <action name=\"MaximizeHorz\"/>\n      <action name=\"MoveResizeTo\">\n        <x>0</x>\n        <y>0</y>\n      </action>\n      <action name=\"NextWindow\">\n        <interactive>no</interactive>\n        <dialog>none</dialog>\n        <finalactions>\n          <action name=\"UnmaximizeFull\"/>\n          <action name=\"MoveResizeTo\">\n            <height>50%</height>\n          </action>\n          <action name=\"MaximizeHorz\"/>\n          <action name=\"MoveResizeTo\">\n            <x>0</x>\n            <y>-0</y>\n          </action>\n        </finalactions>\n      </action>\n    </keybind>\n    <!-- Restore window dimensions -->\n    <keybind key=\"C-W-r\">\n      <action name=\"UnmaximizeFull\"/>\n      <action name=\"NextWindow\">\n        <interactive>no</interactive>\n        <dialog>none</dialog>\n        <finalactions>\n          <action name=\"UnmaximizeFull\"/>\n        </finalactions>\n      </action> \n    </keybind>\n```\n\n\n上述配置设定了 4 个快捷键：\n\nF12：打开终端\n\nWin + Ctrl + V：竖直分屏，最后打开的两个窗口分居左右，铺满屏幕\n\nWin + Ctrl + H：水平分屏，最后打开的两个窗口分居上下，铺满屏幕\n\nWin + Ctrl + R：将竖直或水平分屏摆放的窗口复原\n\n还有一些快捷键是 LXDE 已经为我们配置好的。下面着几个快捷键较为常用：\n\nAlt + 鼠标左键：窗口拖放\n\nAlt + 鼠标右键：对窗口尺寸进行调整\n\nWin + E：打开文件管理器\n\nPrint（PrtSc）：打开 gnome-screenshot 截屏\n\n**中文输入**\n`$ sudo apt-get install fcitx`\n使用桌面菜单「Perference」->「Input Method」打开输入法配置向导，将 fcitx 设为桌面环境的默认输入法。\n\n由于系统 Locale 是 en_US.UTF-8，在 Emacs 中，fcitx 无法输入中文。但是若将 LANG 设为中文，然后再启动 Emacs，就可以输入中文了，即：\n\n`$ LANG=zh_CN.UTF-8 emacs`\n为了方便，我在 /usr/local/bin 目录建立一份 Bash 脚本 em，内容如下：\n```\n$ cat << EOF | sudo tee /usr/local/bin/em\n#!/bin/bash\nLANG=zh_CN.UTF-8\n/usr/bin/emacs $@ 2>/dev/null &\nEOF\n$ sudo chmod +x /usr/local/bin/em\n```\n这样，在终端中可以用 em 来代替 emacs 命令。\n\n触摸板模拟鼠标单击\n`$ sudo apt-get install xserver-xorg-input-synaptics`\n然后修改 /usr/share/X11/xorg.conf.d/70-synaptics.conf 文件，在「Identifier」为「touchpad catchall」的「InputClass 」节中增加：\n\n`Option \"TapButton1\" \"1\"`\n关闭蓝牙\n笔记本支持蓝牙，但平时用不大着。编辑 /etc/rc.local，在「exit 0」之前添加：\n\n`echo disable > /proc/acpi/ibm/bluetooth`\n这样，在系统启动后，蓝牙功能会被自动关闭。\n\n后来，发现在 BIOS 里可以直接关掉，这样便不必修改 rc.local 文件了。\n\n查看笔记本电池的电量\nLXDE 没提供笔记本电池的电量显示功能。在终端中，可使用 acpi -b 命令查看。我喜欢这种方式。平时不需要看电量，只有在电池信号灯警示时，才需要看一下还剩多少电。\n\nNikola\n不知道 Nikola 是什么的人，可忽略此节。\n\n使用 virtualenv + python 3.5 + pip 安装 Nikola 时，会遇到 lxml 包装不上的问题。要解决这个问题，需要事先安装 libxml2-dev, libxslt1-dev 以及 python3-dev。\n\n我常用的三维图形软件\n`$ sudo apt-get install freecad povray`\nC 编程工具\n`$ sudo apt-get gcc make autoconf automake libtool valgrind`\n如果要编译 zero 的源代码，还需要安装 libglib2.0-dev 包。不知道 zero 是什么？没关系。整个地球，可能只有我真正需要编译它的源代码。\n\n中文字体\n简单而粗暴的办法是从 Windows 系统中扒出微软雅黑字体 msyh.ttf，然后在 /usr/share/fonts 中建立 non-free 目录，并将 msyh.ttf 放在这个目录中。\n\n接下来，修改 /etc/fonts/conf.d/65-nonlatin.conf，将其内容替换为：\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE fontconfig SYSTEM \"fonts.dtd\">\n<fontconfig>\n    <alias>\n        <family>serif</family>\n        <prefer>\n            <family>Microsoft YaHei</family>\n        </prefer>\n    </alias>\n    <alias>\n        <family>sans-serif</family>\n        <prefer>\n             <family>Microsoft YaHei</family>\n        </prefer>\n    </alias>\n    <alias>\n        <family>monospace</family>\n        <prefer>\n            <family>Microsoft YaHei</family>\n        </prefer>\n    </alias>\n</fontconfig>\n```\n这样，这样整个桌面环境的中文字体就统一于微软雅黑了。由于我不用 Libreoffice，所以对宋体字没需求。屏幕字体，微软雅黑足够看的。当然，如果为了追求对微软的不屑，可以换成那些自由或免费的黑体字体的一种。现在的 Linux，已经不是 10 年前穷得连一款像样的中文字体都没有的处境了。\n\n**后记**\n我非常满意目前这个运行于 Debian 环境中的 LXDE 桌面。我并没有将它配置到可以截屏向世人炫耀的程度。它的桌面风格停留在 Windows XP 时代，而且我还特意将它的窗口与 Panel 的外观改成了 Windows 2000 时代的风格。\n\n\n令我满意的，它运行起来，只需要 200 MB 左右的内存。即使开启 Firefox 以及我常用的一些软件，内存占用不过 600 MB 左右。这台笔记本的内存共 2G，剩下来的内存，我可以用来编译程序，用来运行 povray，用来更新系统。剩下来的内存空间，即使我用不了，但它们也是属于我的。这种自由且随意的感觉，是 Fedora 提供的 GNOME 3 桌面没法给我的。\n\n此外，在正常的工作状态下，即使开着 WIFI，现在这台笔记本的电池能够坚持两个小时，而此前在 Fedora 的 GNOME 3 环境中，它只能坚持 70 分钟左右。",
			"added": 1582478960,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582481614,
			"title": "深入理解 linux",
			"body": "init\ndbus\nudisk\npolkit\nfstab\nglibc\nsystem call\nldd",
			"added": 1582481790,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582482316,
			"title": "理解Linux操作系统——分析性能瓶颈",
			"body": "标签： 理解 linux 操作系统 | 发表时间：2015-04-29 08:00 | 作者： \n出处：http://blogkun.com\n\n学习自《Linux性能分析》\n\n识别瓶颈\n快速调优策略：\n\n认识你的系统。\n备份系统。\n监控和分析系统性能。\n缩小瓶颈范围，找到根源。\n通过每次只修改一个地方来解决瓶颈问题。\n回到第3步直到对系统的性能满意为止。\n应该记录下调优的操作，特别是对性能有影响的操作。\n\n收集信息\n通常，你能得到的第一手信息就是关于问题的描述。对问题进行探索性地提问和记录是非常重要的。这里有一些问题有助于你对系统有一个更好的了解：\n\n服务器系统类型、版本、配置是什么？\n问题的症状，给出了哪些错误信息，日志记录？\n谁遇到了这个问题？\n问题是否能被重现？重现的步骤、定期出现还是不定期\n之前对系统做了哪些更改可能导致问题的发生？\n问题的紧急程度如何，需要何时解决？\n分析系统性能\n如果是应用程序本身的问题：\n\n自己开发的？debug吧\n开源软件？看是否配置不正确、需要升级，或提issue\n商业软件？看是否配置不正确、需要升级，或找售后服务\n如果是系统本身或硬件问题：\n\nCPU瓶颈\n\n查找瓶颈\n\nuptime 查看负载。\ntop 查看CPU使用率，以及哪个进程占用高。\nsar 需要安装sysstat，可查看系统一段时间内的运行情况。\n通常以上命令的输出信息可以从运维平台获取到。\n\n调优\n\n确保没有运行不需要的程序。 ps -ef，停止或将其改为定时任务，在非峰值时间运行。\n通过renice调整进程priority。\n绑定进程到CPU上。\n考虑纵向扩展CPU（适合单线程程序）还是横向扩展（适合多线程程序）。\n内存瓶颈\n\nMemory available\n\n还有多少内存可以使用，执行 free -l -t -o查看。\n\nPage faults\n\n两种类型：soft page faults（在内存中找到page）和hard page faults（内存中找不到page，必须从磁盘中获取）。 执行 sar -B可查看页面交换情况。\n\nFile system cache\n\n用于文件系统缓存的内存，执行 free -l -t -o查看。\n\nPrivate memory for process\n\n进程占用的内存，执行 pmap查看。\n\n调优\n\n调优swap space。\n增加或减少页面大小。\n改善对active和inactive内存的处理。\n调整page-out rate。\n停止不需要的程序。\n增加内存。\n磁盘瓶颈\n\n查找瓶颈\n\n如果服务器表现出如下症状，很可能是遇到磁盘瓶颈：\n\n低速磁盘可能会导致：\nMemory buffers充满了write data（或waiting for read data），这将会使write request（或the response is waiting for read data in the disk queue）。 在内存不足的情况下，在没有足够的内存提供给network requests的情况下，会导致同步的磁盘I/O。\n\nDisk utilization，controller utilization之一或都会非常高.\n在磁盘I/O完成之后，许多LAN传输才会发生，导致非常长的响应时间和较低的network utilization。\n磁盘I/O会花费许多时间，并且磁盘队列也会变得饱满，所以CPU将会空闲，或者较低的使用率。\n磁盘访问是随机还是顺序？是large I/O还是small I/O？这些问题的答案有助于磁盘子系统的调优。\n\ndisk I/O\n\n随机读写通常需要多块磁盘更好，例如大型数据库。\n\n顺序读写通常需要关注磁盘子系统的bus bandwidth。\n\nvmstat和iostat可用于查看磁盘I/O情况。\n\n调优\n\n如果是随机读写，考虑加磁盘；如果是顺序读写，考虑增加更快的磁盘控制器。\n合理的使用RAID，以及选择文件系统。\n增加RAM。\n网络瓶颈\n\nPackets received、Packets sent：网络接口上的收发包\nCollision packets：当一个域里有太多系统时会发生冲突。Hub的使用可能导致过多的冲突。\nDropped packets：被丢弃的包。\nErrors：通信线路质量不好。\nFaulty adapters：网络硬件出问题了。\n调优\n\n确保网卡配置跟路由器、交换机配置吻合（例如frame size）。\n调整网络拓扑。\n使用更快的网卡。\n调整IPV4 TCP内核参数。",
			"added": 1582482310,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582483156,
			"title": "带你真正认识Linux系统结构!",
			"body": "最新一代安卓系统安卓N已经出现了，和以往的全新安卓系统一样，尽管新的安卓拥有很多激动人心的新特性，但仍很难勾起人们的兴趣。无它，就因为新的安卓系统，和大部分用户绝然是没什么关系的，不能升级说这个有什么用？尽管安卓来自Google，但Google却似乎管生不管养，手中的机器能不能升级到安卓，还得各家OEM厂商说了算。\n\n\n\n安卓N已经发布，但市面上绝大多数机器不能升级，为什么？\n\n但仔细想想，这情况似乎还是有点奇怪。安卓能够运行在各种设备中，类似的系统也不是没有，大家最熟悉的Windows，也是靠硬件不同的机器打天下的。然而，无论是什么电脑厂商制造的Win PC，往往都能轻松升级到最新的Windows甚至随意更换不同的系统，硬件再碎片化，也不存在升级困难的问题。为什么同样是开放授权安装，安卓的升级就如此困难？今天，一起来说说这个事吧。\n\n历史原因：安卓机没有类似IBM兼容机的标准\n\n虽说安卓和Win PC的硬件都是花样百出，但其实这里的门道，还是有些许不同的。在上世纪90年代之前，个人电脑市场也经历过混乱的战国时代，市场上存在着大量不同标准的PC，什么苹果电脑啦，TRS-80机啦日本的PC-9801机等等，相互间硬件和系统都不通用。然后，IBM在1982年公布了IBM PC上几乎所有的技术资料，兼容机就此诞生了。只要使用了IBM公布的技术标准，这些PC机的零部件都可以互换。繁荣的电脑DIY市场就此崛起，为了兼容DIY电脑，Windows在这方面也是做了大量工作。Win PC一时无两，到了90年代，个人电脑市场就只剩下苹果电脑能够在Win PC的重压下喘息了。\n\n\n\nWindows能普及，IBM兼容机功不可没\n\n而安卓机的崛起历程，和Win PC是不一样的。安卓阵营中，并没有出现IBM公开技术标准这样的大事件。Win PC或者说是Windows的繁荣，得益于IBM公布兼容机标准后，DIY市场的兴起；而安卓机的普及，则归功于手机整机OEM制造商各自为政的推广。Google一开始，就没打算让安卓如同Windows那样，可以运行在某种标准架构的设备上，各家OEM制造商拿到Google发布的安卓代码后，把安卓推出去（当然还得添点Google生态的东西），就完成任务了。因此，安卓的推广的过程中，本来就没有Win那样用一样的代码、兼容不同的硬件的基因。\n\n简单来说，Win能够有着如此好的系统升级支持，是因为现在的Win PC都是IBM兼容机，Win以兼容IBM兼容机为己任；而安卓设备并没有一个类似IBM兼容机这样的标准，Google自然也没法直接把最新的安卓推送到任一部安卓机器了。\n\n技术原因：Linux和Win内核架构差异\n\n熟悉电脑装机的朋友应该都知道，DIY电脑安装完了Windows，还没算完，还得通过Windows Update，或者手动安装各种硬件驱动。而安卓一个ROM不能兼容某部机器，最大的原因，就是硬件驱动适配问题，这也造成了Google发布的最新原生系统，不能装在任意安卓机器上。这里面，是不是也存在Windows和安卓的技术差异呢？的确如此。\n\n\n\nWindows和安卓的内核差异其实挺大的\n\n实际上，Windows对驱动的管理，是要比安卓更加方便的。Windows属于比较接近微内核的混合内核结构，这样的结构有一个特点，那就是驱动是单独分发的，并不会和Windows的微内核混合在一起。如此一来，各家硬件厂商单独发Windows驱动就很容易了。新的Windows要兼容某个硬件，硬件厂商只要把驱动发给微软，微软完成认证后，就可以把这驱动放到Windows Update或者干脆整合到Windows的安装镜像中，无需重构Windows的内核代码，并不复杂。\n\n\n\nWindows对驱动的适配更加灵活方便\n\n而安卓则基于Linux，Linux是一个宏内核的结构，Linux的驱动和内核是整合在一起的。要适配某种硬件，得把驱动都整合进Linux内核。虽然Google为了避免GPL污染，已经在Linux之上建立了一个硬件抽象层HAL，但根本问题仍未解决，安卓的硬件驱动仍不能如同Windows那样独立安装。例如某某芯片厂商更新安卓驱动，用户并不能直接安装，需要等安卓厂商把这驱动整合进新ROM中，再提供给用户刷入。\n\n\n\n安卓适配某种硬件，需要厂商进行驱动整合\n\n从这方面来说，如果Google想要为所有安卓机都提供系统升级，就超级麻烦了——Google得为每一种硬件不同的安卓机，都准备一个内核不同的ROM。考虑到市面上的安卓机硬件组合种类的数量……就算是Google，也是干不来的。因此，Google实际上并没有技术条件为市面上所有安卓机都提供系统升级，Google能顾得着自家的Nexus设备，就不错了。\n\n利益原因：安卓并不只是Google的安卓\n\n虽然安卓来自Google，安卓并不仅仅属于Google。Google把安卓的源代码发布到开源项目AOSP后，各家厂商只要遵循Apache协议，就可以利用这些代码构筑自己的ROM了。如果想要使用Google提供的服务，还需要和Google签订协议，预装制定的Google应用。更多的情况是，各家厂商会在安卓中整合自家的服务，把安卓修改成自己想要的模样。\n\n\n\n安卓OEM厂商接触的是安卓开源项目，\n\n而Win PC厂商接触的是Windows成品\n\n放眼望去，其实除了Nexus和Android One这种Google自己管卖的机器外，市面上使用安卓原生系统的安卓机根本就没有。开源让OEM厂商看到了铺开自家生态的机会，安卓被紊乱而繁多的OEM厂商的生态战略冲击分化成数十百种，Google不可能跟随这些厂商的安卓分支，为用户提供后续的系统升级服务——除了必要的部分，这些厂商可不会像Google那样，把修改后的安卓源码也公布出来的。\n\n\n\n你跟Google说这是安卓，Google说不定还不信\n\n安卓源码被发布后，就不仅仅只是Google的安卓了。要问为什么各家厂商不愿用原生安卓？原生安卓只能帮Google赚钱，不能帮自己赚钱，这就是利益问题了。这种情况，在Windows上就没有出现。由于Windows是闭源的系统，因此第三方难以对其进行大幅修改，最多也就预装几个软件，修改成番茄花园那样子已经算是变动比较大的了。微软一直牢牢把握Windows系统的话语权，OEM卖电脑赚的是硬件钱而不是安卓那样的生态钱。微软对Windows升级的支持度，自然也不是Google可以与之相比的。\n\n\n\n保持原汁原味的Nexus，是可以获得安卓最新的系统升级的\n\n总结\n\n虽然安卓和Windows用起来的确拥有一定相似之处，但无论从历史、技术和商业利益的角度来看，双方都存在着明显的差异。这些差异，导致了安卓无法如同Windows那样轻松升级。如果你真想享用到最新版的安卓系统，可以考虑一下Nexus设备，只是Nexus设备在国内的网络环境下难以施展，希望Google日后能够重新返回中国市场吧。",
			"added": 1582483149,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582483209,
			"title": "小白都可以理解Linux操作系统的内容和奥秘",
			"body": "大多数电脑小白对于很多的系统都了解的不多。那么今天小编就为电脑小白扫扫盲，简单化的讲解下关于Linux操作系统的奥妙和内容，让菜鸟们更加的上手！\n\n★两种思想上的误区\n\n　　按照俺的风格，先来说说两种思想上的误区（学习其它技术，通常也存在这两个误区）。\n\n◇望而却步\n\n　　有些新手把 \"掌握 Linux\"看得过于复杂，看得高不可攀。这是非常没有必要的。\n\n　　如果是在上个世纪90年代，抱有这种想法或许还情有可原（毕竟那时候 Linux 内核刚问世没几年）。但是如今捏？Linux 都已经二十几岁了。经过这么些年的发展，已经变得很成熟，很傻瓜化了。在易用性方面，它跟 Windows 的差距已经很小了。\n\n　　如果你还在怀疑 Linux 的易用性，不妨看看如今 Android 手机的市场份额——Android 就是基于 Linux 内核搭建的。\n\n◇急于求成\n\n　　和上面的\"望而却步\"心态相反，有些新手带有一种急于求成的心态——企图一口吃成胖子。这也是不对滴。\n\n　　为啥很多人有这种想法捏？主要是被\"急功近利\"的风气影响，变得浮躁了。对于心态浮躁的同学，建议你看看 Peter Norvig 写的好文《十年学会编程》（Peter Norvig 是 Google 研究总监）\n\n★如何循序渐进？\n\n　　介于上述两种心态之间，俺的观点是：循序渐进。下面来说说，在上手 Linux 的过程中，该如何循序渐进？\n\n◇从\"虚拟机\"到\"实体机\"\n\n　　去年俺专门写了一个《扫盲操作系统虚拟机》的系列（已经写完）。没看过的同学，强烈建议你先去看看。看完这个系列，你自然就能体会到\"操作系统虚拟机\"的种种好处。\n\n　　对于一个新手，一定要先从虚拟机里面开始折腾，而不要直接在实体机上折腾。\n\n虚拟机的好处之1——不用担心搞坏系统\n\n    虚拟机，顾名思义，是\"虚拟的\"。随便你怎么折腾（即使是格式化硬盘），都不会影响到你的实体机（Host OS）\n\n虚拟机的好处之2——快照功能\n\n在你摸索的阶段，可以充分利用虚拟机的\"快照功能\"。\n\n    \"快照功能\"就如同\"后悔药\"。比如你想修改某项系统设置，如果你对此没有把握，可以先做好一个快照，然后再修改。万一改坏了，直接回退到这个快照，系统就恢复原样啦。\n\n虚拟机的好处之3——降低装硬件驱动的麻烦\n\n    常见的虚拟机软件（比如 VirtualBox、VMware），在虚拟系统（Guest OS）中仿真出来的虚拟硬件，往往是比较常见的硬件。因为是比较常见的虚拟硬件，所以你在虚拟机中安装 Linux，Linux 通常都能直接识别出那些虚拟硬件。这就避免了折腾硬件驱动的麻烦。\n\n　　以上就是关于 \"Linux装在虚拟系统\" 的种种好处。只有当你已经脱离了\"菜鸟\"阶段，再考虑把你的实体机换成 Linux。\n\n◇从\"业余环境\"到\"工作环境\"\n\n　　有一句至理名言叫：\"从实践中学习\"。\n\n　　当你已经学会如何装 Linux，学会了一些基本的操作，之后就要在实际环境中使用它（也就是\"实践\"）。那么先从哪种环境开始实践比较好捏？俺建议先从自己的业余环境中开始实践。不要首先在工作环境中尝试。\n\n　　因为当你的水平还不够的情况下，如果首先在工作环境中尝试，万一出了啥差错，会影响到你的工作。而如果在业余的环境中尝试，出了差错风险较小。\n\n　　比方说，你可以专门开一个虚拟系统（Guest OS），装好 Linux，在业余时间用来上网。\n\n◇从\"图形界面\"到\"命令行界面\"\n\n　　作为一个新手，刚开始会被各种各样的 Linux 命令搞得眼花缭乱。为了降低学习曲线的陡峭程度，你可以先从图形界面入手。先通过图形界面，了解 Linux 的各种功能。等到你慢慢熟悉了，再逐步学习命令行界面的使用。\n\n　　顺便再罗嗦一下：\n\n　　命令行界面是 Linux 的精髓之一。善于使用命令行，可以大大提升你的效率。所以，一开始你可以完全依赖\"图形界面\"；但如果要想提升，必须让自己逐步适应\"命令行界面\"。\n\n◇从\"傻瓜化\"到\"DIY\"\n\n　　有些\"傻瓜化\"的发行版，它会把各种各样你可能需要的软件都事先内置了。一旦装好系统之后，（你只需使用它的默认设置）就可以完成日常操作了。显然，这类发行版更容易让菜鸟上手。\n\n　　但是，如果你想在 Linux 领域有所深入，想要充分发挥其特长，不应该仅仅停留在\"傻瓜化\"的层面；相反，你要通过逐渐的摸索，不断地折腾，搞定各种\"DIY\"。在折腾的过程中，你自然会学到很多东西。\n\n　　另外，俺在《磨刀不误砍柴功——聊聊个人IT基础设施的完善》也说了，Linux 相比 Windows 的特色之一就是：高度的可定制化。所以，你可以利用 Linux 的这个特色，定制非常个性化的系统环境，以提高你使用操作系统的效率。\n\n★如何选择发行版？\n\n　　Linux 有千奇百怪的发行版（洋文叫 distribution），有几百种之多。不同的发行版有各自的特色。你可以根据自己的情况，选择一款适合自己的发行版。\n\n　　很多初学者经常困扰于如何选择发行版。在这里，俺先给出第一个建议：一定要选\"成熟的\"发行版。对初学者而言，选择成熟的发行版，有助于你少走弯路，避免浪费时间。\n\n　　判断某个发行版是否\"成熟\"，可以看如下几方面：\n\n◇文档是否足够完善\n\n　　这点对于初学者尤其重要。如果某个发行版缺乏完善的文档，对初学者是巨大的障碍。\n\n◇用户数是否足够多\n\n　　如果你使用的发行版，用户过于稀少。万一你碰到问题，就比较难在网上找到答案。\n\n　　反之，如果你用的发行版，用户数量较大。那么你碰到的问题，通常别人已经碰到过 N 次了。网上已经有很多相关的讨论了。那么你就比较容易 Google 到答案。\n\n◇解决Bug（发布补丁）的速度是否够快\n\n　　只要是软件，难免会有Bug——Linux 系统当然也不例外。有 Bug 不可怕，可怕的是有了 Bug 却迟迟得不到解决（没补丁 或 补丁发布太慢）。\n\n　　对于成熟的发行版，通常有足够多足够牛的维护人员，所以成熟发行版解决问题（发布补丁）的速度通常较快。而不成熟的发行版，维护人员不多，反应速度自然差得多。\n\n　　上述这三个指标，第一个比较容易判断。后面两个指标，对某些菜鸟而言，比较难判断。不过没关系，有一个捷径——你可以通过维基百科来判断某个发行版的 成熟度。某个发行版的词条写得越详细，通常说明这个发行版越成熟。（提醒一下，可以同时参考中英文两个语种的维基百科词条）\n\n　　考虑到篇幅，没法在本文中详细介绍各种类型的发行版。所以，俺另写了一篇博文《扫盲 Linux：如何选择发行版》，从多个角度介绍不同发行版的特色。\n\n★从哪里获得文档和资料？\n\n◇维基百科\n\n　　首先，要善于利用维基百科（尤其是英文维基百科）。通过维基百科，你不但可以找到某个发行版或某个软件的概要介绍，还可以找到与之相关的一系列软件。\n\n　　举个例子，如果你想找轻量级的发行版，只需访问维基百科的这个页面，就可以一目了然。\n\n◇发行版的官网\n\n　　刚才说了，成熟的发行版，必定有相对完善的文档。所以，你可以去该发行版的官网，通常就能找到比较详细的文档。另外，有些成熟的发行版还会提供多语种的文档。\n\n　　说到文档的语言，稍微跑题一下：\n\n　　在折腾 Linux 的过程中，俺强烈建议大伙儿还是尽量看英文文档。有如下好处：\n\n1. 如果你英文的基础不行，顺便可以提升一下英文的阅读能力\n\n2. 英文文档相比其它语种的文档：更新更及时、内容更详细、覆盖面更广。\n\n◇相关软件的官网\n\n　　如果你使用的是\"成熟的\"的发行版，那么该发行版内置的软件，通常也是比较成熟的。这就意味着，这些软件的官网，通常也会有比较完善的文档。\n\n　　所以，如果你使用某个软件碰到困难，可以去该软件的官网看相关的文档。\n\n◇相关的论坛\n\n　　成熟的发行版或者成熟的软件，通常都有专门的论坛/邮件列表。你可以去这些地方寻找你要的文档。（提醒一下：要善于使用 Google 搜索的 site 语法）\n\n◇其它\n\n　　Linux Documentation Project（简称 LDP）上面汇总了许多 HowTo类 和 FAQ类 的文档。\n\n　　除了上述这些，俺也会抽空分享一些关于 Linux 的书籍到俺的网盘上。相比网上的文章/文档，某些好的书籍可以有助于系统化地学习相关知识。\n\n★碰到问题如何解决？\n\n　　在你摸索的过程中，势必会碰到很多问题，这时候你需要学会利用互联网自己找答案。\n\n　　如果你是 Linux 的新手，你碰到的问题，通常是低级问题（所谓的\"低级问题\"就是说，这个问题之前已经有 N 个人碰到过了，属于比较普通常见的）。这种情况下，你通常可以利用搜索引擎，找到自己需要的解答。\n\n    以上就是关于Linux操作系统的问题各内容，非常的详细和非常的简单，只要有认真的看过一遍，那么对于Linux操作知识都能了解的。电脑小白们赶紧学起来吧！",
			"added": 1582483448,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582488210,
			"title": "Gentoo 中文社区",
			"body": "在这里建站不需要花钱，不需要注册帐号",
			"added": 1582488201,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9",
			"type": "group"
		},
		{
			"topic_id": 1582488242,
			"title": "Gentoo 中文社区 又一次成立了",
			"body": "",
			"added": 1582488232,
			"parent_topic_uri": "1582488210_1BmpVY8MGPBg8dnUVWPh56ySU5WuGZui3t"
		},
		{
			"topic_id": 1582549453,
			"title": "Gentoo FAQ",
			"body": "从稳定版更改为测试版时，用户会发现许多软件包将被更新。请记住，移至测试分支后，回到稳定分支可能会很有挑战性",
			"added": 1582549442,
			"parent_topic_uri": "1582488210_1BmpVY8MGPBg8dnUVWPh56ySU5WuGZui3t"
		},
		{
			"topic_id": 1582627138,
			"title": "有没有爱的实验室中文视频 ？",
			"body": "",
			"added": 1582627125,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582629946,
			"title": "什么样的发行版能吸引 linux爱好者？",
			"body": "",
			"added": 1582629932,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582711164,
			"title": "学习Linux的正确姿势",
			"body": "端正学习态度\n1、Linux不等于骇客（or Cracker）。\n当然众所周知很多“黑客工具”都是Linux平台上的，我帮助过很多Linux小白发现他们殊途同归都是朝着类似Aircrack-ng去的。\n\n2、Linux只是一个工具，工具不是目的，只是手段。这一点很重要。\nLinux很快的完成你的需求目标。因为他是个专业级别的工具。\n工具跟工具之间各有利弊 人和人都不能比呢。\n\n3、正确认识qq群。\n潜水的太多\n正经帮人的几乎没有，千人群里面不会超过5个活跃的并且愿意帮助人的高手。\n另外问无意义问题，无厘头问题(没有前因后果，不知道要干啥就提问的问题)太多，高手就都走了。不愿意回答。\n\n4、Linux与Windows\n没必要比，个人认为操作系统当前满足的需求内容是不同的。\n桌面习惯那个就用那个，两个不是水火不相容。\n\n5、什么文章有必要看什么文章没有必要看\n垃圾文，讨论哪个好，哪个坏的。\n一看文章就只是手记，不是给人看的。\n百度文章非热搜词PageRank做的真心是非常糟糕。\n\n6、关于英文\nManual全是英文\n大家在Mailling list和IRC里面都说英文\nEmail跟国外高手切磋得用英文。\ngoogle搜关键问题得用英文。\n压根躲不过去，所以必须得用英文。\n不会英文不会学不好。只是可能会比会英语的人学的慢一点，比会英语的人吃力一点。\n\n7、学Linux不是为了装系统就完了。要学习Linux擅长的一面，而不是薄弱的一面去跟windows相比，但是新的微软（DotNet开源，新的 windows10已经对开发者利好，以及做技术的CEO。。。。），与Ubuntu branch 的新星 Deepin Linux以一定会在未来大放异彩。虽然PC已经疲软。\n\n关于开发\n如果你想用Linux工作的话。那么Linux跟开发绝对不是分开的东西。\n1、开发的不可能不懂一点Linux运维，因为他们不会搭建环境怎么开发。\n2、一个好的运维不可能不懂开发。最贴切的例子：运维脚本。服务器状态数据可视化（Gnuplot，虽然cacti都有现成的了）等等。\n\n发行版本\n1、既然是来学习的，来解决身边问题的。那么就不要考虑好不好的问题，而是考虑什么好用什么不好用的问题。举几个贴切的例子。\nService方面，如果你使用Linux来坐传统的LAMP业务的花，想稳定而且有长期维护的版本那么RHEL（CentOS）系列的就比较适合你了。\n现在是Linux3.0时代，正处于版本号狂飙阶段（据闻，脱袜子准备3.19之后换挡到4.0了），各种新功能各种百花齐放。因此如果想用比较新的功能请使用版本好比较新的发行版本（Ubuntu，Fedora，等等）\n\n2、客观的来讲发行版本的选择：\n选使用人比较多的，因为社区庞大，寻求到帮助的概率比较大。并且BUG也会是比较少的。\n根据应用情况来选择，如果是路由那么就选OpenWRT，另外如果是树莓派等等虽然选择比较多，但是为了稳定运行请选择官方提供的Image。会比较方便。\n\n3、 推荐使用的发行版本\n推荐LFS\n也许很多人会反持有不同的意见。但是LFS如果使用CentOS 6 版本如果严格按照教程来做，那么就会非常非常轻松的完成安装。\n既然这么轻松，为什么我还要推荐LFS来做初次学习Linux的学习版本呢？\n在安装的过程中会熟悉很多很多Linux命令。\n还会熟悉Linux到底怎么组织运行起来的。遇到问题的时候才不会胡子眉毛一把抓。因为它的确不是很简单的小系统。\n会有机会熟悉各种Linux模块，明白到底什么是Linux内核，哪里是Linux内核，哪里是Linux。会绕过很多很多坑。\n\n4、不管选择什么发行版本：学知识，更好学习方法(学习方法，解决问题的方法，搜索的方法，等等都有好处)。\n\n到底要不要桌面\n1、 建议不要桌面。\n2、如果您是windows建议使用VirtualBox+headerLess做成托盘+Putty远程控制。\n3、如果您是Mac 建议使用VBoxHeadless的命令行使用Screen挂起运行。\n\n学习Linux的配置\n1、因为刚开始学习不宜直接安装Linux(如果不是超狂热爱好者还是选择虚拟机Linux比较合适，因为现在已经到了云时代了)\n2、虚拟机配置选择单核或者双核（如果您的机器配置高可以选择更高），如果只是个人使用的话，内存512MB足够了。已经非常大了。一般正常情况下裸奔的Linux不到100MB左右的内存使用。\n\n如何问问题\n1、请不要轻易提问，因为你每一次找人帮忙解决问题不但占用别人的时间，并且最重要的是，丢失了一次重要的学习机会。\n2、轻易不要到qq群里面提问，因为qq群里面有非常非常多的只会装Linux以及讨论Wine，Compiz问题的人，以及问一些关于QQ安装的问题。\n3、请到Mailling List里面看看别人都如何提问的。以及可以看到什么样的提问会有结果，什么样的提问会有很多人来回答。",
			"added": 1582711149,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582711622,
			"title": "Linux的秘密：这才是find的正确使用姿势",
			"body": "毋庸置疑的，作为一个经常要和Linux打交道的开发人员而言，find都是我们日常工具箱中使用最频繁的命令行工具之一，因此其实是很值得我们花费更多时间，来研究一下他的用法的。\n\n最差的find实践：find 路径名\n\nfind命令所需要的最少的一个参数，是所要搜寻的路径。比如，我们可以这样来使用find命令：\n\n    find /\n\n天哪，你的屏幕迅速滚动起来了！这完全没用，甚至还不如使用ls命令。显然的，到了我们需要做点什么的时候了。\n\n稍微好一点：加上-name参数\n\n好吧，也许你只是想在当前用户主目录中找到所有的jpg文件。 使用-name参数，可以帮助你实现这个目标。\n\n    find ~ -name '*jpg'\n\n可是，我记得我藏了一个很......的图片在一个很深的目录里面，它哪里去了？或许？\n\nLinux的秘密：这才是find的正确使用姿势\n它的扩展名可能是大写的，比如这样：JPG？\n\n嗯，很多图片一不小心就会存成这样，所幸的是，find也想到了这一点！用-iname来替代-name吧，就像下面那样，它的优点是，可以把不管是大写还是小写，还是半大写半小写的都给搜出来，嗯，这在模式匹配中叫什么来着，对了：大小写无关性。\n\n    find ~ -iname '*jpg'\n\n等等，好像出来一些了，但我记得我存了很多啊，怎么只有这几个文件？嗯，或许你的是另外的一种情况：\n它的扩展名可能不仅仅包括jpg，也包括jpeg\n\n一定是这样！一些图片可能就是有一个.jpeg扩展名。 幸运的是，我们可以将模式与由-o表示的“或”组合起来，一起使用，比如像下面这样：\n\n    find ~ \\( -iname '*jpeg' -o -iname '*jpg' \\)\n\n这里有两点是需要特别说明的：\n\n    作为一个二元操作符，-o要求或的部分整体用小括号扩起来，但需要注意命令行中但转义，这是必须的\n\n    与此同时，括号和对应的操作值，比如这里的-iname '*jpeg'之间，至少要有一个空格\n\nPerfect！唯一有点儿美中不足的，是还不够清爽啊，天知道当时，我怎么会心血来潮的把这些文件所在的目录，命名为什么jueMiJpg，gongzuoJpg的，莫非是为了表示这是正儿八经的图片文件夹？\n\n可是我现在，只想找到这些文件啊！\n\n-type f参数登场\n\nLinux的哲学告诉我们，只要我们想到，就一定能在Linux下办到。是的，-type f参数，就是解决这一问题的利器，它像一个管道一样，将只查找并输出文件，而不包括文件夹：\n\n    find ~ \\( -iname '*jpeg' -o -iname '*jpg' \\) -type f\n\n当然，既然有-type f，也肯定会有-type d，说不定我以后就是想找那些命名古怪的目录，以便稍后重命名它们呢：\n\n    find ~ \\( -iname '*jpeg' -o -iname '*jpg' \\) -type d\n\n好吧，这可能还是不能令老板满意，就在上周，他要求设计师鼓捣100张图片出来，但现在整个目录下，有近1,000个文件，我怎么直到哪些是上周提交的啊？需要写一个脚本？\n\n答案是：不！因为我们可以：\n建立基于find的时间粒度查找器\n\n\nLinux下，每个文件都包含有3个重要的时间点，在find命令中，则对应表达为：\n\n    创建日期：-ctime\n\n    最后修改日期：-mtime\n\n    最近一次访问日期：-atime\n\n这里，当然是要用-mtime，我们的策略则是：查下最近7天内，设计师提交了多少图片，这里，要用到的是时间运算符号是减号（-），它代表了n天内，比如这样：\n\n    find ~ \\( -iname '*jpeg' -o -iname '*jpg' \\) -type f -mtime -7\n\n把结果输出出来，然后统计下个数，就能向老板交差了。\n其他的时间粒度和运算符号\n\n既然有减号（-），那自然就有加号（+），在find的时间粒度查找中，加号（+）表示什么呢？意思很清楚，n天前，所以下面的逻辑关系应该是成立的：\n\n    find ~ \\( -iname '*jpeg' -o -iname '*jpg' \\) -type f -mtime -7+ find ~ \\( -iname '*jpeg' -o -iname '*jpg' \\) -type f -mtime +7---------------------------------------------------------------------- find ~ \\( -iname '*jpeg' -o -iname '*jpg' \\) -type f\n\n那如果我想更细一些的时间粒度呢？比如不是天？这方面，find可以到达的粒度是分钟，对应着ctime、mtime和atime，有cmin、mmin和amin供我们使用，不过应该用不着吧？\n\n处理完了照片的事情，也许需要来关心关心磁盘的空间了，作为日常的维护，我们总是要定期的把那些已经过期（比如30天前），但巨大（比如大于1G）的log清理掉，第一步当然就是找出它们：\n通过-size参数确定所需查找文件的大小\n\n    find /var/log -size +1G -mtime +30\n\n好了，我觉得我已经够多了。find的所有技巧都在这了么？当然不是，比如你或许可能还会看到这样的find命令：\n\n    find /data -owner root\n\n它代表查询所有拥有者是root的文件，又或许，有这样的命令\n\n    find ~ -perm -o=r\n\n它将在当前主目录下，查找出所有只读的文件，以确保你不会过度的分享。所以，这篇文章其实只是抓住了可以做的事情的表面。通过和比如正则，以及布尔逻辑相结合，可以为您提供难以置信的find查找的灵活性，以便准确找到要查找的文件。\n\n你还喜欢哪些find的表达式？ 在评论中分享他们吧！",
			"added": 1582711606,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582711875,
			"title": "为什么学习Linux及学习的正确姿势",
			"body": "为啥要学Linux？\n\n面对各种难记的命令和复杂的符号，Linux往往让有些人望而却步\n\n这是因为Linux命令有太多，同时每个命令又有太多的选项，各个命令之间又可以通过管道符等方式近些组合，所以综合来说需要记忆的东西实在太多。\n\n但是，为什么放着简单的windows不用，而要去学习Linux呢，这是一个很大的话题。\n\n这主要取决于你的兴趣和野心，因为Linux自有其非凡的魅力所在。\n\n你用了好多年Windows，但是你对操作系统的了解几乎还是一无所知，学习完Linux后，你会对操作系统有个全新的认识。\n\n因为windows是一个黑箱，将计算机各部件都封装起来，基本上只需要一些简单的点击就可以完成大部分操作，但是这也限制了它去完成进一步复杂的高难度的任务。\n\n而Linux舍弃可视化界面（GUI，当然以Ubuntu为代表的这些发行版会配上不错的GUI，但是其本质还是命令行），而保留最本质的计算能力。shell是你直接和计算机各部件进行对话的方式，通过shell，可以直接调用计算机各部件的计算能力和资源。所以，命令行不是为了装逼，是真的为了最大限度的利用计算机，从而高效完成实际场景中的任务。\n\n很多时候，一行命令就能完成一个很复杂的任务。\n\n怎么学Linux？\n\n学习Linux时，不能求快而全，得循序渐进，先从基础的简单的常用的命令开始，再配以一些必要的背景和原理说明，这样可以帮助理解，还有实例的列举，可以加深对命令行与使用场景的印象。\n\n命令（命令就包含了参数）的集合就是命令行，命令行的集合就是shell脚本\n\ncommand ---------------------->  command line ---------------------> shell script\n\n本书在完成了以下三点方面，可以打上85分\n\n1、循序渐进，从linux开始讲起，到shell命令行，再到shell脚本，自然有序。\n\n2、作者对于一些命令的背景及原理介绍，让我觉得很惊喜，是本书的一大两点。\n\n3、命令都是从简单、常用的开始，罗列几乎全部的选项，同时举例时只用常用的部分，点到为止，没有选项都详细讲解。毕竟不是手册，不会让人觉得无聊与单调。\n\n所以，本书适合当做初级入门书籍来阅读，完整读完后，会对linux与shell有一个大概的理解与感觉\n\n过程中，记得去敲书中提到的那些代码，敲一遍敌得过看十遍。\n\n我用的是中英文对照版，有些因为翻译的关系，中文有些难懂，对比着看英文会比较清楚\n\n\n以下是这本书各种格式的连接：https://billie66.github.io/TLCL/\n\n后续，可以找一本进阶的书，最好带有很多实际操练的例子，比如《Linux Shell脚本指南》\n\n开始保持好奇心，继续噼里啪啦敲起来吧。",
			"added": 1582711858,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		},
		{
			"topic_id": 1582712557,
			"title": "教你处理Linux系统问题的正确姿势",
			"body": "我们一直有这样一个希望，希望我们身边的一切，比如汽车上的系统，家庭影院系统，电脑系统，亦或是  Linux 系统能永不出错的运转着。这个想法听起来很棒，生活里一般也正是如此。\n\n虽然一般人在使用 Linux 的时候不会遇到问题，但是对于那些想要获得最好体验和最优信息的人来说却可能会碰到。当然，你可以从很多地方获得专业的帮助。比如，如果你是从像红帽这样的 Linux 供应商那里购买了 Linux 系统，你可以从供应商那里索取咨询服务。事实上，你花钱买的也就是这种服务。另外，除了供应商，你还可以从各种各样的网站和论坛上获得帮助。你所在地区的 Linux 用户使用组和其他使用 Linux 的朋友，都会非常乐意为你提供援手。别犹豫，尽管充分利用这些资源吧。\n\n其实在大多数时间里，我们当中的大多数 Linux 系统使用者更加喜欢自己检修、解决自己在使用系统过程中所遇到的问题。\n\n我们不得不承认，无论是解决什么类型的问题都是一种艺术和技术。解决技术上的问题，诸如电脑故障之类的，就需要一系列的专业知识了。\n\n但在我们实际解决问题的过程中，我们需要的绝不仅仅是一张写着问题和解决步骤的清单。这种只靠步骤清单来解决问题的办法，也就是我们俗称的“对症下药”。它来自于那些观念陈旧的管理者们（这些管理者大都缺乏基层实践），它听起来很理想，但却经不起实践。那么，我们应该怎样正确的处理问题呢？\n\n一、概要\n\n下面是我用来解决Linux使用问题时的五个基本步骤：\n\n1.储备知识\n\n2.观察问题\n\n3.推测原因\n\n4.动手解决\n\n5.测试效果\n\n然而当你处理问题时，虽然你可能已经遵循了上述步骤，但是并没有真正意识到它。如果你每次忙着解决问题时都遵循这个流程，那想来大多数时候你都能成功解决问题。这些方法步骤是通用的、适用于解决绝大多数问题的，并不仅仅局限于解决Linux或电脑问题。\n\n很多年来，我一直在使用这些方法步骤来解决电子和电脑方面的问题，却并没有意识到在使用它。当我被问题卡住，规范化解决问题的流程使得我更有效的解决遇到的问题。在处理问题的过程中，我会我不断回顾已经经历过的步骤，判断自己处在哪一步。在确实需要的时候，我也会重复一个适当的步骤。\n\n你可能已经在过去听说过一些其他的适用于解决问题的方法。这一过程的前三个步骤也被称为确定问题，即寻找问题的原因。最后的两个步骤是解决问题。\n\n1.储备知识\n\n在解决问题方面，拥有足够的知识是第一步。你必须至少了解Linux基本知识，甚至熟悉可能影响到Linux的领域，例如硬件、网络还有环境因素，如温度、湿度和Linux系统操作可能涉及的电气环境。\n\n获得知识的途径有很多。你可以阅读相关的书籍和杂志，也可以参加课程、研讨会和其他会议。你也可以通过网络，与其他同样使用 Linux 的、知识渊博的人交流。\n\n我个人倾向是“玩” Linux 。其实更加准确的说法是用Linux去实验操作，例如搭建网络方面，然后通过听课来理顺自己获得的经验和知识。\n\n要记住，如果没有足够的知识，那么“抵抗是徒劳的”（这里借用博格人的名言）。知识就是力量。\n\n2.观察问题\n\n解决问题的第二步是观察问题的症状。重要的是注意到所有的问题特征。解决一个问题之前，观察有什么是正常工作的也是很重要的。\n\n现在还不到动手解决问题的时候，你只需要观察问题。\n\n观察的重要内容之一就是去问自己看到和看不到什么的问题。除了你要问自己的特殊问题，还有一些一般性的问题要问问自己：\n\n造成这个问题的原因是硬件、Linux系统本身、应用软件或者是相关人员缺乏知识和培训所导致的误操作？\n\n我以前遇到过这样的问题么？\n\n有错误的提示么？\n\n日志里有关于这个问题的记录么？\n\n在错误发生之前，计算机的最后操作是什么？\n\n当这个问题没有发生时，应该出现的正确结果是什么？\n\n最近有关系统硬件和或软件的设置有被改变么？\n\n这些问题将会在你努力寻找它们的答案的时候自己暴露出来。而对于你来说，更重要的是去收集尽可能多的信息。这将会增加你这类问题的了解和彻底解决这类问题的知识。\n\n使用在线资源搜索类似的错误，也许有人已经报告了这个问题，并给出了解决方案。\n\n当你收集数据的时候，永远不要假设从别人那里获得的数据是正确的。请注意观察你工作的一切细节。如果你正在和一个在远方的人一起工作，这可能会是一个主要的问题。这时，仔细询问变得至关重要。而当你试图确认自己给出的信息时，允许远程访问系统问题的工具非常有用。\n\n当询问在远程站点的人时，永远不用问诱导性的问题。他们将尽全力帮助你，有问必答。\n\n在其他时候，你得到的答案一般都取决于你问的那个人对 Linux 的了解程度和电脑知识水平。当一个人懂得或认为他知道关于电脑的知识，你得到的回答可能包含很难反驳的假设。相比于问一句“你检查过了么”，更好的做法是安排另外一个人来实际执行任务所需的检查。并且，相比于告诉一个人他/她应该看到什么结果，还不如简单的让用户解释和描述他/她看到的。再强调一次，对机器的远程访问可以让你确认自己给出的信息。\n\n最好的问题解决者是那些从来不会理所当然的人。他们从来不会假定他们拥有的信息是100%正确和完整的。当你拥有的信息看起来自相矛盾时，如果你对此毫无办法那就重新来过吧。\n\n3.推测原因\n\n从你观察到的现状推断出可能导致问题的原因。\n\n艺术在解决问题上也适用。根据你的知识和过去的经验观察问题就是一种演绎艺术，这有点神奇。伴随着科学方法，依靠产生的灵感、 直觉、 或神秘的心理过程，找到一些有助于查找问题根本原因的线索。\n\n在某些情况下这是一个相当简单的过程。比如你看到一个错误代码，并通过查找现有资料弄明白它的意思。然后，应用自己知道的大量知识推测问题的原因（这是解决问题过程中最为艺术的一步）。在某些情况下，这种推测可能很难作为问题测定过程的一部分。\n\n这个推测的过程有助于记住问题特征而不是记住问题。问题产生了特征现象。但你想解决的是问题而不是问题特征。\n\n4.动手解决\n\n现在是时候来解决问题了。不要害怕，这通常是最简单的部分，最难的部分（分析如何解决问题）刚才已经过去了。在你知道问题的原因后，正确的修复一个问题是很容易的。\n\n解决方案多种多样，可能需要更换硬件的驱动，或者是去更新一些软件程序。\n\n对于一些有错误的软件，如果你或者你的组织没有足够的能力修复它，那至少你可以用适当的方法把错误报告给作者或其他组织。我曾经就用Bugzila给红帽公司报告了几个错误。任何人都可以创建自己Bugzila账号，并查找现有的错误或报告一个新的错误。\n\n5.测试效果\n\n采取了修复措施后就应该要进行测试了。通常意义上，这意味着要从任务失败的地方开始重新操作和重复实验。\n\n如果修复措施没起作用，你应该从错误开始的地方再运行一遍程序试试。由于错误可能会因为你的修复操作而发生变化，所以你要意识到这一点，并对程序运行结果和问题特征进行记录，以便在下一次迭代修复时对解决方案作出相应的修改。这样做即使没能解决问题，问题特征的变化在后续的处理过程里也是很有参考价值的。\n\n二、举个例子\n\n这是一个几年前发生在我自己身上的案例。那时候，我曾经在一个实验室兼职做 Linux 系统管理员。这个问题相当简单，但足以说明我所概述的方法步骤。\n\n我收到了一封来自我们测试员的电子邮件。邮件里说，他安装的一个用来测试的软件崩溃了。错误提示信息是系统交换空间不足（SWAP）。这是用户操作后给我的初步反馈和观察结果。\n\n从我所知道来看，被用来测试应用程序的系统有高达 16GB 的内存和 2GB 的交换空间。而以往的使用经验也表明，这些计算机里的交换空间几乎用不到，它们的内存使用率也往往低于 25% 。\n\n基于上述几点，我推断问题并非真的出在交换空间上，因为这几乎是不可能的。但我仍然保持对它的怀疑，即便这个可能性很小。其实，你也许也发现了许多程序提供的错误提示是有误导嫌疑的，自己观察的结果反而可以让你获得更多有用的信息。\n\n 我为测试人员提供了一些自己的意见。我登录到计算机中，用  free 命令来查看内存和交换空间使用情况。我发现 大量的内存还空闲着，而且交换空间没有被动用。按照我所知道的，如果交换空间的实际使用率为零，那么也就是说开机以后很有可能从未分配可用交换空间，而且内存也没有分页。\n\n以我以往的经验看，解决问题的关键就是错误信息提示。从提示来看，很像是程序想要向系统索取一些资源却没有成功。而对于计算机来说，其他可消耗的资源主要就是 CPU 和硬盘空间。\n\n这并不像 CPU 的问题。所以我用 df 命令检查一下文件系统，发现 var 文件夹满了。我推断 /var 空间全满是导致问题的原因。\n\n我们的系统平常都是给 var 文件夹设置 1.5 GB 大小。通常情况下，我们是在 /opt 中安装应用程序。这也是我们测试的软件安装的地方。\n\n我与测试人员探讨这个问题，他告诉我说他确实把应用程序安装在了 /var 目录。我告诉他要先从 /var 卸载安装的应用程序，并在 /opt 里重新安装。采取这一措施之后，我示意程序员进行测试，结果不出所料，问题被成功解决。\n\n一般来说，你要想解决一个问题，至少需要重复一些步骤。比如说，如果执行给定的修复措施不能解决问题，你可能需要尝试另一种办法或者可能需要回到观察步骤并收集有关该问题的详细信息。\n\n三、必要的过程分析\n\n很多年来，我一直在教别人怎么修复硬件和软件的问题。我也一直在思考人们使用的解决问题的思路是否已经足够规范化。当我被教授了这种解决问题的方法步骤后，它使得我能够在努力解决问题时清楚的意识到自己处在哪一步。这让我能分析我在哪里出现错误，并重回正轨。\n\n你解决问题的方法流程可能也不一样。也许你还没意识到你的思路是一个可描述性和可重复的过程。但是，如果你成功解决了电脑出现的问题，那你所采用的方法就是好方法。了解这个解决问题的方法流程，无论它是否适合你，未来都会有助于你解决遇到的问题。",
			"added": 1582712539,
			"parent_topic_uri": "1571186422_1MvkYQf2rLUspQvPSo18pdJsujt2aXbXB9"
		}
	],
	"topic_vote": {},
	"next_comment_id": 23,
	"comment": {
		"1577836120_1MityxAx6QVFTYWjzSJFc6nCX6eyT5W5yQ": [
			{
				"comment_id": 1,
				"body": "宣传要接地气",
				"added": 1582254214
			},
			{
				"comment_id": 7,
				"body": "继续折腾，多折腾才能有更多的可能性，更多的机会",
				"added": 1582367625
			},
			{
				"comment_id": 8,
				"body": "使用 org-mode写小说\n统一任务管理中心\n正在执行一个事务\n清晰的规则，要尽量避免隐式规则，要灵活透明\n我不喜欢 windows的目录结构",
				"added": 1582391813
			},
			{
				"comment_id": 9,
				"body": "首先说说个人习惯：1、少用鼠标，多用键盘；2、把信息以及鼠标操作对象往一边靠。第1点相信很好理解，除了某些专业领域外，大部分操作都是非精确操作。而鼠标主要用于精确操作，在非精确操作时用键盘比用鼠标效率不知高到哪里去了。比如关闭窗口，键盘就用ctrl+w或者alt+F4，鼠标的话需要精确定位才能操作，而且手要离开键盘区去操作鼠标进行较大范围移动，而笔记本的触摸板一般又比鼠标的效率低。\n&nbsp;  \n第2点什么意思呢，windows的任务栏默认在底边，而窗口的标题栏(各种菜单/按钮)都在上面，这就比较分裂了。这样的结果是你在关注任务栏的东西和窗口标题栏时需要上下瞄，使用鼠标操作时也要上下大范围移动，效率很低好不好？所以我一般会把windows的任务栏设置在顶上，这样视线和光标都不需要大范围移动，获取信息和输出操作都比较集中了。",
				"added": 1582393850
			},
			{
				"comment_id": 11,
				"body": "够用就好，没必要追求最好，折腾出一个适合自己的环境\nDebian 坚如磐石",
				"added": 1582400861
			},
			{
				"comment_id": 12,
				"body": "上学当然是有用的，代表着有了进一步学习的能力",
				"added": 1582480466
			},
			{
				"comment_id": 13,
				"body": "windows 是一个黑盒子，一旦出问题了非常难以修理\n深入理解 linux",
				"added": 1582481305
			},
			{
				"comment_id": 16,
				"body": "找到了一个小白linux群，可以看看他们究竟有多白\nlinux 论坛里的教程管理的一塌糊涂，查找效率非常的低",
				"added": 1582492047
			},
			{
				"comment_id": 18,
				"body": "不以赚钱为目的的为玩 linux，不是爱好，就是浪费时间\n使用LFS的人只是有时间折腾 LFS的人",
				"added": 1582617847
			},
			{
				"comment_id": 20,
				"body": "把身外之物都扔了吧",
				"added": 1582620610
			},
			{
				"comment_id": 21,
				"body": "我一定能做到控制住自己",
				"added": 1582710772
			},
			{
				"comment_id": 22,
				"body": "没有时间再去管别人的事了，没有时间再去帮助别人了",
				"added": 1582753577
			}
		],
		"1582311991_1BmpVY8MGPBg8dnUVWPh56ySU5WuGZui3t": [
			{
				"comment_id": 2,
				"body": "pkill 按进程的名称杀死进程！（这个工具我很惊讶！）\ncv 简直就是linux神器（显示复制拷贝进度条！）\ntee 指定的文件保存制定文件列表中\nspilt 指定文件分割成若干小文件（多半用于分割日志）\nchroot (卧槽我现在还不会用这个命令！)\ncloc: 用来统计代码行数，统计结果比较分类比较详细，支持大部分编程语言。\nfzf，交互式文本搜索\nfd (sharkdp/fd) -- 一个更好并可能更快的find，命令简洁直观，结果用户友好。\n",
				"added": 1582326762
			},
			{
				"comment_id": 3,
				"body": "bro：以用例为主的帮助系统\n\nman 以外的帮助系统有很多，除去 cheat, tldr 外，还有一款有意思的帮助系统 -- bro，它是以用例为主的帮助，所有用例都是由用户提供，并且由用户投票筛选出来的：",
				"added": 1582324686
			},
			{
				"comment_id": 5,
				"body": "ohmyzsh有一个叫做z的插件，比autojump不差",
				"added": 1582325837
			},
			{
				"comment_id": 6,
				"body": "tget jeffjose/tget\n\n啊咳，那个，这个是专门用来下载磁力链接用的啊……因为本人经常混迹于某神社，剩下的我就不多说什么了啊……怎么安装怎么用自己点进去看看就知道了。",
				"added": 1582327698
			}
		],
		"1582325330_1BmpVY8MGPBg8dnUVWPh56ySU5WuGZui3t": [
			{
				"comment_id": 4,
				"body": "ediary下载 - 我的白日梦\nCherryTree(技术人员专用笔记软件) ",
				"added": 1582325577
			}
		],
		"1582481614_1BmpVY8MGPBg8dnUVWPh56ySU5WuGZui3t": [
			{
				"comment_id": 14,
				"body": "理解Linux系统负荷\n对linux系统端口复用技术的一些理解和认识\n熟练掌握Shell Script编程,加深对linux系统的理解\n对Linux系统中/dev/shm的一点认识\n对于linux下system()函数的深度理解(整理)\nLinux操作系统关于C library的理解?",
				"added": 1582483095
			}
		],
		"1582482316_1BmpVY8MGPBg8dnUVWPh56ySU5WuGZui3t": [
			{
				"comment_id": 15,
				"body": "理解 Linux 配置文件\nhttps://www.ibm.com/developerworks/cn/linux/management/configuration/index.html",
				"added": 1582482388
			}
		],
		"1579165212_1FfatX3G2z43rV6nc1F3koYtn8tmD5EVb6": [
			{
				"comment_id": 17,
				"body": "eXtern OS-一个用 Node.js 写的 Linux 桌面",
				"added": 1582616785
			},
			{
				"comment_id": 19,
				"body": "GoboLinux，是一款开源操作系统，其文件系统层次结构与FHS不同，意义在于构建一个在文件层级上结构明晰的系统。\n\nGoboLinux是一个开源操作系统，其最显著的特色是重新组织的文件系统层次结构。它没有遵循以往类UNIX操作系统的文件系统层次结构标准（FHS）。在GoboLinux下，每个软件都有自己的子目录树，其下包含它属的所有文件。因此，程序“Foo”的专属文件与库都在\" /Programs/Foo \"目录下。很明显，“可执行”文件位于\" /Programs/Foo \"。根据GoboLinux开发者的观点，其意义在于构建一个在文件层级上结构明晰的系统。\n\nGoboLinux的设计受一些较早操作系统的影响，如NEXTSTEP，AtheOS and BeOS，另保留原有的文件系统结构以保持对UNIX的兼容性。 GoboLinux目录树的根目录下，有6个目录：Programs, Users, System, Files, Mount and Depot. 每个目录的内容如下：\n\n/Programs/ - 包含安装的程序。每个程序各有其文件夹，每个文件夹下包含一个或多个版本的子文件夹，亦可能有配置子文件夹。例如：/Programs/Bash/3.0/bin/bash 与/Programs/Xorg-Server/Settings/X11/xorg.conf.\n/Users/ - 包含各个用户的主目录。如账号为\"harley\" 的用户会有一个主目录 \"/Users/harley\"。\n/System/ - 包含重要的系统文件。大部分是系统应用程序（如，/System/Settings/passwd）与GoboLinux 脚本程序（例如， /System/Links）.\n/Files/ - 包含程序使用的结构化数据，它们被程序调用但不是程序本身的组成部分。这些文件通常为单独的实体，如字体，解码器，插件。\n/Mount/ - 本地或远程文件系统的挂载点。常见的子目录有CD-ROM，软盘，Zip盘。\n/Depot/ - 用户文件存储。",
				"added": 1582618402
			}
		]
	},
	"comment_vote": {
		"29_1FfatX3G2z43rV6nc1F3koYtn8tmD5EVb6": 1,
		"72_1jqdk1qnBDXUgwVD785o4DEJtUBXiNSb7": 1
	}
}