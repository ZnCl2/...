{
	"title": "Noisy Guy",
	"description": "ZeroNet Blog",
	"links": "- [Source code](https://github.com/HelloZeroNet)\n\n- [Noisy Guy](https://www.noisyguy.com)",
	"next_post_id": 6,
	"demo": false,
	"modified": 1502823676,
	"post": [
		{
			"post_id": 4,
			"title": "利用DNSPOD实现动态域名解析",
			"date_published": 1465963946.945,
			"body": "用家庭宽带搭建服务器，最麻烦的就是IP不固定，（当然还有更麻烦的，比如封端口，还有内网环境）不过我们可以用域名动态解析来解决这个问题。动态域名解析服务有很多选择，最出名的就是花生壳，还有3322.org，但这些都需要客户端或是路由器支持，使用起来有些不太方便。\n\nDNSPOD使用了很久了，以前在GoDaddy买的域名一直挂在这里解析的，国内环境，速度比国外的快很多。其实我也是近段时间才知道DNSPOD有很多的API，其中就能更改域名的记录，号称可以在7秒内更新全部DNS节点。\n\n---\n废话不多说，说正题，以下是用python写的更改域名记录的脚本\n\n```python\n# -*- coding: utf-8 -*-\n \n\"\"\"\nCreated on 2014-02-09\n__mail__   = lenye@hiduan.com\n \ndnspod动态dns更新\n五分钟更新一次, 运行crontab -e, 编辑:\n*/5 * * * * python /home/pi/dnspod_ddns.py\n \n获得domain_id:\ncurl curl -k https://dnsapi.cn/Domain.List -d \"login_email=xxx&login_password=xxx\"\n \n获得record_id:\ncurl -k https://dnsapi.cn/Record.List -d \"login_email=xxx&login_password=xxx&domain_id=xxx\"\n\"\"\"\n \nimport httplib\nimport socket\nimport urllib\nimport json\nimport logging\n \nconfig1 = dict(\n\t\"\"\"\n\t记录1\n\t\"\"\"\n    login_email=\"xxx@example.com\",  # 登录email\n    login_password=\"password\",  # 登录密码\n    domain_id=100,  # replace with your domain_od, can get it by API Domain.List\n    record_id=500,  # replace with your record_id, can get it by API Record.List\n    sub_domain=\"www\",  # replace with your sub_domain\n)\n\nconfig2 = dict(\n\t\"\"\"\n\t记录2\n\t\"\"\"\n    login_email=\"xxx@example.com\",\n    login_password=\"password\",\n    domain_id=100,\n    record_id=501,\n    sub_domain=\"@\",\n)\n\nddns_params1 = dict(\n    format=\"json\",\n    login_email=config1['login_email'],\n    login_password=config1['login_password'],\n    domain_id=config1['domain_id'],\n    record_id=config1['record_id'],\n    sub_domain=config1['sub_domain'],\n    record_line=\"默认\",\n)\n \nrecordinfo_params1 = dict(\n    format=\"json\",\n    login_email=config1['login_email'],\n    login_password=config1['login_password'],\n    domain_id=config1['domain_id'],\n    record_id=config1['record_id'],\n)\n\nddns_params2 = dict(\n    format=\"json\",\n    login_email=config2['login_email'],\n    login_password=config2['login_password'],\n    domain_id=config2['domain_id'],\n    record_id=config2['record_id'],\n    sub_domain=config2['sub_domain'],\n    record_line=\"默认\",\n)\n \nrecordinfo_params2 = dict(\n    format=\"json\",\n    login_email=config2['login_email'],\n    login_password=config2['login_password'],\n    domain_id=config2['domain_id'],\n    record_id=config2['record_id'],\n) \n \ndef ddns(ddns_params):\n    \"\"\"\n    用当前ip更新ddns\n    \"\"\"\n    headers = {\"Content-type\": \"application/x-www-form-urlencoded\", \"Accept\": \"text/json\", \"User-Agent\": \"NoisyGuy_PHP/1.0.0(ituness@me.com)\"}\n    conn = httplib.HTTPSConnection(\"dnsapi.cn\", timeout=30)\n    conn.request(\"POST\", \"/Record.Ddns\", urllib.urlencode(ddns_params), headers)\n \n    response = conn.getresponse()\n    # print response.status, response.reason\n    # data = response.read()\n    # print data\n    conn.close()\n    return response.status == 200\n \n \ndef getrecordip(recordinfo_params):\n    \"\"\"\n    获取记录信息\n    \"\"\"   \n    headers = {\"Content-type\": \"application/x-www-form-urlencoded\", \"Accept\": \"text/json\", \"User-Agent\": \"NoisyGuy_PHP/1.0.0(ituness@me.com)\"}\n    conn = httplib.HTTPSConnection(\"dnsapi.cn\", timeout=30)\n    conn.request(\"POST\", \"/Record.Info\", urllib.urlencode(recordinfo_params), headers)\n    response = conn.getresponse()\n    # print response.status, response.reason\n    data = response.read()\n    # print data\n    conn.close()\n    if response.status == 200:\n        recinfo = json.loads(data)\n        if recinfo['status']['code'] == '1':\n            return recinfo['record']['value']\n    return None\n \n \ndef getlineip():\n    \"\"\"\n    读取当前ip\n    \"\"\"\n    conn = httplib.HTTPConnection(\"ns1.dnspod.net\", 6666, timeout=30)\n    conn.request(\"GET\", \"/\")\n    response = conn.getresponse()\n    ipaddr = None\n    if response.status == 200:\n        httpresp = response.read()\n        if is_valid_ip(httpresp):\n            ipaddr = httpresp\n    conn.close()\n    return ipaddr\n \n \ndef is_valid_ip(ip):\n    \"\"\"Returns true if the given string is a well-formed IP address.\n \n    Supports IPv4 and IPv6.\n    \"\"\"\n    if not ip or '\\x00' in ip:\n        # getaddrinfo resolves empty strings to localhost, and truncates\n        # on zero bytes.\n        return False\n    try:\n        res = socket.getaddrinfo(ip, 0, socket.AF_UNSPEC,\n                                 socket.SOCK_STREAM,\n                                 0, socket.AI_NUMERICHOST)\n        return bool(res)\n    except socket.gaierror as e:\n        if e.args[0] == socket.EAI_NONAME:\n            return False\n        raise\n    return True\n \n \nif __name__ == '__main__':\n    logging.basicConfig(format='%(levelname)-10s %(asctime)s   %(message)s', level=logging.DEBUG)\n    try:\n        lineip = getlineip()\n        current_ip1 = getrecordip(recordinfo_params1)\n        logging.info((lineip, current_ip1))\n        if lineip is not None and current_ip1 != lineip:\n            ddns(ddns_params1)\n\n        current_ip2 = getrecordip(recordinfo_params2)\n        logging.info((lineip, current_ip2))\n        if lineip is not None and current_ip2 != lineip:\n            ddns(ddns_params2)\n    except Exception as e:\n        logging.exception(e)\n```\n\n这个脚本会更新主域名记录和www子域名记录，如果要更新更多的记录，请自行添加。加入到cron计划里，5分钟运行一次，当记录有变化时则更新，如果没变化则跳过，这个很重要，因为DNSPOD的API规定，如果频繁的更新没有变化的记录，则会封API一个小时。"
		},
		{
			"post_id": 3,
			"title": "让Seafile使用Memcache",
			"date_published": 1465963848.72,
			"body": "Memcache是一个缓存软件，能显著的提高性能，并降低数据库的负担，云存储要管理大量的文件、版本，对服务器性能有一定的要求，特别是在大并发的情况下。\n首先你要安装memcache和相应的库\n\n* memcache or memcached\n* python-memcache or python-memcached\n\n首先检查你的memcache是否启动了\n\n\ttelnet 127.0.0.1 11211\n如果能连上，说明已启动。\n\n然后在`seahub_settings.py`中加入以下配置信息\n\n```bash\nCACHES = {\n    'default': {\n        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',\n        'LOCATION': '127.0.0.1:11211',\n    }\n}\n```\n然后重启Seahub\n\n\t./seahub.sh stop\n\t./seahub.sh start-fastcgi\n\t\n然后使用一段时间的Seafile，再登入memcache看看有没有数据写入或读出\n\n```bash\ntelnet 127.0.0.1 11211\nTrying 127.0.0.1...\nConnected to 127.0.0.1.\nEscape character is '^]'.\nstats\nSTAT pid 1660\nSTAT uptime 214929\nSTAT time 1451400086\nSTAT version 1.4.14 (Ubuntu)\nSTAT libevent 2.0.21-stable\nSTAT pointer_size 64\nSTAT rusage_user 4.904494\nSTAT rusage_system 4.368484\nSTAT curr_connections 5\nSTAT total_connections 1739\nSTAT connection_structures 8\nSTAT reserved_fds 20\nSTAT cmd_get 3304\nSTAT cmd_set 3245\nSTAT cmd_flush 0\nSTAT cmd_touch 0\nSTAT get_hits 1745\nSTAT get_misses 1559\nSTAT delete_misses 0\nSTAT delete_hits 0\nSTAT incr_misses 0\nSTAT incr_hits 0\nSTAT decr_misses 0\nSTAT decr_hits 0\nSTAT cas_misses 0\nSTAT cas_hits 0\nSTAT cas_badval 0\nSTAT touch_hits 0\nSTAT touch_misses 0\nSTAT auth_cmds 0\nSTAT auth_errors 0\nSTAT bytes_read 4301028\nSTAT bytes_written 4141263\nSTAT limit_maxbytes 67108864\nSTAT accepting_conns 1\nSTAT listen_disabled_num 0\nSTAT threads 4\nSTAT conn_yields 0\nSTAT hash_power_level 16\nSTAT hash_bytes 524288\nSTAT hash_is_expanding 0\nSTAT expired_unfetched 12\nSTAT evicted_unfetched 0\nSTAT bytes 4738\nSTAT curr_items 17\nSTAT total_items 3245\nSTAT evictions 0\nSTAT reclaimed 13\nEND\n```\n如果看到`cmd_get`和`cmd_set`后边的数字有变化，说明配置已生效。如果没有生产，请试一下删除`seahub_setting.pyc`配置缓存文件。"
		},
		{
			"post_id": 2,
			"title": "在家里搭建Seafile云存储平台",
			"date_published": 1465963543.876,
			"body": "用过Box，用过DropBox，也用过One Drive，还用过Google Driver，但众所周知的原因，用得很是不爽，而且在速度方面有先天的缺点。国产的百度，115等直接无视，数据安全得不到保障。所以就想到了私有云，自己弄一个云存储平台，以前用过OwnCloud，但是这货被我老婆差评，客户端里相片居然没有缩略图，不知道现在的版本解决这问题没有。\n\nSeafile是我近段时间发现另一个高大上的开源的云存储平台，比OwnCloud更强大，速度更快，功能虽然没有OwnCloud多，因为插件没那么多，但是OwnCloud的插件基本上是摆设，而且Seafile的分享功能、权限管理、版本控制、事件通知已经能满足大部分人的要求。还有一个重要的原因，Seafile内核是由C语言编写的，完暴OwnCloud的PHP。废话不多说，研究一下这货是怎么安装使用的。\n\n---\n## 安装\n我家里的服务器是使用LinuxMint，也就是类Ubuntu，或者说是类Debian，戳此[下载](http://download-cn.seafile.com/seafile-server_5.0.3_x86-64.tar.gz \"64位\")，如果你是32位的，戳此[下载](http://download-cn.seafile.com/seafile-server_5.0.3_i386.tar.gz \"32位\")。下载好之后，找个你认为方便的地方解压就可以了。\n在安装前，要确认你已有了必要的库\n\n* python 2.7\n* python-setuptools\n* python-imaging\n* python-mysqldb\n* python-ldap\n* python-memcache\n\n当然，你还必须有MySQL数据库，不然用SQLite也可以，不过性能差些\n在我的系统下，我是这样安装的\n\n\tsudo apt-get update\n\tsudo apt-get install python2.7 python-setuptools python-imaging python-ldap python-mysqldb python-memcache\n\t\n然后运行脚本`setup_seafile_mysql.sh`，按照提示输入就完成了，然后依次启动Seafile和Seahub\n\n\t./seafile.sh start\n\t./seahub.sh start\nPS：第一次启动Seahub时，会提示你创建一个Seafile管理员帐号。\n至此，你就拥有一个能在内网环境下使用的云存储平台了，在浏览器中输入\n\thttp://IP:8000\n就可以打开网页版的Seafile，当然，你还可以安装桌面版客户端，手机版客户端。\n\n## 配置外网访问Seafile\n只能在内网使用，肯定是不完美的，不过配置外网也很简单，如果你有固定IP，那就更简单，我这家庭宽带只能用动态DNS了。\n首先，你要有HTTP服务端，例如Apache或Nginx，因为我是使用Apache，所以下边的例子就只介绍这个。\n安装`python-flup`库\n\n\tsudo apt-get install python-flup\n启用`mod_fastcgi`和`mod_rewrite`\n\n\tsudo apt-get install libApache2-mod-fastcgi\n\tsudo a2enmod rewrite\n\tsudo a2enmod fastcgi\n启用 Apache Proxy\n\n\tsudo a2enmod proxy_http\n在这里，Apache相当于一个中转站，我们用FastCGI来部署Seahub，用反向代理部署FileServer\n首先编辑Apache配置文件`apache2.conf`，在文件末尾添加以下语句\n\n\tFastCGIExternalServer /var/www/seahub.fcgi -host 127.0.0.1:8000\n注意，seahub.fcgi只是一个位置标识符，你并不需要建立这个目录。\n然后建立一个虚拟服务器，创建文件`sites-available/seafile.conf`\n\n```bash\n<VirtualHost *:80>\n  ServerName www.myseafile.com\t//你的域名\n  DocumentRoot /var/www\n  Alias /media  /home/user/haiwen/seafile-server-latest/seahub/media\t\t//你的seafile安装目录\n\n  RewriteEngine On\n\n  <Location /media>\n    Require all granted\n  </Location>\n\n  #\n  # seafile fileserver\n  #\n  ProxyPass /seafhttp http://127.0.0.1:8082\n  ProxyPassReverse /seafhttp http://127.0.0.1:8082\n  RewriteRule ^/seafhttp - [QSA,L]\n\n  #\n  # seahub\n  #\n  RewriteRule ^/(media.*)$ /$1 [QSA,L,PT]\n  RewriteCond %{REQUEST_FILENAME} !-f\n  RewriteRule ^(.*)$ /seahub.fcgi$1 [QSA,L,E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\n</VirtualHost>\n```\n然后启用这个虚拟服务器\n\n\tsudo a2ensite seafile.conf\n\t或\n\tsudo ln -s /var/apache2/sites-available/seafile.conf /var/apache2/sites-enabled/seafile.conf\n然后在Seafile的管理员WEB界面设置SERVICE_URL和FILE_SERVER_ROOT\n\n\tSERVICE_URL: http://www.myseafile.com\n\tFILE_SERVER_ROOT: http://www.myseafile.com/seafhttp\n修改`ccnet.conf`\n\n\tSERVICE_URL = http://www.myseafile.com\n修改`seahub_settings.py`，增加一行\n\n\tFILE_SERVER_ROOT = 'http://www.myseafile.com/seafhttp'\n重启Seafile和Seahub\n\n\tsudo service apache2 restart\n\t./seafile.sh restart\n\t./seahub.sh stop\n\t./seahub.sh start-fastcgi\n现在，你就可以使用`www.myseafile.com`这个域名访问你的Seafile了，客户端也可以这样用了，当然，外网也可以访问了，不过，对于我等屌丝用记，80端口肯定是不能用的，不过好在443端口是打开的，我们还可以使用SSL来访问Seafile。\n\n## 配置SSL\n如果你有付费的SSL证书，你就可以跳过下一步了，屌丝自签证书的，就两行命令搞定，不过网页版会提示证书不信任，客户端还好，能忽略\n\n\topenssl genrsa -out privkey.pem 2048\n\topenssl req -new -x509 -key privkey.pem -out cacert.pem -days 1095\n然后启用Apache的SSL模块\n\n\tsudo a2enmod ssl\n接下来修改你刚刚的虚拟服务器配置文件，`seafile.conf`\n\n```bash\n<VirtualHost *:443>\t\t//修改端口号\n      ServerName www.myseafile.com\n      DocumentRoot /var/www\n      Alias /media  /home/user/haiwen/seafile-server-latest/seahub/media\n\n\t\t//添加下边三行\n      SSLEngine On\n      SSLCertificateFile /path/to/cacert.pem\n      SSLCertificateKeyFile /path/to/privkey.pem\n\n      RewriteEngine On\n\n      #\n      # seafile fileserver\n      #\n      ProxyPass /seafhttp http://127.0.0.1:8082\n      ProxyPassReverse /seafhttp http://127.0.0.1:8082\n      RewriteRule ^/seafhttp - [QSA,L]\n\n      #\n      # seahub\n      #\n      RewriteRule ^/(media.*)$ /$1 [QSA,L,PT]\n      RewriteCond %{REQUEST_FILENAME} !-f\n      RewriteRule ^(.*)$ /seahub.fcgi/$1 [QSA,L,E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\n    </VirtualHost>\n```\n记得还要修改SERVICE_URL和FILE_SERVER_ROOT这两个配置项，然后重启Apache，Seafile，Seahub，至此，你就可以使用`https://www.myseafile.com`这个域名来访问Seafile了。"
		},
		{
			"post_id": 1,
			"title": "Congratulations!",
			"date_published": 1433033779.604,
			"body": "Your zeronet blog has been successfully created!"
		}
	]
}