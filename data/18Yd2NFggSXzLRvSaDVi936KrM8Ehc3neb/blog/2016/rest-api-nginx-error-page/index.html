<!DOCTYPE HTML>
<html lang="ru">
    <head>
      <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>18Yd2NFggSXzLRvSaDVi936KrM8Ehc3neb</title>
      <link rel="stylesheet" href="/18Yd2NFggSXzLRvSaDVi936KrM8Ehc3neb/css/main.css"/>
      <link rel="shortcut icon" type="image/x-icon" href="/18Yd2NFggSXzLRvSaDVi936KrM8Ehc3neb/i/favicon.ico"/>
      <link href="/18Yd2NFggSXzLRvSaDVi936KrM8Ehc3neb/rss.xml" title="Akademic's blog" type="application/rss+xml" rel="alternate"/>
    </head>
    <body>
        <header><h1><a href="/18Yd2NFggSXzLRvSaDVi936KrM8Ehc3neb" rel="home">akademic.name</a></h1></header>
        <main class="content">
            
<article>
    <h1>Настройка nginx для разработки REST-API проекта на PHP</h1> <time>08.02.2016</time>
	<p>Начал проект по созданию REST API.
Предполагается что запросы к API будут совершаться следующим образом:
<code>
GET https://api.example.com/objects/1/action
PUT https://api.example.com/objects/1
POST https://api.example.com/objects
</code></p>

<p>Началось всё несложно: создал новый хост для nginx и настроил для всех url fastcgi_pass.</p>

<pre><code>server {
    listen          80;
    server_name     api.example.com;

    location / {
        index index.php;
        include /etc/nginx/fastcgi_params;
        fastcgi_pass  127.0.0.1:5000;
        fastcgi_index index.php;
        fastcgi_param  SCRIPT_FILENAME  /path/to/project/index.php;
    }
}
</code></pre>

<h2>Всё не так просто</h2>

<p>И всё бы хорошо, но скоро API попало в руки фронтэндера, но разработка API продолжается и 50% времени сервис не &ldquo;лежит&rdquo;.
В время не терпит.
Значит надо завести отдельный репозиторий/каталог, с которым работает фронтэндер, и в который выладывать новый функционал по мере готовности.
Можно, конечно, завести ещё один хост, но у нас 3 разработчика API и 2 фронтэндера.
Плюс политика &ldquo;клон проекта на фичу&rdquo; - замучаешься конфиги nginx править.</p>

<p>Для &ldquo;обычных&rdquo; проектов таких как сайты мы просто раскладываем репозитории по каталогам и доступаемся к ним из браузера примерно так:</p>

<pre><code>http://dev.example.com/path/to/project1/
http://dev.example.com/path/to/project1-feature1/
</code></pre>

<p>Понятно, что для API это не подойдёт, т.к. на файловой системе путей, которые используются в API не существует.
Пример вызова API в структуре &ldquo;обычных&rdquo; проектов:</p>

<pre><code>GET https://dev.example.com/path/to/restproject/objects/1/action
</code></pre>

<p>Сервер в таком случае возвращает 404.</p>

<h2>Решаем проблему</h2>

<p>Естественным желанием было поставить на обработку 404й ошибки скрипт, который бы вычислял правильные пути.
Что и было проделано:
```
server {
    listen          80;
    server_name     dev.example.com;
    error_page 404 = /404.php;</p>

<pre><code>location ~ \.php$ {
    index index.php;
    include /etc/nginx/fastcgi_params;
    fastcgi_pass  127.0.0.1:5000;
    fastcgi_index index.php;
    fastcgi_param SCRIPT_FILENAME /webroot/$fastcgi_script_name;
    fastcgi_param DOCUMENT_ROOT /webroot;
}
</code></pre>

<p>}
```</p>

<p>GET запросы к API в произвольном каталоге на сервере заработали, а вот POST - нет.
Оказалось, что nginx при срабатывании директивы error_page всегда меняет REQUEST_METHOD на GET.</p>

<p>Так нам не подходит. Методом гугления находим, что можно решить эту проблему с помощью именованого location.</p>

<p>Получился такой вариант:
```
server {
    listen          80;
    server_name     dev.example.com;
    error_page 404 = @notfound;</p>

<pre><code>location ~ \.php$ {
    index index.php;
    include /etc/nginx/fastcgi_params;
    fastcgi_pass  127.0.0.1:5000;
    fastcgi_index index.php;
    fastcgi_param SCRIPT_FILENAME /webroot/$fastcgi_script_name;
    fastcgi_param DOCUMENT_ROOT /webroot;
}

location @notfound {
    include /etc/nginx/fastcgi_params;
    fastcgi_pass  127.0.0.1:5000;
    fastcgi_index index.php;
    fastcgi_param SCRIPT_FILENAME /webroot/errors/404.php;
    fastcgi_param DOCUMENT_ROOT /webroot;
}
</code></pre>

<p>}
```</p>

<p>Счастье наступает до тех пор, пока не появятся PUT и DELETE заросы к API.
Nginx на них возвращает 405 ошибку. Но, чёрт возьми, всё работало с первым конфигом в этой статье!
В гугле выясняем, что для поддержки PUT и DELETE надо добавить директиву <code>dav_methods PUT DELETE;</code>:</p>

<pre><code>server {
    listen          80;
    server_name     dev.example.com;
    error_page 404 = @notfound;
    dav_methods PUT DELETE;
    --- rest of config ---
}
</code></pre>

<p>Теперь вместо 405й ошибки начинаем получать 404ю. Оказалось, что, если nginx не находит файла по пути PUT запроса, то вызывается 500-я ошибка.
А если не находится файл для 500-й ошибки (у нас в конфиге прописан <code>error_page 500 50x.html;</code>, то обработчик 404й потом не вызывается.</p>

<h2>В конце всё хорошо</h2>

<p>Итоговый рабочий конфиг получился такой:
```
server {
    listen          80;
    server_name     dev.example.com;
    error_page 404 500 = @notfound;
    dav_methods PUT DELETE;</p>

<pre><code>location ~ \.php$ {
    index index.php;
    include /etc/nginx/fastcgi_params;
    fastcgi_pass  127.0.0.1:5000;
    fastcgi_index index.php;
    fastcgi_param SCRIPT_FILENAME /webroot/$fastcgi_script_name;
    fastcgi_param DOCUMENT_ROOT /webroot;
}

location @notfound {
    include /etc/nginx/fastcgi_params;
    fastcgi_pass  127.0.0.1:5000;
    fastcgi_index index.php;
    fastcgi_param SCRIPT_FILENAME /webroot/errors/404.php;
    fastcgi_param DOCUMENT_ROOT /webroot;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Бэкендеры могут бэкэндить, фронтэндеры - фронтендить, фичи бранчиться, релизы деплоиться.</p>

    
    <span class="next_blog_post">
    <a href="/18Yd2NFggSXzLRvSaDVi936KrM8Ehc3neb/blog/2016/zeronet-static-blog/index.html" rel="next">Во имя копимизма запустил сей блог в zeronet&#39;е</a>
    </span>
	
	
    <span class="prev_blog_post">
    <a href="/18Yd2NFggSXzLRvSaDVi936KrM8Ehc3neb/blog/2015/dell-inspirion-mini-1010/index.html" rel="previous">Что можно сделать со старым нетбуком</a>
    </span>
	
</article>

        </main>
        <footer>
        Будьте внимательны, многое из того, что написано в этом блоге, является личным мнением автора и не претендует на истину.
        <img src="/18Yd2NFggSXzLRvSaDVi936KrM8Ehc3neb/i/yopiright.jpg" width="12" height="12"/> 2008
        </footer>
    </body>
</html>
