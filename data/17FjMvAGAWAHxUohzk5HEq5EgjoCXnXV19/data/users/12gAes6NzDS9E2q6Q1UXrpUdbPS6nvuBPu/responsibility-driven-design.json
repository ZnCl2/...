{
    "article": [
        {
            "title": "Responsibility-driven design",
            "text": "{{primary sources|date=December 2012}}\n'''Responsibility-driven design''' is a design technique in [[object-oriented programming]], which improves encapsulation by using the [[client–server model]]. It focuses on the [[contract]] by considering the actions that the [[Object (computer science)|object]] is responsible for and the information that the object shares. It was proposed by [[Rebecca Wirfs-Brock]] and Brian Wilkerson\n\nResponsibility-driven design is in direct contrast with data-driven design, which promotes defining the behavior of a class along with the data that it holds. Data-driven design is not the same as [[data-driven programming]], which is concerned with using data to determine the [[control flow]], not class design.\n\nIn the [[client–server model]] they refer to, both the client and the server are [[Class (computer programming)|classes]] or [[Instance (computer science)|instances]] of classes. At any particular time, either the client or the server represents an object. Both the parties commit to a [[contract]] and exchange information by adhering to it. The client can only make the requests specified in the contract and the server must answer these requests.<ref name=\"Wirfs-Brock1989\">{{cite journal|last1=Wirfs-Brock|first1=Rebecca|last2=Wilkerson|first2=Brian|title=Object-Oriented Design: A Responsibility-Driven Approach|journal=ACM SIGPLAN Notices|date=1989|volume=24|issue=10|page=74|doi=10.1145/74878.74885|url=http://doi.acm.org/10.1145/74878.74885|accessdate=9 February 2016}}</ref> Thus, responsibility-driven design tries to avoid dealing with details, such as the way in which requests are carried out, by instead only specifying the intent of a certain request. The benefit is increased [[Encapsulation (computer programming)|encapsulation]], since the specification of the exact way in which a request is carried out is private to the server.\n\nTo further the encapsulation of the server, Wirfs-Brock and Wilkerson call for language features that limit outside influence to the behavior of a class. They demand that the visibility of members and functions should be finely grained, such as in [[Eiffel (programming language)|Eiffel]] programming language. Even finer control of the visibility of even classes is available in the [[Newspeak (programming language)|Newspeak]] programming language.\n\n==Overview==\nResponsibility-driven design focuses on the objects as [https://www.cs.cmu.edu/~rbd/doc/nyquist/part4.html behavioral abstractions] which are characterized by their responsibilities.  The [[Class-responsibility-collaboration card|CRC-card]] modelling technique is used to generate these behavioral abstractions. The rest of the object structure including data attributes are assigned later, as and when required.<ref name=\"AnthonySimons\">{{cite web | title=Design Patterns as Litmus Paper to Test the Strength of Object-Oriented Methods | year=1998 | url=http://citeweb.info/19980495062 | doi=10.1007/978-1-4471-0895-5_10 | author1=Anthony J. H. Simons | author2=Monique Snoeck | author3=Kitty Hung}}</ref> This makes the design follow type hierarchy for inheritance which improves encapsulation and makes it easier to identify abstract classes. It can also group the classes together based on their clients which is considered a unique ability.\n\nA good object-oriented design involves an early focus on behaviors to realize the capabilities meeting the stated requirements and a late binding of implementation details to the requirements. This approach especially helps to decentralize control and distribute system behavior which can help manage the complexities of high-functionality large or [http://www.computerhope.com/jargon/d/distribs.htm distributed systems]. Similarly, it can help to design and maintain explanation facilities for cognitive models, intelligent agents, and other knowledge-based systems.<ref name=\"Cognitive Models\">{{cite web | title=Responsibility-Driven Explanation Engineering for Cognitive Models | year=2004 | url=http://citeweb.info/20040821547 | author1=Steven R. Haynes | author2=Isaac G. Councill | author3=Frank E. Ritter}}</ref>\n\n==Building blocks==\nIn their book ''Object Design: Roles, Responsibilities and Collaborations'',<ref name=\"ObjectDesign-entirebook\">{{cite book|author1=Wirfs-Brock, Rebecca|author2=McKean, Alan|title=Object Design: Roles, Responsibilities, and Collaborations|date=2003|publisher=Addison-Wesley|location=Indianapolis, IN|isbn=0201379430|ref=odrrc}}</ref> the authors describe the following building blocks that make up responsibility-driven design.\n\n* Application: A software application is referred to as a set of interacting objects.<ref name=\"ObjectDesign-page3\"/>\n* Candidates: Candidates or candidate objects are key concepts in the form of objects described on CRC cards. They serve as initial inventions in the process of object design.<ref name=\"ObjectDesign-page58\">{{harvnb |Wirfs-Brock|McKean|2002| pp=58 }}</ref>\n* Collaborations: A collaboration is defined as an interaction of objects or roles (or both).<ref name=\"ObjectDesign-page3\"/>\n* CRC Cards: CRC stands for Candidates, Responsibilities, Collaborators. They are index cards used in early design for recording candidates.<ref name=\"ObjectDesign-page61\">{{harvnb |Wirfs-Brock|McKean|2002| pp=61 }}</ref> These cards are split up into an unlined and a lined side.\n** Content of lined side: On this side the candidate's name, its responsibilities and its collaborators are recorded.<ref name=\"ObjectDesign-page61\"/>\n** Content of unlined side: On this side the candidate's name, its purpose in the application, stereotype roles and anything worthwhile such as the names of roles in patterns it participates in are recorded.<ref name=\"ObjectDesign-page61\"/>\n* Hot Spots: Hot Spots are points in the application where variations occur. They are recorded using Hot Spot Cards.<ref name=\"ObjectDesign-page72\">{{harvnb |Wirfs-Brock|McKean|2002| pp=72 }}</ref>\n* Hot Spot Cards: Hot Spot Cards are used for recording variations with just enough detail so you can discriminate important difference. Similar to CRC cards, these are also created from [[index card]]s.<ref name=\"ObjectDesign-page72\"/> These cards consist of:\n** Hot Spot Name\n** General description of the variation\n** At least two specific examples where the variation occurs\n\n=== Objects===\nObjects are described as things that have machine-like behaviors that can be plugged together to work in concert. These objects play well-defined roles and encapsulate scripted responses and information.<ref name=\"ObjectDesign-page3\"/>\n\n* Object Neighborhoods: Another term for subsystem.<ref name=\"ObjectDesign-page17\">{{harvnb |Wirfs-Brock|McKean|2002| pp=17 }}</ref> It is a logical grouping of collaborators.<ref name=\"ObjectDesign-page17\"/>\n* Responsibilities: A responsibility is an obligation to perform a task or know information.<ref name=\"ObjectDesign-page3\">{{harvnb |Wirfs-Brock|McKean|2002| pp=3 }}</ref> These are further categorized according to their usage scenario.\n** Public Responsibilities: Public responsibilities are the responsibilities an object offers as services to others and the information it provides to others.<ref name=\"ObjectDesign-page126\">{{harvnb |Wirfs-Brock|McKean|2002| pp=126 }}</ref>\n** Private Responsibilities: Private responsibilities are the actions an object takes in support of public responsibilities.<ref name=\"ObjectDesign-page126\"/>\n** Subresponsibilities: Sometimes, a large or complicated responsibility is split up into smaller ones called subresponsibilities.<ref name=\"ObjectDesign-page168\">{{harvnb |Wirfs-Brock|McKean|2002| pp=168 }}</ref> They are further categorized based on what they do.\n*** Subordinate Responsibilities: These include the major steps in each subresponsibility.<ref name=\"ObjectDesign-page168\"/>\n*** Sequencing Responsibilities: These refer to the sequencing of the execution of subordinate responsibilities.<ref name=\"ObjectDesign-page168\"/>\n\n===Roles===\nObject role refers to an exterior view of what general service is offered by the object. It is a set of related responsibilities.<ref name=\"ObjectDesign-page3\"/> It can be implemented as a class or an interface. Interface, however, is the preferred implementation as it increases flexibility by hiding the concrete class which ultimately does the work.<ref name=\"ObjectDesign-page340\">{{harvnb |Wirfs-Brock|McKean|2002| pp=340 }}</ref>\n\nRole Stereotypes: Role stereotypes are simplified roles that come with predefined responsibilities.<ref name=\"ObjectDesign-page4\">{{harvnb |Wirfs-Brock|McKean|2002| pp=4 }}</ref> There are several categories.\n* Controller: Object implementing this role makes decisions and closely directs the action of other objects.<ref name=\"ObjectDesign-page4\"/>\n* Coordinator: This role reacts to events by delegating tasks to others.<ref name=\"ObjectDesign-page4\"/>\n* Information Holder: Information holder knows and provides information.<ref name=\"ObjectDesign-page4\"/>\n** Information Provider: A slight variation of an information holder is the information provider, which takes a more active role in managing and maintaining information. This distinction can be used if a designer needs to get more specific.<ref name=\"ObjectDesign-page93\">{{harvnb |Wirfs-Brock|McKean|2002| pp=93 }}</ref>\n* Interfacer: This role transforms information and requests between distinct parts of an application.<ref name=\"ObjectDesign-page4\"/> It is further divided into more specific roles.\n** External Interfacer: External interfacer communicates with other applications rather than its own.<ref name=\"ObjectDesign-page93\"/> It is mainly used for encapsulating non-object-oriented APIs and does not collaborate a lot.<ref name=\"ObjectDesign-page165\"/>\n** Internal Interfacer: Also called intersystem interfacer.<ref name=\"ObjectDesign-page93\"/> It act as a bridge between object neighborhoods.<ref name=\"ObjectDesign-page165\"/>\n** User Interfacer: User interfacer communicates with users by responding to events generated in the UI and then passing them on to more appropriate objects.<ref name=\"ObjectDesign-page93\"/><ref name=\"ObjectDesign-page165\">{{harvnb |Wirfs-Brock|McKean|2002| pp=165 }}</ref><ref name=\"ObjectDesign-page164\">{{harvnb |Wirfs-Brock|McKean|2002| pp=164 }}</ref>\n* Service Provider: This role performs work and offers computing services.<ref name=\"ObjectDesign-page93\"/>\n* Structurer: This role maintains relationships between objects and information about those relationships.<ref name=\"ObjectDesign-page93\"/>\n\n==Control style==\nAn important part in the responsibility-driven design process is the distribution of control responsibilities that results in developing a control style. A control style is concerned about the control flow between [https://en.wiktionary.org/wiki/sub-system subsystems].\n\n* Concept of Control : The responsibilities and collaborations among the classes.<ref name=\"Evaluating the effect of a delegated versus centralized control style on the maintainability of object-oriented software\">{{cite journal|first1=Arisholm|last1 = Eric|first2 = Sjoberg|last2 =Dag I.K.|title=\"Evaluating the effect of a delegated versus centralized control style on the maintainability of object-oriented software\"|date=2004|volume=30|issue=8|url=http://ieeexplore.ieee.org/document/1316869/citations}}</ref>\n* Control Centers : An important aspect of developing a control style is the invention of so-called control centers. These are places where objects charged with controlling and coordinating reside.<ref name=\"ObjectDesign-page196\">{{harvnb |Wirfs-Brock|McKean|2002| pp=196 }}</ref>\n* Control Style Variations : A control style comes in three distinct variations. These are not precise definitions though since a control style can be said to be more centralized or delegated than another.\n\n=== Centralized control style ===\nThis control style inflicts a procedural paradigm on the structure of the application and places major-decision making responsibilities in only a few objects or a single object.\n\n;Types\n* Call-return model : The control of the objects in the application is in hierarchical way. Control starts at root and moves downwards. It is used in a sequential model.\n* Manager model : The control of the objects in the application is in with only one object. Generally, it is implemented in concurrent models. It can also be implemented in sequential model using [[Switch statement|case statement]].\n\n;Advantages\n* Application logic is in one place.\n\n;Disadvantages\n* Control logic can get overly complex\n* Controllers can become dependent on information holders' contents\n* Objects can become coupled indirectly through the actions of their controller\n* The only interesting work is done in the controller\n\n;When to use\nWhen decisions to be made are few, simple, and related to a single task.\n\n===Delegated control style===\nA delegated control style lies in between a centralized and dispersed control style. It passes some of the decision making and much of the action to objects surrounding a control center. Each neighboring object has a significant role to play. It can also be called as event driven model, where the control is delegated to the object requesting it to process the event.\n\n;Types[reference]\n* Broadcast model : An event is broadcast to all objects in the application. The object which can handle the event can acquire the control.\n* Interrupt-driven model : There will be the [[interrupt]] handler to process the interrupt and passes to some object to process it.\n\n;Advantages\n* It is easy to understand.\n* Though there is an external coordinator, Objects can be made smarter to know what they are supposed to do and can be reused in other applications.\n* Delegating coordinators tend to know about fewer objects than dominating controllers.\n* Dialogs are higher-level.\n* It is easy to change as changes typically affect fewer objects.\n* It is easier to divide design work among team members.\n\n;Disadvantages\n* Too much distribution of responsibility can lead to weak objects and weak collaborations\n\n;When to use\nWhen one wants to delegate work to objects that are more specialized.\n\n===Clustered control style===\nThis control style is a variation of the centralized control style wherein control is factored among a group of objects whose actions are coordinated.<ref name=\"ObjectDesign-page197\">{{harvnb |Wirfs-Brock|McKean|2002| pp=197 }}</ref> The main difference between a clustered and delegated control style is that in a clustered control style, the decision making objects are located within a control center whereas in a delegated control style they are mostly outside.<ref name=\"ObjectDesign-page213\">{{harvnb |Wirfs-Brock|McKean|2002| pp=213 }}</ref>\n\n===Dispersed control style===\nA dispersed control style does not contain any control centers. The logic is spread across the entire population of objects, keeping each object small and building in as few dependencies among them as possible.<ref name=\"ObjectDesign-page30\">{{harvnb |Wirfs-Brock|McKean|2002| pp=30 }}</ref>\n\n;Advantages\n* None\n\n;Disadvantages\n* When you want to find out how something works, you must trace the sequence of requests for services across many objects\n* Not very reusable because no single object contributes much\n\n;When to use\nNever.\n\n===Preferred control style===\nAfter extensive results of experiments conducted, only the senior management has the necessary skills to make use of delegated control style and centralized control style benefits programmers. There is no context mentioned about the mid-level employees.<ref name=\"Evaluating the effect of a delegated versus centralized control style on the maintainability of object-oriented software\"/>\n\n==References==\n{{Reflist}}\n\n==Bibliography==\n* [https://dx.doi.org/10.1145/74877.74885 Object-oriented design: a responsibility-driven approach]. In Conference Proceedings on Object-Oriented Programming Systems, Languages and Applications (New Orleans, Louisiana, United States, October 2–06, 1989). OOPSLA '89. ACM Press, New York, NY, 71-75.\n* {{cite book |author1=Wirfs-Brock, Rebecca |author2=McKean, Alan |title= Object Design: Roles, Responsibilities, and Collaborations |publisher= [[Addison Wesley]] |date=November 2002 |isbn= 0-201-37943-0 |ref=CITEREFWirfs-BrockMcKean2002 }}\n\n[[Category:Object-oriented programming]]\n[[Category:Software design]]",
            "slug": "responsibility-driven-design",
            "date_updated": 1537258685061,
            "imported": "https://en.wikipedia.org/wiki/Responsibility-driven_design"
        }
    ]
}