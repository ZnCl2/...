{
    "article": [
        {
            "title": "Virtual file system",
            "text": "{{More footnotes|date=October 2009}}\n{{OS}}\n\nA '''Virtual File System''' ('''VFS''') or '''virtual filesystem switch''' is an abstraction layer on top of a more concrete [[file system]]. The purpose of a VFS is to allow client applications to access different types of concrete file systems in a uniform way. A VFS can, for example, be used to access [[Direct-attached storage|local]] and network storage devices transparently without the client application noticing the difference. It can be used to bridge the differences in [[Microsoft Windows|Windows]], [[classic Mac OS]]/[[macOS]] and [[Unix]] filesystems, so that applications can access files on local file systems of those types without having to know what type of file system they are accessing.\n\nA VFS specifies an [[interface (computer science)|interface]] (or a \"contract\") between the [[kernel (computer science)|kernel]] and a concrete file system. Therefore, it is easy to add support for new file system types to the kernel simply by fulfilling the contract.  The terms of the contract might change incompatibly from release to release, which would require that concrete file system support be recompiled, and possibly modified before recompilation, to allow it to work with a new release of the operating system; or the supplier of the operating system might make only backward-compatible changes to the contract, so that concrete file system support built for a given release of the operating system would work with future versions of the operating system.\n\n==Implementations==\n[[File:IO stack of the Linux kernel.svg|thumb|right|upright=2.0|The position of the VFS layer within various parts of the [[Linux kernel]]'s storage stack.<ref>{{Cite web\n | url = https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram\n | title = Linux Storage Stack Diagram\n | date = 2015-06-01 | accessdate = 2015-06-08\n | author1 = Werner Fischer | author2 = Georg Schönberger\n | publisher = Thomas-Krenn.AG\n}}</ref>]]\n\nOne of the first virtual file system mechanisms on [[Unix-like]] systems was introduced by [[Sun Microsystems]] in [[SunOS]] 2.0 in 1985.<ref>{{cite journal|last1=Kleiman|first1=Steve R.|title=Vnodes: An Architecture for Multiple File System Types in Sun UNIX|journal=USENIX Summer|date=June 1986|volume=86|pages=238–247|url=https://web.archive.org/web/20140629172905/http://www.arl.wustl.edu/~fredk/Courses/cs523/fall01/Papers/kleiman86vnodes.pdf|accessdate=31 December 2016|ref=2}}</ref> It allowed Unix system calls to access local [[Unix File System|UFS]] file systems and remote [[Network File System (protocol)|NFS]] file systems transparently.  For this reason, Unix vendors who licensed the NFS code from Sun often copied the design of Sun's VFS.  Other file systems could be plugged into it also: there was an implementation of the [[MS-DOS]] [[File Allocation Table|FAT]] file system developed at Sun that plugged into the SunOS VFS, although it wasn't shipped as a product until SunOS 4.1.  The SunOS implementation was the basis of the VFS mechanism in [[System V Release 4]].\n\n[[John Heidemann]] developed a ''stacking'' VFS under SunOS 4.0 for the experimental [[Ficus (file system)|Ficus file system]].  This design provided for [[code reuse]] among file system types with differing but similar semantics (''e.g.'', an encrypting file system could reuse all of the naming and storage-management code of a non-encrypting file system).  Heidemann adapted this work for use in [[4.4BSD]] as a part of his [[thesis]] research; descendants of this code underpin the file system implementations in modern BSD derivatives including [[macOS]].\n\nOther Unix virtual file systems include the File System Switch in [[System V Release 3]], the Generic File System in [[Ultrix]], and the VFS in [[Linux]].  In [[OS/2]] and [[Microsoft Windows]], the virtual file system mechanism is called the [[Installable File System]].\n\nThe [[Filesystem in Userspace]] (FUSE) mechanism allows [[userland (computing)|userland]] code to plug into the virtual file system mechanism in Linux, [[NetBSD]], [[FreeBSD]], [[OpenSolaris]], and macOS.\n\nIn Microsoft Windows, virtual filesystems can also be implemented through userland [[Shell extension|Shell namespace extensions]]; however, they do not support the lowest-level file system access [[application programming interface]]s in Windows, so not all applications will be able to access file systems that are implemented as namespace extensions.  [[KIO]] and [[GVfs]]/[[GIO (software)|GIO]] provide similar mechanisms in the [[KDE]] and [[GNOME]] desktop environments (respectively), with similar limitations, although they can be made to use FUSE techniques and therefore integrate smoothly into the system.\n\n==Single-file virtual file systems==\nSometimes Virtual File System refers to a file or a group of files (not necessarily inside a concrete file system) that acts as a manageable container which should provide the functionality of a concrete file system through the usage of software. Examples of such containers are SolFS or a [[Disk image#Virtualization|single-file virtual file system]] in an emulator like [[PCTask]] or so-called [[WinUAE]], Oracle's [[VirtualBox]], Microsoft's [[Virtual PC]], [[VMware]].\n\nThe primary benefit for this type of file system is that it is centralized and easy to remove. A single-file virtual file system may include all the basic features expected of any file system (virtual or otherwise), but access to the internal structure of these file systems is often limited to programs specifically written to make use of the single-file virtual file system (instead of implementation through a driver allowing universal access). Another major drawback is that performance is relatively low when compared to other virtual file systems. Low performance is mostly due to the cost of shuffling virtual files when data is written or deleted from the virtual file system.\n\n===Implementation of single-file virtual filesystems===\nDirect examples of single-file virtual file systems include emulators, such as PCTask and WinUAE, which encapsulate not only the filesystem data but also emulated disk layout. This makes it easy to treat an OS installation like any other piece of software—transferring it with removable media or over the network.\n\n====PCTask====\nThe Amiga emulator [[PCTask]] emulated an [[Intel]] PC [[Intel 8088|8088]] based machine clocked at 4.77[[MHz]] (and later an [[80486]]SX clocked at 25&nbsp;MHz). Users of PCTask could create a file of large size on the Amiga filesystem, and this file would be virtually accessed from the emulator as if it were a real PC Hard Disk. The file could be formatted with the FAT16 filesystem to store normal MS-DOS or Windows files.{{Ref label|PC Drives|1}}{{Ref label|PCTask|2}}\n\n====WinUAE====\nThe [[UAE (emulator)|UAE]] for [[Microsoft Windows|Windows]], [[WinUAE]], allows for large single files on Windows to be treated as Amiga file systems. In WinUAE this file is called a ''hardfile''.{{Ref label|WinUAE Hardfile|3}}\n\nUAE could also treat a directory on the host filesystem ([[Microsoft Windows|Windows]], [[Linux]], [[macOS]], [[AmigaOS]]) as an Amiga filesystem.{{Ref label|WinUAE Add Directory|4}}\n\n==See also==\n* [[9P (protocol)]]{{snd}} a distributed file system protocol that maps directly to the VFS layer of Plan&nbsp;9, making all file system access network-transparent\n* [[Synthetic file system]]{{snd}} a hierarchical interface to non-file objects that appear as if they were regular files in the tree of a disk-based file system\n\n==Notes==\n#{{note|PC Drives}}[http://www.simon.mooli.org.uk/AF/8.html Emulation on Amiga] Comparison between PCX and PCTask, Amiga PC emulators.\n#{{note|PCTask}}See also [http://www.unitechelectronics.com/emul.htm This article] explaining how it works PCTask.\n#{{note|WinUAE Hardfile}}[http://winuaehelp.back2roots.org/gui/hard-drives.htm Help About WinUAE] (See Hardfile section).\n#{{note|WinUAE Add Directory}}[http://winuaehelp.back2roots.org/gui/hard-drives.htm Help About WinUAE] (See Add Directory section)\n\n==References==\n{{Reflist}}\n*[http://www.science.unitn.it/~fiorella/guidelinux/tlk/node102.html#SECTION001120000000000000000 Linux kernel's Virtual File System]\n*{{Cite conference\n | first = R.\n | last = Rodriguez |author2=M. Koehler |author3=R. Hyde\n |date=June 1986\n | title = The Generic File System\n | booktitle = Proceedings of the USENIX Summer Technical Conference\n | publisher = [[USENIX|USENIX Association]]\n | location = Atlanta, Georgia\n | pages = 260–269\n }}\n*{{Cite conference\n | first = M.\n | last = Karels\n | authorlink = Mike Karels\n |author2=M. K. McKusick |authorlink2=Kirk McKusick \n |date=September 1986\n | title = Towards a Compatible File System Interface\n | booktitle = Proceedings of the European UNIX Users Group Meeting\n | publisher = [[EurOpen|EUUG]]\n | location = Manchester, England\n | pages = 481–496\n }}\n*{{Cite techreport\n| first=John\n| last=Heidemann\n| title=Stackable Design of File Systems\n| number=CSD-950032\n| institution=[[University of California, Los Angeles|UCLA]]\n| year=1995\n| url=http://www.isi.edu/~johnh/PAPERS/Heidemann95e.html\n}}\n*''The Linux VFS'', Chapter 4 of ''Linux File Systems'' by [[Moshe Bar (investor)|Moshe Bar]] ([[McGraw-Hill]], 2001). {{ISBN|0-07-212955-7}}\n*Chapter 12 of ''Understanding the Linux Kernel'' by Daniel P. Bovet, Marco Cesati ([[O'Reilly Media]], 2005). {{ISBN|0-596-00565-2}}\n*[http://www.atalon.cz/vfs-m/linux-vfs-model/ The Linux VFS Model: Naming structure]\n\n==External links==\n* [http://www.ibm.com/developerworks/library/l-virtual-filesystem-switch/ Anatomy of the Linux virtual file system switch]\n\n\n{{Storage virtualization}}\n{{File systems}}\n{{Operating system}}\n\n{{DEFAULTSORT:Virtual File System}}\n[[Category:Computer file systems]]\n[[Category:Virtualization software]]",
            "slug": "virtual-file-system",
            "date_updated": 1537260484342,
            "imported": "https://en.wikipedia.org/wiki/Virtual_file_system"
        }
    ]
}