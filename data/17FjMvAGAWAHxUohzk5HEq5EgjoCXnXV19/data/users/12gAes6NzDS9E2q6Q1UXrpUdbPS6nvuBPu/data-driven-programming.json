{
    "article": [
        {
            "title": "Data-driven programming",
            "text": "{{Programming paradigms}}\n\nIn [[computer programming]], '''data-driven programming''' is a [[programming paradigm]] in which the program statements describe the data to be matched and the processing required rather than defining a sequence of steps to be taken.<ref name=\"awk\">{{Cite web |url=http://www.ibm.com/developerworks/aix/tutorials/au-gawk/section2.html |title=Get started with GAWK: AWK language fundamentals |last=Stutz |first=Michael |date=September 19, 2006 |website=developerWorks |publisher=[[IBM]] |archive-url=https://web.archive.org/web/20110520232835/http://www.ibm.com/developerworks/aix/tutorials/au-gawk/section2.html |archive-date=20 May 2011 |access-date=2010-10-23 |quote=[AWK is] often called a data-driven language -- the program statements describe the input data to match and process rather than a sequence of program steps}}</ref> Standard examples of data-driven languages are the text-processing languages [[sed]] and [[AWK]],<ref name=\"awk\" /> where the data is a sequence of lines in an [[input stream]] – these are thus also known as line-oriented languages – and pattern matching is primarily done via [[regular expression]]s or line numbers.\n\n==Related paradigms==\nData-driven programming is similar to [[event-driven programming]], in that both are structured as pattern matching and resulting processing, and are usually implemented by a [[main loop]], though they are typically applied to different domains. The condition/action model is also similar to [[aspect-oriented programming]], where when a [[join point]] (condition) is reached, a [[pointcut]] (action) is executed. A similar paradigm is used in some [[tracing (software)|tracing]] frameworks such as [[DTrace]], where one lists probes (instrumentation points) and associated actions, which execute when the condition is satisfied.\n\nAdapting [[abstract data type]] design methods to [[object-oriented programming]] results in a data-driven design.<ref name=\"responsibility\">{{Cite journal |last=Wirfs-Brock |first=Rebecca |author-link=Rebecca Wirfs-Brock |last2=Wilkerson |first2=Brian |year=1989 |title=Object-oriented design: a responsibility-driven approach |journal=Conference Proceedings on Object-Oriented Programming Systems, Languages and Applications |location=New York |publisher=[[Association for Computing Machinery|ACM]] |pages=71–75 |doi=10.1145/74877.74885}}</ref> This type of design is sometimes used in object-oriented programming to define classes during the conception of a piece of software.\n\n== Applications ==\nData-driven programming is typically applied to streams of structured data, for filtering, transforming, aggregating (such as computing statistics), or calling other programs. Typical streams include [[Computer data logging|log files]], [[delimiter-separated values]], or email messages, notably for [[email filtering]]. For example, an AWK program may take as input a stream of log statements, and for example send all to the console, write ones starting with WARNING to a \"WARNING\" file, and send an email to a [[sysadmin]] in case any line starts with \"ERROR\". It could also record how many warnings are logged per day. Alternatively, one can process streams of delimiter-separated values, processing each line or aggregated lines, such as the sum or max. In email, a language like [[procmail]] can specify conditions to match on some emails, and what actions to take (deliver, bounce, discard, forward, etc.).\n\nSome data-driven languages are [[Turing-complete]], such as AWK and even sed, while others are intentionally very limited, notably for filtering. An extreme example of the latter is [[pcap]], which only consists of filtering, with the only action being “capture”. Less extremely, [[sieve (mail filtering language)|sieve]] has filters and actions, but in the base standard has no variables or loops, only allowing stateless filtering statements: each input element is processed independently. Variables allow state, which allow operations that depend on more than one input element, such as aggregation (summing inputs) or [[Throttling process (computing)|throttling]] (allow at most 5 mails per hour from each sender, or limiting repeated log messages).\n\nData-driven languages frequently have a default action: if no condition matches, line-oriented languages may print the line (as in sed), or deliver a message (as in sieve). In some applications, such as filtering, matching is may be done ''exclusively'' (so only ''first'' matching statement), while in other cases ''all'' matching statements are applied. In either case, failure to match ''any'' pattern may be \"default behavior\" or can be seen as an error, to be caught by a catch-all statement at the end.\n\n== Benefits and issues ==\n\nWhile the benefits and issues may vary between implementation, there are a few big potential benefits of and problems with this paradigm.  Functionality simply requires that it knows the [[abstract data type]] of the variables it is working with.  Functions and [[programming interface|interfaces]] can be used on all objects with the same data fields, for instance the object's \"position\". Data can be grouped into objects or \"entities\" according to preference with little to no consequence.\n\nWhile data-driven design does prevent coupling of data and functionality, in some cases, data-driven programming has been argued to lead to bad [[object-oriented design]], especially when dealing with more abstract data. This is because a purely data-driven object or entity is defined by the way it is [[data representation|represented]].  Any attempt to change the structure of the object would immediately break the functions that rely on it.\n\nAs an example, one might represent [[automotive navigation system|driving direction]]s as a series of intersections (two intersecting streets) where the driver must turn right or left.  If an intersection (in the United States) is represented in data by the [[zip code]] (5-digit number) and two [[street name]]s (strings of text), bugs may appear when a city where streets [[intersection (road)|intersect]] multiple times is encountered.  While this example may be oversimplified, restructuring of data is a fairly common problem in software engineering, either to eliminate bugs, increase efficiency, or support new features. In these cases [[responsibility-driven design]] may be promoted as a better approach, where functionality and data can be coupled together, so functions don't have to deal with the data representation itself.<ref name=\"responsibility\" />\n\n== Data-driven programming languages ==\n*[[AWK]]<ref name=\"awk\" />\n*[[Oz (programming language)|Oz]]\n*[[Perl]] – data-driven programming as in AWK and sed is one paradigm supported by Perl\n*[[sed]]\n*[[Lua (programming language)|Lua]]<ref>{{Cite web |url=https://www.lua.org/manual/5.3/manual.html |title=Lua 5.3 Reference Manual |last=Ierusalimschy |first=Roberto |last2=de Figueiredo |first2=Luiz Henrique |date=2017-02-03 |website=www.lua.org |access-date=2018-06-05 |last3=Celes |first3=Waldemar}}</ref>\n*[[Clojure (programming language)|Clojure]]<ref>{{Cite web |url=https://www.clojure.org |title=Clojure |website=www.clojure.org |access-date=2018-06-05}}</ref>\n\n;Mail filtering languages\n*[[maildrop]]\n*[[procmail]]\n*[[Sieve (mail filtering language)|Sieve]]\n\n== See also ==\n*[[Data-directed programming]]\n*[[Backus–Naur form]]\n\n== References ==\n{{refimprove|date=March 2011}}\n{{reflist}}\n\n{{Programming language}}\n\n{{DEFAULTSORT:Data-Driven Programming}}\n[[Category:Programming paradigms]]",
            "slug": "data-driven-programming",
            "date_updated": 1537258789450,
            "imported": "https://en.wikipedia.org/wiki/Data-driven_programming"
        }
    ]
}