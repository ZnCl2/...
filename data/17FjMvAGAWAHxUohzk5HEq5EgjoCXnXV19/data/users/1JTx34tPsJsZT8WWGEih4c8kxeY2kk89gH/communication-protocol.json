{
    "article": [
        {
            "title": "Communication protocol",
            "text": "{{short description|System for exchanging messages between computing systems}}\n{{Use American English|date=March 2020}}\n{{Use dmy dates|date=May 2020}}\n\nA '''communication protocol''' is a system of rules that allows two or more entities of a [[communications system]] to transmit [[information]] via any kind of variation of a [[physical quantity]]. The protocol defines the rules, [[syntax]], semantics and [[synchronization]] of [[communication]] and possible [[Error detection and correction|error recovery methods]]. Protocols may be implemented by [[Computer hardware|hardware]], [[software]], or a combination of both.<ref>{{Cite patent|title=Wireless communication protocol|gdate=2004-12-01|url=https://patents.google.com/patent/US7529565B2/en}}</ref>\n\nCommunicating systems use well-defined formats for exchanging various messages. Each message has an exact meaning intended to elicit a response from a range of possible responses pre-determined for that particular situation. The specified behavior is typically independent of how it is to be [[Implementation|implemented]]. Communication protocols have to be agreed upon by the parties involved.<ref>{{citation |url=http://www.britannica.com/EBchecked/topic/410357/protocol |title=Protocol |publisher=[[Encyclopædia Britannica]] |access-date=24 September 2012}}</ref> To reach an agreement, a protocol may be developed into a [[technical standard]]. A [[programming language]] describes the same for computations, so there is a close analogy between protocols and programming languages: ''protocols are to communication what programming languages are to computations''.<ref name=\"AnalogyII\">Comer 2000, Sect. 11.2 - The Need For Multiple Protocols, p. 177, \"They (protocols) are to communication what programming languages are to computation\"</ref> An alternate formulation states that ''protocols are to communication what [[algorithm]]s are to computation''.<ref name=\"AnalogyI\">Comer 2000, Sect. 1.3 - Internet Services, p. 3, \"Protocols are to communication what algorithms are to computation\"</ref>\n\nMultiple protocols often describe different aspects of a single communication. A group of protocols designed to work together is known as a protocol suite; when implemented in software they are a [[protocol stack]].\n\nInternet communication protocols are published by the [[Internet Engineering Task Force]] (IETF). The [[IEEE]] (Institute of Electrical and Electronics Engineers) handles wired and wireless networking and the [[International Organization for Standardization]] (ISO) handles other types. The [[ITU-T]] handles telecommunication protocols and formats for the [[public switched telephone network]] (PSTN). As the PSTN and Internet [[Technological convergence|converge]], the standards are also being driven towards convergence.\n\n==Communicating systems==\n=== History ===\nOne of the first uses of the term ''protocol'' in a data-commutation context occurs in a memorandum entitled ''A Protocol for Use in the [[NPL Data Communications Network]]'' written by [[Roger Scantlebury]] and Keith Bartlett in April 1967.<ref>{{Cite book|last=Naughton|first=John|url=https://books.google.com/books?id=bbonCgAAQBAJ&pg=PT290|title=A Brief History of the Future|date=24 September 2015|publisher=Orion|isbn=978-1-4746-0277-8|language=en}}</ref><ref>{{Cite journal|last=Cambell-Kelly|first=Martin|date=1987|title=Data Communications at the National Physical Laboratory (1965-1975)|url=http://archive.org/details/DataCommunicationsAtTheNationalPhysicalLaboratory|journal=Annals of the History of Computing|language=en|volume=9|issue=3/4|pages=221–247|doi=10.1109/MAHC.1987.10023|s2cid=8172150}}</ref>\n\nOn the [[ARPANET]], the starting point for host-to-host communication in 1969 was the [[BBN Report 1822|1822 protocol]], which defined the transmission of messages to an IMP.<ref>[http://www.bitsavers.org/pdf/bbn/imp/BBN1822_Jan1976.pdf ''Interface Message Processor: Specifications for the Interconnection of a Host and an IMP''], Report No. 1822, Bolt Beranek and Newman, Inc. (BBN)</ref> The [[Network Control Program]] for the ARPANET was first implemented in 1970.<ref>{{Cite book|url=https://books.google.com/books?id=dRRDDwAAQBAJ&pg=PA319|title=UGC -NET/JRF/SET PTP & Guide Teaching and Research Aptitude: UGC -NET By HD|last=BOOKS|first=HIGH DEFINITION|publisher=High Definition Books|language=en}}</ref> The NCP interface allowed [[application software]] to connect across the ARPANET by implementing higher-level communication protocols, an early example of the ''protocol layering'' concept.<ref name=\"LINCP\">[http://www.livinginternet.com/i/ii_ncp.htm \"NCP – Network Control Program\"], Living Internet</ref>\n\nNetworking research in the early 1970s by [[Robert E. Kahn]] and [[Vint Cerf]] led to the formulation of the [[Transmission Control Program]] (TCP).<ref>{{Cite journal|last1=Cerf|first1=V.|last2=Kahn|first2=R.|date=1974|title=A Protocol for Packet Network Intercommunication|url=https://www.cs.princeton.edu/courses/archive/fall06/cos561/papers/cerf74.pdf|journal=IEEE Transactions on Communications|volume=22|issue=5|pages=637–648|doi=10.1109/TCOM.1974.1092259|issn=1558-0857|quote=The authors wish to thank a number of colleagues for helpful comments during early discussions of international network protocols, especially R. Metcalfe, R. Scantlebury, D. Walden, and H. Zimmerman; D. Davies and L. Pouzin who constructively commented on the fragmentation and accounting issues; and S. Crocker who commented on the creation and destruction of associations.}}</ref> Its {{IETF RFC|675}} specification was written by Cerf with [[Yogen Dalal]] and Carl Sunshine in December 1974, still a monolithic design at this time.\n\nThe [[International Networking Working Group]] agreed a connectionless [[datagram]] standard which was presented to the [[ITU-T|CCIT]] in 1975 but was not adopted by the ITU or by the ARPANET.<ref name=\":0\">{{Cite journal|last=McKenzie|first=Alexander|date=2011|title=INWG and the Conception of the Internet: An Eyewitness Account|journal=IEEE Annals of the History of Computing|volume=33|issue=1|pages=66–71|doi=10.1109/MAHC.2011.9|s2cid=206443072|issn=1934-1547}}</ref> International research, particularly the work of [[Rémi Després]], contributed to the development of the [[X.25]] standard, based on [[virtual circuit]]s by the [[ITU-T]] in 1976.<ref>{{Cite journal|last=Schwartz|first=Mischa|date=2010|title=X.25 Virtual Circuits - TRANSPAC IN France - Pre-Internet Data Networking [History of communications]|journal=IEEE Communications Magazine|volume=48|issue=11|pages=40–46|doi=10.1109/MCOM.2010.5621965|s2cid=23639680|issn=1558-1896}}</ref><ref>{{Cite journal|last=Rybczynski|first=Tony|date=2009|title=Commercialization of packet switching (1975-1985): A Canadian perspective [History of Communications]|journal=IEEE Communications Magazine|volume=47|issue=12|pages=26–31|doi=10.1109/MCOM.2009.5350364|s2cid=23243636|issn=1558-1896}}</ref> Computer manufacturers developed [[proprietary protocol]]s such as IBM's [[Systems Network Architecture]] (SNA), Digital Equipment Corporation's [[DECnet]] and [[Xerox Network Systems]].<ref>{{Cite book|url=https://books.google.com/books?id=y-tFrTTweRIC&pg=PA337|title=The \"Hidden\" Prehistory of European Research Networking|publisher=Trafford Publishing|isbn=978-1-4669-3935-6|pages=354|language=en}}</ref>\n\nTCP software was redesigned as a modular protocol stack. Originally referred to as ''IP/TCP'', it was installed on [[SATNET]] in 1982 and on the ARPANET in January 1983. The development of a complete protocol suite by 1989, as outlined in {{IETF RFC|1122}} and {{IETF RFC|1123}}, laid the foundation for the growth of [[TCP/IP]] as a comprehensive protocol suite as the core component of the emerging [[Internet]].<ref name=\"LITCPIP\">[http://www.livinginternet.com/i/ii_tcpip.htm \"TCP/IP Internet Protocol\"], Living Internet</ref>\n\nInternational work on a reference model for communication standards led to the [[OSI model]], published in 1984. For a period in the late 1980s and early 1990s, engineers, organizations and nations became [[Protocol Wars|polarized over the issue of which standard]], the OSI model or the Internet protocol suite, would result in the best and most robust computer networks.<ref name=\"ieee2017032\">{{cite magazine|author=Andrew L. Russell|date=30 July 2013|title=OSI: The Internet That Wasn't|url=https://spectrum.ieee.org/computing/networks/osi-the-internet-that-wasnt|magazine=[[IEEE Spectrum]]|volume=50|issue=8}}</ref><ref>{{Cite web|url=https://www2.cs.duke.edu/courses/common/compsci092/papers/govern/consensus.pdf|title=Rough Consensus and Running Code' and the Internet-OSI Standards War|last=Russell|first=Andrew L.|publisher=IEEE Annals of the History of Computing}}</ref><ref>{{Cite document|date=2006|title=Standards Wars|url=https://courses.cs.washington.edu/courses/csep590a/06au/projects/standards-wars.pdf}}</ref>\n\n=== Concept ===\nThe information exchanged between devices through a network or other media is governed by rules and conventions that can be set out in communication protocol specifications. The nature of communication, the actual data exchanged and any [[State (computer science)|state]]-dependent behaviors, is defined by these specifications. In digital computing systems, the rules can be expressed by [[algorithm]]s and [[data structure]]s. Protocols are to communication what algorithms or programming languages are to computations.<ref name=\"AnalogyII\"/><ref name=\"AnalogyI\"/>\n\nOperating systems usually contain a set of cooperating processes that manipulate shared data to communicate with each other. This communication is governed by well-understood protocols, which can be embedded in the process code itself.<ref name=\"Ben-Ari p.18\">Ben-Ari 1982, chapter 2 - The concurrent programming abstraction, p. 18-19, states the same.</ref><ref name=\"Ben-Ari p.27\">Ben-Ari 1982, Section 2.7 - Summary, p. 27, summarizes the concurrent programming abstraction.</ref> In contrast, because there is no [[shared memory]], communicating systems have to communicate with each other using a shared [[transmission medium]]. Transmission is not necessarily reliable, and individual systems may use different hardware or operating systems.\n\nTo implement a networking protocol, the protocol software modules are interfaced with a framework implemented on the machine's operating system. This framework implements the networking functionality of the operating system.<ref name=\"Marsden p.64\"/> When protocol algorithms are expressed in a portable programming language the protocol software may be made [[operating system]] independent. The best-known frameworks are the [[TCP/IP model]] and the [[OSI model]].\n\nAt the time the Internet was developed, [[abstraction layer]]ing had proven to be a successful design approach for both compiler and operating system design and, given the similarities between programming languages and communication protocols, the originally monolithic networking programs were decomposed into cooperating protocols.<ref>Comer 2000, Sect. 11.2 - The Need For Multiple Protocols, p. 177, explains this by drawing analogies between computer communication and programming languages.</ref> This gave rise to the concept of layered protocols which nowadays forms the basis of protocol design.<ref name=\"Sect p. 192\">Sect. 11.10 - The Disadvantage Of Layering, p. 192, states: layering forms the basis for protocol design.</ref>\n\nSystems typically do not use a single protocol to handle a transmission. Instead they use a set of cooperating protocols, sometimes called a [[protocol suite]].<ref name=\"Sect p. 177\">Comer 2000, Sect. 11.2 - The Need For Multiple Protocols, p. 177, states the same.</ref> Some of the best known protocol suites are [[TCP/IP]], [[IPX/SPX]], [[X.25]], [[AX.25]] and [[AppleTalk]].\n\nThe protocols can be arranged based on functionality in groups, for instance, there is a group of [[transport protocol]]s. The functionalities are mapped onto the layers, each layer solving a distinct class of problems relating to, for instance: application-, transport-, internet- and network interface-functions.<ref name=\"Sect p. 178\">Comer 2000, Sect. 11.3 - The Conceptual Layers Of Protocol Software, p. 178, \"Each layer takes responsibility for handling one part of the problem.\"</ref> To transmit a message, a protocol has to be selected from each layer. The selection of the next protocol is accomplished by extending the message with a protocol selector for each layer.<ref>Comer 2000, Sect. 11.11 - The Basic Idea Behind Multiplexing And Demultiplexing, p. 192, states the same.</ref>\n\n==Types==\nThere are two types of communication protocols, based on their representation of the content being carried: text-based and binary.\n\n=== Text-based ===\nA '''text-based protocol''' or '''plain text protocol''' represents its content in [[Human-readable medium|human-readable format]], often in plain text.\n\nThe immediate human readability stands in contrast to binary protocols which have inherent benefits for use in a computer environment (such as ease of mechanical [[parsing]] and [[Lossless compression|improved bandwidth utilization]]).\n\nDifferent network applications have different methods of encapsulating data. One method very common with Internet protocols is a text oriented representation that transmits requests and responses as lines of [[ASCII]] text, terminated by a newline character (and usually a carriage return character). Examples of protocols that use plain, human-readable text for its commands are FTP ([[File Transfer Protocol]]), SMTP ([[Simple Mail Transfer Protocol]]), and the [[finger protocol]].<ref>{{cite web|last=Kirch|first=Olaf|date=2002-01-16|title=Text Based Protocols|url=http://www.lst.de/~okir/blackhats/node76.html|url-status=dead|archive-url=https://web.archive.org/web/20100530140215/http://www.lst.de/~okir/blackhats/node76.html|archive-date=2010-05-30|access-date=2014-10-21}}</ref>\n\nText-based protocols are typically optimized for human parsing and interpretation, and are therefore suitable whenever human inspection of protocol contents is required, such as during [[debugging]] and during early protocol development design phases.\n\n=== Binary ===\nA '''binary protocol''' utilizes all values of a [[byte]], as opposed to a text-based protocol which only uses values corresponding to human-readable characters in [[ASCII]] encoding. Binary protocols are intended to be read by a machine rather than a human being. Binary protocols have the advantage of terseness, which translates into speed of transmission and interpretation.\n\nBinary have been used in the normative documents describing modern standards like [[EbXML]], [[HTTP/2]], [[HTTP/3]] and [[Enterprise Distributed Object Computing|EDOC]].<ref>{{cite web|last=Kirch|first=Olaf|date=2002-01-16|title=Binary Representation Protocols|url=http://www.omg.org/technology/documents/formal/edoc.htm|url-status=dead|archive-url=https://web.archive.org/web/20060305095832/http://www.omg.org/technology/documents/formal/edoc.htm|archive-date=2006-03-05|access-date=2006-05-04|df=}}</ref> An interface in UML<ref>{{cite web|author=|date=|title=Welcome To UML Web Site!|url=http://www.uml.org/|website=Uml.org|accessdate=2017-01-15}}</ref> may also be considered a binary protocol.\n\n==Basic requirements==\nGetting the data across a network is only part of the problem for a protocol. The data received has to be evaluated in the context of the progress of the conversation, so a protocol must include rules describing the context. These kind of rules are said to express the ''syntax'' of the communication. Other rules determine whether the data is meaningful for the context in which the exchange takes place. These kind of rules are said to express the ''semantics'' of the communication.\n\nMessages are sent and received on communicating systems to establish communication. Protocols should therefore specify rules governing the transmission. In general, much of the following should be addressed:<ref>Marsden 1986, Chapter 3 - Fundamental protocol concepts and problem areas, p. 26-42, explains much of the following.</ref>\n;Data formats for data exchange\n:Digital message bitstrings are exchanged. The bitstrings are divided in fields and each field carries information relevant to the protocol. Conceptually the bitstring is divided into two parts called the ''header'' and the ''payload''. The actual message is carried in the payload. The header area contains the fields with relevance to the operation of the protocol. Bitstrings longer than the [[maximum transmission unit]] (MTU) are divided in pieces of appropriate size.<ref>Comer 2000, Sect. 7.7.4 - Datagram Size, Network MTU, and Fragmentation, p. 104, Explains fragmentation and the effect on the header of the fragments.</ref>\n;Address formats for data exchange\n:Addresses are used to identify both the sender and the intended receiver(s). The addresses are carried in the header area of the bitstrings, allowing the receivers to determine whether the bitstrings are of interest and should be processed or should be ignored. A connection between a sender and a receiver can be identified using an address pair ''(sender address, receiver address)''. Usually, some address values have special meanings. An all-''1''s address could be taken to mean an addressing of all stations on the network, so sending to this address would result in a broadcast on the local network. The rules describing the meanings of the address value are collectively called an ''addressing scheme''.<ref>Comer 2000, Chapter 4 - Classful Internet Addresses, p. 64-67;71.</ref>\n;Address mapping\n:Sometimes protocols need to map addresses of one scheme on addresses of another scheme. For instance to translate a logical IP address specified by the application to an Ethernet MAC address. This is referred to as ''address mapping''.<ref>Marsden 1986, Section 14.3 - Layering concepts and general definitions, p. 187, explains address mapping.</ref>\n;Routing\n:When systems are not directly connected, intermediary systems along the ''route'' to the intended receiver(s) need to forward messages on behalf of the sender. On the Internet, the networks are connected using routers. The interconnection of networks through routers is called ''[[internetworking]]''.\n;Detection of transmission errors\n:Error detection is necessary on networks where data corruption is possible. In a common approach, a CRC of the data area is added to the end of packets, making it possible for the receiver to detect differences caused by corruption. The receiver rejects the packets on CRC differences and arranges somehow for retransmission.<ref>Marsden 1986, Section 3.2 - Detection and transmission errors, p. 27, explains the advantages of backward error correction.</ref>\n;Acknowledgements\n:Acknowledgement of correct reception of packets is required for [[connection-oriented communication]]. Acknowledgments are sent from receivers back to their respective senders.<ref>Marsden 1986, Section 3.3 - Acknowledgement, p. 28-33, explains the advantages of positive only acknowledgment and mentions datagram protocols as exceptions.</ref>\n;Loss of information - timeouts and retries\n:Packets may be lost on the network or be delayed in transit. To cope with this, under some protocols, a sender may expect an acknowledgment of correct reception from the receiver within a certain amount of time. Thus, on [[Timeout (computing)|timeouts]], the sender may need to retransmit the information.{{efn|Failure to receive an acknowledgment indicates that either the original transmission or the acknowledgment was lost. The sender has no means to distinguish these cases and therefore, to ensure all data is received, must make the conservative assumption that the original transmission was lost.}} In case of a permanently broken link, the retransmission has no effect so the number of retransmissions is limited. Exceeding the retry limit is considered an error.<ref>Marsden 1986, Section 3.4 - Loss of information - timeouts and retries, p. 33-34.</ref>\n;Direction of information flow\n:Direction needs to be addressed if transmissions can only occur in one direction at a time as on [[half-duplex]] links or from one sender at a time as on a [[shared medium]]. This is known as [[media access control]]. Arrangements have to be made to accommodate the case of [[Collision (telecommunications)|collision]] or [[Contention (telecommunications)|contention]] where two parties respectively simultaneously transmit or wish to transmit.<ref>Marsden 1986, Section 3.5 - Direction of information flow, p. 34-35, explains master/slave and the negotiations to gain control.</ref>\n;Sequence control\n:If long bitstrings are divided into pieces and then sent on the network individually, the pieces may get lost or delayed or, on some types of networks, take different routes to their destination. As a result, pieces may arrive out of sequence. Retransmissions can result in duplicate pieces. By marking the pieces with sequence information at the sender, the receiver can determine what was lost or duplicated, ask for necessary retransmissions and reassemble the original message.<ref>Marsden 1986, Section 3.6 - Sequence control, p. 35-36, explains how packets get lost and how sequencing solves this.</ref>\n;Flow control\n:Flow control is needed when the sender transmits faster than the receiver or intermediate network equipment can process the transmissions. Flow control can be implemented by messaging from receiver to sender.<ref>Marsden 1986, Section 3.7 - Flow control, p. 36-38.</ref>\n;Queueing\n:Communicating processes or state machines employ queues (or \"buffers\"), usually FIFO queues, to deal with the messages in the order sent, and may sometimes have multiple queues with different prioritization\n\n==Protocol design==\n[[Systems engineering]] principles have been applied to create a set of common network protocol design principles. The design of complex protocols often involves decomposition into simpler, cooperating protocols. Such a set of cooperating protocols is sometimes called a protocol family or a protocol suite,<ref name=\"Sect p. 177\"/> within a conceptual framework.\n\nCommunicating systems operate concurrently. An important aspect of [[concurrent programming]] is the synchronization of software for receiving and transmitting messages of communication in proper sequencing. Concurrent programming has traditionally been a topic in operating systems theory texts.<ref>Ben-Ari 1982, in his preface, p. xiii.</ref> Formal verification seems indispensable because concurrent programs are notorious for the hidden and sophisticated bugs they contain.<ref>Ben-Ari 1982, in his preface, p. xiv.</ref> A mathematical approach to the study of concurrency and communication is referred to as [[communicating sequential processes]] (CSP).<ref>Hoare 1985, Chapter 4 - Communication, p. 133, deals with communication.</ref> Concurrency can also be modeled using [[finite state machine]]s, such as [[Mealy machine|Mealy]] and [[Moore machine]]s. Mealy and Moore machines are in use as design tools in digital electronics systems encountered in the form of hardware used in telecommunication or electronic devices in general.<ref>{{citation |author=S. Srinivasan |publisher=NPTEL courses |title=Digital Circuits and Systems |url=http://nptel.iitm.ac.in/video.php?courseId=1005&p=3 |url-status=dead |archive-url=https://web.archive.org/web/20091227210642/http://nptel.iitm.ac.in/video.php?courseId=1005&p=3 |archive-date=27 December 2009  }}</ref>{{better source needed|date=September 2018}}\n\nThe literature presents numerous analogies between computer communication and programming. In analogy, a transfer mechanism of a protocol is comparable to a central processing unit (CPU). The framework introduces rules that allow the programmer to design cooperating protocols independently of one another.\n\n===Layering===\n[[File:Internet layering.svg|thumb|alt=Figure 2. Protocols in relation to the Internet layering scheme.|Figure 2. The TCP/IP model or Internet layering scheme and its relation to some common protocols.]]\n\nIn modern protocol design, protocols are layered to form a protocol stack. Layering is a design principle that divides the protocol design task into smaller steps, each of which accomplishes a specific part, interacting with the other parts of the protocol only in a small number of well-defined ways. Layering allows the parts of a protocol to be designed and tested without a [[combinatorial explosion]] of cases, keeping each design relatively simple.\n\nThe communication protocols in use on the [[Internet]] are designed to function in diverse and complex settings. Internet protocols are designed for simplicity and modularity and fit into a coarse hierarchy of functional layers defined in the [[Internet Protocol Suite]].<ref name=\"Comer decomposition\"/> The first two cooperating protocols, the [[Transmission Control Protocol]] (TCP) and the [[Internet Protocol]] (IP) resulted from the decomposition of the original Transmission Control Program, a monolithic communication protocol, into this layered communication suite.\n\nThe [[OSI model]] was developed internationally based on experience with networks that predated the internet as a reference model for general communication with much stricter rules of protocol interaction and rigorous layering.\n\nTypically, application software is built upon a robust data transport layer. Underlying this transport layer is a datagram delivery and routing mechanism that is typically [[connectionless]] in the Internet. Packet relaying across networks happens over another layer that involves only network link technologies, which are often specific to certain physical layer technologies, such as [[Ethernet]]. Layering provides opportunities to exchange technologies when needed, for example, protocols are often stacked in a [[Tunneling protocol|tunneling]] arrangement to accommodate the connection of dissimilar networks. For example, IP may be tunneled across an [[Asynchronous Transfer Mode]] (ATM) network.\n\n====Protocol layering====\n[[File:Message flows.svg|thumb|alt=Figure 3. Message flows using a protocol suite.|Figure 3. Message flows using a protocol suite. Black loops show the actual messaging loops, red loops are the effective communication between layers enabled by the lower layers.]]\n\nProtocol layering forms the basis of protocol design.<ref name=\"Sect p. 192\"/> It allows the decomposition of single, complex protocols into simpler, cooperating protocols.<ref name=\"Comer decomposition\">Comer 2000, Sect. 11.2 - The Need For Multiple Protocols, p. 177, introduces the decomposition in layers.</ref> The protocol layers each solve a distinct class of communication problems. Together, the layers make up a layering scheme or model.\n\nComputations deal with algorithms and data; Communication involves protocols and messages; So the analog of a [[data flow diagram]] is some kind of message flow diagram.<ref name=\"AnalogyI\"/> To visualize protocol layering and protocol suites, a diagram of the message flows in and between two systems, A and B, is shown in figure 3. The systems, A and B, both make use of the same protocol suite. The vertical flows (and protocols) are in-system and the horizontal message flows (and protocols) are between systems. The message flows are governed by rules, and data formats specified by protocols. The blue lines mark the boundaries of the (horizontal) protocol layers.\n\n====Software layering====\n[[File:Protocol and Software layering.svg|thumb|alt=Figure 5: protocol and software layering |Figure 5: Protocol and software layering. The software modules implementing the protocols are represented by cubes. The information flow between the modules is represented by arrows. The (top two horizontal) red arrows are virtual. The blue lines mark the layer boundaries.]]\n\nThe software supporting protocols has a layered organization and its relationship with protocol layering is shown in figure 5.\n\nTo send a message on system A, the top-layer software module interacts with the module directly below it and hands over the message to be encapsulated. The lower module fills in the header data in accordance with the protocol it implements and interacts with the bottom module which sends the message over the communications channel to the bottom module of system B. On the receiving system B the reverse happens, so ultimately the message gets delivered in its original form to the top module of system B.<ref>Comer 2000, Sect. 11.3 - The Conceptual Layers Of Protocol Software, p. 179, the first two paragraphs describe the sending of a message through successive layers.</ref>\n\n[[Program translation]] is divided into subproblems. As a result, the translation software is layered as well, allowing the software layers to be designed independently. The same approach can be seen in the TCP/IP layering.<ref name=\"Comer p. 178\">Comer 2000, Sect. 11.2 - The need for multiple protocols, p. 178, explains similarities protocol software and compiler, assembler, linker, loader.</ref>\n\nThe modules below the application layer are generally considered part of the operating system. Passing data between these modules is much less expensive than passing data between an application program and the transport layer. The boundary between the application layer and the transport layer is called the operating system boundary.<ref>Comer 2000, Sect. 11.9.1 - Operating System Boundary, p. 192, describes the operating system boundary.</ref>\n\n====Strict layering====\nStrictly adhering to a layered model, a practice known as strict layering, is not always the best approach to networking.<ref>IETF 1989, Sect 1.3.1 - Organization, p. 15, 2nd paragraph: many design choices involve creative \"breaking\" of strict layering.</ref> Strict layering can have a negative impact on the performance of an implementation.<ref>Comer 2000, Sect. 11.10 - The Disadvantage Of Layering, p. 192, explains why \"strict layering can be extremely inefficient\" giving examples of optimizations.</ref>\n\nWhile the use of protocol layering is today ubiquitous across the field of computer networking, it has been historically criticized by many researchers<ref>{{cite journal| last = Wakeman| first = I| date = Jan 1992| title = Layering considered harmful| journal = IEEE Network| pages =20–24}}</ref> as abstracting the protocol stack in this way may cause a higher layer to duplicate the functionality of a lower layer, a prime example being error recovery on both a per-link basis and an end-to-end basis.<ref>{{cite book |last1=Kurose |first1=James | last2=Ross | first2=Keith |year= 2005 | title=Computer Networking: A Top-Down Approach |publisher=Pearson}}</ref>\n\n===Design patterns===\nCommonly recurring problems in the design and implementation of communication protocols can be addressed by [[software design pattern]]s.<ref>Jorge Edison Lascano, Stephen Clyde, and Ali Raza. \"Communication-protocol Design Patterns (CommDP) - COMMDP.\" [Online]. Available: http://commdp.serv.usu.edu/wiki/index.php/Communication-protocol_Design_Patterns_(CommDP) {{Webarchive|url=https://web.archive.org/web/20170318090654/http://commdp.serv.usu.edu/wiki/index.php/Communication-protocol_Design_Patterns_(CommDP) |date=18 March 2017 }}. [Accessed: 17 March 2017].</ref><ref>J. E. Lascano and S. Clyde, \"A Pattern Language for Application-level Communication Protocols,\" presented at the ICSEA 2016, The Eleventh International Conference on Software Engineering Advances, 2016, pp. 22–30.</ref><ref>R. Daigneau, Service Design Patterns: Fundamental Design Solutions for SOAP/WSDL and RESTful Web Services, 1 edition. Upper Saddle River, NJ: Addison-Wesley Professional, 2011.</ref><ref>M. Fowler, Patterns of Enterprise Application Architecture, 1 edition. Boston: Addison-Wesley Professional, 2002.</ref><ref>[1]F. Buschmann, K. Henney, and D. C. Schmidt, Pattern-Oriented Software Architecture Volume 4: A Pattern Language for Distributed Computing, Volume 4 edition. Chichester England; New York: Wiley, 2007.</ref>\n\n===Formal specification===\nPopular formal methods of describing communication syntax are [[Abstract Syntax Notation One]] (an [[International Organization for Standardization|ISO]] standard) and [[augmented Backus–Naur form]] (an [[IETF]] standard).\n\n[[Finite-state machine]] models are used to formally describe the possible interactions of the protocol.<ref>{{Cite journal | last1 = Bochmann | first1 = G. | title = Finite state description of communication protocols | doi = 10.1016/0376-5075(78)90015-6 | journal = Computer Networks | volume = 2 | issue = 4–5 | pages = 361–372| year = 1978 }}</ref><ref>Comer 2000, Glossary of Internetworking Terms and Abbreviations, p. 704, term protocol.</ref> and communicating finite-state machines<ref>{{cite journal|doi=10.1145/322374.322380|title=On Communicating Finite-State Machines|journal=Journal of the ACM|volume=30|issue=2|pages=323|year=1983|last1=Brand|first1=Daniel|last2=Zafiropulo|first2=Pitro|s2cid=11607967}}</ref>\n\n==Protocol development==\nFor communication to occur, protocols have to be selected. The rules can be expressed by algorithms and data structures. Hardware and operating system independence is enhanced by expressing the algorithms in a portable programming language. Source independence of the specification provides wider interoperability.\n\nProtocol standards are commonly created by obtaining the approval or support of a [[standards organization]], which initiates the standardization process. The members of the standards organization agree to adhere to the work result on a voluntary basis. Often the members are in control of large market-shares relevant to the protocol and in many cases, standards are enforced by law or the government because they are thought to serve an important public interest, so getting approval can be very important for the protocol.\n\n===The need for protocol standards===\nThe need for protocol standards can be shown by looking at what happened to the bi-sync protocol (BSC) invented by [[IBM]]. BSC is an early link-level protocol used to connect two separate nodes. It was originally not intended to be used in a multinode network, but doing so revealed several deficiencies of the protocol. In the absence of standardization, manufacturers and organizations felt free to enhance the protocol, creating incompatible versions on their networks. In some cases, this was deliberately done to discourage users from using equipment from other manufacturers. There are more than 50 variants of the original bi-sync protocol. One can assume, that a standard would have prevented at least some of this from happening.<ref name=\"Marsden p.64\">Marsden 1986, Section 6.1 - Why are standards necessary?, p. 64-65, uses BSC as an example to show the need for both standard protocols and a standard framework.</ref>\n\nIn some cases, protocols gain market dominance without going through a standardization process. Such protocols are referred to as ''[[de facto standard]]s''. De facto standards are common in emerging markets, niche markets, or markets that are [[monopoly|monopolized]] (or [[oligopoly|oligopolized]]). They can hold a market in a very negative grip, especially when used to scare away competition. From a historical perspective, standardization should be seen as a measure to counteract the ill-effects of de facto standards. Positive exceptions exist; a de facto standard operating system like Linux does not have this negative grip on its market, because the sources are published and maintained in an open way, thus inviting competition.<!--[[User:Kvng/RTH]]-->\n\n===Standards Organizations===\nSome of the [[standards organization]]s of relevance for communication protocols are the [[International Organization for Standardization]] (ISO), the [[International Telecommunication Union]] (ITU), the [[Institute of Electrical and Electronics Engineers]] (IEEE), and the [[Internet Engineering Task Force]] (IETF). The IETF maintains the protocols in use on the Internet. The IEEE controls many software and hardware protocols in the electronics industry for commercial and consumer devices. The ITU is an umbrella organization of telecommunication engineers designing the [[public switched telephone network]] (PSTN), as well as many [[radio]] communication systems. For [[marine electronics]] the [[National Marine Electronics Association|NMEA]] standards are used. The [[World Wide Web Consortium]] (W3C) produces protocols and standards for Web technologies.\n\nInternational standards organizations are supposed to be more impartial than local organizations with a national or commercial self-interest to consider. Standards organizations also do research and development for standards of the future. In practice, the standards organizations mentioned, cooperate closely with each other.<ref>Marsden 1986, Section 6.3 - Advantages of standardization, p. 66-67, states the same.</ref>\n\n===The Standardization Process===\nThe standardization process starts off with ISO commissioning a sub-committee workgroup. The workgroup issues working drafts and discussion documents to interested parties (including other standards bodies) in order to provoke discussion and comments. This will generate a lot of questions, much discussion and usually some disagreement on what the standard should provide and if it can satisfy all needs (usually not). All conflicting views should be taken into account, often by way of compromise, to progress to a ''draft proposal'' of the working group.\n\nThe draft proposal is discussed by the member countries' standard bodies and other organizations within each country. Comments and suggestions are collated and national views will be formulated, before the members of ISO vote on the proposal. If rejected, the draft proposal has to consider the objections and counter-proposals to create a new draft proposal for another vote. After a lot of feedback, modification, and compromise the proposal reaches the status of a ''draft international standard'', and ultimately an ''international standard''.\n\nThe process normally takes several years to complete. The original paper draft created by the designer will differ substantially from the standard, and will contain some of the following 'features':\n* Various optional modes of operation, for example, to allow for setup of different packet sizes at startup time, because the parties could not reach consensus on the optimum packet size.\n* Parameters that are left undefined or allowed to take on values of a defined set at the discretion of the implementor. This often reflects conflicting views of some of the members.\n* Parameters reserved for future use, reflecting that the members agreed the facility should be provided, but could not reach agreement on how this should be done in the available time.\n* Various inconsistencies and ambiguities will inevitably be found when implementing the standard.\n\nInternational standards are reissued periodically to handle the deficiencies and reflect changing views on the subject.<ref>Marsden 1986, Section 6.4 - Some problems with standardisation, p. 67, follows HDLC to illustrate the process.</ref>\n\n===OSI Standardisation===\nA lesson learned from [[ARPANET]], the predecessor of the Internet, was that protocols need a framework to operate. It is therefore important to develop a general-purpose, future-proof framework suitable for ''structured protocols'' (such as layered protocols) and their standardization. This would prevent protocol standards with overlapping functionality and would allow clear definition of the responsibilities of a protocol at the different levels (layers).<ref>Marsden 1986, Section 6.1 - Why are standards necessary?, p. 65, explains lessons learned from ARPANET.</ref> This gave rise to the OSI ''Open Systems Interconnection reference model'' (RM/OSI), which is used as a framework for the design of standard protocols and services conforming to the various layer specifications.<ref>Marsden 1986, Section 14.1 - Introduction, p. 181, introduces OSI.</ref>\n\nIn the [[OSI model]], communicating systems are assumed to be connected by an underlying physical medium providing a basic (and unspecified) transmission mechanism. The layers above it are numbered (from one to seven); the n<sup>th</sup> layer is referred to as (n)-layer. Each layer provides service to the layer above it (or at the top to the application process) using the services of the layer immediately below it. The layers communicate with each other by means of an interface, called a ''service access point''. Corresponding layers at each system are called ''peer entities''. To communicate, two peer entities at a given layer use an (n)-protocol, which is implemented by using services of the (n-1)-layer. When systems are not directly connected, intermediate peer entities (called ''relays'') are used. An ''address'' uniquely identifies a service access point. The address naming domains need not be restricted to one layer, so it is possible to use just one naming domain for all layers.<ref>Marsden 1986, Section 14.3 - Layering concepts and general definitions, p. 183-185, explains terminology.</ref>\nFor each layer, there are two types of standards: protocol standards defining how peer entities at a given layer communicate, and service standards defining how a given layer communicates with the layer above it.\n\nIn the original version of RM/OSI, the layers and their functionality are (from highest to lowest layer):\n* The ''[[Application layer]]'' may provide the following services to the application processes: identification of the intended communication partners, establishment of the necessary authority to communicate, determination of availability and authentication of the partners, agreement on privacy mechanisms for the communication, agreement on responsibility for error recovery and procedures for ensuring data integrity, synchronization between cooperating application processes, identification of any constraints on syntax (e.g. character sets and data structures), determination of cost and acceptable quality of service, selection of the dialogue discipline, including required logon and logoff procedures.<ref>Marsden 1986, Section 14.4 - The application layer, p. 188, explains this.</ref>\n* The ''[[presentation layer]]'' may provide the following services to the application layer: a request for the establishment of a session, data transfer, negotiation of the syntax to be used between the application layers, any necessary syntax transformations, formatting and special purpose transformations (e.g. data compression and data encryption).<ref>Marsden 1986, Section 14.5 - The presentation layer, p. 189, explains this.</ref>\n* The ''[[session layer]]'' may provide the following services to the presentation layer: establishment and release of session connections, normal and expedited data exchange, a quarantine service which allows the sending presentation entity to instruct the receiving session entity not to release data to its presentation entity without permission, interaction management so presentation entities can control whose turn it is to perform certain control functions, resynchronization of a session connection, reporting of unrecoverable exceptions to the presentation entity.<ref>Marsden 1986, Section 14.6 - The session layer, p. 190, explains this.</ref>\n* The ''[[transport layer]]'' provides reliable and transparent data transfer in a cost-effective way as required by the selected quality of service. It may support the multiplexing of several transport connections on to one network connection or split one transport connection into several network connections.<ref>Marsden 1986, Section 14.7 - The transport layer, p. 191, explains this.</ref>\n* The ''[[network layer]]'' does the setup, maintenance and release of network paths between transport peer entities. When relays are needed, routing and relay functions are provided by this layer. The quality of service is negotiated between network and transport entities at the time the connection is set up. This layer is also responsible for [[network congestion]] control.<ref>Marsden 1986, Section 14.8 - The network layer, p. 192, explains this.</ref>\n* The ''[[data link layer]]'' does the setup, maintenance and release of data link connections. Errors occurring in the physical layer are detected and may be corrected. Errors are reported to the network layer. The exchange of data link units (including flow control) is defined by this layer.<ref>Marsden 1986, Section 14.9 - The data link layer, p. 194, explains this.</ref>\n* The ''[[physical layer]]'' describes details like the electrical characteristics of the physical connection, the transmission techniques used, and the setup, maintenance and clearing of physical connections.<ref>Marsden 1986, Section 14.10 - The physical layer, p. 195, explains this.</ref>\n\nIn contrast to the [[#Software layering|TCP/IP layering scheme]], which assumes a connectionless network, RM/OSI assumed a connection-oriented network. Connection-oriented networks are more suitable for wide area networks and connectionless networks are more suitable for local area networks. Using connections to communicate implies some form of session and (virtual) circuits, hence the (in the TCP/IP model lacking) session layer. The constituent members of ISO were mostly concerned with wide area networks, so development of RM/OSI concentrated on connection-oriented networks and connectionless networks were only mentioned in an addendum to RM/OSI.<ref>Marsden 1986, Section 14.11 - Connectionless mode and RM/OSI, p. 195, mentions this.</ref>\nAt the time, the IETF had to cope with this and the fact that the Internet needed protocols that simply were not there. As a result, the IETF developed its own standardization process based on \"rough consensus and running code\".<ref>Comer 2000, Section 1.9 - Internet Protocols And Standardization, p. 12, explains why the IETF did not use existing protocols.</ref>\n\nThe standardization process is described by [http://tools.ietf.org/html/rfc2026 RFC2026].\n\nNowadays, the IETF has become a standards organization for the protocols in use on the Internet. RM/OSI has extended its model to include connectionless services and because of this, both TCP and IP could be developed into international standards.\n\n==Taxonomies==\nClassification schemes for protocols usually focus on the domain of use and function. As an example of domain of use, [[connection-oriented protocol]]s and [[connectionless protocol]]s are used on connection-oriented networks and connectionless networks respectively. An example of function is a [[tunneling protocol]], which is used to encapsulate packets in a high-level protocol so that the packets can be passed across a transport system using the high-level protocol.\n\nA [[#Protocol layering|''layering scheme'']] combines both function and domain of use. The dominant layering schemes are the ones proposed by the IETF and by ISO. Despite the fact that the underlying assumptions of the layering schemes are different enough to warrant distinguishing the two, it is a common practice to compare the two by relating common protocols to the layers of the two schemes.<ref>Comer 2000, Sect. 11.5.1 - The TCP/IP 5-Layer Reference Model, p. 183, states the same.</ref>\n\nThe layering scheme from the IETF is called ''Internet layering'' or ''TCP/IP layering''.\n\nThe layering scheme from ISO is called ''the OSI model'' or ''ISO layering''.\n\nIn networking equipment configuration, a term-of-art distinction is often drawn: The term \"protocol\" strictly refers to the transport layer, and the term \"service\" refers to protocols utilizing a \"protocol\" for transport. In the common case of TCP and UDP, services are distinguished by port numbers. Conformance to these port numbers is voluntary, so in content inspection systems the term \"service\" strictly refers to port numbers, and the term \"application\" is often used to refer to protocols identified through inspection signatures.\n\n==See also==\n*[[Lists of network protocols]]\n\n==Notes==\n{{Notelist}}\n\n==References==\n{{Reflist}}\n\n===Bibliography===\n* [[Radia Perlman]]: ''Interconnections: Bridges, Routers, Switches, and Internetworking Protocols.'' 2nd Edition. Addison-Wesley 1999, {{ISBN|0-201-63448-1}}. In particular Ch. 18 on \"network design folklore\", which is also available online at http://www.informit.com/articles/article.aspx?p=20482\n* [[Gerard J. Holzmann]]: ''Design and Validation of Computer Protocols.'' Prentice Hall, 1991, {{ISBN|0-13-539925-4}}. Also available online at http://spinroot.com/spin/Doc/Book91.html\n* {{cite book |author=Douglas E. Comer |year=2000 |title=Internetworking with TCP/IP - Principles, Protocols and Architecture |edition=4th |publisher=Prentice Hall |isbn=0-13-018380-6|author-link=Douglas E. Comer }} In particular Ch.11 Protocol layering. Also has a RFC guide and a Glossary of Internetworking Terms and Abbreviations.\n* Internet Engineering Task Force abbr. IETF (1989): ''RFC1122, Requirements for Internet Hosts -- Communication Layers, R. Braden (ed.)'', Available online at http://tools.ietf.org/html/rfc1122. Describes TCP/IP to the implementors of protocolsoftware. In particular the introduction gives an overview of the design goals of the suite.\n* [[M. Ben-Ari]] (1982): ''Principles of concurrent programming'' 10th Print. Prentice Hall International, {{ISBN|0-13-701078-8}}.\n* C.A.R. Hoare (1985): ''Communicating sequential processes'' 10th Print. Prentice Hall International, {{ISBN|0-13-153271-5}}. Available online via http://www.usingcsp.com\n* R.D. Tennent (1981): ''Principles of programming languages'' 10th Print. Prentice Hall International, {{ISBN|0-13-709873-1}}.\n* Brian W Marsden (1986): ''Communication network protocols'' 2nd Edition. Chartwell Bratt, {{ISBN|0-86238-106-1}}.\n* [[Andrew S. Tanenbaum]] (1984): ''Structured computer organization'' 10th Print. Prentice Hall International, {{ISBN|0-13-854605-3}}.\n\n==Further reading==\n* [[Radia Perlman]], ''Interconnections: Bridges, Routers, Switches, and Internetworking Protocols (2nd Edition)''. Addison-Wesley 1999. {{ISBN|0-201-63448-1}}. In particular Ch. 18 on \"network design folklore\".\n* [[Gerard J. Holzmann]], ''Design and Validation of Computer Protocols''. Prentice Hall, 1991. {{ISBN|0-13-539925-4}}. Also available online at http://spinroot.com/spin/Doc/Book91.html\n\n==External links==\n* [https://web.archive.org/web/20040610001039/http://javvin.com/protocolsuite.html Javvin's Protocol Dictionary]\n* [https://www.ipcomm.de/protocols_en.html Overview of protocols in telecontrol field with OSI Reference Model]\n\n{{Telecommunications}}\n{{Computer science}}\n{{Authority control}}\n\n[[Category:Communications protocols| ]]\n[[Category:Data transmission]]\n[[Category:Network protocols|*]]",
            "slug": "communication-protocol",
            "date_updated": 1635496555900,
            "imported": "https://en.wikipedia.org/wiki/Communication_protocol"
        }
    ]
}