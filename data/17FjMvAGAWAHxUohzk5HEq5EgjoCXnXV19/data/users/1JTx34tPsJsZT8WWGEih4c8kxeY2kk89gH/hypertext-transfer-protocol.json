{
    "article": [
        {
            "title": "Hypertext Transfer Protocol",
            "text": "{{Short description|Application protocol for distributed, collaborative, hypermedia information systems}}\n{{pp-pc1}}\n{{Infobox protocol\n| image       = HTTP logo.svg\n| standard    = {{IETF RFC|1945}} HTTP/1.0 <small>(1996)</small><br />\n{{IETF RFC|2068}} HTTP/1.1 <small>(1997)</small><br />\n{{IETF RFC|2616}} HTTP/1.1 <small>(1999)</small><br />\n{{IETF RFC|7230}} HTTP/1.1: Message Syntax and Routing <small>(2014)</small><br />\n{{IETF RFC|7231}} HTTP/1.1: Semantics and Content <small>(2014)</small><br />\n{{IETF RFC|7232}} HTTP/1.1: Conditional Requests <small>(2014)</small><br />\n{{IETF RFC|7233}} HTTP/1.1: Range Requests <small>(2014)</small><br />\n{{IETF RFC|7234}} HTTP/1.1: Caching <small>(2014)</small><br />\n{{IETF RFC|7235}} HTTP/1.1: Authentication <small>(2014)</small><br />\n{{IETF RFC|7540}} HTTP/2 <small>(2015)</small><br />\n{{IETF RFC|7541}} HTTP/2: HPACK Header Compression <small>(2015)</small><br />\n{{IETF RFC|8164}} HTTP/2: Opportunistic Security for HTTP/2 <small>(2017)</small><br />\n{{IETF RFC|8336}} HTTP/2: The ORIGIN HTTP/2 Frame <small>(2018)</small><br />\n{{IETF RFC|8441}} HTTP/2: Bootstrapping WebSockets with HTTP/2 <small>(2018)</small><br />\n{{IETF RFC|8740}} HTTP/2: Using TLS 1.3 with HTTP/2 <small>(2020)</small>\n| developer   = initially [[CERN]]; [[IETF]], [[W3C]]\n| introdate   = {{Start date and age|1991|df=yes}}\n| newer       =\n}}\n{{HTTP}}\n{{IPstack}}\n\nThe '''Hypertext Transfer Protocol''' ('''HTTP''') is an [[application layer]] protocol in the [[Internet protocol suite]] model for distributed, collaborative, [[hypermedia]] information systems.<ref name=\"ietf2616\">{{cite IETF |rfc=2616 |title=Hypertext Transfer Protocol – HTTP/1.1 |first1=Roy T. |last1=Fielding |first2=James |last2=Gettys |first3=Jeffrey C. |last3=Mogul |first4=Henrik Frystyk |last4=Nielsen |first5=Larry |last5=Masinter |first6=Paul J. |last6=Leach |first7=Tim |last7=Berners-Lee |publisher=[[Internet Engineering Task Force|IETF]] |date=June 1999 |ref=ietf}}</ref> HTTP is the foundation of data communication for the [[World Wide Web]], where [[hypertext]] documents include [[hyperlink]]s to other resources that the user can easily access, for example by a [[Computer mouse|mouse]] click or by tapping the screen in a web browser.\n\nDevelopment of HTTP was initiated by [[Tim Berners-Lee]] at [[CERN]] in 1989 and summarized in a simple document describing the behavior of a client and a server using the first HTTP protocol version that was named 0.9.<ref name=\"HTTP/0.9-specifications\">{{Cite web|url=https://www.w3.org/pub/WWW/Protocols/HTTP/AsImplemented.html|title=The Original HTTP as defined in 1991|website=www.w3.org|publisher=World Wide Web Consortium|date=1991-01-01|access-date=2010-07-24|language=en|author=Tim Berner-Lee}}</ref>\n\nThat first version of HTTP protocol soon evolved into a more elaborated version that was the first draft toward a far future version 1.0.<ref name=\"HTTP/1.0-first-unofficial-draft\">{{Cite web|url=https://www.w3.org/Protocols/HTTP/HTTP2.html|title=Basic HTTP as defined in 1992|website=www.w3.org|publisher=World Wide Web Consortium|year=1992|access-date=2021-10-19|language=en|author=Tim Berner-Lee}}</ref>\n\nDevelopment of early HTTP [[Requests for Comments]] (RFCs) started a few years later and it was a coordinated effort by the [[Internet Engineering Task Force]] (IETF) and the [[World Wide Web Consortium]] (W3C), with work later moving to the IETF.\n\nHTTP/1 was finalized and fully documented (as version 1.0) in 1996.<ref>In {{IETF RFC|1945}}. That specification was then overcome by HTTP/1.1.</ref>  It evolved (as version 1.1) in 1997.<ref>In {{IETF RFC|2068}}. That specification was obsoleted by {{IETF RFC|2616}} in 1999, which was likewise replaced by {{IETF RFC|7230}} in 2014.</ref> <!-- As of 2021, about 30% of [[website]]s only support HTTP/1.  100% - 50.5% (HTTP/2) - 19.0% (HTTP/3) = 30.5% --> \n\n[[HTTP/2]] is a more efficient expression of HTTP's semantics \"on the wire\", and was published in 2015, and is used by 45% of websites; it is now supported by virtually all web browsers<ref>{{Cite web|title=Can I use... Support tables for HTML5, CSS3, etc|url=https://caniuse.com/#search=http2|access-date=2020-06-02|website=caniuse.com}}</ref> and major web servers over [[Transport Layer Security]] (TLS) using an [[Application-Layer Protocol Negotiation]] (ALPN) extension<ref name=\"rfc7301\">{{cite web|url=https://tools.ietf.org/html/rfc7301|title=Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension|date=July 2014|publisher=IETF|rfc=7301}}</ref> where [[TLS 1.2]] or newer is required.<ref>{{cite web|url=https://http2.github.io/http2-spec/#TLSUsage|title=Hypertext Transfer Protocol Version 2, Use of TLS Features|last1=Belshe|first1=M.|last2=Peon|first2=R.|access-date=2015-02-10|last3=Thomson|first3=M.}}</ref><ref>{{Cite web|first=David|last=Benjamin|title=Using TLS 1.3 with HTTP/2|url=https://tools.ietf.org/html/rfc8740.html|access-date=2020-06-02|website=tools.ietf.org|quote=This lowers the barrier for deploying TLS 1.3, a major security improvement over TLS 1.2.|language=en}}</ref>\n\n[[HTTP/3]] is the proposed successor to HTTP/2,<ref>{{cite web|url=https://tools.ietf.org/html/draft-ietf-quic-http-34|title=Hypertext Transfer Protocol Version 3 (HTTP/3)|last=Bishop|first=Mike|website=tools.ietf.org|language=en|date=February 2, 2021|access-date=2021-04-07}}</ref><ref>{{Cite news|url=https://www.zdnet.com/article/http-over-quic-to-be-renamed-http3/|title=HTTP-over-QUIC to be renamed HTTP/3 {{!}} ZDNet|last=Cimpanu|first=Catalin|work=ZDNet|access-date=2018-11-19|language=en}}</ref> and two-thirds of web browser users (both on desktop and mobile) can already use HTTP/3, on the 20% of websites that already support it; it uses [[QUIC]] instead of [[Transmission Control Protocol|TCP]] for the underlying transport protocol. Like HTTP/2, it does not obsolete previous major versions of the protocol. Support for HTTP/3 was added to [[Cloudflare]] and [[Google Chrome]] first,<ref>{{cite web|url=https://www.zdnet.com/article/cloudflare-google-chrome-and-firefox-add-http3-support/|title=Cloudflare, Google Chrome, and Firefox add HTTP/3 support|website=ZDNet|date=26 September 2019|access-date=27 September 2019|df=dmy-all|first=Catalin|last=Cimpanu}}</ref><ref>{{Cite web|url=https://blog.cloudflare.com/http3-the-past-present-and-future/|title=HTTP/3: the past, the present, and the future|date=2019-09-26|website=The Cloudflare Blog|language=en|access-date=2019-10-30}}</ref> and is also enabled in [[Firefox]].<ref>{{cite web |url=https://community.cloudflare.com/t/firefox-nightly-supports-http-3/127778 |title=Firefox Nightly supports HTTP 3 - General - Cloudflare Community |date=2019-11-19 |access-date=2020-01-23}}</ref>\n\n==Technical overview==\n[[File:Internet1.svg|thumb|right|[[URL]] beginning with the HTTP scheme and the [[World Wide Web|WWW]] domain name label]]\n\nHTTP functions as a [[request–response]] protocol in the [[client–server model]]. A [[web browser]], for example, may be the ''client'' and a [[Process (computing)|process]], named [[web server]], running on a computer [[Host (network)|hosting]] one or more [[website]]s may be the ''server''. The client submits an HTTP ''request'' message to the server. The server, which provides ''resources'' such as [[HTML]] files and other content, or performs other functions on behalf of the client, returns a ''response'' message to the client. The response contains completion status information about the request and may also contain requested content in its message body.\n\nA web browser is an example of a ''[[user agent]]'' (UA). Other types of user agent include the indexing software used by search providers ([[web crawler]]s), [[voice browser]]s, [[mobile app]]s, and other [[software]] that accesses, consumes, or displays web content.\n\nHTTP is designed to permit intermediate network elements to improve or enable communications between clients and servers. High-traffic websites often benefit from [[web cache]] servers that deliver content on behalf of [[upstream server]]s to improve response time. Web browsers cache previously accessed web resources and reuse them, whenever possible, to reduce network traffic. HTTP [[proxy server]]s at [[private network]] boundaries can facilitate communication for clients without a globally routable address, by relaying messages with external servers.\n\nTo allow intermediate HTTP nodes (proxy servers, web caches, etc.) to accomplish their functions, some of the [[List of HTTP header fields|HTTP headers]] (found in HTTP requests/responses) are managed '''hop-by-hop''' whereas other HTTP headers are managed '''end-to-end''' (managed only by the source client and by the target web server).\n\nHTTP is an [[application layer]] protocol designed within the framework of the [[Internet protocol suite]]. Its definition presumes an underlying and reliable [[transport layer]] protocol,<ref>{{cite IETF |rfc=2616 |sectionname=Overall Operation |section=1.4|title=RFC 2616 |page=12 |idanchor=ietf}}</ref> thus [[Transmission Control Protocol]] (TCP) is commonly used. However, HTTP can be adapted to use unreliable protocols such as the [[User Datagram Protocol]] (UDP), for example in [[HTTPU]] and [[Simple Service Discovery Protocol]] (SSDP).\n\n[[Web resource|HTTP resources]] are identified and located on the network by [[Uniform Resource Locator]]s (URLs), using the [[Uniform Resource Identifier]]s (URI's) schemes ''http'' and ''[[https]]''. As defined in {{IETF RFC|3986}}, URIs are encoded as [[hyperlink]]s in [[HTML]] documents, so as to form interlinked [[hypertext]] documents.\n\nHTTP/1.1 is a revision of the original HTTP (HTTP/1.0). In HTTP/1.0 a separate [[Connection-oriented communication|connection]] to the same server is made for every resource request. HTTP/1.1 instead can reuse a connection to make multiple resource requests (i.e. of HTML pages, frames, images, [[Client-side scripting|scripts]], [[Cascading Style Sheets|stylesheets]], etc.).\n\nHTTP/1.1 communications therefore experience less [[Latency (engineering)|latency]] as the establishment of TCP connections presents considerable overhead, specially under high traffic conditions.<ref>{{cite web |url=https://www.w3.org/Protocols/Classic.html |title=Classic HTTP Documents |publisher=W3.org |date=1998-05-14 |access-date=2010-08-01}}</ref>\n\n[[HTTP/2]] is a revision of previous HTTP/1.1 in order to mantain the same client-server model and the same protocol methods but with these differences in order:\n* to use a compressed binary representation of metadata (HTTP headers) instead of a textual one, so that headers require much less space;\n* to use a single TCP/IP (usually [[Encryption|encrypted]]) connection per accessed server domain instead of 2..8 TCP/IP connections;\n* to use one or more bidirectional streams per TCP/IP connection in which HTTP requests and responses are broken down and transmitted in small packets to solve the problem of the HOLB ([[Head-of-line blocking|head of line blocking]]; NOTE: in practice these streams are used as multiple TCP/IP sub-connections to [[Multiplexing|multiplex]] concurrent requests/responses, thus greately reducing the number of real TCP/IP connections on server side, from 2..8 per client to 1, and allowing many more clients to be served at once);\n* to add a push capability in order to allow server application to send data to clients whenever new data is available (without forcing clients to request periodically new data to server by using [[Polling (computer science)|polling]] methods).\n\nHTTP/2 communications therefore experience much less latency and, in most cases, even more speed than HTTP/1.1 communications.\n\n[[HTTP/3]] is a revision of previous HTTP/2 in order to use UDP + [[QUIC]] transport protocols instead of TCP/IP connections and so to overcome the problem of TCP/IP connection congestion that can block or slow down the data flow of all its streams.\n\n== History ==\n[[File:Tim Berners-Lee CP 2.jpg|thumb|[[Tim Berners-Lee]] ]]\n\nThe term [[hypertext]] was coined by [[Ted Nelson]] in '''1965''' in the [[Xanadu Project]], which was in turn inspired by [[Vannevar Bush]]'s 1930s vision of the microfilm-based information retrieval and management \"[[memex]]\" system described in his 1945 essay \"[[As We May Think]]\". [[Tim Berners-Lee]] and his team at [[CERN]] are credited with inventing the original HTTP, along with HTML and the associated technology for a [[web server]] and a client [[user interface]] called [[web browser]]. Berners-Lee first proposed the \"WorldWideWeb\" project in '''1989''', now known as the [[World Wide Web]].\n\n[[CERN httpd|The first web server]] went live in '''1990'''.<ref>{{Cite web|title=Invention Of The Web, Web History, Who Invented the Web, Tim Berners-Lee, Robert Cailliau, CERN, First Web Server|url=https://www.livinginternet.com/w/wi_lee.htm|access-date=2021-08-11|website=LivingInternet|language=en-US}}</ref><ref>{{Cite web|last=Berners-Lee|first=Tim|date=1990-10-02|title=daemon.c - TCP/IP based server for HyperText|url=https://www.w3.org/Daemon/old/V0.1/daemon.c|url-status=live|access-date=2021-08-11|website=www.w3.org}}</ref> The protocol used had only one method, namely GET, which would request a page from a server.<ref>{{cite web |last=Berners-Lee |first=Tim |title=HyperText Transfer Protocol |url=https://www.w3.org/History/19921103-hypertext/hypertext/WWW/Protocols/HTTP.html |publisher=[[World Wide Web Consortium]] |access-date=31 August 2010}}</ref> The response from the server was always an HTML page.<ref name=\"HTTP/0.9-specifications\"/>\n\n'''HTTP/0.9'''<br/>\nIn '''1991''' the first documented official version of HTTP was written as a simple document and this version was named HTTP/0.9.<ref name=\"HTTP/0.9-specifications\"/>\n\n'''HTTP/1.0-draft'''<br/>\nSince '''1992''' a new document was written to specify the evolution of the basic protocol towards its next full version. It supported both the simple request method of the 0.9 version and the full GET request that included the client HTTP version. This was the first of the many unofficial '''HTTP/1.0 drafts''' that preceded the final work on HTTP/1.0.<ref name=\"HTTP/1.0-first-unofficial-draft\"/>\n\n'''W3C HTTP Working Group'''<br/>\nAfter having decided that new features of HTTP protocol were required and that they had to be fully documented as official [[Request for Comments|RFC]]s, in early '''1995''' the '''HTTP Working Group''' (HTTP WG, led by [[Dave Raggett]]) was constituted with the aim to standardize and expand the protocol with extended operations, extended negotiation, richer meta-information, tied with a security protocol which became more efficient by adding additional methods and [[List of HTTP header fields|header fields]].<ref name=\"raggettprofile\">{{Cite web |last=Raggett |first=Dave |title=Dave Raggett's Bio |url=https://www.w3.org/People/Raggett/profile.html|publisher=World Wide Web Consortium |access-date=11 June 2010}}</ref><ref>{{cite web |last=Raggett |first=Dave |title=Hypertext Transfer Protocol Working Group |url=https://www.w3.org/Arena/webworld/httpwgcharter.html |publisher=World Wide Web Consortium |access-date=29 September 2010 |first2=Tim |last2=Berners-Lee}}</ref>\n\nThe HTTP WG planned to revise and publish new versions of the protocol as HTTP/1.0 and HTTP/1.1 within 1995, but, because of the many revisions, that timeline lasted much more than one year.<ref>{{Cite web |last=Raggett |first=Dave |title=HTTP WG Plans |url=https://www.w3.org/Arena/webworld/httpwgplans.html |publisher=World Wide Web Consortium |access-date=29 September 2010}}</ref>\n\nThe HTTP WG planned also to specify a far future version of HTTP called HTTP-NG (HTTP Next Generation) that would have solved all remaining problems, of previous versions, related to performances, low latency responses, etc. but this work started only a few years later and it was never completed.\n\n'''HTTP/1.0'''<br/>\nIn '''May 1996''' {{IETF RFC|1945}} was published as a final HTTP/1.0 revision of what had been used in previous 4 years as a pre-standard HTTP/1.0-draft which was already used by many web browsers and web servers.\n\nIn early 1996 developers started to even include unofficial extensions of the HTTP/1.0 protocol (i.e. keep-alive connections, etc.) into their products by using drafts of the upcoming HTTP/1.1 specifications.<ref name=\"HTTP-Persistent-Connections\"/>\n\n'''HTTP/1.1'''<br/>\nSince early 1996, major web browsers and web server developers also started to implement new features specified by pre-standard HTTP/1.1 drafts specifications.  End-user adoption of the new versions of browsers and servers was rapid. In March 1996, one web hosting company reported that over 40% of browsers in use on the Internet used the new HTTP/1.1 header \"Host\" to enable [[virtual hosting]]. That same web hosting company reported that by June 1996, 65% of all browsers accessing their servers were pre-standard HTTP/1.1 compliant.<ref>{{Cite web |work=Webcom.com Glossary entry |title=HTTP/1.1 |url=https://www.webcom.com/glossary/http1.1.shtml |archive-url=https://webarchive.loc.gov/all/20011121001051/https://www.webcom.com/glossary/http1.1.shtml |url-status=dead |archive-date=2001-11-21 |access-date=2009-05-29 }}</ref>\n\nIn '''January 1997''' {{IETF RFC|2068}} was officially released as HTTP/1.1 specifications.\n\nIn '''June 1999''' {{IETF RFC|2616}} was released to include all improvements and updates based on previous (obsolete) HTTP/1.1 specifications.\n\n'''W3C HTTP-NG Working Group'''<br/>\nResuming the old 1995 plan of previous HTTP Working Group, in '''1997''' an '''HTTP-NG Working Group''' was formed to develop a new HTTP protocol named HTTP-NG (HTTP New Generation).  A few proposals / drafts were produced for the new protocol to use multiplexing of HTTP transactions inside a single TCP/IP connection but in '''1999 the group stopped its activity''' passing the technical problems to IETF.<ref name=\"HTTP-NG-Working-Group\">{{Cite web|url=https://www.w3.org/Protocols/HTTP-NG/|title=HTTP-NG Working Group|website=www.w3.org|publisher=World Wide Web Consortium|year=1997|access-date=2021-10-19|language=en|author=}}</ref>\n\n'''IETF HTTP Working Group restarted'''<br/>\nIn '''2007''', the IETF '''[https://httpwg.org/ HTTP Working Group]''' (HTTP WG bis or HTTPbis) was restarted firstly to revise and clarify previous HTTP/1.1 specifications and secondly to write and refine future HTTP/2 specifications (named httpbis).<ref name=\"HTTP-WG-2\">{{Cite web|url=https://httpwg.org/|title=HTTP Working Group|website=httpwg.org|publisher=IETF|year=2007|access-date=2021-10-19|language=en|author=Web Administrator}}</ref>\n<ref name=\"HTTP-WG-httpbis\">{{Cite web|url=https://datatracker.ietf.org/wg/httpbis/charter/|title=HTTP Working Group: charter httpbis|website=datatracker.ietf.org|publisher=IETF|year=2007|access-date=2021-10-19|language=en|author=Web Administrator}}</ref>\n\n'''HTTP/1.1 Final Update'''<br/>\nIn '''June 2014''', the HTTP Working Group released an updated six-part HTTP/1.1 specification obsoleting {{IETF RFC|2616}}:\n\n* {{IETF RFC|7230}}, ''HTTP/1.1: Message Syntax and Routing''\n* {{IETF RFC|7231}}, ''HTTP/1.1: Semantics and Content''\n* {{IETF RFC|7232}}, ''HTTP/1.1: Conditional Requests''\n* {{IETF RFC|7233}}, ''HTTP/1.1: Range Requests''\n* {{IETF RFC|7234}}, ''HTTP/1.1: Caching''\n* {{IETF RFC|7235}}, ''HTTP/1.1: Authentication''\n\n'''SPDY: an unofficial HTTP protocol developed by Google'''<br/>\nIn '''2009''' [[Google]], a private company, announced that it had developed and tested a new HTTP binary protocol named [[SPDY]]. The implicit aim was to greately speed up web traffic (specially between future web browsers and its servers).\n\nSPDY was indeed much faster than HTTP/1.1 in many tests and so it was fastly adopted by [[Chromium (web browser)|Chromium]] and then by other major web browsers.<ref name=\"SPDY-vs-HTTP/1.1\">{{Cite web|url=http://dev.chromium.org/spdy/spdy-whitepaper|title=SPDY: An experimental protocol for a faster web|website=dev.chromium.org|publisher=Google|date=2009-11-01|access-date=2021-10-19|language=en|author=}}</ref>\n\nSome of the ideas about multiplexing HTTP streams over a single TCP/IP connection were taken from various sources, including the work of W3C HTTP-NG Working Group.\n\n'''HTTP/2'''<br/>\nIn '''January-March 2012''' HTTP Working Group (HTTPbis) announced the need to start to focus on a new HTTP/2 protocol (while finishing the revision of HTTP/1.1 specifications), maybe taking in consideration ideas and work done for SPDY.<ref name=\"HTTPbis-rechartering-prop\">{{Cite web|url=https://lists.w3.org/Archives/Public/ietf-http-wg/2012JanMar/0098.html|title=Rechartering httpbis|publisher=IETF; HTTP WG|date=2012-01-24|access-date=2021-10-19|language=en|author=}}</ref> <ref name=\"HTTPbis-rechartering-act\">{{Cite web|url=https://lists.w3.org/Archives/Public/ietf-http-wg/2012JanMar/0902.html|title=WG Action: RECHARTER: Hypertext Transfer Protocol Bis (httpbis)|publisher=IETF; HTTP WG|date=2012-03-19|access-date=2021-10-19|language=en|author=IESG Secretary}}</ref>\n\nAfter a few months about what to do to develop a new version of HTTP, it was decided to derive it from SPDY.<ref name=\"HTTP/2-introduction\">{{Cite web|url=https://developers.google.com/web/fundamentals/performance/http2|title=High Performance Browser Networking: Introduction to HTTP/2\"|website=developers.google.com|publisher=Google|date=2019-09-03|access-date=2021-10-19|language=en|author1=Ilya Grigorik|author2=Surma}}</ref>\n\nIn '''May 2015''' [[HTTP/2]] was published as {{IETF RFC|7540}} and fastly adopted by all web browsers already supporting SPDY and more slowly by web servers.\n\n'''HTTP/0.9 Deprecation'''<br/>\nSince 2016 many product managers and developers of user agents (browsers, etc.) and web servers have begun planning to gradually '''deprecate and dismiss support for HTTP/0.9''' protocol, mainly for the following reasons:<ref name=\"HTTP/0.9-chrome-deprecated\">{{Cite web|url=https://groups.google.com/a/chromium.org/g/blink-dev/c/OdKnpLlvVUo/m/1EpFGVUjAwAJ|title=Intent to Deprecate and Remove: HTTP/0.9 Support|website=groups.google.com|date=2016-06-30|access-date=2021-10-15|language=en|author=Matt Menke}}</ref>\n* it is clearly obsolete because it is so simple that nobody bothered to even write an RFC document (there is only the original document);<ref name=\"HTTP/0.9-specifications\"/>\n* it has no HTTP headers and it lacks many other features too that nowadays are really required for minimal security reasons;\n* it has not been really used since 1999..2000 (because of HTTP/1.0 and HTTP/1.1);\n* it looks like that it is randomly used only by some very old network hardware, i.e. [[Router (computing)|routers]], etc.\n\nNOTE: in 2021 HTTP/0.9 support has not been officially deprecated and it is still present (even if it is usually disabled) in many web servers and browsers (for server responses only) so it's not clear how long this dismission will take, maybe it will be first completed in user agents (browsers, etc.) and then in web servers.\n\n'''HTTP/3'''<br/>\nIn '''2020''' [[HTTP/3]] first drafts have been published and major web browsers and web servers started to adopt it.\n\n\n'''Summary of HTTP milestone versions'''<br/>\n\n{| class=\"wikitable\"\n|-\n!Year\n!Version\n|-\n|1991\n|HTTP/0.9\n|-\n|1996\n|HTTP/1.0\n|-\n|1997\n|HTTP/1.1\n|-\n|2015\n|[[HTTP/2]]\n|-\n|2020 <small style=\"font-weight: bold\">(draft)</small>\n|[[HTTP/3]]\n|}\n\n== HTTP session ==\nAn HTTP session is a sequence of network request–response transactions. An HTTP client initiates a request by establishing a [[Transmission Control Protocol]] (TCP) connection to a particular [[TCP and UDP port|port]] on a server (typically port 80, occasionally port 8080; see [[List of TCP and UDP port numbers]]). An HTTP server listening on that port waits for a client's request message. Upon receiving the request, the server sends back a status line, such as \"{{nowrap|HTTP/1.1 200 OK}}\", and a message of its own. The body of this message is typically the requested resource, although an error message or other information may also be returned.<ref name=\"ietf2616\" />\n\n=== Persistent connections ===\n{{Main|HTTP persistent connection}}\nIn HTTP/0.9 the TCP/IP '''connection''' is always '''closed''' after server response has been sent.\n\nIn HTTP/1.0, as stated in RFC 1945, the TCP/IP '''connection''' should always be '''closed''' by server after a response has been sent. NOTE: since late 1996, some developers of popular HTTP/1.0 browsers and servers (specially those who had planned support for HTTP/1.1 too), started to deploy (as an unofficial extension) a sort of keep-alive-mechanism (by using new HTTP headers) in order to keep the TCP/IP connection open for more than a request/response pair and so to speed up the exchange of multiple requests/responses.<ref name=\"HTTP-Persistent-Connections\">{{Cite web|url=https://www.oreilly.com/library/view/http-the-definitive/1565925092/ch04s05.html|title=HTTP: The Definitive Guide. (excerpt of chapter: \"Persistent Connections\")|author1=David Gourley|author2=Brian Totty|author3=Marjorie Sayer|author4=Anshu Aggarwal|author5=Sailu Reddy|language=en|publisher=O'Reilly Media, inc.|isbn=9781565925090|year=2002|access-date=2021-10-18}}</ref>\n\nIn HTTP/1.1 a keep-alive-mechanism was officially introduced so that a connection could be reused for more than one request/response. Such '''persistent connections''' reduce request [[latency (engineering)|latency]] perceptibly because the client does not need to re-negotiate the TCP 3-Way-Handshake connection after the first request has been sent. Another positive side effect is that, in general, the connection becomes faster with time due to TCP's [[TCP congestion control#Slow start|slow-start]]-mechanism.\n\nHTTP/1.1 added also [[HTTP pipelining]] in order to further reduce lag time when using persistent connections by allowing clients to send multiple requests before waiting for each response.  This optimization was never considered really safe because a few web servers and many [[proxy server]]s, specially transparent proxy servers placed in Internet / [[Intranet]]s between clients and servers, did not handled pipelined requests properly (they served only the first request discarding the others or they closed the connection because they saw more data after the first request, etc.).  Besides this only GET and HEAD requests could be pipelined in a safe and idempotent mode.  After many years of struggling with the problems introduced by enabling pipelining, this feature was first disabled and then removed from most browsers also because of the announced adoption of HTTP/2.\n\nHTTP/2 extended the usage of '''persistent connections''' by '''multiplexing''' many concurrent requests/responses through a single TCP/IP connection.\n\nHTTP/3 does not use TCP/IP connections but UDP + QUIC to avoid the problem of TCP/IP congestion of a connection.\n\n=== Content retrieval optimizations ===\nIn HTTP/0.9 a requested resource was always sent entirely.\n\nHTTP/1.0 added headers to manage resources cached by client in order to allow '''conditional GET requests'''; in practice a server has to return the entire content of the requested resource only if its last modified time is not known by client or if it changed since last full response to GET request.\n\nHTTP/1.0 added header \"Content-Encoding\" to specify whether the returned content of a resource was or was not '''compressed'''.\n\nIn HTTP/1.0, if the total length of the content of a resource was not known in advance (i.e. because it was dynamically generated, etc.) then the header <code>\"Content-Length: number\"</code> was not present in HTTP headers and the client assumed that when server closed the connection, the content had been entirely sent.  This mechanism could not distinguish between a resource transfer successfully completed and an interrupted one (because of a server / network error or something else).\n\nHTTP/1.1 added new headers to better manage the conditional retrieval of cached resources.\n\nHTTP/1.1 introduced [[chunked transfer encoding]] to allow content to be streamed in chunks in order to reliably send it even when the server does not know in advance its length (i.e. because it is dynamically generated, etc.).\n\nHTTP/1.1 added also [[Byte serving|byte range serving]], where a client can request only one or more portions (ranges of bytes) of a resource (i.e. the first part, a part in the middle or in the end of the entire content, etc.) and the server usually sends only the requested part(s).  This is useful to resume an interrupted download (when a file is really big), when only a part of a content has to be shown or dynamically added to the already visible part by a browser (i.e. only the first or the following n comments of a web page) in order to spare time, bandwidth and system resources, etc.\n\nHTTP/2 and HTTP/3 have kept the above mentioned features of HTTP/1.1.\n\n=== HTTP session state ===\nHTTP is a [[stateless protocol]]. A stateless protocol does not require the [[HTTP server]] to retain information or status about each user for the duration of multiple requests. However, some [[web application]]s implement states or [[Session (computer science)|server side sessions]] using for instance [[HTTP cookie]]s or hidden [[variable (computer science)|variable]]s within [[Form (web)|web form]]s.\n\n== HTTP authentication ==\nHTTP provides multiple authentication schemes such as [[basic access authentication]] and [[digest access authentication]] which operate via a challenge–response mechanism whereby the server identifies and issues a challenge before serving the requested content.\n\nHTTP provides a general framework for access control and authentication, via an extensible set of challenge–response authentication schemes, which can be used by a server to challenge a client request and by a client to provide authentication information.<ref name=\"ietf7235\">{{cite IETF |rfc=7235 |title=Hypertext Transfer Protocol (HTTP/1.1): Authentication |first1=Roy T. |last1=Fielding |first2=Julian F. |last2=Reschke |publisher=IETF |date=June 2014 |ref=ietf}}</ref>\n\n=== Authentication realms ===\nThe HTTP Authentication specification also provides an arbitrary, implementation-specific construct for further dividing resources common to a given root [[Uniform Resource Identifier|URI]]. The realm value string, if present, is combined with the canonical root URI to form the protection space component of the challenge. This in effect allows the server to define separate authentication scopes under one root URI.<ref name=\"ietf7235\" />\n\n== Request messages{{anchor|Request_message}} ==\n=== Request syntax ===\nA client sends ''request messages'' to the server, which consist of:<ref name=\"rfc7230-3\">{{cite IETF |rfc=7230 |sectionname=Message format |section=3 |page=19 |title=RFC 7230: HTTP/1.1 Message Syntax and Routing |idanchor=ietf}}</ref>\n\n* a request line, consisting of the case-sensitive request method, a [[Space (punctuation)|space]], the request target, another space, the protocol version, a [[carriage return]], and a [[line feed]], e.g.:\n <code>GET /images/logo.png HTTP/1.1</code>\n* zero or more [[HTTP request header field|request header fields]] (at least 1 or more headers in case of HTTP/1.1), each consisting of the case-insensitive field name, a colon, optional leading [[Whitespace (computer science)|whitespace]], the field value, an optional trailing whitespace and ending with a carriage return and a line feed, e.g.:\n <code>Host: www.example.com</code>\n <code>Accept-Language: en</code>\n* an empty line, consisting of a carriage return and a line feed;\n* an optional [[HTTP message body|message body]].\n\n\nIn the HTTP/1.1 protocol, all header fields except <code>Host: hostname</code> are optional.\n\nA request line containing only the path name is accepted by servers to maintain compatibility with HTTP clients before the HTTP/1.0 specification in {{IETF RFC|1945}}.<ref name=\"apacheweek_com-http11\">{{cite web |title=Apache Week. HTTP/1.1 |url=https://www.apacheweek.com/features/http11}} 090502 apacheweek.com</ref>\n\n=== Request methods ===\n[[File:Http request telnet ubuntu.png|thumb|right|An HTTP/1.1 request made using telnet. The [[HTTP request|request]] message, [[HTTP response|response]] header section, and response body are highlighted.]]\nHTTP defines methods (sometimes referred to as ''verbs'', but nowhere in the specification does it mention ''verb'', nor is OPTIONS or HEAD a verb) to indicate the desired action to be performed on the identified resource. What this resource represents, whether pre-existing data or data that is generated dynamically, depends on the implementation of the server. Often, the resource corresponds to a file or the output of an executable residing on the server. The HTTP/1.0 specification<ref>{{cite IETF |rfc=1945 |title=Hypertext Transfer Protocol – HTTP/1.0 |first1=Tim |last1=Berners-Lee |first2=Roy T. |last2=Fielding |first3=Henrik Frystyk |last3=Nielsen |publisher=IETF |sectionname=Method Definitions |section=8 |pages=30–32}}</ref> defined the GET, HEAD and POST methods, and the HTTP/1.1 specification<ref>{{cite IETF |rfc=2616 |sectionname=Method Definitions |section=9 |title=RFC 2616|pages=51–57 |idanchor=ietf}}</ref> added five new methods: PUT, DELETE, CONNECT, OPTIONS, and TRACE. By being specified in these documents, their semantics are well-known and can be depended on. Any client can use any method and the server can be configured to support any combination of methods. If a method is unknown to an intermediate, it will be treated as an unsafe and [[idempotence|non-idempotent]] method. There is no limit to the number of methods that can be defined and this allows for future methods to be specified without breaking existing infrastructure. For example, [[WebDAV]] defined seven new methods and {{IETF RFC|5789}} specified the [[Patch verb|PATCH]] method.\n\nMethod names are case sensitive.<ref>{{cite web|url=https://tools.ietf.org/html/rfc7230#section-3.1.1 |title=RFC-7210 section 3.1.1 |publisher=Tools.ietf.org |access-date=2019-06-26}}</ref><ref>{{cite web|url=https://tools.ietf.org/html/rfc7231#section-4.1 |title=RFC-7231 section 4.1 |publisher=Tools.ietf.org |access-date=2019-06-26}}</ref> This is in contrast to HTTP header field names which are case-insensitive.<ref>{{cite web|url=https://tools.ietf.org/html/rfc7230#section-3.2 |title=RFC-7230 section 3.2 |publisher=Tools.ietf.org |access-date=2019-06-26}}</ref>\n\n; GET: The GET method requests that the target resource transfers a representation of its state. GET requests should only [[Data retrieval|retrieve data]] and should have no other effect. (This is also true of some other HTTP methods.)<ref name=\"ietf2616\" /> The [[W3C]] has published guidance principles on this distinction, saying, \"[[Web application]] design should be informed by the above principles, but also by the relevant limitations.\"<ref>{{cite web |last=Jacobs |first=Ian |title=URIs, Addressability, and the use of HTTP GET and POST |url=https://www.w3.org/2001/tag/doc/whenToUseGet.html#checklist |work=Technical Architecture Group finding |publisher=W3C |access-date=26 September 2010 |year=2004}}</ref> See [[#Safe methods|safe methods]] below.\n\n; HEAD: The HEAD method requests that the target resource transfers a representation of its state, like for a GET request, but without the representation data enclosed in the response body. This is useful for retrieving the representation metadata in the response header, without having to transfer the entire representation.\n\n; POST: The [[POST (HTTP)|POST method]] requests that the target resource processes the representation enclosed in the request according to the semantics of the target resource. For example, it is used for posting a message to an [[Internet forum]], subscribing to a [[mailing list]], or completing an [[online shopping]] transaction.<ref>{{cite IETF |rfc=2616 |sectionname=POST |section=9.5|title=RFC 2616 |page=54 |idanchor=ietf}}</ref>\n\n; PUT: The PUT method requests that the target resource creates or updates its state with the state defined by the representation enclosed in the request.<ref>{{cite IETF |rfc=2616 |sectionname=PUT |section=9.6|title=RFC 2616 |page=55 |idanchor=ietf}}</ref>\n\n; DELETE: The DELETE method requests that the target resource deletes its state.\n\n; CONNECT: The CONNECT method request that the intermediary establishes a [[tunneling protocol|TCP/IP tunnel]] to the origin server identified by the request target. It is often used to secure connections through one or more [[HTTP proxy|HTTP proxies]] with [[Transport Layer Security|TLS]].<ref name=\"rfc2616.9.9\">{{cite IETF |title=Hypertext Transfer Protocol – HTTP/1.1 |rfc=2616 |sectionname=CONNECT |section=9.9 |page=57 |date=June 1999 |publisher=IETF |access-date=23 February 2014}}</ref><ref>{{cite IETF |rfc=2817 |title=Upgrading to TLS Within HTTP/1.1 |first1=Rohit |last1=Khare |first2=Scott |last2=Lawrence |date=May 2000 |publisher=IETF}}</ref><ref>{{cite web |url=https://www.kb.cert.org/vuls/id/150227 |title=Vulnerability Note VU#150227: HTTP proxy default configurations allow arbitrary TCP connections |access-date=2007-05-10 |date=2002-05-17 |publisher=[[CERT Coordination Center|US-CERT]]}}</ref> See [[HTTP tunnel#HTTP CONNECT method|HTTP CONNECT method]].\n\n; OPTIONS: The OPTIONS method requests that the target resource transfers the HTTP methods that it supports. This can be used to check the functionality of a web server by requesting '*' instead of a specific resource.\n\n; TRACE: The TRACE method requests that the target resource transfers the received request in the response body. That way a client can see what (if any) changes or additions have been made by intermediaries.\n\n; PATCH: The PATCH method requests that the target resource modifies its state according to the partial update defined in the representation enclosed in the request.<ref>{{cite IETF |rfc=5789 |title=PATCH Method for HTTP |first1=Lisa |last1=Dusseault |first2=James M. |last2=Snell |date=March 2010 |publisher=IETF}}</ref>\nAll general-purpose HTTP servers are required to implement at least the GET and HEAD methods, and all other methods are considered optional by the specification.<ref>{{cite IETF |rfc=2616 |sectionname=Method |section=5.1.1|title=RFC 2616 |page=36 |idanchor=ietf}}</ref>\n\n{| class=\"wikitable sortable\" style=\"text-align: center; width: auto; table-layout: fixed;\"\n|+Properties of request methods\n|-\n!scope=\"col\"| Request method\n!scope=\"col\"| RFC\n!scope=\"col\"| Request has payload body\n!scope=\"col\"| Response has payload body\n!scope=\"col\"| Safe\n!scope=\"col\"| Idempotent\n!scope=\"col\"| Cacheable\n|-\n!scope=\"row\"| GET\n| {{IETF RFC|7231}}\n| {{Optional}}\n| {{Yes}}\n| {{Yes}}\n| {{Yes}}\n| {{Yes}}\n|-\n!scope=\"row\"| HEAD\n| {{IETF RFC|7231}}\n| {{Optional}}\n| {{No}}\n| {{Yes}}\n| {{Yes}}\n| {{Yes}}\n|-\n!scope=\"row\"| POST\n| {{IETF RFC|7231}}\n| {{Yes}}\n| {{Yes}}\n| {{No}}\n| {{No}}\n| {{Yes}}\n|-\n!scope=\"row\"| PUT\n| {{IETF RFC|7231}}\n| {{Yes}}\n| {{Yes}}\n| {{No}}\n| {{Yes}}\n| {{No}}\n|-\n!scope=\"row\"| DELETE\n| {{IETF RFC|7231}}\n| {{Optional}}\n| {{Yes}}\n| {{No}}\n| {{Yes}}\n| {{No}}\n|-\n!scope=\"row\"| CONNECT\n| {{IETF RFC|7231}}\n| {{Optional}}\n| {{Yes}}\n| {{No}}\n| {{No}}\n| {{No}}\n|-\n!scope=\"row\"| OPTIONS\n| {{IETF RFC|7231}}\n| {{Optional}}\n| {{Yes}}\n| {{Yes}}\n| {{Yes}}\n| {{No}}\n|-\n!scope=\"row\"| TRACE\n| {{IETF RFC|7231}}\n| {{No}}\n| {{Yes}}\n| {{Yes}}\n| {{Yes}}\n| {{No}}\n|-\n!scope=\"row\"| PATCH\n| {{IETF RFC|5789}}\n| {{Yes}}\n| {{Yes}}\n| {{No}}\n| {{No}}\n| {{No}}\n|}\n\n==== Safe methods ====\n\nA request method is ''safe'' if a request with that method has no intended effect on the server. The methods GET, HEAD, OPTIONS, and TRACE are defined as safe. In other words, safe methods are intended to be [[Command–query separation|read-only]]. They do not exclude [[Side effect (computer science)|side effects]] though, such as appending request information to a [[Server log|log file]] or charging an [[Web banner|advertising account]], since they are not requested by the client, by definition.\n\nIn contrast, the methods POST, PUT, DELETE, CONNECT, and PATCH are not safe. They may modify the state of the server or have other effects such as sending an [[email]]. Such methods are therefore not usually used by conforming [[Internet bot|web robots]] or web crawlers; some that do not conform tend to make requests without regard to context or consequences.\n\nDespite the prescribed safety of ''GET'' requests, in practice their handling by the server is not technically limited in any way. Therefore, careless or deliberate programming can cause non-trivial changes on the server. This is discouraged, because it can cause problems for [[web caching]], [[search engines]] and other automated agents, which can make unintended changes on the server. For example, a website might allow deletion of a resource through a URL such as ''<nowiki>https://example.com/article/1234/delete</nowiki>'', which, if arbitrarily fetched, even using ''GET'', would simply delete the article.<ref name=\"oreilly-get-rails\">{{cite book |last=Ediger |first=Brad |date=2007-12-21 |title=Advanced Rails: Building Industrial-Strength Web Apps in Record Time |url=https://shop.oreilly.com/product/9780596510329.do |publisher=O'Reilly Media, Inc. |page=188 |isbn= 978-0596519728 |quote=A common mistake is to use GET for an action that updates a resource. [...] This problem came into the Rails public eye in 2005, when the Google Web Accelerator was released.}}</ref>\n\nOne example of this occurring in practice was during the short-lived [[Google Web Accelerator]] [[Beta test|beta]], which prefetched arbitrary URLs on the page a user was viewing, causing records to be automatically altered or deleted ''en masse''. The beta was suspended only weeks after its first release, following widespread criticism.<ref>{{cite web |url=https://blogs.adobe.com/cantrell/archives/2005/06/what_have_we_le.html |title=What Have We Learned From the Google Web Accelerator? |last=Cantrell |first=Christian |archive-url=https://web.archive.org/web/20170819161233/https://blogs.adobe.com/cantrell/archives/2005/06/what_have_we_le.html |archive-date=2017-08-19 |date=2005-06-01 |website=Adobe Blogs |publisher=Adobe |access-date=2018-11-19 |url-status=dead }}</ref><ref name=\"oreilly-get-rails\" />\n\n==== Idempotent methods ====\n{{see also|Idempotent#Computer science meaning}}\nA request method is ''idempotent'' if multiple identical requests with that method have the same intended effect as a single such request. The methods PUT and DELETE, and safe methods are defined as idempotent.\n\nIn contrast, the methods POST, CONNECT, and PATCH are not necessarily idempotent, and therefore sending an identical POST request multiple times may further modify the state of the server or have further effects such as sending an [[email]]. In some cases this may be desirable, but in other cases this could be due to an accident, such as when a user does not realize that their action will result in sending another request, or they did not receive adequate feedback that their first request was successful. While [[web browser]]s may show [[alert dialog box]]es to warn users in some cases where reloading a page may re-submit a POST request, it is generally up to the web application to handle cases where a POST request should not be submitted more than once.\n\nNote that whether a method is idempotent is not enforced by the protocol or web server. It is perfectly possible to write a web application in which (for example) a database insert or other non-idempotent action is triggered by a GET or other request. Ignoring this recommendation, however, may result in undesirable consequences, if a [[user agent]] assumes that repeating the same request is safe when it is not.\n\n==== Cacheable methods ====\n{{see also|Web cache}}\nA request method is ''cacheable'' if responses to requests with that method may be stored for future reuse. The methods GET, HEAD, and POST are defined as cacheable.\n\nIn contrast, the methods PUT, DELETE, CONNECT, OPTIONS, TRACE, and PATCH are not cacheable.\n\n=== Request header fields ===\n{{see also|List of HTTP header fields#Request fields}}\nRequest header fields allow the client to pass additional information beyond the request line, acting as request modifiers (similarly to the parameters of a procedure). They give information about the client, about the target resource, or about the expected handling of the request.\n\n== Response messages ==\n=== Response syntax ===\nA server sends ''response messages'' to the client, which consist of:<ref name=\"rfc7230-3\" />\n\n* a status line, consisting of the protocol version, a [[Space (punctuation)|space]], the [[List of HTTP status codes|response status code]], another space, a possibly empty reason phrase, a [[carriage return]] and a [[line feed]], e.g.:\n <code>HTTP/1.1 200 OK</code>\n* zero or more [[HTTP response header field|response header fields]], each consisting of the case-insensitive field name, a colon, optional leading [[Whitespace (computer science)|whitespace]], the field value, an optional trailing whitespace and ending with a carriage return and a line feed, e.g.:\n <code>Content-Type: text/html</code>\n* an empty line, consisting of a carriage return and a line feed;\n* an optional [[HTTP message body|message body]].\n\n=== Response status codes ===\n{{See also|List of HTTP status codes}}\nIn HTTP/1.0 and since, the first line of the HTTP response is called the ''status line'' and includes a numeric ''status code'' (such as \"[[HTTP 404|404]]\") and a textual ''reason phrase'' (such as \"Not Found\"). The response status code is a three-digit integer code representing the result of the server's attempt to understand and satisfy the client's corresponding request. The way the client handles the response depends primarily on the status code, and secondarily on the other response header fields. Clients may not understand all registered status codes but they must understand their class (given by the first digit of the status code) and treat an unrecognized status code as being equivalent to the x00 status code of that class.\n\nThe standard ''reason phrases'' are only recommendations, and can be replaced with \"local equivalents\" at the [[web developer]]'s discretion. If the status code indicated a problem, the user agent might display the ''reason phrase'' to the user to provide further information about the nature of the problem. The standard also allows the user agent to attempt to interpret the ''reason phrase'', though this might be unwise since the standard explicitly specifies that status codes are machine-readable and ''reason phrases'' are human-readable.\n\nThe first digit of the status code defines its class:\n\n; <code>1XX</code> (informational): The request was received, continuing process.\n\n; <code>2XX</code> (successful): The request was successfully received, understood, and accepted.\n\n; <code>3XX</code> (redirection): Further action needs to be taken in order to complete the request.\n\n; <code>4XX</code> (client error): The request contains bad syntax or cannot be fulfilled.\n\n; <code>5XX</code> (server error): The server failed to fulfill an apparently valid request.\n\n=== Response header fields ===\n{{see also|List of HTTP header fields#Response fields}}\nThe response header fields allow the server to pass additional information beyond the status line, acting as response modifiers. They give information about the server or about further access to the target resource or related resources.\n\nEach response header field has a defined meaning which can be further refined by the semantics of the request method or response status code.\n\n== Encrypted connections ==\nThe most popular way of establishing an encrypted HTTP connection is [[HTTPS]].<ref>{{cite book |last=Canavan |first=John |title=Fundamentals of Networking Security |year=2001 |publisher=Artech House |location=Norwood, MA |isbn=9781580531764 |pages=82–83}}</ref> Two other methods for establishing an encrypted HTTP connection also exist: [[Secure Hypertext Transfer Protocol]], and using the [[HTTP/1.1 Upgrade header]] to specify an upgrade to TLS. Browser support for these two is, however, nearly non-existent.<ref>{{cite web |last1=Zalewski |first1=Michal |title=Browser Security Handbook |url=https://code.google.com/p/browsersec/wiki/Part1#True_URL_schemes |access-date=30 April 2015}}</ref><ref>{{cite web |title=Chromium Issue 4527: implement RFC 2817: Upgrading to TLS Within HTTP/1.1 |url=https://code.google.com/p/chromium/issues/detail?id=4527 |access-date=30 April 2015}}</ref><ref>{{cite web |title=Mozilla Bug 276813 – [RFE] Support RFC 2817 / TLS Upgrade for HTTP 1.1 |url=https://bugzilla.mozilla.org/show_bug.cgi?id=276813 |access-date=30 April 2015}}</ref>\n\n== Example session ==\nBelow is a sample conversation between an HTTP client and an HTTP server running on [[example.com|www.example.com]], port 80.\n\n=== Client request ===\n<syntaxhighlight lang=\"http\">\nGET / HTTP/1.1\nHost: www.example.com\nUser-Agent: Mozilla/5.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\nAccept-Language: en-GB,en;q=0.5\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\n\n</syntaxhighlight>\n\nA client request (consisting in this case of the request line and a few headers that can be reduced to only the <code>\"Host: hostname\"</code> header) is followed by a blank line, so that the request ends with a double end of line, each in the form of a [[carriage return]] followed by a [[line feed]]. The <code>\"Host: hostname\"</code> header value distinguishes between various [[Domain Name System|DNS]] names sharing a single [[IP address]], allowing name-based [[virtual hosting]]. While optional in HTTP/1.0, it is mandatory in HTTP/1.1. (A \"/\" (slash) will usually fetch a [[Webserver_directory_index|/index.html]] file if there is one.)\n\n=== Server response ===\n<syntaxhighlight lang=\"http\">\nHTTP/1.1 200 OK\nDate: Mon, 23 May 2005 22:38:34 GMT\nContent-Type: text/html; charset=UTF-8\nContent-Length: 155\nLast-Modified: Wed, 08 Jan 2003 23:11:55 GMT\nServer: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)\nETag: \"3f80f-1b6-3e1cb03b\"\nAccept-Ranges: bytes\nConnection: close\n\n<html>\n  <head>\n    <title>An Example Page</title>\n  </head>\n  <body>\n    <p>Hello World, this is a very simple HTML document.</p>\n  </body>\n</html>\n</syntaxhighlight>\n\nThe [[HTTP ETag|ETag]] (entity tag) header field is used to determine if a cached version of the requested resource is identical to the current version of the resource on the server. <code>\"Content-Type\"</code> specifies the [[Internet media type]] of the data conveyed by the HTTP message, while <code>\"Content-Length\"</code> indicates its length in bytes. The HTTP/1.1 [[webserver]] publishes its ability to respond to requests for certain byte ranges of the document by setting the field <code>\"Accept-Ranges: bytes\"</code>. This is useful, if the client needs to have only certain portions<ref>{{cite IETF |draft=draft-ietf-http-range-retrieval-00 |title=Byte Range Retrieval Extension to HTTP |first1=Ari |last1=Luotonen |first2=John |last2=Franks |publisher=IETF |date=February 22, 1996}}</ref> of a resource sent by the server, which is called [[byte serving]]. When <code>\"Connection: close\"</code> is sent, it means that the [[web server]] will close the [[Transmission Control Protocol|TCP]] connection immediately after the end of the transfer of this response.\n\nMost of the header lines are optional but some are mandatory. When header <code>\"Content-Length: number\"</code> is missing in a response with an entity body then this should be considered an error in HTTP/1.0 but it may not be an error in HTTP/1.1 if header <code>\"Transfer-Encoding: chunked\"</code> is present. Chunked transfer encoding uses a chunk size of 0 to mark the end of the content. Some old implementations of HTTP/1.0 omitted the header <code>\"Content-Length\"</code> when the length of the body entity was not known at the beginning of the response and so the transfer of data to client continued until server closed the socket.\n\nA <code>\"Content-Encoding: [[gzip]]\"</code> can be used to inform the client that the body entity part of the transmitted data is compressed by gzip algorithm.\n\n== Similar protocols ==\n* The [[Gopher (protocol)|Gopher protocol]] is a content delivery protocol that was displaced by HTTP in the early 1990s.\n* The [[SPDY]] protocol is an alternative to HTTP developed at [[Google]], superseded by [[HTTP/2]].\n* The [[Gemini (protocol)|Gemini protocol]] is a Gopher-inspired protocol which mandates privacy-related features.\n\n== See also ==\n{{HTTP}}\n\n* [[Comparison of file transfer protocols]]\n* [[Constrained Application Protocol]] – a semantically similar protocol to HTTP but used UDP or UDP-like messages targeted for devices with limited processing capability; re-uses HTTP and other internet concepts like [[Internet media type]] and web linking (<nowiki>RFC 5988</nowiki>)<ref>{{cite IETF |rfc=5988 |title=Web Linking |first1=Mark |last1=Nottingham |publisher=IETF |date=October 2010}}</ref>\n* [[Content negotiation]]\n* [[Digest access authentication]]\n* [[HTTP compression]]\n* [[HTTP/2]] – developed by the IETF's Hypertext Transfer Protocol (httpbis) working group<ref>{{cite web |url=https://datatracker.ietf.org/wg/httpbis/charter/ |title=Hypertext Transfer Protocol Bis (httpbis) – Charter |publisher=IETF |year=2012}}</ref>\n* [[List of HTTP header fields]]\n* [[List of HTTP status codes]]\n* [[Representational state transfer]] (REST)\n* [[Variant object]]\n* [[Web cache]]\n* [[WebSocket]]\n\n== References ==\n{{reflist}}\n\n\n== External links ==\n{{Commons category|Hypertext Transfer Protocol}}\n* {{cite web |url=https://www.w3.org/Protocols/History.html |title=Change History for HTTP |publisher=W3.org |access-date=2010-08-01}} A detailed technical history of HTTP.\n* {{cite web |url=https://www.w3.org/Protocols/DesignIssues.html |title=Design Issues for HTTP |publisher=W3.org |access-date=2010-08-01}} Design Issues by Berners-Lee when he was designing the protocol.\n\n{{Web browsers|fsp}}\n{{Semantic Web}}\n{{URI scheme}}\n{{Web interfaces}}\n\n{{Authority control}}\n\n[[Category:Hypertext Transfer Protocol| ]]\n[[Category:Application layer protocols]]\n[[Category:Computer-related introductions in 1991]]\n[[Category:Internet protocols]]\n[[Category:Network booting]]\n[[Category:Network protocols]]\n[[Category:World Wide Web]]\n[[Category:World Wide Web Consortium standards]]",
            "slug": "hypertext-transfer-protocol",
            "date_updated": 1635496881128,
            "imported": "https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol"
        }
    ]
}