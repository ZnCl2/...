{
    "article": [
        {
            "title": "Coroutine",
            "text": "'''Coroutines''' are [[computer program|computer-program]] components that generalize [[subroutine]]s for [[non-preemptive multitasking]], by allowing multiple [[entry point]]s for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing familiar program components such as [[cooperative multitasking|cooperative task]]s, [[exception handling|exception]]s, [[event loop]]s, [[iterator]]s, [[lazy evaluation|infinite list]]s and [[pipeline (software)|pipe]]s.\n\nAccording to [[Donald Knuth]], [[Melvin Conway]] coined the term ''coroutine'' in 1958 when he applied it to construction of an [[assembly language|assembly program]].<ref name=\"KnuthVol1_1_4_5\" /> The first published explanation of the coroutine appeared later, in 1963.<ref name=\"Conway1963\"/>\n\n==Comparison with subroutines==\nSubroutines are special cases of coroutines.<ref name=\"KnuthVol1_1_4_2\"/> When subroutines are invoked, execution begins at the start, and once a subroutine exits, it is finished; an instance of a subroutine only returns once, and does not hold state between invocations. By contrast, coroutines can exit by calling other coroutines, which may later return to the point where they were invoked in the original coroutine; from the coroutine's point of view, it is not exiting but calling another coroutine.<ref name=\"KnuthVol1_1_4_2\"/> Thus, a coroutine instance holds state, and varies between invocations; there can be multiple instances of a given coroutine at once. The difference between calling another coroutine by means of [[Yield (multithreading)|\"yielding\"]] to it and simply calling another routine (which then, also, would return to the original point), is that the relationship between two coroutines which yield to each other is not that of caller-callee, but instead symmetric.\n\nAny subroutine can be translated to a coroutine which does not call ''yield''.<ref name=\"Perlis1982_6\"/>\n\nHere is a simple example of how coroutines can be useful. Suppose you have a consumer-producer relationship where one routine creates items and adds them to a queue and another removes items from the queue and uses them. For reasons of efficiency, you want to add and remove several items at once. The code might look like this:\n\n ''var'' q := new queue\n \n '''coroutine''' produce\n     '''loop'''\n         '''while''' q is not full\n             create some new items\n             add the items to q\n         '''yield''' to consume\n \n '''coroutine''' consume\n     '''loop'''\n         '''while''' q is not empty\n             remove some items from q\n             use the items\n         '''yield''' to produce\n\nThe queue is then completely filled or emptied before yielding control to the other coroutine using the ''yield'' command. The further coroutines calls are starting right after the ''yield'', in the outer coroutine loop.\n\nAlthough this example is often used to introduce [[thread (computing)|multithreading]], two threads are not needed for this: the ''yield'' statement can be implemented by a jump directly from one routine into the other.\n\n==Comparison with generators==\n[[generator (computer science)|Generators]], also known as semicoroutines,<ref name=\"Ralston2000\">{{cite book|author=Anthony Ralston|title=Encyclopedia of computer science|url=https://books.google.com/books?id=yQ9LAQAAIAAJ|accessdate=11 May 2013|year=2000|publisher=Nature Pub. Group|isbn=978-1-56159-248-7}}</ref> are also a generalisation of subroutines, but are more limited than coroutines. Specifically, while both of these can yield multiple times, suspending their execution and allowing re-entry at multiple entry points, they differ in coroutines' ability to control where execution continues immediately after they yield, while generators cannot, instead transferring control back to the generator's caller.<ref>See for example ''[https://docs.python.org/reference/index.html The Python Language Reference]''\n\"https://docs.python.org/reference/expressions.html#yieldexpr 5.2.10. Yield expressions]\":<br />\n\"All of this makes generator functions quite similar to coroutines; they yield multiple times, they have more than one entry point and their execution can be suspended. The only difference is that a generator function cannot control where should the execution continue after it yields; the control is always transferred to the generator's caller.\"</ref> That is, since generators are primarily used to simplify the writing of [[iterator]]s, the <code>yield</code> statement in a generator does not specify a coroutine to jump to, but rather passes a value back to a parent routine.\n\nHowever, it is still possible to implement coroutines on top of a generator facility, with the aid of a top-level dispatcher routine (a [[trampoline (computing)|trampoline]], essentially) that passes control explicitly to child generators identified by tokens passed back from the generators:\n\n ''var'' q := new queue\n\n '''generator''' produce\n     '''loop'''\n         '''while''' q is not full\n             create some new items\n             add the items to q\n         '''yield''' consume\n\n '''generator''' consume\n     '''loop'''\n         '''while''' q is not empty\n             remove some items from q\n             use the items\n         '''yield''' produce\n\n '''subroutine''' dispatcher\n     ''var'' d := new dictionary('''generator''' → '''iterator''')\n     d[produce] := '''start''' produce\n     d[consume] := '''start''' consume\n     ''var'' current := produce\n     '''loop'''\n         current := '''next''' d[current]\n\nA number of implementations of coroutines for languages with generator support but no native coroutines (e.g. Python<ref name=\"MertzIBM\"/> before 2.5) use this or a similar model.\n\n==Comparison with mutual recursion==\n{{Further|Mutual recursion}}\nUsing coroutines for state machines or concurrency is similar to using [[mutual recursion]] with [[tail call]]s, as in both cases the control changes to a different one of a set of routines. However, coroutines are more flexible and generally more efficient. Since coroutines yield rather than return, and then resume execution rather than restarting from the beginning, they are able to hold state, both variables (as in a closure) and execution point, and yields are not limited to being in tail position; mutually recursive subroutines must either use shared variables or pass state as parameters. Further, each mutually recursive call of a subroutine requires a new stack frame (unless [[tail call elimination]] is implemented), while passing control between coroutines uses the existing contexts and can be implemented simply by a jump.\n\n==Common uses==\nCoroutines are useful to implement the following:\n\n* [[State machine]]s within a single subroutine, where the state is determined by the current entry/exit point of the procedure; this can result in more readable code compared to use of [[goto]], and may also be implemented via [[mutual recursion]] with [[tail call]]s.\n* [[Actor model]] of concurrency, for instance in [[video game]]s. Each actor has its own procedures (this again logically separates the code), but they voluntarily give up control to central scheduler, which executes them sequentially (this is a form of [[cooperative multitasking]]).\n* [[Generator (computer programming)|Generator]]s, and these are useful for [[Stream (computing)|streams]]{{snd}}particularly input/output{{snd}}and for generic traversal of data structures.\n* [[Communicating sequential processes]] where each sub-process is a coroutine. Channel inputs/outputs and blocking operations yield coroutines and a scheduler unblocks them on completion events.\n\n==Programming languages with native support==\n\nCoroutines originated as an [[assembly language]] method, but are supported in some [[high-level programming language]]s.  Early examples include [[Simula]]<ref name=\"Dahl1972\">{{cite book|title=Structured Programming|author=Dahl, O.-J. and Hoare, C.A.R. (ed)|first=|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175-220|chapter=Hierarchical Program Structures}}</ref> and [[Modula-2]]. More recent examples are [[Ruby (programming language)|Ruby]], [[Lua (programming language)|Lua]],  [[Julia (programming language)|Julia]], and [[Go (programming language)|Go]].\n\n{{Div col|colwidth=18em}}\n* [[Aikido (programming language)|Aikido]]\n* [[AngelScript]]\n* [[BCPL]]\n* [[Pascal (programming language)|Pascal]] (Borland [[Turbo Pascal]] 7.0 with uThreads module)\n* [[BETA (programming language)|BETA]]\n* [[BLISS]]\n* [[ChucK]]\n* [[D (programming language)|D]]\n* [[Dynamic C]]\n* [[Erlang (programming language)|Erlang]]\n* [[F Sharp (programming language)|F#]]\n* [[Factor (programming language)|Factor]]\n* [[GameMonkey Script]]\n* [[Godot (game engine)|GDScript]] (Godot's scripting language)\n* [[Go (programming language)|Go]]\n* [[Haskell (programming language)|Haskell]]<ref>{{cite web\n| title = Coroutine: Type-safe coroutines using lightweight session types\n| url = http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Coroutine\n}}</ref><ref>{{cite web\n| title = Co-routines in Haskell\n| url = http://random.axman6.com/blog/?p=231\n}}</ref>\n* [[High Level Assembly]]<ref>{{cite web\n| title = The Coroutines Module (coroutines.hhf)\n| url = http://www.plantation-productions.com/Webster/HighLevelAsm/HLADoc/HLAStdlib/1_HTML/HLAStdlib.htm#50618574_pgfId-998318\n| work = HLA Standard Library Manual\n}}</ref>\n* [[Icon (programming language)|Icon]]\n* [[Io (programming language)|Io]]\n* [[JavaScript]] (since 1.7, standardized in ECMAScript 6)<ref>{{cite web\n| title = New in JavaScript 1.7\n| url = https://developer.mozilla.org/en/docs/New_in_JavaScript_1.7\n}}</ref><!-- Does JavaScript belong here? See the link. --> ECMAScript 2017 also includes [[await]] support.\n* [[Julia (programming language)|Julia]]<ref>{{cite web | title=Julia Manual - Control Flow - Tasks (aka Coroutines)|url=http://docs.julialang.org/en/latest/manual/control-flow#man-tasks-1}}</ref>\n* [[Kotlin (programming language)|Kotlin]] (since 1.1)<ref>{{cite web | title=What's New in Kotlin 1.1|url=https://kotlinlang.org/docs/reference/whatsnew11.html#coroutines-experimental}}</ref>\n* [[Limbo (programming language)|Limbo]]\n* [[Lua (programming language)|Lua]]<ref>{{cite web |title=Lua 5.2 Reference Manual – 2.6 – Coroutines|url=http://www.lua.org/manual/5.2/manual.html#2.6}}</ref>\n* [[Lucid (programming language)|Lucid]]\n* [[µC++]]\n* [[MiniD]]\n* [[Modula-2]]\n* [[Nemerle]]\n* [[Perl 5]] (using the [https://metacpan.org/pod/Coro Coro module])\n* [[Perl 6]]<ref>{{cite web | title=Gather and/or Coroutines|url=https://perl6advent.wordpress.com/2012/12/19/gather-andor-coroutines/}}</ref>\n* [[PHP]] (with [https://github.com/facebook/hiphop-php HipHop], native since PHP 5.5)\n* [[Picolisp]]\n* [[Prolog]]\n* [[Python (programming language)|Python]] (since 2.5,<ref>{{cite web |title=Python async/await Tutorial|url=http://stackabuse.com/python-async-await-tutorial/}}</ref> with improved support since 3.3 and with explicit syntax since 3.5<ref>{{cite web |title=Python 3 reference: Coroutine function definition|url=https://docs.python.org/3/reference/compound_stmts.html#async-def}}</ref>)\n* [[Ruby (programming language)|Ruby]]\n* [[Sather]]\n* [[Scheme (programming language)|Scheme]]\n* [[Self (programming language)|Self]]\n* [[Simula]] 67\n* [[Squirrel (programming language)|Squirrel]]\n* [[Stackless Python]]\n* [[SuperCollider]]<ref>McCartney, J. [http://portal.acm.org/citation.cfm?id=1245228 \"Rethinking the Computer Music Programming Language: SuperCollider\"]. Computer Music Journal, 26(4):61-68. MIT Press, 2002.</ref>\n* [[Tcl]] (since 8.6)\n* [[urbiscript]]\n<!-- Coroutines can be implemented in any language, so please limit this list to languages with native support.\nSpecifically, don't re-add the following entries without consideration:\n* [[C Sharp (programming language)|C#]]\n* [[Perl]]\n* [[Smalltalk]]\n-->\n{{div col end}}\nSince [[continuation]]s can be used to implement coroutines, programming languages that support them can also quite easily support coroutines.\n\n==Implementations==\n{{As of|2003}}, many of the most popular programming languages, including C and its derivatives, do not have direct support for coroutines within the language or their standard libraries. (This is, in large part, due to the limitations of [[call stack|stack-based]] subroutine implementation.) An exception is the C++ library [http://www.boost.org/doc/libs/1_55_0/libs/context/doc/html/index.html Boost.Context], part of [http://www.boost.org boost libraries], which supports context swapping on ARM, MIPS, PowerPC, SPARC and x86 on POSIX, Mac OS X and Windows. Coroutines can be built upon Boost.Context.\n\nIn situations where a coroutine would be the natural implementation of a mechanism, but is not available, the typical response is to use a [[Closure (computer science)|closure]]{{snd}}a subroutine with state variables ([[static variable]]s, often boolean flags) to maintain an internal state between calls, and to transfer control to the correct point. Conditionals within the code result in the execution of different code paths on successive calls, based on the values of the state variables. Another typical response is to implement an explicit state machine in the form of a large and complex [[switch statement]] or via a [[goto]] statement, particularly a [[computed goto]]. Such implementations are considered difficult to understand and maintain, and a motivation for coroutine support.\n\n[[thread (computing)|Threads]], and to a lesser extent [[fiber (computer science)|fibers]], are an alternative to coroutines in mainstream programming environments today. Threads provide facilities for managing the realtime cooperative interaction of ''simultaneously'' executing pieces of code. Threads are widely available in environments that support C (and are supported natively in many other modern languages), are familiar to many programmers, and are usually well-implemented, well-documented and well-supported. However, as they solve a large and difficult problem they include many powerful and complex facilities and have a correspondingly difficult learning curve. As such, when a coroutine is all that is needed, using a thread can be overkill.\n\nOne important difference between threads and coroutines is that threads are typically preemptively scheduled while coroutines are not. Because threads can be rescheduled at any instant and can execute concurrently, programs using threads must be careful about [[lock (computer science)|locking]]. In contrast, because coroutines can only be rescheduled at specific points in the program and do not execute concurrently, programs using coroutines can often avoid locking entirely. (This property is also cited as a benefit of [[event-driven programming|event-driven]] or asynchronous programming.)\n\nSince fibers are cooperatively scheduled, they provide an ideal base for implementing coroutines above.<ref name=\"msdn-wrap\">[http://msdn.microsoft.com/msdnmag/issues/03/09/CoroutinesinNET/default.aspx Implementing Coroutines for .NET by Wrapping the Unmanaged Fiber API], Ajai Shankar, [[MSDN Magazine]]</ref> However, system support for fibers is often lacking compared to that for threads.\n\n===Implementations for C===\nSeveral attempts have been made to implement coroutines in [[C (programming language)|C]] with combinations of subroutines and macros. [[Simon Tatham]]'s contribution,<ref name=\"tatham\">{{cite web|url=http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html|author=Simon Tatham|title=Coroutines in C|year=2000}}</ref> based on [[Duff's device]], is a good example of the genre, and is the basis for [[Protothread|Protothreads]]. Tatham's comments provide a frank evaluation of the limitations of this approach: \"Of course, this trick violates every coding standard in the book... [but] any coding standard which insists on syntactic clarity at the expense of algorithmic clarity should be rewritten. If your employer fires you for using this trick, tell them that repeatedly as the security staff drag you out of the building.\" The main shortcoming of this approach is that, in not maintaining a separate stack frame for each coroutine, local variables are not preserved across multiple entries to the function.<ref name=\"tatham\" />\n\nA more reliable approach to implementing coroutines in C is to give up on absolute portability and write platform-specific implementations of functions to save and restore a coroutine context. Methods for achieving this include use of [[sigaltstack]] and a springboard function called from a signal handler<ref  name=\"rse-pmt\">https://www.gnu.org/software/pth/rse-pmt.ps</ref><ref name=\"libco\">https://byuu.org/library/libco/</ref>, as well as less reliable techniques such as jumping the stack pointer into an allocation within the heap (or merely further down the stack) using a [[C99]] [[variable-length array]] or [[C_dynamic_memory_allocation#Extensions_and_alternatives|alloca]]<ref>http://fanf.livejournal.com/105413.html</ref>. The [[setjmp/longjmp|setjmp and longjmp]] functions in the [[standard C library]] can then be used to implement the jumps between coroutines. Portability is an issue, as [[Samuel P. Harbison|Harbison]] and [[Guy L. Steele Jr.|Steele]] note, \"the ''setjmp'' and ''longjmp'' functions are notoriously difficult to implement, and the programmer would do well to make minimal assumptions about them.\"<ref>{{cite book|title=C: A Reference Manual|authors=Samuel P. Harbison and Guy L. Steele, Jr|edition=3|publisher=Prentice-Hall|year=1991|isbn=0-13-110933-2}}</ref>\n\nC libraries complying to [[POSIX]] or the [[Single Unix Specification]] (SUSv3) provide such routines as [[setcontext|getcontext, setcontext, makecontext and swapcontext]].  The setcontext family of functions is thus considerably more powerful than ''setjmp/longjmp'', but conforming implementations are as rare if not rarer. These functions were declared obsolete in POSIX 1.2008 <ref>http://man7.org/linux/man-pages/man3/getcontext.3.html</ref>. Aside from portability, the main shortcoming of this approach is that the coroutine's stack is a fixed size and cannot be grown during execution. Thus, programs tend to allocate much more stack than they actually need to avoid the potential for stack overflow.\n\nDue to the limits of standard libraries, some authors have written their own libraries for coroutines.  Russ Cox's libtask library<ref name=\"libtask\">[http://swtch.com/libtask/] - Russ Cox's libtask coroutine library for FreeBSD, Linux, Mac OS X, and SunOS</ref> is a good example of this genre.  It uses the context functions if they are provided by the native C library; otherwise it provides its own implementations for ARM, PowerPC, Sparc, and x86.  Other notable implementations include libpcl,<ref>[http://xmailserver.org/libpcl.html ''Portable Coroutine Library''] - C library using POSIX/SUSv3 facilities</ref> coro,<ref>[http://www.goron.de/~froese/coro/] - Edgar Toernig's coro library for x86, Linux & FreeBSD</ref> lthread,<ref>[https://github.com/halayli/lthread] - lthread is a multicore/multithread coroutine library written in C</ref> libCoroutine,<ref>{{cite web|url=http://dekorte.com/projects/opensource/libcoroutine/|title=libcoroutine: A portable coroutine implementation}} for FreeBSD, Linux, OS X PPC and x86, SunOS, Symbian and others</ref> libconcurrency,<ref>{{cite web|url=http://code.google.com/p/libconcurrency/libconcurrency|title=libconcurrency - A scalable concurrency library for C}} a simple C library for portable stack-switching coroutines</ref> libcoro,<ref>{{cite web|url=http://software.schmorp.de/pkg/libcoro.html|title=libcoro: C-library that implements coroutines (cooperative multitasking) in a portable fashion}} used as the basis for the Coro perl module.</ref> ribs2,<ref>{{cite web|url=https://github.com/Adaptv/ribs2|title=RIBS (Robust Infrastructure for Backend Systems)}}</ref> libdill.<ref>{{cite web|url=http://libdill.org|title=Structured Concurrency for C}}</ref>, libco<ref name=\"libco\" />, and [[Protothread|Protothreads]].\n\n===Implementations for C++===\n* C++ coroutines TS (Technical Specification), a standard for C++ language extensions for stackless coroutines, is under development. Visual C++, gcc, and Clang already support major portions in the std::experimental namespace. [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf coroutines Technical Specification]\n*[http://www.boost.org/doc/libs/1_57_0/libs/coroutine/doc/html/index.html Boost.Coroutine] - created by Oliver Kowalke, is the official released portable coroutine library of [http://boost.org boost] since version 1.53. The library relies on [http://www.boost.org/doc/libs/1_53_0/libs/context/doc/html/index.html Boost.Context] and supports ARM, MIPS, PowerPC, SPARC and X86 on POSIX, Mac OS X and Windows.\n*[http://www.boost.org/doc/libs/1_61_0/libs/coroutine2/doc/html/index.html Boost.Coroutine2] - also created by Oliver Kowalke, is a modernized portable coroutine library since boost version 1.59. It takes advantage of C++11 features, but removes the support for symmetric coroutines.\n*[https://github.com/mozy/mordor Mordor] - In 2010, [[Mozy]] open sourced a C++ library implementing coroutines, with an emphasis on using them to abstract [[asynchronous I/O]] into a more familiar sequential model.<ref>[http://mozy.com/blog/announcements/open-source-and-mozy-the-debut-of-mozy-code/] - Open Source and Mozy: The Debut of Mozy Code</ref>\n*[https://github.com/jamboree/co2 CO2] - stackless coroutine based on C++ [[preprocessor]] tricks, providing await/yield emulation.\n*[https://github.com/scummvm/scummvm/blob/master/common/coroutines.h ScummVM] - The [[ScummVM]] project implements a light-weight version of coroutines based on [http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html Simon Tatham's article].\n*[https://github.com/tonbit/coroutine tonbit::coroutine] - C++11 single .h asymmetric coroutine implementation via ucontext / fiber\n* Coroutines landed in [[Clang]] in May 2017, with libc++ implementation ongoing.<ref>[https://twitter.com/eric01/status/867473461836263424] - EricWF: Coroutines are now in Clang Trunk! Working on the Libc++ implementation now.</ref>\n* [https://github.com/infinit/elle elle] by Docker\n\n===Implementations for C#===\n*[https://github.com/MindTouch/dream MindTouch Dream] - The MindTouch Dream REST framework provides an implementation of coroutines based on the [[C Sharp (programming language)|C#]] 2.0 iterator pattern\n*[http://caliburn.codeplex.com/Wiki/View.aspx?title=IResult Caliburn] - The Caliburn screen patterns framework for WPF uses C# 2.0 iterators to ease UI programming, particularly in asynchronous scenarios.\n*[http://www.wintellect.com/PowerThreading.aspx Power Threading Library] - The Power Threading Library by [[Jeffrey Richter]] implements an AsyncEnumerator that provides simplified Asynchronous Programming Model using iterator-based coroutines.\n*[https://github.com/yevhen/Servelat-Pieces Servelat Pieces] - The Servelat Pieces project by [[Yevhen Bobrov]] provides transparent asynchrony for Silverlight WCF services and ability to asynchronously call any synchronous method. The implementation is based on Caliburn's Coroutines iterator and C# iterator blocks.\n*[http://msdn.microsoft.com/en-us/library/dscyy5s0(VS.80).aspx] - The .NET 2.0+ Framework now provides semi-coroutine ([[generator (computer programming)|generator]]) functionality through the iterator pattern and yield keyword.\n\n[[C Sharp 5.0|C# 5.0]] includes [[await]] syntax support.\n\n===Implementations for D===\n[[D (programming language)]] implements coroutines as its standard library class [http://dlang.org/phobos/core_thread.html#.Fiber Fiber]\n\n[http://dlang.org/phobos/std_concurrency.html#.Generator Generator] makes it trivial to expose a fiber function as an [http://dlang.org/phobos/std_range_primitives.html#isInputRange InputRange], making any fiber compatible with existing range algorithms.\n\n===Implementations for Java===\nThere are several implementations for coroutines in [[Java (programming language)|Java]].  Despite the constraints imposed by Java's abstractions, the JVM does not preclude the possibility.<ref name=\"jvmsummit\">{{cite web|url=http://www.wiki.jvmlangsummit.com/images/2/2b/JVMLanguageSummit_Stadler_Continuations.pdf|author=Lukas Stadler|series=JVM Language Summit|title=JVM Continuations|year=2009}}</ref> There are four general methods used, but two break bytecode portability among standards-compliant JVMs.\n\n* Modified JVMs. It is possible to build a patched JVM to support coroutines more natively. The [http://openjdk.java.net/projects/mlvm/ Da Vinci JVM] has had patches created.<ref name=\"javanet-forax\">{{cite web|url=http://weblogs.java.net/blog/forax/archive/2009/11/19/holy-crap-jvm-has-coroutinecontinuationfiber-etc|author=Remi Forax|archiveurl=https://web.archive.org/web/20150319052055/http://weblogs.java.net/blog/forax/archive/2009/11/19/holy-crap-jvm-has-coroutinecontinuationfiber-etc|archivedate=19 March 2015|title=Holy crap: JVM has coroutine/continuation/fiber etc.|date=19 November 2009}}</ref>\n* Modified bytecode. Coroutine functionality is possible by rewriting regular Java bytecode, either on the fly or at compile time. Toolkits include [http://commons.apache.org/sandbox/commons-javaflow/ Javaflow], [http://code.google.com/p/coroutines/ Java Coroutines], and [https://github.com/offbynull/coroutines Coroutines].\n* Platform-specific JNI mechanisms. These use JNI methods implemented in the OS or C libraries to provide the functionality to the JVM.{{citation needed|date=May 2014}}\n* Thread abstractions. Coroutine libraries which are implemented using threads may be heavyweight, though performance will vary based on the JVM's thread implementation.\n\n=== Implementations in Javascript ===\n* [https://github.com/fibjs/fibjs Fibjs] - fibjs is a JavaScript runtime built on Chrome's V8 JavaScript engine. fibjs uses [[Fiber (computer science)|fibers-switch]], sync style & non-blocking IO model to build scalable systems.\n* Since [http://es6-features.org/#GeneratorFunctionIteratorProtocol ECMAScript 2015], stackless coroutine functionality through \"generators\" and yield expressions is provided.\n\n===Implementation in Mono===\nThe [[Mono (software)|Mono]] Common Language Runtime has support for continuations,<ref name=\"monoco\">[http://www.mono-project.com/Continuations] Mono Continuations</ref> from which coroutines can be built.\n\n===Implementation in the .NET Framework as fibers===\nDuring the development of the [[.NET Framework]] 2.0, Microsoft extended the design of the [[Common Language Runtime]] (CLR) hosting APIs to handle fiber-based scheduling with an eye towards its use in fiber-mode for SQL server.<ref name=\"cbrumme-fibermode\">[http://blogs.msdn.com/cbrumme/archive/2004/02/21/77595.aspx], Chris Brumme, [http://blogs.msdn.com/cbrumme/default.aspx cbrumme's WebLog]</ref> Before release, support for the task switching hook ICLRTask::SwitchOut was removed due to time constraints.<ref name=\"dino-fibermodegone\">[http://blogs.msdn.com/dinoviehland/archive/2005/09/15/469642.aspx], Dino Viehland, [http://blogs.msdn.com/dinoviehland/default.aspx Dino's Blog]</ref>\nConsequently, the use of the fiber API to switch tasks is currently not a viable option in the .NET Framework.\n\n===Implementations for Python===\n*[[Python (programming language)|Python]] 2.5 implements better support for coroutine-like functionality, based on extended generators ([https://www.python.org/dev/peps/pep-0342/ PEP 342])\n*[[Python (programming language)|Python]] 3.3 improves this ability, by supporting delegating to a subgenerator ([https://www.python.org/dev/peps/pep-0380/ PEP 380])\n*[[Python (programming language)|Python]] 3.4 introduces a comprehensive asynchronous I/O framework as standardized in [https://www.python.org/dev/peps/pep-3156/ PEP 3156], which includes coroutines that leverage subgenerator delegation \n*[[Python (programming language)|Python]] 3.5 introduces explicit support for coroutines with async/[[await]] syntax ([https://www.python.org/dev/peps/pep-0492/ PEP 0492]).\n*[http://eventlet.net/ Eventlet]\n*[https://github.com/python-greenlet/greenlet Greenlet]\n*[http://www.gevent.org gevent]\n*[https://pypi.python.org/pypi/multitask multitask]\n*[http://chiral.j4cbo.com/trac chiral]\n*[http://code.google.com/p/cogen cogen]\n*[http://www.kamaelia.org Kamaelia]\n*[https://github.com/ironport/shrapnel/ Shrapnel]\n*[http://www.stackless.com/ stackless python]\n\n===Implementations for Ruby===\n* [[Ruby (programming language)|Ruby]] 1.9 supports coroutines natively which are implemented as [http://rubydoc.info/stdlib/core/1.9.2/Fiber fibers], which are semi-coroutines.<ref>{{cite web|url=http://www.ruby-forum.com/topic/126011 |authorlink1=https://web.archive.org/web/20071024123936/http://www.ruby-forum.com/topic/126011 |title=semi-coroutines |archivedate=October 24, 2007 |language=English |deadurl=yes |archiveurl=https://web.archive.org/web/20071024123936/http://www.ruby-forum.com/topic/126011 }}</ref>\n* [http://liber.sourceforge.net/coroutines.rb An implementation by Marc De Scheemaecker]\n\n===Implementations for Perl===\n* [https://metacpan.org/module/Coro Coro]\n\nCoroutines are natively implemented in all [[Perl 6]] backends.<ref>{{cite web | title = RFC #31 | url = http://www.perl6.org/archive/rfc/31}}</ref>\n\n===Implementations for Rust===\nThere is a library for [[Rust (programming language)|Rust]] that provides coroutines.<ref>{{cite web|url=https://crates.io/crates/coroutine|title=coroutine - Cargo: packages for Rust|accessdate=2017-06-24}}</ref>\nGenerators are an experimental feature available in nightly rust that provides an implementation of coroutines with async/await.<ref>{{cite web|title=Tracking issue for RFC 2033: Experimentally add coroutines to Rust|url=https://github.com/rust-lang/rust/issues/43122|website=GitHub}}</ref>\n\n===Implementations for Scala===\n[http://storm-enroute.com/coroutines/ Scala Coroutines] is a coroutine implementation for [[Scala (programming language)|Scala]]. This implementation is a library-level extension that relies on the Scala macro system to statically transform sections of the program into coroutine objects. As such, this implementation does not require modifications in the JVM, so it is fully portable between different JVMs and works with alternative Scala backends, such as [[Scala.js (programming language)|Scala.js]], which compiles to JavaScript.<ref>[http://storm-enroute.com/coroutines/docs/faq/ Scala Coroutines FAQ]</ref>\n\nScala Coroutines rely on the <code>coroutine</code> macro that transforms a normal block of code into a coroutine definition. Such a coroutine definition can be invoked with the <code>call</code> operation, which instantiates a coroutine frame. A coroutine frame can be resumed with the <code>resume</code> method, which resumes the execution of the coroutine's body, until reaching a <code>yieldval</code> keyword, which suspends the coroutine frame. Scala Coroutines also expose a <code>snapshot</code> method, which effectively duplicates the coroutine.<ref name=\"scala-coroutine-snapshots\">[http://storm-enroute.com/coroutines/docs/0.6/snapshots/index.html Scala Coroutine Snapshots]</ref>\n\n===Implementations for Smalltalk===\nSince, in most [[Smalltalk]] environments, the execution stack is a first-class citizen, coroutines can be implemented without additional library or VM support.\n\n===Implementations for Scheme===\nSince [[Scheme (programming language)|Scheme]] provides full support for continuations, implementing coroutines is nearly trivial, requiring only that a queue of continuations be maintained.\n\n===Implementation for Tool Command Language (Tcl)===\nSince version 8.6, the Tool Command Language supports coroutines in the core language.\n<ref>{{cite web|url=https://www.tcl.tk/man/tcl/TclCmd/coroutine.htm |title=coroutine manual page - Tcl Built-In Commands |publisher=Tcl.tk |date= |accessdate=2016-06-27}}</ref>\n\n===Implementations for Vala===\n[[vala (programming language)|Vala]] implements native support for coroutines. They are designed to be used with a Gtk Main Loop, but can be used alone if care is taken to ensure that the end callback will never have to be called before doing, at least, one yield.\n\n===Implementations in assembly languages===\nMachine-dependent [[assembly language]]s often provide direct methods for coroutine execution. For example, in [[MACRO-11]], the assembly language of the [[PDP-11]] family of minicomputers, the “classic” coroutine switch is effected by the instruction \"JSR PC,@(SP)+\", which jumps to the address popped from the stack and pushes the current (''i.e'' that of the '''next''') instruction address onto the stack. On [[VAX]]en (in [[VAX Macro|Macro-32]]) the comparable instruction is \"JSB @(SP)+\". Even on a [[Motorola 6809]] there is the instruction \"JSR [,S++]\"; note the \"++\", as 2 bytes (of address) are popped from the stack. This instruction is much used in the (standard) 'monitor' [[ASSIST (computing)|Assist]] 09.\n\n==See also==\n* [[Pipeline (Unix)]], a kind of coroutine used for communicating between programs<ref name=\"EvolutionUnix\"/>\n* [[Protothreads]], a stackless lightweight thread implementation using a coroutine like mechanism\n\n==References==\n{{Reflist|refs=\n<ref name=\"KnuthVol1_1_4_5\">{{Cite book | first = Donald Ervin | last = Knuth | series = The Art of Computer Programming | volume = 1 | title = Fundamental Algorithms | edition = 3rd | publisher = Addison-Wesley | year = 1997| isbn = 0-201-89683-4 | at = Section 1.4.5: History and Bibliography, pp.&nbsp;229}}</ref> <!--pages = 229-->\n<ref name=\"Conway1963\">{{Cite journal | last1 = Conway | first1 = M. E. | doi = 10.1145/366663.366704 | title = Design of a Separable Transition-Diagram Compiler| journal = Communications of the ACM | publisher = Association for Computing Machinery| location = New York, NY, USA | volume = 6 | issue = 7| pages = 396&ndash;408 | date =July 1963 }}</ref>\n<ref name=\"KnuthVol1_1_4_2\">{{Cite book | first = Donald Ervin | last = Knuth | series = The Art of Computer Programming | volume = 1 | title = Fundamental Algorithms | edition = 3rd | publisher = Addison-Wesley | year = 1997| isbn = 0-201-89683-4 | at = Section 1.4.2: Coroutines, pp.&nbsp;193–200}}</ref> <!--pages = 193–200-->\n<ref name=\"EvolutionUnix\">{{Cite journal | first = Dennis M. | last = Ritchie | title = The Evolution of the Unix Time-sharing System | url = http://cm.bell-labs.com/cm/cs/who/dmr/hist.html | journal = Lecture Notes in Computer Science | year = 1980 | volume = 79 | issue = Language Design and Programming Methodology | pages = 25–35 | doi=10.1007/3-540-09745-7_2}}</ref>\n<ref name=\"Perlis1982_6\">{{Cite journal\n| last1 = Perlis | first1 = Alan J.\n| doi = 10.1145/947955.1083808\n| title = Epigrams on programming\n| journal = ACM SIGPLAN Notices\n| publisher = Association for Computing Machinery\n| location = New York, NY, USA\n| volume = 17\n| issue = 9\n| pages = 7–13\n|date=September 1982\n| url = http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html\n| archiveurl = https://web.archive.org/web/19990117034445/http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html\n| archivedate = January 17, 1999\n| quote = 6. Symmetry is a complexity reducing concept (co-routines include sub-routines); seek it everywhere\n}}</ref>\n<ref name=\"MertzIBM\">{{cite web|url=http://www.ibm.com/developerworks/library/l-pygen.html |title=Generator-based State Machines |work=Charming Python |first=David |last=Mertz |publisher=IBM developerWorks |date=July 1, 2002 |accessdate=Feb 2, 2011 |archiveurl=https://www.webcitation.org/5wCZa062h?url=http://www.ibm.com/developerworks/library/l-pygen.html |archivedate=February 2, 2011 |deadurl=yes |df= }}</ref>\n}}\n\n==Further reading==\n* {{cite journal|citeseerx=10.1.1.58.4017|author1=Ana Lucia de Moura|author2=Roberto Ierusalimschy|title=Revisiting Coroutines|year=2004|doi=10.1145/1462166.1462167}}\n\n==External links==\n* [[Simon Tatham]]'s C oriented [http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html comprehensive introduction to coroutines]\n* [http://www.softpanorama.org/Lang/coroutines.shtml Softpanorama coroutine page]{{snd}}contains extensive assembler coroutines links\n\n[[Category:Concurrent computing]]\n[[Category:Subroutines]]",
            "slug": "coroutine",
            "date_updated": 1532099998981,
            "imported": "https://en.wikipedia.org/wiki/Coroutine"
        },
        {
            "title": "Coroutine",
            "text": {
                "title": "Coroutine",
                "content": "'''Coroutines''' are [[computer program|computer-program]] components that generalize [[subroutine]]s for [[non-preemptive multitasking]], by allowing multiple [[entry point]]s for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing familiar program components such as [[cooperative multitasking|cooperative task]]s, [[exception handling|exception]]s, [[event loop]]s, [[iterator]]s, [[lazy evaluation|infinite list]]s and [[pipeline (software)|pipe]]s.\n\nAccording to [[Donald Knuth]], [[Melvin Conway]] coined the term ''coroutine'' in 1958 when he applied it to construction of an [[assembly language|assembly program]].<ref name=\"KnuthVol1_1_4_5\" /> The first published explanation of the coroutine appeared later, in 1963.<ref name=\"Conway1963\"/>\n\n==Comparison with subroutines==\nSubroutines are special cases of coroutines.<ref name=\"KnuthVol1_1_4_2\"/> When subroutines are invoked, execution begins at the start, and once a subroutine exits, it is finished; an instance of a subroutine only returns once, and does not hold state between invocations. By contrast, coroutines can exit by calling other coroutines, which may later return to the point where they were invoked in the original coroutine; from the coroutine's point of view, it is not exiting but calling another coroutine.<ref name=\"KnuthVol1_1_4_2\"/> Thus, a coroutine instance holds state, and varies between invocations; there can be multiple instances of a given coroutine at once. The difference between calling another coroutine by means of [[Yield (multithreading)|\"yielding\"]] to it and simply calling another routine (which then, also, would return to the original point), is that the relationship between two coroutines which yield to each other is not that of caller-callee, but instead symmetric.\n\nAny subroutine can be translated to a coroutine which does not call ''yield''.<ref name=\"Perlis1982_6\"/>\n\nHere is a simple example of how coroutines can be useful. Suppose you have a consumer-producer relationship where one routine creates items and adds them to a queue and another removes items from the queue and uses them. For reasons of efficiency, you want to add and remove several items at once. The code might look like this:\n\n ''var'' q := new queue\n \n '''coroutine''' produce\n     '''loop'''\n         '''while''' q is not full\n             create some new items\n             add the items to q\n         '''yield''' to consume\n \n '''coroutine''' consume\n     '''loop'''\n         '''while''' q is not empty\n             remove some items from q\n             use the items\n         '''yield''' to produce\n\nThe queue is then completely filled or emptied before yielding control to the other coroutine using the ''yield'' command. The further coroutines calls are starting right after the ''yield'', in the outer coroutine loop.\n\nAlthough this example is often used to introduce [[thread (computing)|multithreading]], two threads are not needed for this: the ''yield'' statement can be implemented by a jump directly from one routine into the other.\n\n==Comparison with generators==\n[[generator (computer science)|Generators]], also known as semicoroutines,<ref name=\"Ralston2000\">{{cite book|author=Anthony Ralston|title=Encyclopedia of computer science|url=https://books.google.com/books?id=yQ9LAQAAIAAJ|accessdate=11 May 2013|year=2000|publisher=Nature Pub. Group|isbn=978-1-56159-248-7}}</ref> are also a generalisation of subroutines, but are more limited than coroutines. Specifically, while both of these can yield multiple times, suspending their execution and allowing re-entry at multiple entry points, they differ in coroutines' ability to control where execution continues immediately after they yield, while generators cannot, instead transferring control back to the generator's caller.<ref>See for example ''[https://docs.python.org/reference/index.html The Python Language Reference]''\n\"https://docs.python.org/reference/expressions.html#yieldexpr 5.2.10. Yield expressions]\":<br />\n\"All of this makes generator functions quite similar to coroutines; they yield multiple times, they have more than one entry point and their execution can be suspended. The only difference is that a generator function cannot control where should the execution continue after it yields; the control is always transferred to the generator's caller.\"</ref> That is, since generators are primarily used to simplify the writing of [[iterator]]s, the <code>yield</code> statement in a generator does not specify a coroutine to jump to, but rather passes a value back to a parent routine.\n\nHowever, it is still possible to implement coroutines on top of a generator facility, with the aid of a top-level dispatcher routine (a [[trampoline (computing)|trampoline]], essentially) that passes control explicitly to child generators identified by tokens passed back from the generators:\n\n ''var'' q := new queue\n\n '''generator''' produce\n     '''loop'''\n         '''while''' q is not full\n             create some new items\n             add the items to q\n         '''yield''' consume\n\n '''generator''' consume\n     '''loop'''\n         '''while''' q is not empty\n             remove some items from q\n             use the items\n         '''yield''' produce\n\n '''subroutine''' dispatcher\n     ''var'' d := new dictionary('''generator''' → '''iterator''')\n     d[produce] := '''start''' produce\n     d[consume] := '''start''' consume\n     ''var'' current := produce\n     '''loop'''\n         current := '''next''' d[current]\n\nA number of implementations of coroutines for languages with generator support but no native coroutines (e.g. Python<ref name=\"MertzIBM\"/> before 2.5) use this or a similar model.\n\n==Comparison with mutual recursion==\n{{Further|Mutual recursion}}\nUsing coroutines for state machines or concurrency is similar to using [[mutual recursion]] with [[tail call]]s, as in both cases the control changes to a different one of a set of routines. However, coroutines are more flexible and generally more efficient. Since coroutines yield rather than return, and then resume execution rather than restarting from the beginning, they are able to hold state, both variables (as in a closure) and execution point, and yields are not limited to being in tail position; mutually recursive subroutines must either use shared variables or pass state as parameters. Further, each mutually recursive call of a subroutine requires a new stack frame (unless [[tail call elimination]] is implemented), while passing control between coroutines uses the existing contexts and can be implemented simply by a jump.\n\n==Common uses==\nCoroutines are useful to implement the following:\n\n* [[State machine]]s within a single subroutine, where the state is determined by the current entry/exit point of the procedure; this can result in more readable code compared to use of [[goto]], and may also be implemented via [[mutual recursion]] with [[tail call]]s.\n* [[Actor model]] of concurrency, for instance in [[video game]]s. Each actor has its own procedures (this again logically separates the code), but they voluntarily give up control to central scheduler, which executes them sequentially (this is a form of [[cooperative multitasking]]).\n* [[Generator (computer programming)|Generator]]s, and these are useful for [[Stream (computing)|streams]]{{snd}}particularly input/output{{snd}}and for generic traversal of data structures.\n* [[Communicating sequential processes]] where each sub-process is a coroutine. Channel inputs/outputs and blocking operations yield coroutines and a scheduler unblocks them on completion events.\n\n==Programming languages with native support==\n\nCoroutines originated as an [[assembly language]] method, but are supported in some [[high-level programming language]]s.  Early examples include [[Simula]]<ref name=\"Dahl1972\">{{cite book|title=Structured Programming|author=Dahl, O.-J. and Hoare, C.A.R. (ed)|first=|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175-220|chapter=Hierarchical Program Structures}}</ref> and [[Modula-2]]. More recent examples are [[Ruby (programming language)|Ruby]], [[Lua (programming language)|Lua]],  [[Julia (programming language)|Julia]], and [[Go (programming language)|Go]].\n\n{{Div col|colwidth=18em}}\n* [[Aikido (programming language)|Aikido]]\n* [[AngelScript]]\n* [[BCPL]]\n* [[Pascal (programming language)|Pascal]] (Borland [[Turbo Pascal]] 7.0 with uThreads module)\n* [[BETA (programming language)|BETA]]\n* [[BLISS]]\n* [[ChucK]]\n* [[D (programming language)|D]]\n* [[Dynamic C]]\n* [[Erlang (programming language)|Erlang]]\n* [[F Sharp (programming language)|F#]]\n* [[Factor (programming language)|Factor]]\n* [[GameMonkey Script]]\n* [[Godot (game engine)|GDScript]] (Godot's scripting language)\n* [[Go (programming language)|Go]]\n* [[Haskell (programming language)|Haskell]]<ref>{{cite web\n| title = Coroutine: Type-safe coroutines using lightweight session types\n| url = http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Coroutine\n}}</ref><ref>{{cite web\n| title = Co-routines in Haskell\n| url = http://random.axman6.com/blog/?p=231\n}}</ref>\n* [[High Level Assembly]]<ref>{{cite web\n| title = The Coroutines Module (coroutines.hhf)\n| url = http://www.plantation-productions.com/Webster/HighLevelAsm/HLADoc/HLAStdlib/1_HTML/HLAStdlib.htm#50618574_pgfId-998318\n| work = HLA Standard Library Manual\n}}</ref>\n* [[Icon (programming language)|Icon]]\n* [[Io (programming language)|Io]]\n* [[JavaScript]] (since 1.7, standardized in ECMAScript 6)<ref>{{cite web\n| title = New in JavaScript 1.7\n| url = https://developer.mozilla.org/en/docs/New_in_JavaScript_1.7\n}}</ref><!-- Does JavaScript belong here? See the link. --> ECMAScript 2017 also includes [[await]] support.\n* [[Julia (programming language)|Julia]]<ref>{{cite web | title=Julia Manual - Control Flow - Tasks (aka Coroutines)|url=http://docs.julialang.org/en/latest/manual/control-flow#man-tasks-1}}</ref>\n* [[Kotlin (programming language)|Kotlin]] (since 1.1)<ref>{{cite web | title=What's New in Kotlin 1.1|url=https://kotlinlang.org/docs/reference/whatsnew11.html#coroutines-experimental}}</ref>\n* [[Limbo (programming language)|Limbo]]\n* [[Lua (programming language)|Lua]]<ref>{{cite web |title=Lua 5.2 Reference Manual – 2.6 – Coroutines|url=http://www.lua.org/manual/5.2/manual.html#2.6}}</ref>\n* [[Lucid (programming language)|Lucid]]\n* [[µC++]]\n* [[MiniD]]\n* [[Modula-2]]\n* [[Nemerle]]\n* [[Perl 5]] (using the [https://metacpan.org/pod/Coro Coro module])\n* [[Perl 6]]<ref>{{cite web | title=Gather and/or Coroutines|url=https://perl6advent.wordpress.com/2012/12/19/gather-andor-coroutines/}}</ref>\n* [[PHP]] (with [https://github.com/facebook/hiphop-php HipHop], native since PHP 5.5)\n* [[Picolisp]]\n* [[Prolog]]\n* [[Python (programming language)|Python]] (since 2.5,<ref>{{cite web |title=Python async/await Tutorial|url=http://stackabuse.com/python-async-await-tutorial/}}</ref> with improved support since 3.3 and with explicit syntax since 3.5<ref>{{cite web |title=Python 3 reference: Coroutine function definition|url=https://docs.python.org/3/reference/compound_stmts.html#async-def}}</ref>)\n* [[Ruby (programming language)|Ruby]]\n* [[Sather]]\n* [[Scheme (programming language)|Scheme]]\n* [[Self (programming language)|Self]]\n* [[Simula]] 67\n* [[Squirrel (programming language)|Squirrel]]\n* [[Stackless Python]]\n* [[SuperCollider]]<ref>McCartney, J. [http://portal.acm.org/citation.cfm?id=1245228 \"Rethinking the Computer Music Programming Language: SuperCollider\"]. Computer Music Journal, 26(4):61-68. MIT Press, 2002.</ref>\n* [[Tcl]] (since 8.6)\n* [[urbiscript]]\n<!-- Coroutines can be implemented in any language, so please limit this list to languages with native support.\nSpecifically, don't re-add the following entries without consideration:\n* [[C Sharp (programming language)|C#]]\n* [[Perl]]\n* [[Smalltalk]]\n-->\n{{div col end}}\nSince [[continuation]]s can be used to implement coroutines, programming languages that support them can also quite easily support coroutines.\n\n==Implementations==\n{{As of|2003}}, many of the most popular programming languages, including C and its derivatives, do not have direct support for coroutines within the language or their standard libraries. (This is, in large part, due to the limitations of [[call stack|stack-based]] subroutine implementation.) An exception is the C++ library [http://www.boost.org/doc/libs/1_55_0/libs/context/doc/html/index.html Boost.Context], part of [http://www.boost.org boost libraries], which supports context swapping on ARM, MIPS, PowerPC, SPARC and x86 on POSIX, Mac OS X and Windows. Coroutines can be built upon Boost.Context.\n\nIn situations where a coroutine would be the natural implementation of a mechanism, but is not available, the typical response is to use a [[Closure (computer science)|closure]]{{snd}}a subroutine with state variables ([[static variable]]s, often boolean flags) to maintain an internal state between calls, and to transfer control to the correct point. Conditionals within the code result in the execution of different code paths on successive calls, based on the values of the state variables. Another typical response is to implement an explicit state machine in the form of a large and complex [[switch statement]] or via a [[goto]] statement, particularly a [[computed goto]]. Such implementations are considered difficult to understand and maintain, and a motivation for coroutine support.\n\n[[thread (computing)|Threads]], and to a lesser extent [[fiber (computer science)|fibers]], are an alternative to coroutines in mainstream programming environments today. Threads provide facilities for managing the realtime cooperative interaction of ''simultaneously'' executing pieces of code. Threads are widely available in environments that support C (and are supported natively in many other modern languages), are familiar to many programmers, and are usually well-implemented, well-documented and well-supported. However, as they solve a large and difficult problem they include many powerful and complex facilities and have a correspondingly difficult learning curve. As such, when a coroutine is all that is needed, using a thread can be overkill.\n\nOne important difference between threads and coroutines is that threads are typically preemptively scheduled while coroutines are not. Because threads can be rescheduled at any instant and can execute concurrently, programs using threads must be careful about [[lock (computer science)|locking]]. In contrast, because coroutines can only be rescheduled at specific points in the program and do not execute concurrently, programs using coroutines can often avoid locking entirely. (This property is also cited as a benefit of [[event-driven programming|event-driven]] or asynchronous programming.)\n\nSince fibers are cooperatively scheduled, they provide an ideal base for implementing coroutines above.<ref name=\"msdn-wrap\">[http://msdn.microsoft.com/msdnmag/issues/03/09/CoroutinesinNET/default.aspx Implementing Coroutines for .NET by Wrapping the Unmanaged Fiber API], Ajai Shankar, [[MSDN Magazine]]</ref> However, system support for fibers is often lacking compared to that for threads.\n\n===Implementations for C===\nSeveral attempts have been made to implement coroutines in [[C (programming language)|C]] with combinations of subroutines and macros. [[Simon Tatham]]'s contribution,<ref name=\"tatham\">{{cite web|url=http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html|author=Simon Tatham|title=Coroutines in C|year=2000}}</ref> based on [[Duff's device]], is a good example of the genre, and is the basis for [[Protothread|Protothreads]]. Tatham's comments provide a frank evaluation of the limitations of this approach: \"Of course, this trick violates every coding standard in the book... [but] any coding standard which insists on syntactic clarity at the expense of algorithmic clarity should be rewritten. If your employer fires you for using this trick, tell them that repeatedly as the security staff drag you out of the building.\" The main shortcoming of this approach is that, in not maintaining a separate stack frame for each coroutine, local variables are not preserved across multiple entries to the function.<ref name=\"tatham\" />\n\nA more reliable approach to implementing coroutines in C is to give up on absolute portability and write platform-specific implementations of functions to save and restore a coroutine context. Methods for achieving this include use of [[sigaltstack]] and a springboard function called from a signal handler<ref  name=\"rse-pmt\">https://www.gnu.org/software/pth/rse-pmt.ps</ref><ref name=\"libco\">https://byuu.org/library/libco/</ref>, as well as less reliable techniques such as jumping the stack pointer into an allocation within the heap (or merely further down the stack) using a [[C99]] [[variable-length array]] or [[C_dynamic_memory_allocation#Extensions_and_alternatives|alloca]]<ref>http://fanf.livejournal.com/105413.html</ref>. The [[setjmp/longjmp|setjmp and longjmp]] functions in the [[standard C library]] can then be used to implement the jumps between coroutines. Portability is an issue, as [[Samuel P. Harbison|Harbison]] and [[Guy L. Steele Jr.|Steele]] note, \"the ''setjmp'' and ''longjmp'' functions are notoriously difficult to implement, and the programmer would do well to make minimal assumptions about them.\"<ref>{{cite book|title=C: A Reference Manual|authors=Samuel P. Harbison and Guy L. Steele, Jr|edition=3|publisher=Prentice-Hall|year=1991|isbn=0-13-110933-2}}</ref>\n\nC libraries complying to [[POSIX]] or the [[Single Unix Specification]] (SUSv3) provide such routines as [[setcontext|getcontext, setcontext, makecontext and swapcontext]].  The setcontext family of functions is thus considerably more powerful than ''setjmp/longjmp'', but conforming implementations are as rare if not rarer. These functions were declared obsolete in POSIX 1.2008 <ref>http://man7.org/linux/man-pages/man3/getcontext.3.html</ref>. Aside from portability, the main shortcoming of this approach is that the coroutine's stack is a fixed size and cannot be grown during execution. Thus, programs tend to allocate much more stack than they actually need to avoid the potential for stack overflow.\n\nDue to the limits of standard libraries, some authors have written their own libraries for coroutines.  Russ Cox's libtask library<ref name=\"libtask\">[http://swtch.com/libtask/] - Russ Cox's libtask coroutine library for FreeBSD, Linux, Mac OS X, and SunOS</ref> is a good example of this genre.  It uses the context functions if they are provided by the native C library; otherwise it provides its own implementations for ARM, PowerPC, Sparc, and x86.  Other notable implementations include libpcl,<ref>[http://xmailserver.org/libpcl.html ''Portable Coroutine Library''] - C library using POSIX/SUSv3 facilities</ref> coro,<ref>[http://www.goron.de/~froese/coro/] - Edgar Toernig's coro library for x86, Linux & FreeBSD</ref> lthread,<ref>[https://github.com/halayli/lthread] - lthread is a multicore/multithread coroutine library written in C</ref> libCoroutine,<ref>{{cite web|url=http://dekorte.com/projects/opensource/libcoroutine/|title=libcoroutine: A portable coroutine implementation}} for FreeBSD, Linux, OS X PPC and x86, SunOS, Symbian and others</ref> libconcurrency,<ref>{{cite web|url=http://code.google.com/p/libconcurrency/libconcurrency|title=libconcurrency - A scalable concurrency library for C}} a simple C library for portable stack-switching coroutines</ref> libcoro,<ref>{{cite web|url=http://software.schmorp.de/pkg/libcoro.html|title=libcoro: C-library that implements coroutines (cooperative multitasking) in a portable fashion}} used as the basis for the Coro perl module.</ref> ribs2,<ref>{{cite web|url=https://github.com/Adaptv/ribs2|title=RIBS (Robust Infrastructure for Backend Systems)}}</ref> libdill.<ref>{{cite web|url=http://libdill.org|title=Structured Concurrency for C}}</ref>, libco<ref name=\"libco\" />, and [[Protothread|Protothreads]].\n\n===Implementations for C++===\n* C++ coroutines TS (Technical Specification), a standard for C++ language extensions for stackless coroutines, is under development. Visual C++, gcc, and Clang already support major portions in the std::experimental namespace. [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf coroutines Technical Specification]\n*[http://www.boost.org/doc/libs/1_57_0/libs/coroutine/doc/html/index.html Boost.Coroutine] - created by Oliver Kowalke, is the official released portable coroutine library of [http://boost.org boost] since version 1.53. The library relies on [http://www.boost.org/doc/libs/1_53_0/libs/context/doc/html/index.html Boost.Context] and supports ARM, MIPS, PowerPC, SPARC and X86 on POSIX, Mac OS X and Windows.\n*[http://www.boost.org/doc/libs/1_61_0/libs/coroutine2/doc/html/index.html Boost.Coroutine2] - also created by Oliver Kowalke, is a modernized portable coroutine library since boost version 1.59. It takes advantage of C++11 features, but removes the support for symmetric coroutines.\n*[https://github.com/mozy/mordor Mordor] - In 2010, [[Mozy]] open sourced a C++ library implementing coroutines, with an emphasis on using them to abstract [[asynchronous I/O]] into a more familiar sequential model.<ref>[http://mozy.com/blog/announcements/open-source-and-mozy-the-debut-of-mozy-code/] - Open Source and Mozy: The Debut of Mozy Code</ref>\n*[https://github.com/jamboree/co2 CO2] - stackless coroutine based on C++ [[preprocessor]] tricks, providing await/yield emulation.\n*[https://github.com/scummvm/scummvm/blob/master/common/coroutines.h ScummVM] - The [[ScummVM]] project implements a light-weight version of coroutines based on [http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html Simon Tatham's article].\n*[https://github.com/tonbit/coroutine tonbit::coroutine] - C++11 single .h asymmetric coroutine implementation via ucontext / fiber\n* Coroutines landed in [[Clang]] in May 2017, with libc++ implementation ongoing.<ref>[https://twitter.com/eric01/status/867473461836263424] - EricWF: Coroutines are now in Clang Trunk! Working on the Libc++ implementation now.</ref>\n* [https://github.com/infinit/elle elle] by Docker\n\n===Implementations for C#===\n*[https://github.com/MindTouch/dream MindTouch Dream] - The MindTouch Dream REST framework provides an implementation of coroutines based on the [[C Sharp (programming language)|C#]] 2.0 iterator pattern\n*[http://caliburn.codeplex.com/Wiki/View.aspx?title=IResult Caliburn] - The Caliburn screen patterns framework for WPF uses C# 2.0 iterators to ease UI programming, particularly in asynchronous scenarios.\n*[http://www.wintellect.com/PowerThreading.aspx Power Threading Library] - The Power Threading Library by [[Jeffrey Richter]] implements an AsyncEnumerator that provides simplified Asynchronous Programming Model using iterator-based coroutines.\n*[https://github.com/yevhen/Servelat-Pieces Servelat Pieces] - The Servelat Pieces project by [[Yevhen Bobrov]] provides transparent asynchrony for Silverlight WCF services and ability to asynchronously call any synchronous method. The implementation is based on Caliburn's Coroutines iterator and C# iterator blocks.\n*[http://msdn.microsoft.com/en-us/library/dscyy5s0(VS.80).aspx] - The .NET 2.0+ Framework now provides semi-coroutine ([[generator (computer programming)|generator]]) functionality through the iterator pattern and yield keyword.\n\n[[C Sharp 5.0|C# 5.0]] includes [[await]] syntax support.\n\n===Implementations for D===\n[[D (programming language)]] implements coroutines as its standard library class [http://dlang.org/phobos/core_thread.html#.Fiber Fiber]\n\n[http://dlang.org/phobos/std_concurrency.html#.Generator Generator] makes it trivial to expose a fiber function as an [http://dlang.org/phobos/std_range_primitives.html#isInputRange InputRange], making any fiber compatible with existing range algorithms.\n\n===Implementations for Java===\nThere are several implementations for coroutines in [[Java (programming language)|Java]].  Despite the constraints imposed by Java's abstractions, the JVM does not preclude the possibility.<ref name=\"jvmsummit\">{{cite web|url=http://www.wiki.jvmlangsummit.com/images/2/2b/JVMLanguageSummit_Stadler_Continuations.pdf|author=Lukas Stadler|series=JVM Language Summit|title=JVM Continuations|year=2009}}</ref> There are four general methods used, but two break bytecode portability among standards-compliant JVMs.\n\n* Modified JVMs. It is possible to build a patched JVM to support coroutines more natively. The [http://openjdk.java.net/projects/mlvm/ Da Vinci JVM] has had patches created.<ref name=\"javanet-forax\">{{cite web|url=http://weblogs.java.net/blog/forax/archive/2009/11/19/holy-crap-jvm-has-coroutinecontinuationfiber-etc|author=Remi Forax|archiveurl=https://web.archive.org/web/20150319052055/http://weblogs.java.net/blog/forax/archive/2009/11/19/holy-crap-jvm-has-coroutinecontinuationfiber-etc|archivedate=19 March 2015|title=Holy crap: JVM has coroutine/continuation/fiber etc.|date=19 November 2009}}</ref>\n* Modified bytecode. Coroutine functionality is possible by rewriting regular Java bytecode, either on the fly or at compile time. Toolkits include [http://commons.apache.org/sandbox/commons-javaflow/ Javaflow], [http://code.google.com/p/coroutines/ Java Coroutines], and [https://github.com/offbynull/coroutines Coroutines].\n* Platform-specific JNI mechanisms. These use JNI methods implemented in the OS or C libraries to provide the functionality to the JVM.{{citation needed|date=May 2014}}\n* Thread abstractions. Coroutine libraries which are implemented using threads may be heavyweight, though performance will vary based on the JVM's thread implementation.\n\n=== Implementations in Javascript ===\n* [https://github.com/fibjs/fibjs Fibjs] - fibjs is a JavaScript runtime built on Chrome's V8 JavaScript engine. fibjs uses [[Fiber (computer science)|fibers-switch]], sync style & non-blocking IO model to build scalable systems.\n* Since [http://es6-features.org/#GeneratorFunctionIteratorProtocol ECMAScript 2015], stackless coroutine functionality through \"generators\" and yield expressions is provided.\n\n===Implementation in Mono===\nThe [[Mono (software)|Mono]] Common Language Runtime has support for continuations,<ref name=\"monoco\">[http://www.mono-project.com/Continuations] Mono Continuations</ref> from which coroutines can be built.\n\n===Implementation in the .NET Framework as fibers===\nDuring the development of the [[.NET Framework]] 2.0, Microsoft extended the design of the [[Common Language Runtime]] (CLR) hosting APIs to handle fiber-based scheduling with an eye towards its use in fiber-mode for SQL server.<ref name=\"cbrumme-fibermode\">[http://blogs.msdn.com/cbrumme/archive/2004/02/21/77595.aspx], Chris Brumme, [http://blogs.msdn.com/cbrumme/default.aspx cbrumme's WebLog]</ref> Before release, support for the task switching hook ICLRTask::SwitchOut was removed due to time constraints.<ref name=\"dino-fibermodegone\">[http://blogs.msdn.com/dinoviehland/archive/2005/09/15/469642.aspx], Dino Viehland, [http://blogs.msdn.com/dinoviehland/default.aspx Dino's Blog]</ref>\nConsequently, the use of the fiber API to switch tasks is currently not a viable option in the .NET Framework.\n\n===Implementations for Python===\n*[[Python (programming language)|Python]] 2.5 implements better support for coroutine-like functionality, based on extended generators ([https://www.python.org/dev/peps/pep-0342/ PEP 342])\n*[[Python (programming language)|Python]] 3.3 improves this ability, by supporting delegating to a subgenerator ([https://www.python.org/dev/peps/pep-0380/ PEP 380])\n*[[Python (programming language)|Python]] 3.4 introduces a comprehensive asynchronous I/O framework as standardized in [https://www.python.org/dev/peps/pep-3156/ PEP 3156], which includes coroutines that leverage subgenerator delegation \n*[[Python (programming language)|Python]] 3.5 introduces explicit support for coroutines with async/[[await]] syntax ([https://www.python.org/dev/peps/pep-0492/ PEP 0492]).\n*[http://eventlet.net/ Eventlet]\n*[https://github.com/python-greenlet/greenlet Greenlet]\n*[http://www.gevent.org gevent]\n*[https://pypi.python.org/pypi/multitask multitask]\n*[http://chiral.j4cbo.com/trac chiral]\n*[http://code.google.com/p/cogen cogen]\n*[http://www.kamaelia.org Kamaelia]\n*[https://github.com/ironport/shrapnel/ Shrapnel]\n*[http://www.stackless.com/ stackless python]\n\n===Implementations for Ruby===\n* [[Ruby (programming language)|Ruby]] 1.9 supports coroutines natively which are implemented as [http://rubydoc.info/stdlib/core/1.9.2/Fiber fibers], which are semi-coroutines.<ref>{{cite web|url=http://www.ruby-forum.com/topic/126011 |authorlink1=https://web.archive.org/web/20071024123936/http://www.ruby-forum.com/topic/126011 |title=semi-coroutines |archivedate=October 24, 2007 |language=English |deadurl=yes |archiveurl=https://web.archive.org/web/20071024123936/http://www.ruby-forum.com/topic/126011 }}</ref>\n* [http://liber.sourceforge.net/coroutines.rb An implementation by Marc De Scheemaecker]\n\n===Implementations for Perl===\n* [https://metacpan.org/module/Coro Coro]\n\nCoroutines are natively implemented in all [[Perl 6]] backends.<ref>{{cite web | title = RFC #31 | url = http://www.perl6.org/archive/rfc/31}}</ref>\n\n===Implementations for Rust===\nThere is a library for [[Rust (programming language)|Rust]] that provides coroutines.<ref>{{cite web|url=https://crates.io/crates/coroutine|title=coroutine - Cargo: packages for Rust|accessdate=2017-06-24}}</ref>\nGenerators are an experimental feature available in nightly rust that provides an implementation of coroutines with async/await.<ref>{{cite web|title=Tracking issue for RFC 2033: Experimentally add coroutines to Rust|url=https://github.com/rust-lang/rust/issues/43122|website=GitHub}}</ref>\n\n===Implementations for Scala===\n[http://storm-enroute.com/coroutines/ Scala Coroutines] is a coroutine implementation for [[Scala (programming language)|Scala]]. This implementation is a library-level extension that relies on the Scala macro system to statically transform sections of the program into coroutine objects. As such, this implementation does not require modifications in the JVM, so it is fully portable between different JVMs and works with alternative Scala backends, such as [[Scala.js (programming language)|Scala.js]], which compiles to JavaScript.<ref>[http://storm-enroute.com/coroutines/docs/faq/ Scala Coroutines FAQ]</ref>\n\nScala Coroutines rely on the <code>coroutine</code> macro that transforms a normal block of code into a coroutine definition. Such a coroutine definition can be invoked with the <code>call</code> operation, which instantiates a coroutine frame. A coroutine frame can be resumed with the <code>resume</code> method, which resumes the execution of the coroutine's body, until reaching a <code>yieldval</code> keyword, which suspends the coroutine frame. Scala Coroutines also expose a <code>snapshot</code> method, which effectively duplicates the coroutine.<ref name=\"scala-coroutine-snapshots\">[http://storm-enroute.com/coroutines/docs/0.6/snapshots/index.html Scala Coroutine Snapshots]</ref>\n\n===Implementations for Smalltalk===\nSince, in most [[Smalltalk]] environments, the execution stack is a first-class citizen, coroutines can be implemented without additional library or VM support.\n\n===Implementations for Scheme===\nSince [[Scheme (programming language)|Scheme]] provides full support for continuations, implementing coroutines is nearly trivial, requiring only that a queue of continuations be maintained.\n\n===Implementation for Tool Command Language (Tcl)===\nSince version 8.6, the Tool Command Language supports coroutines in the core language.\n<ref>{{cite web|url=https://www.tcl.tk/man/tcl/TclCmd/coroutine.htm |title=coroutine manual page - Tcl Built-In Commands |publisher=Tcl.tk |date= |accessdate=2016-06-27}}</ref>\n\n===Implementations for Vala===\n[[vala (programming language)|Vala]] implements native support for coroutines. They are designed to be used with a Gtk Main Loop, but can be used alone if care is taken to ensure that the end callback will never have to be called before doing, at least, one yield.\n\n===Implementations in assembly languages===\nMachine-dependent [[assembly language]]s often provide direct methods for coroutine execution. For example, in [[MACRO-11]], the assembly language of the [[PDP-11]] family of minicomputers, the “classic” coroutine switch is effected by the instruction \"JSR PC,@(SP)+\", which jumps to the address popped from the stack and pushes the current (''i.e'' that of the '''next''') instruction address onto the stack. On [[VAX]]en (in [[VAX Macro|Macro-32]]) the comparable instruction is \"JSB @(SP)+\". Even on a [[Motorola 6809]] there is the instruction \"JSR [,S++]\"; note the \"++\", as 2 bytes (of address) are popped from the stack. This instruction is much used in the (standard) 'monitor' [[ASSIST (computing)|Assist]] 09.\n\n==See also==\n* [[Pipeline (Unix)]], a kind of coroutine used for communicating between programs<ref name=\"EvolutionUnix\"/>\n* [[Protothreads]], a stackless lightweight thread implementation using a coroutine like mechanism\n\n==References==\n{{Reflist|refs=\n<ref name=\"KnuthVol1_1_4_5\">{{Cite book | first = Donald Ervin | last = Knuth | series = The Art of Computer Programming | volume = 1 | title = Fundamental Algorithms | edition = 3rd | publisher = Addison-Wesley | year = 1997| isbn = 0-201-89683-4 | at = Section 1.4.5: History and Bibliography, pp.&nbsp;229}}</ref> <!--pages = 229-->\n<ref name=\"Conway1963\">{{Cite journal | last1 = Conway | first1 = M. E. | doi = 10.1145/366663.366704 | title = Design of a Separable Transition-Diagram Compiler| journal = Communications of the ACM | publisher = Association for Computing Machinery| location = New York, NY, USA | volume = 6 | issue = 7| pages = 396&ndash;408 | date =July 1963 }}</ref>\n<ref name=\"KnuthVol1_1_4_2\">{{Cite book | first = Donald Ervin | last = Knuth | series = The Art of Computer Programming | volume = 1 | title = Fundamental Algorithms | edition = 3rd | publisher = Addison-Wesley | year = 1997| isbn = 0-201-89683-4 | at = Section 1.4.2: Coroutines, pp.&nbsp;193–200}}</ref> <!--pages = 193–200-->\n<ref name=\"EvolutionUnix\">{{Cite journal | first = Dennis M. | last = Ritchie | title = The Evolution of the Unix Time-sharing System | url = http://cm.bell-labs.com/cm/cs/who/dmr/hist.html | journal = Lecture Notes in Computer Science | year = 1980 | volume = 79 | issue = Language Design and Programming Methodology | pages = 25–35 | doi=10.1007/3-540-09745-7_2}}</ref>\n<ref name=\"Perlis1982_6\">{{Cite journal\n| last1 = Perlis | first1 = Alan J.\n| doi = 10.1145/947955.1083808\n| title = Epigrams on programming\n| journal = ACM SIGPLAN Notices\n| publisher = Association for Computing Machinery\n| location = New York, NY, USA\n| volume = 17\n| issue = 9\n| pages = 7–13\n|date=September 1982\n| url = http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html\n| archiveurl = https://web.archive.org/web/19990117034445/http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html\n| archivedate = January 17, 1999\n| quote = 6. Symmetry is a complexity reducing concept (co-routines include sub-routines); seek it everywhere\n}}</ref>\n<ref name=\"MertzIBM\">{{cite web|url=http://www.ibm.com/developerworks/library/l-pygen.html |title=Generator-based State Machines |work=Charming Python |first=David |last=Mertz |publisher=IBM developerWorks |date=July 1, 2002 |accessdate=Feb 2, 2011 |archiveurl=https://www.webcitation.org/5wCZa062h?url=http://www.ibm.com/developerworks/library/l-pygen.html |archivedate=February 2, 2011 |deadurl=yes |df= }}</ref>\n}}\n\n==Further reading==\n* {{cite journal|citeseerx=10.1.1.58.4017|author1=Ana Lucia de Moura|author2=Roberto Ierusalimschy|title=Revisiting Coroutines|year=2004|doi=10.1145/1462166.1462167}}\n\n==External links==\n* [[Simon Tatham]]'s C oriented [http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html comprehensive introduction to coroutines]\n* [http://www.softpanorama.org/Lang/coroutines.shtml Softpanorama coroutine page]{{snd}}contains extensive assembler coroutines links\n\n[[Category:Concurrent computing]]\n[[Category:Subroutines]]"
            },
            "slug": "coroutine",
            "date_updated": 1532100153755,
            "imported": "https://en.wikipedia.org/wiki/Coroutine"
        },
        {
            "title": "Coroutine",
            "text": {
                "title": "Coroutine",
                "content": "'''Coroutines''' are [[computer program|computer-program]] components that generalize [[subroutine]]s for [[non-preemptive multitasking]], by allowing multiple [[entry point]]s for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing familiar program components such as [[cooperative multitasking|cooperative task]]s, [[exception handling|exception]]s, [[event loop]]s, [[iterator]]s, [[lazy evaluation|infinite list]]s and [[pipeline (software)|pipe]]s.\n\nAccording to [[Donald Knuth]], [[Melvin Conway]] coined the term ''coroutine'' in 1958 when he applied it to construction of an [[assembly language|assembly program]].<ref name=\"KnuthVol1_1_4_5\" /> The first published explanation of the coroutine appeared later, in 1963.<ref name=\"Conway1963\"/>\n\n==Comparison with subroutines==\nSubroutines are special cases of coroutines.<ref name=\"KnuthVol1_1_4_2\"/> When subroutines are invoked, execution begins at the start, and once a subroutine exits, it is finished; an instance of a subroutine only returns once, and does not hold state between invocations. By contrast, coroutines can exit by calling other coroutines, which may later return to the point where they were invoked in the original coroutine; from the coroutine's point of view, it is not exiting but calling another coroutine.<ref name=\"KnuthVol1_1_4_2\"/> Thus, a coroutine instance holds state, and varies between invocations; there can be multiple instances of a given coroutine at once. The difference between calling another coroutine by means of [[Yield (multithreading)|\"yielding\"]] to it and simply calling another routine (which then, also, would return to the original point), is that the relationship between two coroutines which yield to each other is not that of caller-callee, but instead symmetric.\n\nAny subroutine can be translated to a coroutine which does not call ''yield''.<ref name=\"Perlis1982_6\"/>\n\nHere is a simple example of how coroutines can be useful. Suppose you have a consumer-producer relationship where one routine creates items and adds them to a queue and another removes items from the queue and uses them. For reasons of efficiency, you want to add and remove several items at once. The code might look like this:\n\n ''var'' q := new queue\n \n '''coroutine''' produce\n     '''loop'''\n         '''while''' q is not full\n             create some new items\n             add the items to q\n         '''yield''' to consume\n \n '''coroutine''' consume\n     '''loop'''\n         '''while''' q is not empty\n             remove some items from q\n             use the items\n         '''yield''' to produce\n\nThe queue is then completely filled or emptied before yielding control to the other coroutine using the ''yield'' command. The further coroutines calls are starting right after the ''yield'', in the outer coroutine loop.\n\nAlthough this example is often used to introduce [[thread (computing)|multithreading]], two threads are not needed for this: the ''yield'' statement can be implemented by a jump directly from one routine into the other.\n\n==Comparison with generators==\n[[generator (computer science)|Generators]], also known as semicoroutines,<ref name=\"Ralston2000\">{{cite book|author=Anthony Ralston|title=Encyclopedia of computer science|url=https://books.google.com/books?id=yQ9LAQAAIAAJ|accessdate=11 May 2013|year=2000|publisher=Nature Pub. Group|isbn=978-1-56159-248-7}}</ref> are also a generalisation of subroutines, but are more limited than coroutines. Specifically, while both of these can yield multiple times, suspending their execution and allowing re-entry at multiple entry points, they differ in coroutines' ability to control where execution continues immediately after they yield, while generators cannot, instead transferring control back to the generator's caller.<ref>See for example ''[https://docs.python.org/reference/index.html The Python Language Reference]''\n\"https://docs.python.org/reference/expressions.html#yieldexpr 5.2.10. Yield expressions]\":<br />\n\"All of this makes generator functions quite similar to coroutines; they yield multiple times, they have more than one entry point and their execution can be suspended. The only difference is that a generator function cannot control where should the execution continue after it yields; the control is always transferred to the generator's caller.\"</ref> That is, since generators are primarily used to simplify the writing of [[iterator]]s, the <code>yield</code> statement in a generator does not specify a coroutine to jump to, but rather passes a value back to a parent routine.\n\nHowever, it is still possible to implement coroutines on top of a generator facility, with the aid of a top-level dispatcher routine (a [[trampoline (computing)|trampoline]], essentially) that passes control explicitly to child generators identified by tokens passed back from the generators:\n\n ''var'' q := new queue\n\n '''generator''' produce\n     '''loop'''\n         '''while''' q is not full\n             create some new items\n             add the items to q\n         '''yield''' consume\n\n '''generator''' consume\n     '''loop'''\n         '''while''' q is not empty\n             remove some items from q\n             use the items\n         '''yield''' produce\n\n '''subroutine''' dispatcher\n     ''var'' d := new dictionary('''generator''' → '''iterator''')\n     d[produce] := '''start''' produce\n     d[consume] := '''start''' consume\n     ''var'' current := produce\n     '''loop'''\n         current := '''next''' d[current]\n\nA number of implementations of coroutines for languages with generator support but no native coroutines (e.g. Python<ref name=\"MertzIBM\"/> before 2.5) use this or a similar model.\n\n==Comparison with mutual recursion==\n{{Further|Mutual recursion}}\nUsing coroutines for state machines or concurrency is similar to using [[mutual recursion]] with [[tail call]]s, as in both cases the control changes to a different one of a set of routines. However, coroutines are more flexible and generally more efficient. Since coroutines yield rather than return, and then resume execution rather than restarting from the beginning, they are able to hold state, both variables (as in a closure) and execution point, and yields are not limited to being in tail position; mutually recursive subroutines must either use shared variables or pass state as parameters. Further, each mutually recursive call of a subroutine requires a new stack frame (unless [[tail call elimination]] is implemented), while passing control between coroutines uses the existing contexts and can be implemented simply by a jump.\n\n==Common uses==\nCoroutines are useful to implement the following:\n\n* [[State machine]]s within a single subroutine, where the state is determined by the current entry/exit point of the procedure; this can result in more readable code compared to use of [[goto]], and may also be implemented via [[mutual recursion]] with [[tail call]]s.\n* [[Actor model]] of concurrency, for instance in [[video game]]s. Each actor has its own procedures (this again logically separates the code), but they voluntarily give up control to central scheduler, which executes them sequentially (this is a form of [[cooperative multitasking]]).\n* [[Generator (computer programming)|Generator]]s, and these are useful for [[Stream (computing)|streams]]{{snd}}particularly input/output{{snd}}and for generic traversal of data structures.\n* [[Communicating sequential processes]] where each sub-process is a coroutine. Channel inputs/outputs and blocking operations yield coroutines and a scheduler unblocks them on completion events.\n\n==Programming languages with native support==\n\nCoroutines originated as an [[assembly language]] method, but are supported in some [[high-level programming language]]s.  Early examples include [[Simula]]<ref name=\"Dahl1972\">{{cite book|title=Structured Programming|author=Dahl, O.-J. and Hoare, C.A.R. (ed)|first=|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175-220|chapter=Hierarchical Program Structures}}</ref> and [[Modula-2]]. More recent examples are [[Ruby (programming language)|Ruby]], [[Lua (programming language)|Lua]],  [[Julia (programming language)|Julia]], and [[Go (programming language)|Go]].\n\n{{Div col|colwidth=18em}}\n* [[Aikido (programming language)|Aikido]]\n* [[AngelScript]]\n* [[BCPL]]\n* [[Pascal (programming language)|Pascal]] (Borland [[Turbo Pascal]] 7.0 with uThreads module)\n* [[BETA (programming language)|BETA]]\n* [[BLISS]]\n* [[ChucK]]\n* [[D (programming language)|D]]\n* [[Dynamic C]]\n* [[Erlang (programming language)|Erlang]]\n* [[F Sharp (programming language)|F#]]\n* [[Factor (programming language)|Factor]]\n* [[GameMonkey Script]]\n* [[Godot (game engine)|GDScript]] (Godot's scripting language)\n* [[Go (programming language)|Go]]\n* [[Haskell (programming language)|Haskell]]<ref>{{cite web\n| title = Coroutine: Type-safe coroutines using lightweight session types\n| url = http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Coroutine\n}}</ref><ref>{{cite web\n| title = Co-routines in Haskell\n| url = http://random.axman6.com/blog/?p=231\n}}</ref>\n* [[High Level Assembly]]<ref>{{cite web\n| title = The Coroutines Module (coroutines.hhf)\n| url = http://www.plantation-productions.com/Webster/HighLevelAsm/HLADoc/HLAStdlib/1_HTML/HLAStdlib.htm#50618574_pgfId-998318\n| work = HLA Standard Library Manual\n}}</ref>\n* [[Icon (programming language)|Icon]]\n* [[Io (programming language)|Io]]\n* [[JavaScript]] (since 1.7, standardized in ECMAScript 6)<ref>{{cite web\n| title = New in JavaScript 1.7\n| url = https://developer.mozilla.org/en/docs/New_in_JavaScript_1.7\n}}</ref><!-- Does JavaScript belong here? See the link. --> ECMAScript 2017 also includes [[await]] support.\n* [[Julia (programming language)|Julia]]<ref>{{cite web | title=Julia Manual - Control Flow - Tasks (aka Coroutines)|url=http://docs.julialang.org/en/latest/manual/control-flow#man-tasks-1}}</ref>\n* [[Kotlin (programming language)|Kotlin]] (since 1.1)<ref>{{cite web | title=What's New in Kotlin 1.1|url=https://kotlinlang.org/docs/reference/whatsnew11.html#coroutines-experimental}}</ref>\n* [[Limbo (programming language)|Limbo]]\n* [[Lua (programming language)|Lua]]<ref>{{cite web |title=Lua 5.2 Reference Manual – 2.6 – Coroutines|url=http://www.lua.org/manual/5.2/manual.html#2.6}}</ref>\n* [[Lucid (programming language)|Lucid]]\n* [[µC++]]\n* [[MiniD]]\n* [[Modula-2]]\n* [[Nemerle]]\n* [[Perl 5]] (using the [https://metacpan.org/pod/Coro Coro module])\n* [[Perl 6]]<ref>{{cite web | title=Gather and/or Coroutines|url=https://perl6advent.wordpress.com/2012/12/19/gather-andor-coroutines/}}</ref>\n* [[PHP]] (with [https://github.com/facebook/hiphop-php HipHop], native since PHP 5.5)\n* [[Picolisp]]\n* [[Prolog]]\n* [[Python (programming language)|Python]] (since 2.5,<ref>{{cite web |title=Python async/await Tutorial|url=http://stackabuse.com/python-async-await-tutorial/}}</ref> with improved support since 3.3 and with explicit syntax since 3.5<ref>{{cite web |title=Python 3 reference: Coroutine function definition|url=https://docs.python.org/3/reference/compound_stmts.html#async-def}}</ref>)\n* [[Ruby (programming language)|Ruby]]\n* [[Sather]]\n* [[Scheme (programming language)|Scheme]]\n* [[Self (programming language)|Self]]\n* [[Simula]] 67\n* [[Squirrel (programming language)|Squirrel]]\n* [[Stackless Python]]\n* [[SuperCollider]]<ref>McCartney, J. [http://portal.acm.org/citation.cfm?id=1245228 \"Rethinking the Computer Music Programming Language: SuperCollider\"]. Computer Music Journal, 26(4):61-68. MIT Press, 2002.</ref>\n* [[Tcl]] (since 8.6)\n* [[urbiscript]]\n<!-- Coroutines can be implemented in any language, so please limit this list to languages with native support.\nSpecifically, don't re-add the following entries without consideration:\n* [[C Sharp (programming language)|C#]]\n* [[Perl]]\n* [[Smalltalk]]\n-->\n{{div col end}}\nSince [[continuation]]s can be used to implement coroutines, programming languages that support them can also quite easily support coroutines.\n\n==Implementations==\n{{As of|2003}}, many of the most popular programming languages, including C and its derivatives, do not have direct support for coroutines within the language or their standard libraries. (This is, in large part, due to the limitations of [[call stack|stack-based]] subroutine implementation.) An exception is the C++ library [http://www.boost.org/doc/libs/1_55_0/libs/context/doc/html/index.html Boost.Context], part of [http://www.boost.org boost libraries], which supports context swapping on ARM, MIPS, PowerPC, SPARC and x86 on POSIX, Mac OS X and Windows. Coroutines can be built upon Boost.Context.\n\nIn situations where a coroutine would be the natural implementation of a mechanism, but is not available, the typical response is to use a [[Closure (computer science)|closure]]{{snd}}a subroutine with state variables ([[static variable]]s, often boolean flags) to maintain an internal state between calls, and to transfer control to the correct point. Conditionals within the code result in the execution of different code paths on successive calls, based on the values of the state variables. Another typical response is to implement an explicit state machine in the form of a large and complex [[switch statement]] or via a [[goto]] statement, particularly a [[computed goto]]. Such implementations are considered difficult to understand and maintain, and a motivation for coroutine support.\n\n[[thread (computing)|Threads]], and to a lesser extent [[fiber (computer science)|fibers]], are an alternative to coroutines in mainstream programming environments today. Threads provide facilities for managing the realtime cooperative interaction of ''simultaneously'' executing pieces of code. Threads are widely available in environments that support C (and are supported natively in many other modern languages), are familiar to many programmers, and are usually well-implemented, well-documented and well-supported. However, as they solve a large and difficult problem they include many powerful and complex facilities and have a correspondingly difficult learning curve. As such, when a coroutine is all that is needed, using a thread can be overkill.\n\nOne important difference between threads and coroutines is that threads are typically preemptively scheduled while coroutines are not. Because threads can be rescheduled at any instant and can execute concurrently, programs using threads must be careful about [[lock (computer science)|locking]]. In contrast, because coroutines can only be rescheduled at specific points in the program and do not execute concurrently, programs using coroutines can often avoid locking entirely. (This property is also cited as a benefit of [[event-driven programming|event-driven]] or asynchronous programming.)\n\nSince fibers are cooperatively scheduled, they provide an ideal base for implementing coroutines above.<ref name=\"msdn-wrap\">[http://msdn.microsoft.com/msdnmag/issues/03/09/CoroutinesinNET/default.aspx Implementing Coroutines for .NET by Wrapping the Unmanaged Fiber API], Ajai Shankar, [[MSDN Magazine]]</ref> However, system support for fibers is often lacking compared to that for threads.\n\n===Implementations for C===\nSeveral attempts have been made to implement coroutines in [[C (programming language)|C]] with combinations of subroutines and macros. [[Simon Tatham]]'s contribution,<ref name=\"tatham\">{{cite web|url=http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html|author=Simon Tatham|title=Coroutines in C|year=2000}}</ref> based on [[Duff's device]], is a good example of the genre, and is the basis for [[Protothread|Protothreads]]. Tatham's comments provide a frank evaluation of the limitations of this approach: \"Of course, this trick violates every coding standard in the book... [but] any coding standard which insists on syntactic clarity at the expense of algorithmic clarity should be rewritten. If your employer fires you for using this trick, tell them that repeatedly as the security staff drag you out of the building.\" The main shortcoming of this approach is that, in not maintaining a separate stack frame for each coroutine, local variables are not preserved across multiple entries to the function.<ref name=\"tatham\" />\n\nA more reliable approach to implementing coroutines in C is to give up on absolute portability and write platform-specific implementations of functions to save and restore a coroutine context. Methods for achieving this include use of [[sigaltstack]] and a springboard function called from a signal handler<ref  name=\"rse-pmt\">https://www.gnu.org/software/pth/rse-pmt.ps</ref><ref name=\"libco\">https://byuu.org/library/libco/</ref>, as well as less reliable techniques such as jumping the stack pointer into an allocation within the heap (or merely further down the stack) using a [[C99]] [[variable-length array]] or [[C_dynamic_memory_allocation#Extensions_and_alternatives|alloca]]<ref>http://fanf.livejournal.com/105413.html</ref>. The [[setjmp/longjmp|setjmp and longjmp]] functions in the [[standard C library]] can then be used to implement the jumps between coroutines. Portability is an issue, as [[Samuel P. Harbison|Harbison]] and [[Guy L. Steele Jr.|Steele]] note, \"the ''setjmp'' and ''longjmp'' functions are notoriously difficult to implement, and the programmer would do well to make minimal assumptions about them.\"<ref>{{cite book|title=C: A Reference Manual|authors=Samuel P. Harbison and Guy L. Steele, Jr|edition=3|publisher=Prentice-Hall|year=1991|isbn=0-13-110933-2}}</ref>\n\nC libraries complying to [[POSIX]] or the [[Single Unix Specification]] (SUSv3) provide such routines as [[setcontext|getcontext, setcontext, makecontext and swapcontext]].  The setcontext family of functions is thus considerably more powerful than ''setjmp/longjmp'', but conforming implementations are as rare if not rarer. These functions were declared obsolete in POSIX 1.2008 <ref>http://man7.org/linux/man-pages/man3/getcontext.3.html</ref>. Aside from portability, the main shortcoming of this approach is that the coroutine's stack is a fixed size and cannot be grown during execution. Thus, programs tend to allocate much more stack than they actually need to avoid the potential for stack overflow.\n\nDue to the limits of standard libraries, some authors have written their own libraries for coroutines.  Russ Cox's libtask library<ref name=\"libtask\">[http://swtch.com/libtask/] - Russ Cox's libtask coroutine library for FreeBSD, Linux, Mac OS X, and SunOS</ref> is a good example of this genre.  It uses the context functions if they are provided by the native C library; otherwise it provides its own implementations for ARM, PowerPC, Sparc, and x86.  Other notable implementations include libpcl,<ref>[http://xmailserver.org/libpcl.html ''Portable Coroutine Library''] - C library using POSIX/SUSv3 facilities</ref> coro,<ref>[http://www.goron.de/~froese/coro/] - Edgar Toernig's coro library for x86, Linux & FreeBSD</ref> lthread,<ref>[https://github.com/halayli/lthread] - lthread is a multicore/multithread coroutine library written in C</ref> libCoroutine,<ref>{{cite web|url=http://dekorte.com/projects/opensource/libcoroutine/|title=libcoroutine: A portable coroutine implementation}} for FreeBSD, Linux, OS X PPC and x86, SunOS, Symbian and others</ref> libconcurrency,<ref>{{cite web|url=http://code.google.com/p/libconcurrency/libconcurrency|title=libconcurrency - A scalable concurrency library for C}} a simple C library for portable stack-switching coroutines</ref> libcoro,<ref>{{cite web|url=http://software.schmorp.de/pkg/libcoro.html|title=libcoro: C-library that implements coroutines (cooperative multitasking) in a portable fashion}} used as the basis for the Coro perl module.</ref> ribs2,<ref>{{cite web|url=https://github.com/Adaptv/ribs2|title=RIBS (Robust Infrastructure for Backend Systems)}}</ref> libdill.<ref>{{cite web|url=http://libdill.org|title=Structured Concurrency for C}}</ref>, libco<ref name=\"libco\" />, and [[Protothread|Protothreads]].\n\n===Implementations for C++===\n* C++ coroutines TS (Technical Specification), a standard for C++ language extensions for stackless coroutines, is under development. Visual C++, gcc, and Clang already support major portions in the std::experimental namespace. [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf coroutines Technical Specification]\n*[http://www.boost.org/doc/libs/1_57_0/libs/coroutine/doc/html/index.html Boost.Coroutine] - created by Oliver Kowalke, is the official released portable coroutine library of [http://boost.org boost] since version 1.53. The library relies on [http://www.boost.org/doc/libs/1_53_0/libs/context/doc/html/index.html Boost.Context] and supports ARM, MIPS, PowerPC, SPARC and X86 on POSIX, Mac OS X and Windows.\n*[http://www.boost.org/doc/libs/1_61_0/libs/coroutine2/doc/html/index.html Boost.Coroutine2] - also created by Oliver Kowalke, is a modernized portable coroutine library since boost version 1.59. It takes advantage of C++11 features, but removes the support for symmetric coroutines.\n*[https://github.com/mozy/mordor Mordor] - In 2010, [[Mozy]] open sourced a C++ library implementing coroutines, with an emphasis on using them to abstract [[asynchronous I/O]] into a more familiar sequential model.<ref>[http://mozy.com/blog/announcements/open-source-and-mozy-the-debut-of-mozy-code/] - Open Source and Mozy: The Debut of Mozy Code</ref>\n*[https://github.com/jamboree/co2 CO2] - stackless coroutine based on C++ [[preprocessor]] tricks, providing await/yield emulation.\n*[https://github.com/scummvm/scummvm/blob/master/common/coroutines.h ScummVM] - The [[ScummVM]] project implements a light-weight version of coroutines based on [http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html Simon Tatham's article].\n*[https://github.com/tonbit/coroutine tonbit::coroutine] - C++11 single .h asymmetric coroutine implementation via ucontext / fiber\n* Coroutines landed in [[Clang]] in May 2017, with libc++ implementation ongoing.<ref>[https://twitter.com/eric01/status/867473461836263424] - EricWF: Coroutines are now in Clang Trunk! Working on the Libc++ implementation now.</ref>\n* [https://github.com/infinit/elle elle] by Docker\n\n===Implementations for C#===\n*[https://github.com/MindTouch/dream MindTouch Dream] - The MindTouch Dream REST framework provides an implementation of coroutines based on the [[C Sharp (programming language)|C#]] 2.0 iterator pattern\n*[http://caliburn.codeplex.com/Wiki/View.aspx?title=IResult Caliburn] - The Caliburn screen patterns framework for WPF uses C# 2.0 iterators to ease UI programming, particularly in asynchronous scenarios.\n*[http://www.wintellect.com/PowerThreading.aspx Power Threading Library] - The Power Threading Library by [[Jeffrey Richter]] implements an AsyncEnumerator that provides simplified Asynchronous Programming Model using iterator-based coroutines.\n*[https://github.com/yevhen/Servelat-Pieces Servelat Pieces] - The Servelat Pieces project by [[Yevhen Bobrov]] provides transparent asynchrony for Silverlight WCF services and ability to asynchronously call any synchronous method. The implementation is based on Caliburn's Coroutines iterator and C# iterator blocks.\n*[http://msdn.microsoft.com/en-us/library/dscyy5s0(VS.80).aspx] - The .NET 2.0+ Framework now provides semi-coroutine ([[generator (computer programming)|generator]]) functionality through the iterator pattern and yield keyword.\n\n[[C Sharp 5.0|C# 5.0]] includes [[await]] syntax support.\n\n===Implementations for D===\n[[D (programming language)]] implements coroutines as its standard library class [http://dlang.org/phobos/core_thread.html#.Fiber Fiber]\n\n[http://dlang.org/phobos/std_concurrency.html#.Generator Generator] makes it trivial to expose a fiber function as an [http://dlang.org/phobos/std_range_primitives.html#isInputRange InputRange], making any fiber compatible with existing range algorithms.\n\n===Implementations for Java===\nThere are several implementations for coroutines in [[Java (programming language)|Java]].  Despite the constraints imposed by Java's abstractions, the JVM does not preclude the possibility.<ref name=\"jvmsummit\">{{cite web|url=http://www.wiki.jvmlangsummit.com/images/2/2b/JVMLanguageSummit_Stadler_Continuations.pdf|author=Lukas Stadler|series=JVM Language Summit|title=JVM Continuations|year=2009}}</ref> There are four general methods used, but two break bytecode portability among standards-compliant JVMs.\n\n* Modified JVMs. It is possible to build a patched JVM to support coroutines more natively. The [http://openjdk.java.net/projects/mlvm/ Da Vinci JVM] has had patches created.<ref name=\"javanet-forax\">{{cite web|url=http://weblogs.java.net/blog/forax/archive/2009/11/19/holy-crap-jvm-has-coroutinecontinuationfiber-etc|author=Remi Forax|archiveurl=https://web.archive.org/web/20150319052055/http://weblogs.java.net/blog/forax/archive/2009/11/19/holy-crap-jvm-has-coroutinecontinuationfiber-etc|archivedate=19 March 2015|title=Holy crap: JVM has coroutine/continuation/fiber etc.|date=19 November 2009}}</ref>\n* Modified bytecode. Coroutine functionality is possible by rewriting regular Java bytecode, either on the fly or at compile time. Toolkits include [http://commons.apache.org/sandbox/commons-javaflow/ Javaflow], [http://code.google.com/p/coroutines/ Java Coroutines], and [https://github.com/offbynull/coroutines Coroutines].\n* Platform-specific JNI mechanisms. These use JNI methods implemented in the OS or C libraries to provide the functionality to the JVM.{{citation needed|date=May 2014}}\n* Thread abstractions. Coroutine libraries which are implemented using threads may be heavyweight, though performance will vary based on the JVM's thread implementation.\n\n=== Implementations in Javascript ===\n* [https://github.com/fibjs/fibjs Fibjs] - fibjs is a JavaScript runtime built on Chrome's V8 JavaScript engine. fibjs uses [[Fiber (computer science)|fibers-switch]], sync style & non-blocking IO model to build scalable systems.\n* Since [http://es6-features.org/#GeneratorFunctionIteratorProtocol ECMAScript 2015], stackless coroutine functionality through \"generators\" and yield expressions is provided.\n\n===Implementation in Mono===\nThe [[Mono (software)|Mono]] Common Language Runtime has support for continuations,<ref name=\"monoco\">[http://www.mono-project.com/Continuations] Mono Continuations</ref> from which coroutines can be built.\n\n===Implementation in the .NET Framework as fibers===\nDuring the development of the [[.NET Framework]] 2.0, Microsoft extended the design of the [[Common Language Runtime]] (CLR) hosting APIs to handle fiber-based scheduling with an eye towards its use in fiber-mode for SQL server.<ref name=\"cbrumme-fibermode\">[http://blogs.msdn.com/cbrumme/archive/2004/02/21/77595.aspx], Chris Brumme, [http://blogs.msdn.com/cbrumme/default.aspx cbrumme's WebLog]</ref> Before release, support for the task switching hook ICLRTask::SwitchOut was removed due to time constraints.<ref name=\"dino-fibermodegone\">[http://blogs.msdn.com/dinoviehland/archive/2005/09/15/469642.aspx], Dino Viehland, [http://blogs.msdn.com/dinoviehland/default.aspx Dino's Blog]</ref>\nConsequently, the use of the fiber API to switch tasks is currently not a viable option in the .NET Framework.\n\n===Implementations for Python===\n*[[Python (programming language)|Python]] 2.5 implements better support for coroutine-like functionality, based on extended generators ([https://www.python.org/dev/peps/pep-0342/ PEP 342])\n*[[Python (programming language)|Python]] 3.3 improves this ability, by supporting delegating to a subgenerator ([https://www.python.org/dev/peps/pep-0380/ PEP 380])\n*[[Python (programming language)|Python]] 3.4 introduces a comprehensive asynchronous I/O framework as standardized in [https://www.python.org/dev/peps/pep-3156/ PEP 3156], which includes coroutines that leverage subgenerator delegation \n*[[Python (programming language)|Python]] 3.5 introduces explicit support for coroutines with async/[[await]] syntax ([https://www.python.org/dev/peps/pep-0492/ PEP 0492]).\n*[http://eventlet.net/ Eventlet]\n*[https://github.com/python-greenlet/greenlet Greenlet]\n*[http://www.gevent.org gevent]\n*[https://pypi.python.org/pypi/multitask multitask]\n*[http://chiral.j4cbo.com/trac chiral]\n*[http://code.google.com/p/cogen cogen]\n*[http://www.kamaelia.org Kamaelia]\n*[https://github.com/ironport/shrapnel/ Shrapnel]\n*[http://www.stackless.com/ stackless python]\n\n===Implementations for Ruby===\n* [[Ruby (programming language)|Ruby]] 1.9 supports coroutines natively which are implemented as [http://rubydoc.info/stdlib/core/1.9.2/Fiber fibers], which are semi-coroutines.<ref>{{cite web|url=http://www.ruby-forum.com/topic/126011 |authorlink1=https://web.archive.org/web/20071024123936/http://www.ruby-forum.com/topic/126011 |title=semi-coroutines |archivedate=October 24, 2007 |language=English |deadurl=yes |archiveurl=https://web.archive.org/web/20071024123936/http://www.ruby-forum.com/topic/126011 }}</ref>\n* [http://liber.sourceforge.net/coroutines.rb An implementation by Marc De Scheemaecker]\n\n===Implementations for Perl===\n* [https://metacpan.org/module/Coro Coro]\n\nCoroutines are natively implemented in all [[Perl 6]] backends.<ref>{{cite web | title = RFC #31 | url = http://www.perl6.org/archive/rfc/31}}</ref>\n\n===Implementations for Rust===\nThere is a library for [[Rust (programming language)|Rust]] that provides coroutines.<ref>{{cite web|url=https://crates.io/crates/coroutine|title=coroutine - Cargo: packages for Rust|accessdate=2017-06-24}}</ref>\nGenerators are an experimental feature available in nightly rust that provides an implementation of coroutines with async/await.<ref>{{cite web|title=Tracking issue for RFC 2033: Experimentally add coroutines to Rust|url=https://github.com/rust-lang/rust/issues/43122|website=GitHub}}</ref>\n\n===Implementations for Scala===\n[http://storm-enroute.com/coroutines/ Scala Coroutines] is a coroutine implementation for [[Scala (programming language)|Scala]]. This implementation is a library-level extension that relies on the Scala macro system to statically transform sections of the program into coroutine objects. As such, this implementation does not require modifications in the JVM, so it is fully portable between different JVMs and works with alternative Scala backends, such as [[Scala.js (programming language)|Scala.js]], which compiles to JavaScript.<ref>[http://storm-enroute.com/coroutines/docs/faq/ Scala Coroutines FAQ]</ref>\n\nScala Coroutines rely on the <code>coroutine</code> macro that transforms a normal block of code into a coroutine definition. Such a coroutine definition can be invoked with the <code>call</code> operation, which instantiates a coroutine frame. A coroutine frame can be resumed with the <code>resume</code> method, which resumes the execution of the coroutine's body, until reaching a <code>yieldval</code> keyword, which suspends the coroutine frame. Scala Coroutines also expose a <code>snapshot</code> method, which effectively duplicates the coroutine.<ref name=\"scala-coroutine-snapshots\">[http://storm-enroute.com/coroutines/docs/0.6/snapshots/index.html Scala Coroutine Snapshots]</ref>\n\n===Implementations for Smalltalk===\nSince, in most [[Smalltalk]] environments, the execution stack is a first-class citizen, coroutines can be implemented without additional library or VM support.\n\n===Implementations for Scheme===\nSince [[Scheme (programming language)|Scheme]] provides full support for continuations, implementing coroutines is nearly trivial, requiring only that a queue of continuations be maintained.\n\n===Implementation for Tool Command Language (Tcl)===\nSince version 8.6, the Tool Command Language supports coroutines in the core language.\n<ref>{{cite web|url=https://www.tcl.tk/man/tcl/TclCmd/coroutine.htm |title=coroutine manual page - Tcl Built-In Commands |publisher=Tcl.tk |date= |accessdate=2016-06-27}}</ref>\n\n===Implementations for Vala===\n[[vala (programming language)|Vala]] implements native support for coroutines. They are designed to be used with a Gtk Main Loop, but can be used alone if care is taken to ensure that the end callback will never have to be called before doing, at least, one yield.\n\n===Implementations in assembly languages===\nMachine-dependent [[assembly language]]s often provide direct methods for coroutine execution. For example, in [[MACRO-11]], the assembly language of the [[PDP-11]] family of minicomputers, the “classic” coroutine switch is effected by the instruction \"JSR PC,@(SP)+\", which jumps to the address popped from the stack and pushes the current (''i.e'' that of the '''next''') instruction address onto the stack. On [[VAX]]en (in [[VAX Macro|Macro-32]]) the comparable instruction is \"JSB @(SP)+\". Even on a [[Motorola 6809]] there is the instruction \"JSR [,S++]\"; note the \"++\", as 2 bytes (of address) are popped from the stack. This instruction is much used in the (standard) 'monitor' [[ASSIST (computing)|Assist]] 09.\n\n==See also==\n* [[Pipeline (Unix)]], a kind of coroutine used for communicating between programs<ref name=\"EvolutionUnix\"/>\n* [[Protothreads]], a stackless lightweight thread implementation using a coroutine like mechanism\n\n==References==\n{{Reflist|refs=\n<ref name=\"KnuthVol1_1_4_5\">{{Cite book | first = Donald Ervin | last = Knuth | series = The Art of Computer Programming | volume = 1 | title = Fundamental Algorithms | edition = 3rd | publisher = Addison-Wesley | year = 1997| isbn = 0-201-89683-4 | at = Section 1.4.5: History and Bibliography, pp.&nbsp;229}}</ref> <!--pages = 229-->\n<ref name=\"Conway1963\">{{Cite journal | last1 = Conway | first1 = M. E. | doi = 10.1145/366663.366704 | title = Design of a Separable Transition-Diagram Compiler| journal = Communications of the ACM | publisher = Association for Computing Machinery| location = New York, NY, USA | volume = 6 | issue = 7| pages = 396&ndash;408 | date =July 1963 }}</ref>\n<ref name=\"KnuthVol1_1_4_2\">{{Cite book | first = Donald Ervin | last = Knuth | series = The Art of Computer Programming | volume = 1 | title = Fundamental Algorithms | edition = 3rd | publisher = Addison-Wesley | year = 1997| isbn = 0-201-89683-4 | at = Section 1.4.2: Coroutines, pp.&nbsp;193–200}}</ref> <!--pages = 193–200-->\n<ref name=\"EvolutionUnix\">{{Cite journal | first = Dennis M. | last = Ritchie | title = The Evolution of the Unix Time-sharing System | url = http://cm.bell-labs.com/cm/cs/who/dmr/hist.html | journal = Lecture Notes in Computer Science | year = 1980 | volume = 79 | issue = Language Design and Programming Methodology | pages = 25–35 | doi=10.1007/3-540-09745-7_2}}</ref>\n<ref name=\"Perlis1982_6\">{{Cite journal\n| last1 = Perlis | first1 = Alan J.\n| doi = 10.1145/947955.1083808\n| title = Epigrams on programming\n| journal = ACM SIGPLAN Notices\n| publisher = Association for Computing Machinery\n| location = New York, NY, USA\n| volume = 17\n| issue = 9\n| pages = 7–13\n|date=September 1982\n| url = http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html\n| archiveurl = https://web.archive.org/web/19990117034445/http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html\n| archivedate = January 17, 1999\n| quote = 6. Symmetry is a complexity reducing concept (co-routines include sub-routines); seek it everywhere\n}}</ref>\n<ref name=\"MertzIBM\">{{cite web|url=http://www.ibm.com/developerworks/library/l-pygen.html |title=Generator-based State Machines |work=Charming Python |first=David |last=Mertz |publisher=IBM developerWorks |date=July 1, 2002 |accessdate=Feb 2, 2011 |archiveurl=https://www.webcitation.org/5wCZa062h?url=http://www.ibm.com/developerworks/library/l-pygen.html |archivedate=February 2, 2011 |deadurl=yes |df= }}</ref>\n}}\n\n==Further reading==\n* {{cite journal|citeseerx=10.1.1.58.4017|author1=Ana Lucia de Moura|author2=Roberto Ierusalimschy|title=Revisiting Coroutines|year=2004|doi=10.1145/1462166.1462167}}\n\n==External links==\n* [[Simon Tatham]]'s C oriented [http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html comprehensive introduction to coroutines]\n* [http://www.softpanorama.org/Lang/coroutines.shtml Softpanorama coroutine page]{{snd}}contains extensive assembler coroutines links\n\n[[Category:Concurrent computing]]\n[[Category:Subroutines]]"
            },
            "slug": "coroutine",
            "date_updated": 1532100180900,
            "imported": "https://en.wikipedia.org/wiki/Coroutine"
        },
        {
            "title": "Coroutine",
            "text": {
                "title": "Coroutine",
                "content": "'''Coroutines''' are [[computer program|computer-program]] components that generalize [[subroutine]]s for [[non-preemptive multitasking]], by allowing multiple [[entry point]]s for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing familiar program components such as [[cooperative multitasking|cooperative task]]s, [[exception handling|exception]]s, [[event loop]]s, [[iterator]]s, [[lazy evaluation|infinite list]]s and [[pipeline (software)|pipe]]s.\n\nAccording to [[Donald Knuth]], [[Melvin Conway]] coined the term ''coroutine'' in 1958 when he applied it to construction of an [[assembly language|assembly program]].<ref name=\"KnuthVol1_1_4_5\" /> The first published explanation of the coroutine appeared later, in 1963.<ref name=\"Conway1963\"/>\n\n==Comparison with subroutines==\nSubroutines are special cases of coroutines.<ref name=\"KnuthVol1_1_4_2\"/> When subroutines are invoked, execution begins at the start, and once a subroutine exits, it is finished; an instance of a subroutine only returns once, and does not hold state between invocations. By contrast, coroutines can exit by calling other coroutines, which may later return to the point where they were invoked in the original coroutine; from the coroutine's point of view, it is not exiting but calling another coroutine.<ref name=\"KnuthVol1_1_4_2\"/> Thus, a coroutine instance holds state, and varies between invocations; there can be multiple instances of a given coroutine at once. The difference between calling another coroutine by means of [[Yield (multithreading)|\"yielding\"]] to it and simply calling another routine (which then, also, would return to the original point), is that the relationship between two coroutines which yield to each other is not that of caller-callee, but instead symmetric.\n\nAny subroutine can be translated to a coroutine which does not call ''yield''.<ref name=\"Perlis1982_6\"/>\n\nHere is a simple example of how coroutines can be useful. Suppose you have a consumer-producer relationship where one routine creates items and adds them to a queue and another removes items from the queue and uses them. For reasons of efficiency, you want to add and remove several items at once. The code might look like this:\n\n ''var'' q := new queue\n \n '''coroutine''' produce\n     '''loop'''\n         '''while''' q is not full\n             create some new items\n             add the items to q\n         '''yield''' to consume\n \n '''coroutine''' consume\n     '''loop'''\n         '''while''' q is not empty\n             remove some items from q\n             use the items\n         '''yield''' to produce\n\nThe queue is then completely filled or emptied before yielding control to the other coroutine using the ''yield'' command. The further coroutines calls are starting right after the ''yield'', in the outer coroutine loop.\n\nAlthough this example is often used to introduce [[thread (computing)|multithreading]], two threads are not needed for this: the ''yield'' statement can be implemented by a jump directly from one routine into the other.\n\n==Comparison with generators==\n[[generator (computer science)|Generators]], also known as semicoroutines,<ref name=\"Ralston2000\">{{cite book|author=Anthony Ralston|title=Encyclopedia of computer science|url=https://books.google.com/books?id=yQ9LAQAAIAAJ|accessdate=11 May 2013|year=2000|publisher=Nature Pub. Group|isbn=978-1-56159-248-7}}</ref> are also a generalisation of subroutines, but are more limited than coroutines. Specifically, while both of these can yield multiple times, suspending their execution and allowing re-entry at multiple entry points, they differ in coroutines' ability to control where execution continues immediately after they yield, while generators cannot, instead transferring control back to the generator's caller.<ref>See for example ''[https://docs.python.org/reference/index.html The Python Language Reference]''\n\"https://docs.python.org/reference/expressions.html#yieldexpr 5.2.10. Yield expressions]\":<br />\n\"All of this makes generator functions quite similar to coroutines; they yield multiple times, they have more than one entry point and their execution can be suspended. The only difference is that a generator function cannot control where should the execution continue after it yields; the control is always transferred to the generator's caller.\"</ref> That is, since generators are primarily used to simplify the writing of [[iterator]]s, the <code>yield</code> statement in a generator does not specify a coroutine to jump to, but rather passes a value back to a parent routine.\n\nHowever, it is still possible to implement coroutines on top of a generator facility, with the aid of a top-level dispatcher routine (a [[trampoline (computing)|trampoline]], essentially) that passes control explicitly to child generators identified by tokens passed back from the generators:\n\n ''var'' q := new queue\n\n '''generator''' produce\n     '''loop'''\n         '''while''' q is not full\n             create some new items\n             add the items to q\n         '''yield''' consume\n\n '''generator''' consume\n     '''loop'''\n         '''while''' q is not empty\n             remove some items from q\n             use the items\n         '''yield''' produce\n\n '''subroutine''' dispatcher\n     ''var'' d := new dictionary('''generator''' → '''iterator''')\n     d[produce] := '''start''' produce\n     d[consume] := '''start''' consume\n     ''var'' current := produce\n     '''loop'''\n         current := '''next''' d[current]\n\nA number of implementations of coroutines for languages with generator support but no native coroutines (e.g. Python<ref name=\"MertzIBM\"/> before 2.5) use this or a similar model.\n\n==Comparison with mutual recursion==\n{{Further|Mutual recursion}}\nUsing coroutines for state machines or concurrency is similar to using [[mutual recursion]] with [[tail call]]s, as in both cases the control changes to a different one of a set of routines. However, coroutines are more flexible and generally more efficient. Since coroutines yield rather than return, and then resume execution rather than restarting from the beginning, they are able to hold state, both variables (as in a closure) and execution point, and yields are not limited to being in tail position; mutually recursive subroutines must either use shared variables or pass state as parameters. Further, each mutually recursive call of a subroutine requires a new stack frame (unless [[tail call elimination]] is implemented), while passing control between coroutines uses the existing contexts and can be implemented simply by a jump.\n\n==Common uses==\nCoroutines are useful to implement the following:\n\n* [[State machine]]s within a single subroutine, where the state is determined by the current entry/exit point of the procedure; this can result in more readable code compared to use of [[goto]], and may also be implemented via [[mutual recursion]] with [[tail call]]s.\n* [[Actor model]] of concurrency, for instance in [[video game]]s. Each actor has its own procedures (this again logically separates the code), but they voluntarily give up control to central scheduler, which executes them sequentially (this is a form of [[cooperative multitasking]]).\n* [[Generator (computer programming)|Generator]]s, and these are useful for [[Stream (computing)|streams]]{{snd}}particularly input/output{{snd}}and for generic traversal of data structures.\n* [[Communicating sequential processes]] where each sub-process is a coroutine. Channel inputs/outputs and blocking operations yield coroutines and a scheduler unblocks them on completion events.\n\n==Programming languages with native support==\n\nCoroutines originated as an [[assembly language]] method, but are supported in some [[high-level programming language]]s.  Early examples include [[Simula]]<ref name=\"Dahl1972\">{{cite book|title=Structured Programming|author=Dahl, O.-J. and Hoare, C.A.R. (ed)|first=|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175-220|chapter=Hierarchical Program Structures}}</ref> and [[Modula-2]]. More recent examples are [[Ruby (programming language)|Ruby]], [[Lua (programming language)|Lua]],  [[Julia (programming language)|Julia]], and [[Go (programming language)|Go]].\n\n{{Div col|colwidth=18em}}\n* [[Aikido (programming language)|Aikido]]\n* [[AngelScript]]\n* [[BCPL]]\n* [[Pascal (programming language)|Pascal]] (Borland [[Turbo Pascal]] 7.0 with uThreads module)\n* [[BETA (programming language)|BETA]]\n* [[BLISS]]\n* [[ChucK]]\n* [[D (programming language)|D]]\n* [[Dynamic C]]\n* [[Erlang (programming language)|Erlang]]\n* [[F Sharp (programming language)|F#]]\n* [[Factor (programming language)|Factor]]\n* [[GameMonkey Script]]\n* [[Godot (game engine)|GDScript]] (Godot's scripting language)\n* [[Go (programming language)|Go]]\n* [[Haskell (programming language)|Haskell]]<ref>{{cite web\n| title = Coroutine: Type-safe coroutines using lightweight session types\n| url = http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Coroutine\n}}</ref><ref>{{cite web\n| title = Co-routines in Haskell\n| url = http://random.axman6.com/blog/?p=231\n}}</ref>\n* [[High Level Assembly]]<ref>{{cite web\n| title = The Coroutines Module (coroutines.hhf)\n| url = http://www.plantation-productions.com/Webster/HighLevelAsm/HLADoc/HLAStdlib/1_HTML/HLAStdlib.htm#50618574_pgfId-998318\n| work = HLA Standard Library Manual\n}}</ref>\n* [[Icon (programming language)|Icon]]\n* [[Io (programming language)|Io]]\n* [[JavaScript]] (since 1.7, standardized in ECMAScript 6)<ref>{{cite web\n| title = New in JavaScript 1.7\n| url = https://developer.mozilla.org/en/docs/New_in_JavaScript_1.7\n}}</ref><!-- Does JavaScript belong here? See the link. --> ECMAScript 2017 also includes [[await]] support.\n* [[Julia (programming language)|Julia]]<ref>{{cite web | title=Julia Manual - Control Flow - Tasks (aka Coroutines)|url=http://docs.julialang.org/en/latest/manual/control-flow#man-tasks-1}}</ref>\n* [[Kotlin (programming language)|Kotlin]] (since 1.1)<ref>{{cite web | title=What's New in Kotlin 1.1|url=https://kotlinlang.org/docs/reference/whatsnew11.html#coroutines-experimental}}</ref>\n* [[Limbo (programming language)|Limbo]]\n* [[Lua (programming language)|Lua]]<ref>{{cite web |title=Lua 5.2 Reference Manual – 2.6 – Coroutines|url=http://www.lua.org/manual/5.2/manual.html#2.6}}</ref>\n* [[Lucid (programming language)|Lucid]]\n* [[µC++]]\n* [[MiniD]]\n* [[Modula-2]]\n* [[Nemerle]]\n* [[Perl 5]] (using the [https://metacpan.org/pod/Coro Coro module])\n* [[Perl 6]]<ref>{{cite web | title=Gather and/or Coroutines|url=https://perl6advent.wordpress.com/2012/12/19/gather-andor-coroutines/}}</ref>\n* [[PHP]] (with [https://github.com/facebook/hiphop-php HipHop], native since PHP 5.5)\n* [[Picolisp]]\n* [[Prolog]]\n* [[Python (programming language)|Python]] (since 2.5,<ref>{{cite web |title=Python async/await Tutorial|url=http://stackabuse.com/python-async-await-tutorial/}}</ref> with improved support since 3.3 and with explicit syntax since 3.5<ref>{{cite web |title=Python 3 reference: Coroutine function definition|url=https://docs.python.org/3/reference/compound_stmts.html#async-def}}</ref>)\n* [[Ruby (programming language)|Ruby]]\n* [[Sather]]\n* [[Scheme (programming language)|Scheme]]\n* [[Self (programming language)|Self]]\n* [[Simula]] 67\n* [[Squirrel (programming language)|Squirrel]]\n* [[Stackless Python]]\n* [[SuperCollider]]<ref>McCartney, J. [http://portal.acm.org/citation.cfm?id=1245228 \"Rethinking the Computer Music Programming Language: SuperCollider\"]. Computer Music Journal, 26(4):61-68. MIT Press, 2002.</ref>\n* [[Tcl]] (since 8.6)\n* [[urbiscript]]\n<!-- Coroutines can be implemented in any language, so please limit this list to languages with native support.\nSpecifically, don't re-add the following entries without consideration:\n* [[C Sharp (programming language)|C#]]\n* [[Perl]]\n* [[Smalltalk]]\n-->\n{{div col end}}\nSince [[continuation]]s can be used to implement coroutines, programming languages that support them can also quite easily support coroutines.\n\n==Implementations==\n{{As of|2003}}, many of the most popular programming languages, including C and its derivatives, do not have direct support for coroutines within the language or their standard libraries. (This is, in large part, due to the limitations of [[call stack|stack-based]] subroutine implementation.) An exception is the C++ library [http://www.boost.org/doc/libs/1_55_0/libs/context/doc/html/index.html Boost.Context], part of [http://www.boost.org boost libraries], which supports context swapping on ARM, MIPS, PowerPC, SPARC and x86 on POSIX, Mac OS X and Windows. Coroutines can be built upon Boost.Context.\n\nIn situations where a coroutine would be the natural implementation of a mechanism, but is not available, the typical response is to use a [[Closure (computer science)|closure]]{{snd}}a subroutine with state variables ([[static variable]]s, often boolean flags) to maintain an internal state between calls, and to transfer control to the correct point. Conditionals within the code result in the execution of different code paths on successive calls, based on the values of the state variables. Another typical response is to implement an explicit state machine in the form of a large and complex [[switch statement]] or via a [[goto]] statement, particularly a [[computed goto]]. Such implementations are considered difficult to understand and maintain, and a motivation for coroutine support.\n\n[[thread (computing)|Threads]], and to a lesser extent [[fiber (computer science)|fibers]], are an alternative to coroutines in mainstream programming environments today. Threads provide facilities for managing the realtime cooperative interaction of ''simultaneously'' executing pieces of code. Threads are widely available in environments that support C (and are supported natively in many other modern languages), are familiar to many programmers, and are usually well-implemented, well-documented and well-supported. However, as they solve a large and difficult problem they include many powerful and complex facilities and have a correspondingly difficult learning curve. As such, when a coroutine is all that is needed, using a thread can be overkill.\n\nOne important difference between threads and coroutines is that threads are typically preemptively scheduled while coroutines are not. Because threads can be rescheduled at any instant and can execute concurrently, programs using threads must be careful about [[lock (computer science)|locking]]. In contrast, because coroutines can only be rescheduled at specific points in the program and do not execute concurrently, programs using coroutines can often avoid locking entirely. (This property is also cited as a benefit of [[event-driven programming|event-driven]] or asynchronous programming.)\n\nSince fibers are cooperatively scheduled, they provide an ideal base for implementing coroutines above.<ref name=\"msdn-wrap\">[http://msdn.microsoft.com/msdnmag/issues/03/09/CoroutinesinNET/default.aspx Implementing Coroutines for .NET by Wrapping the Unmanaged Fiber API], Ajai Shankar, [[MSDN Magazine]]</ref> However, system support for fibers is often lacking compared to that for threads.\n\n===Implementations for C===\nSeveral attempts have been made to implement coroutines in [[C (programming language)|C]] with combinations of subroutines and macros. [[Simon Tatham]]'s contribution,<ref name=\"tatham\">{{cite web|url=http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html|author=Simon Tatham|title=Coroutines in C|year=2000}}</ref> based on [[Duff's device]], is a good example of the genre, and is the basis for [[Protothread|Protothreads]]. Tatham's comments provide a frank evaluation of the limitations of this approach: \"Of course, this trick violates every coding standard in the book... [but] any coding standard which insists on syntactic clarity at the expense of algorithmic clarity should be rewritten. If your employer fires you for using this trick, tell them that repeatedly as the security staff drag you out of the building.\" The main shortcoming of this approach is that, in not maintaining a separate stack frame for each coroutine, local variables are not preserved across multiple entries to the function.<ref name=\"tatham\" />\n\nA more reliable approach to implementing coroutines in C is to give up on absolute portability and write platform-specific implementations of functions to save and restore a coroutine context. Methods for achieving this include use of [[sigaltstack]] and a springboard function called from a signal handler<ref  name=\"rse-pmt\">https://www.gnu.org/software/pth/rse-pmt.ps</ref><ref name=\"libco\">https://byuu.org/library/libco/</ref>, as well as less reliable techniques such as jumping the stack pointer into an allocation within the heap (or merely further down the stack) using a [[C99]] [[variable-length array]] or [[C_dynamic_memory_allocation#Extensions_and_alternatives|alloca]]<ref>http://fanf.livejournal.com/105413.html</ref>. The [[setjmp/longjmp|setjmp and longjmp]] functions in the [[standard C library]] can then be used to implement the jumps between coroutines. Portability is an issue, as [[Samuel P. Harbison|Harbison]] and [[Guy L. Steele Jr.|Steele]] note, \"the ''setjmp'' and ''longjmp'' functions are notoriously difficult to implement, and the programmer would do well to make minimal assumptions about them.\"<ref>{{cite book|title=C: A Reference Manual|authors=Samuel P. Harbison and Guy L. Steele, Jr|edition=3|publisher=Prentice-Hall|year=1991|isbn=0-13-110933-2}}</ref>\n\nC libraries complying to [[POSIX]] or the [[Single Unix Specification]] (SUSv3) provide such routines as [[setcontext|getcontext, setcontext, makecontext and swapcontext]].  The setcontext family of functions is thus considerably more powerful than ''setjmp/longjmp'', but conforming implementations are as rare if not rarer. These functions were declared obsolete in POSIX 1.2008 <ref>http://man7.org/linux/man-pages/man3/getcontext.3.html</ref>. Aside from portability, the main shortcoming of this approach is that the coroutine's stack is a fixed size and cannot be grown during execution. Thus, programs tend to allocate much more stack than they actually need to avoid the potential for stack overflow.\n\nDue to the limits of standard libraries, some authors have written their own libraries for coroutines.  Russ Cox's libtask library<ref name=\"libtask\">[http://swtch.com/libtask/] - Russ Cox's libtask coroutine library for FreeBSD, Linux, Mac OS X, and SunOS</ref> is a good example of this genre.  It uses the context functions if they are provided by the native C library; otherwise it provides its own implementations for ARM, PowerPC, Sparc, and x86.  Other notable implementations include libpcl,<ref>[http://xmailserver.org/libpcl.html ''Portable Coroutine Library''] - C library using POSIX/SUSv3 facilities</ref> coro,<ref>[http://www.goron.de/~froese/coro/] - Edgar Toernig's coro library for x86, Linux & FreeBSD</ref> lthread,<ref>[https://github.com/halayli/lthread] - lthread is a multicore/multithread coroutine library written in C</ref> libCoroutine,<ref>{{cite web|url=http://dekorte.com/projects/opensource/libcoroutine/|title=libcoroutine: A portable coroutine implementation}} for FreeBSD, Linux, OS X PPC and x86, SunOS, Symbian and others</ref> libconcurrency,<ref>{{cite web|url=http://code.google.com/p/libconcurrency/libconcurrency|title=libconcurrency - A scalable concurrency library for C}} a simple C library for portable stack-switching coroutines</ref> libcoro,<ref>{{cite web|url=http://software.schmorp.de/pkg/libcoro.html|title=libcoro: C-library that implements coroutines (cooperative multitasking) in a portable fashion}} used as the basis for the Coro perl module.</ref> ribs2,<ref>{{cite web|url=https://github.com/Adaptv/ribs2|title=RIBS (Robust Infrastructure for Backend Systems)}}</ref> libdill.<ref>{{cite web|url=http://libdill.org|title=Structured Concurrency for C}}</ref>, libco<ref name=\"libco\" />, and [[Protothread|Protothreads]].\n\n===Implementations for C++===\n* C++ coroutines TS (Technical Specification), a standard for C++ language extensions for stackless coroutines, is under development. Visual C++, gcc, and Clang already support major portions in the std::experimental namespace. [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf coroutines Technical Specification]\n*[http://www.boost.org/doc/libs/1_57_0/libs/coroutine/doc/html/index.html Boost.Coroutine] - created by Oliver Kowalke, is the official released portable coroutine library of [http://boost.org boost] since version 1.53. The library relies on [http://www.boost.org/doc/libs/1_53_0/libs/context/doc/html/index.html Boost.Context] and supports ARM, MIPS, PowerPC, SPARC and X86 on POSIX, Mac OS X and Windows.\n*[http://www.boost.org/doc/libs/1_61_0/libs/coroutine2/doc/html/index.html Boost.Coroutine2] - also created by Oliver Kowalke, is a modernized portable coroutine library since boost version 1.59. It takes advantage of C++11 features, but removes the support for symmetric coroutines.\n*[https://github.com/mozy/mordor Mordor] - In 2010, [[Mozy]] open sourced a C++ library implementing coroutines, with an emphasis on using them to abstract [[asynchronous I/O]] into a more familiar sequential model.<ref>[http://mozy.com/blog/announcements/open-source-and-mozy-the-debut-of-mozy-code/] - Open Source and Mozy: The Debut of Mozy Code</ref>\n*[https://github.com/jamboree/co2 CO2] - stackless coroutine based on C++ [[preprocessor]] tricks, providing await/yield emulation.\n*[https://github.com/scummvm/scummvm/blob/master/common/coroutines.h ScummVM] - The [[ScummVM]] project implements a light-weight version of coroutines based on [http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html Simon Tatham's article].\n*[https://github.com/tonbit/coroutine tonbit::coroutine] - C++11 single .h asymmetric coroutine implementation via ucontext / fiber\n* Coroutines landed in [[Clang]] in May 2017, with libc++ implementation ongoing.<ref>[https://twitter.com/eric01/status/867473461836263424] - EricWF: Coroutines are now in Clang Trunk! Working on the Libc++ implementation now.</ref>\n* [https://github.com/infinit/elle elle] by Docker\n\n===Implementations for C#===\n*[https://github.com/MindTouch/dream MindTouch Dream] - The MindTouch Dream REST framework provides an implementation of coroutines based on the [[C Sharp (programming language)|C#]] 2.0 iterator pattern\n*[http://caliburn.codeplex.com/Wiki/View.aspx?title=IResult Caliburn] - The Caliburn screen patterns framework for WPF uses C# 2.0 iterators to ease UI programming, particularly in asynchronous scenarios.\n*[http://www.wintellect.com/PowerThreading.aspx Power Threading Library] - The Power Threading Library by [[Jeffrey Richter]] implements an AsyncEnumerator that provides simplified Asynchronous Programming Model using iterator-based coroutines.\n*[https://github.com/yevhen/Servelat-Pieces Servelat Pieces] - The Servelat Pieces project by [[Yevhen Bobrov]] provides transparent asynchrony for Silverlight WCF services and ability to asynchronously call any synchronous method. The implementation is based on Caliburn's Coroutines iterator and C# iterator blocks.\n*[http://msdn.microsoft.com/en-us/library/dscyy5s0(VS.80).aspx] - The .NET 2.0+ Framework now provides semi-coroutine ([[generator (computer programming)|generator]]) functionality through the iterator pattern and yield keyword.\n\n[[C Sharp 5.0|C# 5.0]] includes [[await]] syntax support.\n\n===Implementations for D===\n[[D (programming language)]] implements coroutines as its standard library class [http://dlang.org/phobos/core_thread.html#.Fiber Fiber]\n\n[http://dlang.org/phobos/std_concurrency.html#.Generator Generator] makes it trivial to expose a fiber function as an [http://dlang.org/phobos/std_range_primitives.html#isInputRange InputRange], making any fiber compatible with existing range algorithms.\n\n===Implementations for Java===\nThere are several implementations for coroutines in [[Java (programming language)|Java]].  Despite the constraints imposed by Java's abstractions, the JVM does not preclude the possibility.<ref name=\"jvmsummit\">{{cite web|url=http://www.wiki.jvmlangsummit.com/images/2/2b/JVMLanguageSummit_Stadler_Continuations.pdf|author=Lukas Stadler|series=JVM Language Summit|title=JVM Continuations|year=2009}}</ref> There are four general methods used, but two break bytecode portability among standards-compliant JVMs.\n\n* Modified JVMs. It is possible to build a patched JVM to support coroutines more natively. The [http://openjdk.java.net/projects/mlvm/ Da Vinci JVM] has had patches created.<ref name=\"javanet-forax\">{{cite web|url=http://weblogs.java.net/blog/forax/archive/2009/11/19/holy-crap-jvm-has-coroutinecontinuationfiber-etc|author=Remi Forax|archiveurl=https://web.archive.org/web/20150319052055/http://weblogs.java.net/blog/forax/archive/2009/11/19/holy-crap-jvm-has-coroutinecontinuationfiber-etc|archivedate=19 March 2015|title=Holy crap: JVM has coroutine/continuation/fiber etc.|date=19 November 2009}}</ref>\n* Modified bytecode. Coroutine functionality is possible by rewriting regular Java bytecode, either on the fly or at compile time. Toolkits include [http://commons.apache.org/sandbox/commons-javaflow/ Javaflow], [http://code.google.com/p/coroutines/ Java Coroutines], and [https://github.com/offbynull/coroutines Coroutines].\n* Platform-specific JNI mechanisms. These use JNI methods implemented in the OS or C libraries to provide the functionality to the JVM.{{citation needed|date=May 2014}}\n* Thread abstractions. Coroutine libraries which are implemented using threads may be heavyweight, though performance will vary based on the JVM's thread implementation.\n\n=== Implementations in Javascript ===\n* [https://github.com/fibjs/fibjs Fibjs] - fibjs is a JavaScript runtime built on Chrome's V8 JavaScript engine. fibjs uses [[Fiber (computer science)|fibers-switch]], sync style & non-blocking IO model to build scalable systems.\n* Since [http://es6-features.org/#GeneratorFunctionIteratorProtocol ECMAScript 2015], stackless coroutine functionality through \"generators\" and yield expressions is provided.\n\n===Implementation in Mono===\nThe [[Mono (software)|Mono]] Common Language Runtime has support for continuations,<ref name=\"monoco\">[http://www.mono-project.com/Continuations] Mono Continuations</ref> from which coroutines can be built.\n\n===Implementation in the .NET Framework as fibers===\nDuring the development of the [[.NET Framework]] 2.0, Microsoft extended the design of the [[Common Language Runtime]] (CLR) hosting APIs to handle fiber-based scheduling with an eye towards its use in fiber-mode for SQL server.<ref name=\"cbrumme-fibermode\">[http://blogs.msdn.com/cbrumme/archive/2004/02/21/77595.aspx], Chris Brumme, [http://blogs.msdn.com/cbrumme/default.aspx cbrumme's WebLog]</ref> Before release, support for the task switching hook ICLRTask::SwitchOut was removed due to time constraints.<ref name=\"dino-fibermodegone\">[http://blogs.msdn.com/dinoviehland/archive/2005/09/15/469642.aspx], Dino Viehland, [http://blogs.msdn.com/dinoviehland/default.aspx Dino's Blog]</ref>\nConsequently, the use of the fiber API to switch tasks is currently not a viable option in the .NET Framework.\n\n===Implementations for Python===\n*[[Python (programming language)|Python]] 2.5 implements better support for coroutine-like functionality, based on extended generators ([https://www.python.org/dev/peps/pep-0342/ PEP 342])\n*[[Python (programming language)|Python]] 3.3 improves this ability, by supporting delegating to a subgenerator ([https://www.python.org/dev/peps/pep-0380/ PEP 380])\n*[[Python (programming language)|Python]] 3.4 introduces a comprehensive asynchronous I/O framework as standardized in [https://www.python.org/dev/peps/pep-3156/ PEP 3156], which includes coroutines that leverage subgenerator delegation \n*[[Python (programming language)|Python]] 3.5 introduces explicit support for coroutines with async/[[await]] syntax ([https://www.python.org/dev/peps/pep-0492/ PEP 0492]).\n*[http://eventlet.net/ Eventlet]\n*[https://github.com/python-greenlet/greenlet Greenlet]\n*[http://www.gevent.org gevent]\n*[https://pypi.python.org/pypi/multitask multitask]\n*[http://chiral.j4cbo.com/trac chiral]\n*[http://code.google.com/p/cogen cogen]\n*[http://www.kamaelia.org Kamaelia]\n*[https://github.com/ironport/shrapnel/ Shrapnel]\n*[http://www.stackless.com/ stackless python]\n\n===Implementations for Ruby===\n* [[Ruby (programming language)|Ruby]] 1.9 supports coroutines natively which are implemented as [http://rubydoc.info/stdlib/core/1.9.2/Fiber fibers], which are semi-coroutines.<ref>{{cite web|url=http://www.ruby-forum.com/topic/126011 |authorlink1=https://web.archive.org/web/20071024123936/http://www.ruby-forum.com/topic/126011 |title=semi-coroutines |archivedate=October 24, 2007 |language=English |deadurl=yes |archiveurl=https://web.archive.org/web/20071024123936/http://www.ruby-forum.com/topic/126011 }}</ref>\n* [http://liber.sourceforge.net/coroutines.rb An implementation by Marc De Scheemaecker]\n\n===Implementations for Perl===\n* [https://metacpan.org/module/Coro Coro]\n\nCoroutines are natively implemented in all [[Perl 6]] backends.<ref>{{cite web | title = RFC #31 | url = http://www.perl6.org/archive/rfc/31}}</ref>\n\n===Implementations for Rust===\nThere is a library for [[Rust (programming language)|Rust]] that provides coroutines.<ref>{{cite web|url=https://crates.io/crates/coroutine|title=coroutine - Cargo: packages for Rust|accessdate=2017-06-24}}</ref>\nGenerators are an experimental feature available in nightly rust that provides an implementation of coroutines with async/await.<ref>{{cite web|title=Tracking issue for RFC 2033: Experimentally add coroutines to Rust|url=https://github.com/rust-lang/rust/issues/43122|website=GitHub}}</ref>\n\n===Implementations for Scala===\n[http://storm-enroute.com/coroutines/ Scala Coroutines] is a coroutine implementation for [[Scala (programming language)|Scala]]. This implementation is a library-level extension that relies on the Scala macro system to statically transform sections of the program into coroutine objects. As such, this implementation does not require modifications in the JVM, so it is fully portable between different JVMs and works with alternative Scala backends, such as [[Scala.js (programming language)|Scala.js]], which compiles to JavaScript.<ref>[http://storm-enroute.com/coroutines/docs/faq/ Scala Coroutines FAQ]</ref>\n\nScala Coroutines rely on the <code>coroutine</code> macro that transforms a normal block of code into a coroutine definition. Such a coroutine definition can be invoked with the <code>call</code> operation, which instantiates a coroutine frame. A coroutine frame can be resumed with the <code>resume</code> method, which resumes the execution of the coroutine's body, until reaching a <code>yieldval</code> keyword, which suspends the coroutine frame. Scala Coroutines also expose a <code>snapshot</code> method, which effectively duplicates the coroutine.<ref name=\"scala-coroutine-snapshots\">[http://storm-enroute.com/coroutines/docs/0.6/snapshots/index.html Scala Coroutine Snapshots]</ref>\n\n===Implementations for Smalltalk===\nSince, in most [[Smalltalk]] environments, the execution stack is a first-class citizen, coroutines can be implemented without additional library or VM support.\n\n===Implementations for Scheme===\nSince [[Scheme (programming language)|Scheme]] provides full support for continuations, implementing coroutines is nearly trivial, requiring only that a queue of continuations be maintained.\n\n===Implementation for Tool Command Language (Tcl)===\nSince version 8.6, the Tool Command Language supports coroutines in the core language.\n<ref>{{cite web|url=https://www.tcl.tk/man/tcl/TclCmd/coroutine.htm |title=coroutine manual page - Tcl Built-In Commands |publisher=Tcl.tk |date= |accessdate=2016-06-27}}</ref>\n\n===Implementations for Vala===\n[[vala (programming language)|Vala]] implements native support for coroutines. They are designed to be used with a Gtk Main Loop, but can be used alone if care is taken to ensure that the end callback will never have to be called before doing, at least, one yield.\n\n===Implementations in assembly languages===\nMachine-dependent [[assembly language]]s often provide direct methods for coroutine execution. For example, in [[MACRO-11]], the assembly language of the [[PDP-11]] family of minicomputers, the “classic” coroutine switch is effected by the instruction \"JSR PC,@(SP)+\", which jumps to the address popped from the stack and pushes the current (''i.e'' that of the '''next''') instruction address onto the stack. On [[VAX]]en (in [[VAX Macro|Macro-32]]) the comparable instruction is \"JSB @(SP)+\". Even on a [[Motorola 6809]] there is the instruction \"JSR [,S++]\"; note the \"++\", as 2 bytes (of address) are popped from the stack. This instruction is much used in the (standard) 'monitor' [[ASSIST (computing)|Assist]] 09.\n\n==See also==\n* [[Pipeline (Unix)]], a kind of coroutine used for communicating between programs<ref name=\"EvolutionUnix\"/>\n* [[Protothreads]], a stackless lightweight thread implementation using a coroutine like mechanism\n\n==References==\n{{Reflist|refs=\n<ref name=\"KnuthVol1_1_4_5\">{{Cite book | first = Donald Ervin | last = Knuth | series = The Art of Computer Programming | volume = 1 | title = Fundamental Algorithms | edition = 3rd | publisher = Addison-Wesley | year = 1997| isbn = 0-201-89683-4 | at = Section 1.4.5: History and Bibliography, pp.&nbsp;229}}</ref> <!--pages = 229-->\n<ref name=\"Conway1963\">{{Cite journal | last1 = Conway | first1 = M. E. | doi = 10.1145/366663.366704 | title = Design of a Separable Transition-Diagram Compiler| journal = Communications of the ACM | publisher = Association for Computing Machinery| location = New York, NY, USA | volume = 6 | issue = 7| pages = 396&ndash;408 | date =July 1963 }}</ref>\n<ref name=\"KnuthVol1_1_4_2\">{{Cite book | first = Donald Ervin | last = Knuth | series = The Art of Computer Programming | volume = 1 | title = Fundamental Algorithms | edition = 3rd | publisher = Addison-Wesley | year = 1997| isbn = 0-201-89683-4 | at = Section 1.4.2: Coroutines, pp.&nbsp;193–200}}</ref> <!--pages = 193–200-->\n<ref name=\"EvolutionUnix\">{{Cite journal | first = Dennis M. | last = Ritchie | title = The Evolution of the Unix Time-sharing System | url = http://cm.bell-labs.com/cm/cs/who/dmr/hist.html | journal = Lecture Notes in Computer Science | year = 1980 | volume = 79 | issue = Language Design and Programming Methodology | pages = 25–35 | doi=10.1007/3-540-09745-7_2}}</ref>\n<ref name=\"Perlis1982_6\">{{Cite journal\n| last1 = Perlis | first1 = Alan J.\n| doi = 10.1145/947955.1083808\n| title = Epigrams on programming\n| journal = ACM SIGPLAN Notices\n| publisher = Association for Computing Machinery\n| location = New York, NY, USA\n| volume = 17\n| issue = 9\n| pages = 7–13\n|date=September 1982\n| url = http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html\n| archiveurl = https://web.archive.org/web/19990117034445/http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html\n| archivedate = January 17, 1999\n| quote = 6. Symmetry is a complexity reducing concept (co-routines include sub-routines); seek it everywhere\n}}</ref>\n<ref name=\"MertzIBM\">{{cite web|url=http://www.ibm.com/developerworks/library/l-pygen.html |title=Generator-based State Machines |work=Charming Python |first=David |last=Mertz |publisher=IBM developerWorks |date=July 1, 2002 |accessdate=Feb 2, 2011 |archiveurl=https://www.webcitation.org/5wCZa062h?url=http://www.ibm.com/developerworks/library/l-pygen.html |archivedate=February 2, 2011 |deadurl=yes |df= }}</ref>\n}}\n\n==Further reading==\n* {{cite journal|citeseerx=10.1.1.58.4017|author1=Ana Lucia de Moura|author2=Roberto Ierusalimschy|title=Revisiting Coroutines|year=2004|doi=10.1145/1462166.1462167}}\n\n==External links==\n* [[Simon Tatham]]'s C oriented [http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html comprehensive introduction to coroutines]\n* [http://www.softpanorama.org/Lang/coroutines.shtml Softpanorama coroutine page]{{snd}}contains extensive assembler coroutines links\n\n[[Category:Concurrent computing]]\n[[Category:Subroutines]]"
            },
            "slug": "coroutine",
            "date_updated": 1532100313200,
            "imported": "https://en.wikipedia.org/wiki/Coroutine"
        }
    ]
}