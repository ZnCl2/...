{
    "article": [
        {
            "title": "microkernel",
            "text": "[[File:OS-structure.svg|thumb|450px|Structure of monolithic and microkernel-based operating systems, respectively]]\n\nIn [[computer science]], a '''microkernel''' (also known as '''μ-kernel''') is the near-minimum amount of [[software]] that can provide the mechanisms needed to implement an [[operating system]] (OS). These mechanisms include low-level [[address space]] management, [[thread (computing)|thread]] management, and [[inter-process communication]] (IPC).\n\nIf the hardware provides multiple [[Protection ring|rings]] or [[CPU modes]], the microkernel may be the only software executing at the most privileged level, which is generally referred to as [[kernel mode|supervisor or kernel mode]]. Traditional operating system functions, such as [[device driver]]s, [[protocol stack]]s and [[file system]]s, are typically removed from the microkernel itself and are instead run in [[user space]].<ref>{{cite web\n | url = http://www.minix3.org/theses/herder-true-microkernel.pdf\n | title = Toward a True Microkernel Operating System\n | date = 23 February 2005 | accessdate = 22 June 2015\n | author = Jorrit N. Herder | website = minix3.org\n}}</ref>\n\nIn terms of the source code size, as a general rule microkernels tend to be smaller than [[monolithic kernel]]s. The [[MINIX&nbsp;3]] microkernel, for example, has approximately 12,000 lines of code.<ref>{{cite web|url=http://wiki.minix3.org/doku.php?id=www:documentation:read-more|title=read-more|last=|first=|date=|publisher=|accessdate=20 December 2016|work=minix3.org|df=}}</ref>\n\n==History==\nMicrokernels trace their roots back to Danish computer pioneer [[Per Brinch Hansen]] and his tenure in Danish computer company [[Regnecentralen]] where he led software development efforts for the RC 4000 computer.<ref name=\"ieee_2002\">{{cite web\n| url = https://www.computer.org/web/awards/pioneer-per-hansen\n| title = 2002 Computer Pioneer Award Recipient\n| publisher = IEEE Computer Society\n| accessdate = 13 September 2016\n}}\n</ref>\nIn 1967, Regnecentralen was installing a RC 4000 prototype in a Polish fertilizer plant in [[Puławy]]. The computer used a small real-time operating system tailored for the needs of the plant. Brinch Hansen and his team became concerned with the lack of generality and reusability of the RC 4000 system. They feared that each installation would require a different operating system so they started to investigate novel and more general ways of creating software for the RC 4000.<ref name=\"Hansen_2004\">{{cite book\n| url = http://brinch-hansen.net/memoirs/contents.html\n| title = A Programmer's Story: The Life of a Computer Pioneer\n| last= Brinch Hansen\n| first=Per\n| publisher=\n| year=2004\n| isbn=\n| location=\n| pages=\n| accessdate = 13 September 2016}}\n</ref>\nIn 1969, their effort resulted in the completion of the [[RC 4000 multiprogramming system|RC 4000 Multiprogramming System]]. Its nucleus provided inter-process communication based on message-passing for up to 23 unprivileged processes, out of which 8 at a time were protected from one another. It further implemented scheduling of time slices of programs executed in parallel, initiation and control of program execution at the request of other running programs, and initiation of data transfers to or from peripherals. Besides these elementary mechanisms, it had no built-in strategy for program execution and resource allocation. This strategy was to be implemented by a hierarchy of running programs in which parent processes had complete control over child processes and acted as their operating systems.<ref name=\"Hansen_1969\">{{cite techreport\n| first = Per\n| last = Brinch Hansen\n| title = RC 4000 Software: Multiprogramming System\n| institution = Regnecentralen\n| date = April 1969\n| url = http://brinch-hansen.net/papers/1969a.pdf\n| accessdate = 13 September 2016\n}}\n</ref><ref>{{cite journal\n | author = Brinch Hansen, Per\n | year = 1970\n | volume = 13\n | title = The Nucleus of a Multiprogramming Operating System\n | journal = Communications of the ACM\n | pages = 238–250\n | url = http://www.brinch-hansen.net/papers/1970a.pdf\n | doi = 10.1145/362258.362278\n | issue = 4\n}}\n</ref>\n\nFollowing Brinch Hansen's work, microkernels have been developed since the 1970s<ref name=\"Wulf_74\">.{{cite journal\n | last1 = Wulf\n | first1 = William\n | last2 = Cohen\n | first2 = Ellis\n | last3 = Corwin\n | first3 = William\n | last4 = Jones\n | first4 = Anita\n | last5 = Levin\n | first5 = Roy\n | last6 = Pierson\n | first6 = C.\n | last7 = Pollack\n | first7 = Fred\n | date = June 1974\n | title = HYDRA: The Kernel of a Multiprocessor Operating System\n | journal = Communications of the ACM\n | volume = 17\n | issue = 6\n | pages = 337-345\n | pmid =\n | doi = 10.1145/355616.364017\n | id =\n | url =\n | laysummary =\n | laysource =\n | laydate =\n | quote =\n }}</ref> The term microkernel itself appeared no later than 1981.<ref name=\"Rashid_81\">{{cite conference\n | last1 = Rashid\n | first1 = Richard\n | last2 = Robertson\n | first2 = George\n | title = Accent: A communication oriented network operating system kernel\n | doi = 10.1145/800216.806593\n | booktitle = SOSP '81 Proceedings of the eighth ACM symposium on Operating systems principles\n | pages = 64-75\n | date = December 1981\n | location = Pacific Grove, California, USA\n }}</ref> Microkernels were meant as a response to changes in the computer world, and to several challenges adapting existing \"[[mono-kernel]]s\" to these new systems. New device drivers, protocol stacks, file systems and other low-level systems were being developed all the time. This code was normally located in the monolithic kernel, and thus required considerable work and careful code management to work on. Microkernels were developed with the idea that all of these services would be implemented as user-space programs, like any other, allowing them to be worked on monolithically and started and stopped like any other program. This would not only allow these services to be more easily worked on, but also separated the kernel code to allow it to be finely tuned without worrying about unintended side effects. Moreover, it would allow entirely new operating systems to be \"built up\" on a common core, aiding OS research.\n\nMicrokernels were a very hot topic in the 1980s when the first usable [[local area network]]s were being introduced.{{Citation needed|date=November 2012}} The same mechanisms that allowed the kernel to be distributed into user space also allowed the system to be distributed across network links. The first microkernels, notably [[Mach (kernel)|Mach]], proved to have disappointing performance, but the inherent advantages appeared so great that it was a major line of research into the late 1990s.{{Citation needed|date=November 2012}} However, during this time the speed of computers grew greatly in relation to networking systems, and the disadvantages in performance came to overwhelm the advantages in development terms.{{citation needed|date = June 2015}} Many attempts were made to adapt the existing systems to have better performance, but the overhead was always considerable and most of these efforts required the user-space programs to be moved back into the kernel. By 2000, most large-scale (Mach-like) efforts had ended, although Apple's [[macOS]], released in 2001, uses a [[hybrid kernel]] called [[XNU]], which combines a heavily modified (hybrid) [[OSFMK]] 7.3 kernel with code from BSD UNIX,<ref>{{cite av media|url=https://www.youtube.com/watch?v=ggnFoDqzGMU|author=Jim Magee|title=WWDC 2000 Session 106 - Mac OS X: Kernel|minutes=14}}</ref><ref>{{cite web|title=Porting UNIX/Linux Applications to Mac OS X|url=https://developer.apple.com/library/mac/#documentation/Porting/Conceptual/PortingUnix/glossary/glossary.html#//apple_ref/doc/uid/TP40002859-TPXREF101|publisher=Apple|accessdate=26 April 2011}}</ref> and this kernel is also used in [[iOS]], [[tvOS]], and [[watchOS]]. {{As of|2012}}, the Mach-based [[GNU Hurd]] is also functional and included in testing versions of [[Arch Linux]] and [[Debian]].\n\nAlthough major work on microkernels had largely ended, experimenters continued development.{{Citation needed|date=November 2012}} It has since been shown that many of the performance problems of earlier designs were not a fundamental limitation of the concept, but instead due to the designer's desire to use single-purpose systems to implement as many of these services as possible.{{Citation needed|date=November 2012}} Using a more pragmatic approach to the problem, including [[assembly code]] and relying on the processor to enforce concepts normally supported in software led to a new series of microkernels with dramatically improved performance.\n\nMicrokernels are closely related to [[exokernel]]s.<ref name=\"Liedtke_96\">{{cite journal\n | last = Liedtke\n | first = Jochen\n | date = September 1996\n | title = Towards Real Microkernels\n | journal = Communications of the ACM\n | volume = 39\n | issue = 9\n | pages = 70–77\n | pmid =\n | doi = 10.1145/234215.234473\n | id =\n | url =\n | laysummary =\n | laysource =\n | laydate =\n | quote =\n }}</ref>\nThey also have much in common with [[hypervisor]]s,<ref name=\"Heiser_UL_06\">{{cite journal\n | title=Are Virtual-Machine Monitors Microkernels Done Right?\n | authorlink1=Gernot Heiser|last1=Heiser|first1=Gernot|last2= Uhlig|first2= Volkmar |last3= LeVasseur|first3= Joshua\n | journal=ACM SIGOPS Operating Systems Review\n | volume=40\n | issue=1\n | pages=95–99\n |date=January 2006\n | url=http://os.ibds.kit.edu/65_747.php\n | publisher=ACM\n | doi = 10.1145/1113361.1113363\n | format=PDF}}</ref>\nbut the latter make no claim to minimality and are specialized to supporting [[virtual machine]]s; indeed, the [[L4 microkernel]] frequently finds use in a hypervisor capacity.\n\n==Introduction==\nEarly operating system kernels were rather small, partly because computer memory was limited. As the capability of computers grew, the number of devices the kernel had to control also grew. Throughout the early history of [[Unix]], kernels were generally small, even though they contained various [[device driver]]s and [[file system]] implementations. When address spaces increased from 16 to 32 bits, kernel design was no longer constrained by the hardware architecture, and kernels began to grow larger.\n\nThe [[Berkeley Software Distribution]] (BSD) of [[Unix]] began the era of larger kernels. In addition to operating a basic system consisting of the CPU, disks and printers, BSD added a complete [[protocol stack|TCP/IP networking system]] and a number of \"virtual\" devices that allowed the existing programs to work 'invisibly' over the network. This growth continued for many years, resulting in kernels with millions of lines of [[source code]]. As a result of this growth, kernels were prone to bugs and became increasingly difficult to maintain.\n\nThe microkernel was intended to address this growth of kernels and the difficulties that resulted. In theory, the microkernel design allows for easier management of code due to its division into [[user space]] services. This also allows for increased security and stability resulting from the reduced amount of code running in [[kernel mode]]. For example, if a networking service crashed due to [[buffer overflow]], only the networking service's memory would be corrupted, leaving the rest of the system still functional.\n\n==Inter-process communication==\n[[Inter-process communication]] (IPC) is any mechanism which allows separate processes to communicate with each other, usually by sending [[message passing|messages]]. [[Shared memory (interprocess communication)|Shared memory]] is strictly speaking also an inter-process communication mechanism, but the abbreviation IPC usually only refers to message passing, and it is the latter that is particularly relevant to microkernels. IPC allows the operating system to be built from a number of small programs called servers, which are used by other programs on the system, invoked via IPC. Most or all support for peripheral  hardware is handled in this fashion, with servers for device drivers, [[network protocol stack]]s, file systems, graphics, etc.\n\nIPC can be synchronous or asynchronous. Asynchronous IPC is analogous to network communication: the sender dispatches a message and continues executing. The receiver checks (polls) for the availability of the message by attempting a receive, or is alerted to it via some notification mechanism. Asynchronous IPC requires that the kernel maintains buffers and queues for messages, and deals with buffer overflows; it also requires double copying of messages (sender to kernel and kernel to receiver). In synchronous IPC, the first party (sender or receiver) blocks until the other party is ready to perform the IPC. It does not require buffering or multiple copies, but the implicit rendezvous can make programming tricky. Most programmers prefer asynchronous send and synchronous receive.\n\nFirst-generation microkernels typically supported synchronous as well as asynchronous IPC, and suffered from poor IPC performance. [[Jochen Liedtke]] assumed the design and implementation of the IPC mechanisms to be the underlying reason for this poor performance. In his [[L4 microkernel family|L4 microkernel]] he pioneered methods that lowered IPC costs by an [[order of magnitude]].<ref name=\"Liedtke_93\">{{cite conference\n | first = Jochen\n | last = Liedtke\n | authorlink = Jochen Liedtke\n | title = Improving IPC by kernel design\n | booktitle = 14th ACM Symposium on Operating System Principles\n | pages = 175–88\n |date=December 1993\n | location = Asheville, NC, USA\n | citeseerx = 10.1.1.40.1293\n }}</ref> These include an IPC system call that supports a send as well as a receive operation, making all IPC synchronous, and passing as much data as possible in registers. Furthermore, Liedtke introduced the concept of the ''direct process switch'', where during an IPC execution an (incomplete) [[context switch]] is performed from the sender directly to the receiver. If, as in L4, part or all of the message is passed in registers, this transfers the in-register part of the message without any copying at all. Furthermore, the overhead of invoking the scheduler is avoided; this is especially beneficial in the common case where IPC is used in an [[remote procedure call|RPC]]-type fashion by a client invoking a server. Another optimization, called ''lazy scheduling'', avoids traversing scheduling queues during IPC by leaving threads that block during IPC in the ready queue. Once the scheduler is invoked, it moves such threads to the appropriate waiting queue. As in many cases a thread gets unblocked before the next scheduler invocation, this approach saves significant work. Similar approaches have since been adopted by [[QNX]] and [[MINIX 3]].{{Citation needed|date=August 2010}}\n\nIn a series of experiments, Chen and Bershad compared memory [[cycles per instruction]] (MCPI) of monolithic [[Ultrix]] with those of microkernel [[Mach (kernel)|Mach]] combined with a [[4.3BSD]] [[Unix]] server running in [[user space]]. Their results explained Mach's poorer performance by higher MCPI and demonstrated that IPC alone is not responsible for much of the system overhead, suggesting that optimizations focused exclusively on IPC will have limited impact.<ref name=\"Chen_Bershad_93\">{{cite conference\n | first1 = J. Bradley\n | last1 = Chen\n | first2 = Brian N.\n | last2 = Bershad\n | title = The Impact of Operating System Structure on Memory System Performance\n | booktitle = SOSP '93 Proceedings of the fourteenth ACM symposium on Operating systems principles\n | pages = 120–133\n | date= December 1993\n | location = Asheville, NC, USA\n | doi = 10.1145/168619.168629\n | url = https://people.eecs.berkeley.edu/~prabal/resources/osprelim/CB93.pdf\n }}</ref> Liedtke later refined Chen and Bershad's results by making an observation that the bulk of the difference between Ultrix and Mach MCPI was caused by capacity [[CPU cache#Cache-miss|cache-misses]] and concluding that drastically reducing the cache working set of a microkernel will solve the problem.<ref name=\"Liedtke_95\">{{cite conference\n | first = Jochen\n | last = Liedtke\n | authorlink = Jochen Liedtke\n | title = On µ-Kernel Construction\n | booktitle = SOSP '95 Proceedings of the fifteenth ACM symposium on Operating systems principles\n | pages = 237–250\n | date= December 1995\n | location = Copper Mountain Resort, CO, USA \n | doi = 10.1145/224056.224075\n }}</ref>\n\nIn a client-server system, most communication is essentially synchronous, even if using asynchronous primitives, as the typical operation is a client invoking a server and then waiting for a reply. As it also lends itself to more efficient implementation, most microkernels generally followed L4's lead and only provided a synchronous IPC primitive. Asynchronous IPC could be implemented on top by using helper threads. However, experience has shown that the utility of synchronous IPC is dubious: synchronous IPC forces a multi-threaded design onto otherwise simple systems, with the resulting synchronization complexities. Moreover, an RPC-like server invocation sequentializes client and server, which should be avoided if they are running on separate cores. Versions of L4 deployed in commercial products have therefore found it necessary to add an asynchronous notification mechanism to better support asynchronous communication. This [[signal (computing)|signal]]-like mechanism does not carry data and therefore does not require buffering by the kernel. By having two forms of IPC, they have nonetheless violated the principle of minimality. Other versions of L4 have switched to asynchronous IPC completely.<ref name=\"elphinstone_2013\">{{cite conference\n | first1 = Kevin\n | last1 = Elphinstone\n | first2 = Gernot\n | last2 = Heiser\n | title = From L3 to seL4: What Have We Learnt in 20 Years of L4 Microkernels?\n | booktitle = SOSP '13 Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles\n | pages = 133–150\n | date = November 2013\n | location = Farmington, PA, USA \n | doi = 10.1145/2517349.2522720\n}}\n</ref>\n\nAs synchronous IPC blocks the first party until the other is ready, unrestricted use could easily lead to deadlocks. Furthermore, a client could easily mount a [[denial-of-service]] attack on a server by sending a request and never attempting to receive the reply. Therefore, synchronous IPC must provide a means to prevent indefinite blocking. Many microkernels provide [[timeout (telecommunication)|timeouts]] on IPC calls, which limit the blocking time. In practice, choosing sensible timeout values is difficult, and systems almost inevitably use infinite timeouts for clients and zero timeouts for servers. As a consequence, the trend is towards not providing arbitrary timeouts, but only a flag which indicates that the IPC should fail immediately if the partner is not ready. This approach effectively provides a choice of the two timeout values of zero and infinity. Recent versions of L4 and MINIX have gone down this path (older versions of L4 used timeouts, as does QNX).\n\n==Servers==\nMicrokernel servers are essentially [[daemon (computer software)|daemon]] programs like any others, except that the kernel grants some of them privileges to interact with parts of physical memory that are otherwise off limits to most programs. This allows some servers, particularly device drivers, to interact directly with hardware.\n\nA basic set of servers for a general-purpose microkernel includes file system servers, device driver servers, networking servers, [[display server]]s, and user interface device servers. This set of servers (drawn from [[QNX]]) provides roughly the set of services offered by a Unix [[monolithic kernel]]. The necessary servers are started at system startup and provide services, such as file, network, and device access, to ordinary application programs. With such servers running in the environment of a user application, server development is similar to ordinary application development, rather than the build-and-boot process needed for kernel development.\n\nAdditionally, many \"crashes\" can be corrected by simply [[Crash-only software|stopping and restarting the server]]. However, part of the system state is lost with the failing server, hence this approach requires applications to cope with failure. A good example is a server responsible for [[Internet protocol suite|TCP/IP]] connections: If this server is restarted, applications will experience a \"lost\" connection, a normal occurrence in a networked system. For other services, failure is less expected and may require changes to application code. For QNX, restart capability is offered as the QNX High Availability Toolkit.<ref>{{cite web|url=http://www.qnx.com/download/download/8107/QNX_High_Availability_Toolkit.pdf|title=The QNX High Availability Toolkit|archive-url=https://web.archive.org/web/20050824015422/http://www.qnx.com/download/download/8107/QNX_High_Availability_Toolkit.pdf|archive-date=24 August 2005 }}</ref>\n\nTo make all servers restartable, some microkernels have concentrated on adding various [[database]]-like methods such as [[database transaction|transaction]]s, [[replication (computer science)|replication]] and [[checkpointing]] to preserve essential state across single server restarts. An example is [[ChorusOS]], which was made for high-availability applications in the telecommunications world. Chorus included features to allow any \"properly written\" server to be restarted at any time, with clients using those servers being paused while the server brought itself back into its original state.{{Citation needed|date=February 2007}} However, such kernel features are incompatible with the minimality principle, and are thus not provided in modern microkernels, which instead rely on appropriate user-level protocols.\n\n==Device drivers==\n[[Device driver]]s frequently perform [[direct memory access]] (DMA), and therefore can write to arbitrary locations of physical memory, including various kernel data structures. Such drivers must therefore be trusted. It is a common misconception that this means that they must be part of the kernel. In fact, a driver is not inherently more or less trustworthy by being part of the kernel.\n\nWhile running a device driver in user space does not necessarily reduce the damage a misbehaving driver can cause, in practice it is beneficial for system stability in the presence of buggy (rather than malicious) drivers: memory-access violations by the driver code itself (as opposed to the device) may still be caught by the memory-management hardware. Furthermore, many devices are not DMA-capable, their drivers can be made untrusted by running them in user space. Recently, an increasing number of computers feature [[IOMMU]]s, many of which can be used to restrict a device's access to physical memory.<ref name=\"Wong_07\">{{cite journal |title=I/O, I/O, It's Off to Virtual Work We Go |url=http://www.electronicdesign.com/embedded/io-io-its-virtual-work-we-go |last=Wong |first=William |journal=[[Electronic Design (magazine)|Electronic Design]] |date=27 April 2007 |accessdate=8 June 2009 }}</ref> (IBM mainframes have had IO MMUs since the [[IBM System/360 Model 67]] and [[System/370]].) This also allows user-mode drivers to become untrusted.\n\nUser-mode drivers actually predate microkernels. The [[Michigan Terminal System]] (MTS), in 1967, supported user space drivers (including its file system support), the first operating system to be designed with that capability.<ref>{{cite journal |title=Organization and Features of the Michigan Terminal System |first=Michael T. |last=Alexander |journal=Proceedings of the November 16–18, 1971, fall joint computer conference |volume=40 |year=1971 |pages=589–591 |doi=10.1145/1478873.1478951}}</ref>\nHistorically, drivers were less of a problem, as the number of devices was small and trusted anyway, so having them in the kernel simplified the design and avoided potential performance problems. This led to the traditional driver-in-the-kernel style of Unix,<ref name=\"Lions book\">{{cite book |title=[[Lions' Commentary on UNIX 6th Edition, with Source Code]] |last=Lions |first=John |date=1 August 1977 |isbn=978-1-57398-013-5 |publisher=Peer-To-Peer Communications}}</ref> Linux, and Windows before [[Windows XP]].\nWith the proliferation of various kinds of peripherals, the amount of driver code escalated and in modern operating systems dominates the kernel in code size.\n\n==Essential components and minimality==\nAs a microkernel must allow building arbitrary operating system services on top, it must provide some core functionality. At a minimum, this includes:\n* some mechanisms for dealing with [[address space]]s, required for managing memory protection\n* some execution abstraction to manage CPU allocation, typically [[thread (computing)|threads]] or [[scheduler activations]]\n* [[inter-process communication]], required to invoke servers running in their own address spaces\n\nThis minimal design was pioneered by [[Brinch Hansen]]'s [[RC 4000 Multiprogramming System|Nucleus]] and the hypervisor of IBM's [[VM (operating system)|VM]]. It has since been formalised in Liedtke's ''minimality principle'':\n<blockquote>A concept is tolerated inside the microkernel only if moving it outside the kernel, i.e., permitting competing implementations, would prevent the implementation of the system's required functionality.<ref name=\"Liedtke_95\" /></blockquote>\nEverything else can be done in a usermode program, although device drivers implemented as user programs may on some processor architectures require special privileges to access I/O hardware.\n\nRelated to the minimality principle, and equally important for microkernel design, is the [[separation of mechanism and policy]], it is what enables the construction of arbitrary systems on top of a minimal kernel. Any policy built into the kernel cannot be overwritten at user level and therefore limits the generality of the microkernel.<ref name=\"Liedtke_96\"/>\nPolicy implemented in user-level servers can be changed by replacing the servers (or letting the application choose between competing servers offering similar services).\n\nFor efficiency, most microkernels contain schedulers and manage timers, in violation of the minimality principle and the principle of policy-mechanism separation.\n\nStart up ([[booting]]) of a microkernel-based system requires [[device driver]]s, which are not part of the kernel. Typically this means that they are packaged with the kernel in the boot image, and the kernel supports a bootstrap protocol that defines how the drivers are located and started; this is the traditional bootstrap procedure of [[L4 microkernel family|L4 microkernels]]. Some microkernels simplify this by placing some key drivers inside the kernel (in violation of the minimality principle), [[LynxOS]] and the original [[Minix]] are examples. Some even include a [[file system]] in the kernel to simplify booting. A <!-- In other cases,  [[GNU GRUB]] for example, (This is NOT according to GRUB wiki) --> microkernel-based system may boot via multiboot compatible boot loader. Such systems usually load statically-linked servers to make an initial bootstrap or mount an OS image to continue bootstrapping.\n\nA key component of a microkernel is a good [[Inter-process communication|IPC]] system and virtual-memory-manager design that allows implementing page-fault handling and swapping in usermode servers in a safe way. Since all services are performed by usermode programs, efficient means of communication between programs are essential, far more so than in monolithic kernels. The design of the IPC system makes or breaks a microkernel. To be effective, the IPC system must not only have low overhead, but also interact well with CPU scheduling.\n\n==Performance==\nOn most mainstream processors, obtaining a service is inherently more expensive in a microkernel-based system than a monolithic system.<ref name=\"Liedtke_96\"/> In the monolithic system, the service is obtained by a single system call, which requires two ''mode switches'' (changes of the processor's [[ring (computer security)|ring]] or [[CPU modes|CPU mode]]). In the microkernel-based system, the service is obtained by sending an IPC message to a server, and obtaining the result in another IPC message from the server. This requires a [[context switch]] if the drivers are implemented as processes, or a function call if they are implemented as procedures. In addition, passing actual data to the server and back may incur extra copying overhead, while in a monolithic system the kernel can directly access the data in the client's buffers.\n\nPerformance is therefore a potential issue in microkernel systems. Indeed, the experience of first-generation microkernels such as [[Mach (kernel)|Mach]] and [[ChorusOS]] showed that systems based on them performed very poorly.<ref name=\"Chen_Bershad_93\" /> However, [[Jochen Liedtke]] showed that Mach's performance problems were the result of poor design and implementation, specifically Mach's excessive [[CPU cache|cache]] footprint.<ref name=\"Liedtke_95\"/>\nLiedtke demonstrated with his own [[L4 microkernel]] that through careful design and implementation, and especially by following the minimality principle, IPC costs could be reduced by more than an order of magnitude compared to Mach. L4's IPC performance is still unbeaten across a range of architectures.<ref name=\"Liedtke_ESHHIJ_97\">{{cite conference\n | first1 = Jochen\n | last1 = Liedtke\n | authorlink1 = Jochen Liedtke\n | last2 = Elphinstone | first2 = Kevin | last3 = Schönberg | first3 = Sebastian | last4 = Härtig | first4 = Hermann | authorlink5 = Gernot Heiser | last5 = Heiser | first5 = Gernot | last6 = Islam | first6 = Nayeem | last7 = Jaeger | first7 = Trent\n | title = Achieved IPC performance (still the foundation for extensibility)\n | booktitle = 6th Workshop on Hot Topics in Operating Systems\n | pages = 28–31\n | publisher = IEEE\n | date = May 1997\n | location = Cape Cod, MA, USA\n | url = http://ieeexplore.ieee.org/xpl/RecentCon.jsp?punumber=4643\n | id =\n}}</ref><ref name=\"Gray_CCMH_05\">{{cite conference\n |first=Charles |last=Gray |author2=Chapman, Matthew |author3=Chubb, Peter |author4=Mosberger-Tang, David |author5=[[Gernot Heiser|Heiser, Gernot]] |title=Itanium—a system implementor's tale |booktitle=USENIX Annual Technical Conference |pages=264–278 |date=April 2005|location=Annaheim, CA, USA |url=http://www.usenix.org/publications/library/proceedings/usenix05/tech/general/gray.html\n}}</ref><ref name=\"vanSchaik_Heiser_07\">\n{{cite conference\n | first1 = Carl\n | last1 = van Schaik\n | authorlink2 = Gernot Heiser | last2 = Heiser | first2 = Gernot\n | title = High-performance microkernels and virtualisation on ARM and segmented architectures\n | booktitle = 1st International Workshop on Microkernels for Embedded Systems\n | pages = 11–21\n | publisher = NICTA\n | date = January 2007\n | location = Sydney, Australia\n | url = http://ertos.nicta.com.au/publications\n | accessdate = 1 April 2007\n | id =\n}}</ref>\n\nWhile these results demonstrate that the poor performance of systems based on first-generation microkernels is not representative for second-generation kernels such as L4, this constitutes no proof that microkernel-based systems can be built with good performance. It has been shown that a monolithic Linux server ported to L4 exhibits only a few percent overhead over native Linux.<ref name=\"Hartig_97\">{{cite journal | first1 = Hermann | last1 = Härtig |\nlast2 = Hohmuth | first2 = Michael | authorlink3 = Jochen Liedtke | last3 = Liedtke | first3 = Jochen | last4 = Schönberg | first4 = Sebastian | title=The performance of µ-kernel-based systems | journal = Proceedings of the sixteenth ACM symposium on Operating systems principles  | date = October 1997 | url = http://portal.acm.org/citation.cfm?id=266660&dl=ACM&coll=&CFID=15151515&CFTOKEN=6184618 | pages=66–77|doi=10.1145/268998.266660 | isbn = 0-89791-916-5 }}</ref>\nHowever, such a single-server system exhibits few, if any, of the advantages microkernels are supposed to provide by structuring operating system functionality into separate servers.\n\nA number of commercial multi-server systems exist, in particular the [[Real-time operating system|real-time systems]] [[QNX]] and [[Integrity (operating system)|Integrity]]. No comprehensive comparison of performance relative to monolithic systems has been published for those multiserver systems. Furthermore, performance does not seem to be the overriding concern for those commercial systems, which instead emphasize reliably quick interrupt handling response times (QNX) and simplicity for the sake of robustness. An attempt to build a high-performance multiserver operating system was the IBM Sawmill Linux project.<ref name=\"Gefflaut_JPLEUTDR_00\">\n{{cite conference\n | first1 = Alain\n | last1 = Gefflaut\n | last2 = Jaeger | first2 = Trent | last3 = Park | first3 = Yoonho | authorlink4 = Jochen Liedtke | last4 = Liedtke | first4 = Jochen | last5 = Elphinstone | first5 = Kevin J. | last6 = Uhlig | first6 = Volkmar | last7 = Tidswell | first7 = Jonathon E. | last8 = Deller | first8 = Luke | last9 = Reuther | first9 = Lars | displayauthors=8\n | title = The Sawmill multiserver approach\n | booktitle = 9th ACM SIGOPS European Worshop\n | location = Kolding, Denmark\n | pages = 109–114\n | year = 2000\n| citeseerx = 10.1.1.25.8376}}</ref>\nHowever, this project was never completed.\n\nIt has been shown in the meantime that user-level device drivers can come close to the performance of in-kernel drivers even for such high-throughput, high-interrupt devices as Gigabit Ethernet.<ref name=\"Leslie_CFGGMPSEH_05\">{{cite journal |last1=Leslie |first1=Ben |last2=Chubb|first2= Peter|last3 = FitzRoy-Dale|first3= Nicholas|last4= Götz|first4 =Stefan|last5= Gray|first5= Charles|last6= Macpherson|first6= Luke|last7= Potts|first7= Daniel|last8= Shen|first8= Yueting|last9= Elphinstone|first9= Kevin| authorlink10=Gernot Heiser|last10=Heiser|first10= Gernot | date=September 2005 |title=User-level device drivers: achieved performance |journal=Journal of Computer Science and Technology |volume=20 |issue=5 |pages=654–664 |doi=10.1007/s11390-005-0654-4}}</ref> This seems to imply that high-performance multi-server systems are possible.\n\n== Security ==\nThe security benefits of microkernels have been frequently discussed.<ref>{{cite web | authorlink = Andrew S. Tanenbaum | last = Tanenbaum | first = Andrew S. | url = http://www.cs.vu.nl/~ast/reliable-os/ | title = Tanenbaum-Torvalds debate, part II }}</ref><ref>Tanenbaum, A., Herder, J. and Bos, H. (May 2006).</ref> In the context of security the minimality principle of microkernels is, some have argued, a direct consequence of the [[principle of least privilege]], according to which all code should have only the privileges needed to provide required functionality. Minimality requires that a system's [[trusted computing base]] (TCB) should be kept minimal. As the kernel (the code that executes in the privileged mode of the hardware) has unvetted access to any data and can thus violate its integrity or confidentiality, the kernel is always part of the TCB. Minimizing it is natural in a security-driven design.\n\nConsequently, microkernel designs have been used for systems designed for high-security applications, including [[KeyKOS]], [[Extremely Reliable Operating System|EROS]] and military systems. In fact [[common criteria]] (CC) at the highest assurance level ([[Evaluation Assurance Level]] (EAL) 7) has an explicit requirement that the target of evaluation be \"simple\", an acknowledgment of the practical impossibility of establishing true trustworthiness for a complex system. Unfortunately, again, the term \"simple\" is misleading and ill-defined. At least the Department of Defense Trusted Computer System Evaluation Criteria introduced somewhat more precise verbiage at the B3/A1 classes:\n\n{{Quote|text=\"The TCB shall [implement] complete, conceptually simple protection mechanisms with precisely defined semantics. Significant system engineering shall be directed toward minimizing the complexity of the TCB, as well as excluding from the TCB those modules that are not protection-critical.\"|sign=|source=Department of Defense Trusted Computer System Evaluation Criteria}}\n\n==Third generation==\nRecent work on microkernels has been focusing on formal specifications of the kernel API, and formal proofs of the API's security properties and implementation correctness. The first example of this is a mathematical proof of the confinement mechanisms in EROS, based on a simplified model of the EROS API.<ref>{{cite conference\n |first1      = Jonathan S.\n |last1       = Shapiro\n |last2       = Weber\n |first2      = Samuel\n |title       = Verifying the EROS Confinement Mechanism\n |booktitle   = IEEE Conference on Security and Privacy\n |url         = http://www.eros-os.org/papers/oakland2000.ps\n |id          = \n |deadurl     = yes\n |archiveurl  = https://web.archive.org/web/20160303174121/http://www.eros-os.org/papers/oakland2000.ps\n |archivedate = 3 March 2016\n |df          = dmy-all\n}}</ref> More recently, a comprehensive set of machine-checked proofs has been performed of the properties of the protection model of [[L4 microkernel family#High assurance: seL4|seL4]], a version of L4.<ref>{{Cite book\n  | first = Dhammika\n  | last = Elkaduwe\n  | author-link =\n  | first2 =  Gerwin\n  | last2 = Klein\n  | first3 = Kevin\n  | last3 = Elphinstone\n  | author2-link =\n  | editor-last =\n  | editor-first =\n  | editor2-last =\n  | editor2-first =\n  | contribution =\n  | contribution-url =\n  | title =Verified Protection Model of the seL4 Microkernel\n  | year = 2007\n  | place =\n  | publisher = submitted for publication\n  | url = http://ertos.org/publications/papers/Elkaduwe_GE_07.abstract\n  | id =  }}</ref>\n\nThis has led to what is referred to as ''third-generation microkernels'',<ref Name=\"Klein_EHACDEEKNSTW_09\">\n{{cite conference\n | first1 = Gerwin\n | last1 = Klein\n | last2 = Elphinstone | first2 = Kevin | last3 = Heiser | first3 = Gernot | last4 = Andronick | first4 = June | last5 = Cock | first5 = David | last6 = Derrin | first6 = Philip | last7 = Elkaduwe | first7 = Dhammika | last8 = Engelhardt | first8 = Kai | last9 = Kolanski | first9 = Rafal | last10 = Norrish | first10 = Michael | last11 = Sewell | first11 = Thomas | last12 = Tuch | first12 = Harvey | last13 = Winwood | first13 = Simon\n | title = seL4: Formal verification of an OS kernel\n | booktitle = 22nd ACM Symposium on Operating System Principles\n | date = October 2009\n | location = Big Sky, MT, USA\n | url = http://www.sigops.org/sosp/sosp09/papers/klein-sosp09.pdf\n}}</ref>\ncharacterised by a security-oriented API with resource access controlled by [[capability-based security|capabilities]], [[virtual machines#System virtual machines|virtualization]] as a first-class concern, novel approaches to kernel resource management,<ref Name=\"Elkaduwe_DE_08\">\n{{cite conference\n | first1 = Dhammika\n | last1 = Elkaduwe\n | last2 = Derrin | first2 = Philip | last3 = Elphinstone | first3 = Kevin\n | title = Kernel design for isolation and assurance of physical memory\n | booktitle = 1st Workshop on Isolation and Integration in Embedded Systems\n | date = April 2008\n | location = Glasgow, UK\n | doi = 10.1145/1435458\n | url = http://ertos.nicta.com.au/publications/papers/Elkaduwe_DE_08.abstract\n}}</ref>\nand a design goal of suitability for [[formal methods|formal analysis]], besides the usual goal of high performance. Examples are [[Coyotos]], [[L4 microkernel family#High assurance: seL4|seL4]], Nova,<ref name=\"TUD\">{{cite web |url=http://www.inf.tu-dresden.de/index.php?node_id=2697 |date=12 August 2010 |title=TUD Home: Operating Systems: Research: Microkernel & Hypervisor |work=Faculty of Computer Science |publisher=Technische Universität Dresden |accessdate=5 November 2011}}</ref><ref Name=\"Steinberg_Kauer_EuroSys_2010\">\n{{cite conference\n | first = Udo\n | last = Steinberg\n | first2 = Bernhard\n | last2 = Kauer\n | title = NOVA: A Microhypervisor-Based Secure Virtualization Architecture\n | booktitle = Eurosys 2010\n | date = April 2010\n | location = Paris, France\n | pages=209–222\n | url = http://doi.acm.org/10.1145/1755913.1755935\n}}</ref>\n[[Redox (operating system)|Redox]] and Fiasco.OC.<ref name=\"TUD\"/><ref name=Lackor_Warg_IIES_09>{{cite conference\n | first = Adam\n | last = Lackorzynski\n | first2 = Alexander\n | last2 = Warg\n | title = Taming Subsystems – Capabilities as Universal Resource Access Control in L4\n | booktitle = IIES'09: Second Workshop on Isolation and Integration in Embedded Systems\n | date = March 2009\n | location = [[Nuremberg]], Germany\n | url = http://portal.acm.org/citation.cfm?id=1519135&dl=ACM\n | citeseerx = 10.1.1.629.9845\n }}</ref>\n\nIn the case of seL4, complete formal verification of the implementation has been achieved,<ref Name=\"Klein_EHACDEEKNSTW_09\"/> i.e. a mathematical proof that the kernel's implementation is consistent with its formal specification. This provides a guarantee that the properties proved about the API actually hold for the real kernel, a degree of assurance which goes beyond even CC EAL7. It was followed by proofs of security-enforcement properties of the API, and a proof demonstrating that the executable binary code is a correct translation of the C implementation, taking the compiler out of the TCB. Taken together, these proofs establish an end-to-end proof of security properties of the kernel.<ref name=\"Klein_AEMSKH_14\">{{cite journal\n | last1 = Klein\n | first1 = Gerwin\n | last2 = Andronick\n | first2 = June\n | last3 = Elphinstone\n | first3= Kevin \n | last4 = Murray\n | first4 = Toby \n | last5 = Sewell\n | first5 = Thomas \n | last6 = Kolanski\n | first6 = Rafal \n | last7 = Heiser\n | first7 = Gernot\n | date = February 2014\n | title = Comprehensive Formal Verification of an OS Microkernel\n | journal = ACM Transactions on Computer Systems\n | volume = 32\n | issue = 1\n | pages = 2:1–2:70\n | doi = 10.1145/2560537\n }}</ref>\n\n== Nanokernel ==\nThe term ''nanokernel'' or ''picokernel'' historically referred to:\n* A kernel where the total amount of kernel code, i.e. code executing in the privileged mode of the hardware, is very small. The term ''picokernel'' was sometimes used to further emphasize small size. The term ''nanokernel'' was coined by Jonathan S. Shapiro in the paper [https://web.archive.org/web/20110621235229/http://www.cis.upenn.edu/~KeyKOS/NanoKernel/NanoKernel.html ''The KeyKOS NanoKernel Architecture'']. It was a sardonic response to [[Mach (kernel)|Mach]], which claimed to be a microkernel while Shapiro considered it monolithic, essentially unstructured, and slower than the systems it sought to replace. Subsequent reuse of and response to the term, including the picokernel coinage, suggest that the point was largely missed. Both ''nanokernel'' and ''picokernel'' have subsequently come to have the same meaning expressed by the term microkernel.\n* A virtualization layer underneath an operating system, which is more correctly referred to as a [[hypervisor]].\n* A [[hardware abstraction layer]] that forms the lowest-level part of a kernel, sometimes used to provide [[Real-time computing|real-time]] functionality to normal operating systems, like [[Adaptive Domain Environment for Operating Systems|Adeos]].\n\nThere is also at least one case where the term nanokernel is used to refer not to a small kernel, but one that supports a [[nanosecond]] clock resolution.<ref name=\"udel\">{{cite web|url=http://www.eecis.udel.edu/~mills/database/papers/nano/nano2.pdf|date=28 November 2000|title=The Nanokernel|author=David L. Mills and Poul-Henning Kamp |accessdate=28 August 2017}}</ref>\n\n==See also==\n*[[Kernel (computer science)]]\n**[[Exokernel]]\n**[[Hybrid kernel]]\n**[[Loadable kernel module]]\n**[[Monolithic kernel]]\n*[[Tanenbaum–Torvalds debate]]\n*[[Trusted computing base]]\n*[[Unikernel]]\n\n== References ==\n{{Reflist|30em}}\n\n==Further reading==\n* [http://citeseerx.ist.psu.edu/search?q=microkernel Scientific articles about microkernels] (on [[CiteSeerX]]), including:\n** {{cite journal | author=   Dan Hildebrand|title=An Architectural Overview of QNX|journal=Proceedings of the Workshop on Micro-kernels and Other Kernel Architectures  | year=1992 |   pages=113–126 | isbn=   1-880446-42-1 |citeseerx=10.1.1.459.4481}} – the basic QNX reference.\n** {{cite journal | title=Can We Make Operating Systems Reliable and Secure? | author=Tanenbaum, A., Herder, J. and Bos, H.| journal = Computer|date=May 2006 | url = http://www.computer.org/portal/site/computer/menuitem.eb7d70008ce52e4b0ef1bd108bcd45f3/index.jsp?&pName=computer_level1&path=computer/homepage/0506&file=cover1.xml&xsl=article.xsl |pages = 44–51 | doi=10.1109/MC.2006.156 | volume=39 | issue=5}} -the basic reliable reference.\n** {{cite journal |title=Microkernel Operating System Architecture and Mach | author=Black, D.L., Golub, D.B., Julin, D.P., Rashid, R.F., Draves, R.P., Dean, R.W., Forin, A., Barrera, J., Tokuda, H., Malan, G., and Bohman, D. |journal=Journal of Information Processing|volume=14 |date=March 1992 | issue=4}} – the basic Mach reference.\n* *{{cite journal | magazine=Byte | date=January 1994 | title=Small Kernels Hit It Big | first=Peter D. | last=Varhol | url=http://www.byte.com:80/art/9401/sec8/art2.htm | deadurl=yes | archiveurl=https://web.archive.org/web/20060307075538/http://www.byte.com/art/9401/sec8/art2.htm | archivedate=7 March 2006 | accessdate=September 20, 2017 | df=dmy-all }} An assessment of the present and future state of microkernel based OSes as of January 1994\n* [http://c2.com/cgi/wiki?MicroKernel MicroKernel page] from the [[Portland Pattern Repository]]\n* The [[Tanenbaum–Torvalds debate]]\n** [http://www.oreilly.com/catalog/opensources/book/appa.html The Tanenbaum-Torvalds Debate, 1992.01.29]\n** Tanenbaum, A. S. \"[http://www.computer.org/csdl/mags/co/2006/05/r5044-abs.html Can We Make Operating Systems Reliable and Secure?]\".\n** Torvalds, L. [http://www.realworldtech.com/forums/index.cfm?action=detail&id=66630&threadid=66595&roomid=11 Linus Torvalds about the microkernels again, 2006.05.09]\n** Shapiro, J. \"[https://web.archive.org/web/20160922022726/http://www.coyotos.org/docs/misc/linus-rebuttal.html Debunking Linus's Latest]\".\n** Tanenbaum, A. S. \"[http://www.cs.vu.nl/~ast/reliable-os/ Tanenbaum-Torvalds Debate: Part II]\".\n\n{{Microkernel}}\n{{Operating system}}\n{{Use dmy dates|date=October 2012}}\n\n{{Authority control}}\n\n[[Category:Microkernels]]\n\n[[fr:Noyau de système d'exploitation#Systèmes à micro-noyaux]]\n[[it:Kernel#Microkernel]]\n[[fi:Käyttöjärjestelmän ydin#Mikroydin]]",
            "slug": "microkernel",
            "date_updated": 1519550848155,
            "imported": "https://en.wikipedia.org/wiki/microkernel"
        },
        {
            "title": "Microkernel",
            "text": "[[File:OS-structure.svg|thumb|450px|Structure of monolithic and microkernel-based operating systems, respectively]]\n\nIn [[computer science]], a '''microkernel''' (also known as '''μ-kernel''') is the near-minimum amount of [[software]] that can provide the mechanisms needed to implement an [[operating system]] (OS). These mechanisms include low-level [[address space]] management, [[thread (computing)|thread]] management, and [[inter-process communication]] (IPC).\n\nIf the hardware provides multiple [[Protection ring|rings]] or [[CPU modes]], the microkernel may be the only software executing at the most privileged level, which is generally referred to as [[kernel mode|supervisor or kernel mode]]. Traditional operating system functions, such as [[device driver]]s, [[protocol stack]]s and [[file system]]s, are typically removed from the microkernel itself and are instead run in [[user space]].<ref>{{cite web\n | url = http://www.minix3.org/theses/herder-true-microkernel.pdf\n | title = Toward a True Microkernel Operating System\n | date = 23 February 2005 | accessdate = 22 June 2015\n | author = Jorrit N. Herder | website = minix3.org\n}}</ref>\n\nIn terms of the source code size, as a general rule microkernels tend to be smaller than [[monolithic kernel]]s. The [[MINIX&nbsp;3]] microkernel, for example, has approximately 12,000 lines of code.<ref>{{cite web|url=http://wiki.minix3.org/doku.php?id=www:documentation:read-more|title=read-more|last=|first=|date=|publisher=|accessdate=20 December 2016|work=minix3.org|df=}}</ref>\n\n==History==\nMicrokernels trace their roots back to Danish computer pioneer [[Per Brinch Hansen]] and his tenure in Danish computer company [[Regnecentralen]] where he led software development efforts for the RC 4000 computer.<ref name=\"ieee_2002\">{{cite web\n| url = https://www.computer.org/web/awards/pioneer-per-hansen\n| title = 2002 Computer Pioneer Award Recipient\n| publisher = IEEE Computer Society\n| accessdate = 13 September 2016\n}}\n</ref>\nIn 1967, Regnecentralen was installing a RC 4000 prototype in a Polish fertilizer plant in [[Puławy]]. The computer used a small real-time operating system tailored for the needs of the plant. Brinch Hansen and his team became concerned with the lack of generality and reusability of the RC 4000 system. They feared that each installation would require a different operating system so they started to investigate novel and more general ways of creating software for the RC 4000.<ref name=\"Hansen_2004\">{{cite book\n| url = http://brinch-hansen.net/memoirs/contents.html\n| title = A Programmer's Story: The Life of a Computer Pioneer\n| last= Brinch Hansen\n| first=Per\n| publisher=\n| year=2004\n| isbn=\n| location=\n| pages=\n| accessdate = 13 September 2016}}\n</ref>\nIn 1969, their effort resulted in the completion of the [[RC 4000 multiprogramming system|RC 4000 Multiprogramming System]]. Its nucleus provided inter-process communication based on message-passing for up to 23 unprivileged processes, out of which 8 at a time were protected from one another. It further implemented scheduling of time slices of programs executed in parallel, initiation and control of program execution at the request of other running programs, and initiation of data transfers to or from peripherals. Besides these elementary mechanisms, it had no built-in strategy for program execution and resource allocation. This strategy was to be implemented by a hierarchy of running programs in which parent processes had complete control over child processes and acted as their operating systems.<ref name=\"Hansen_1969\">{{cite techreport\n| first = Per\n| last = Brinch Hansen\n| title = RC 4000 Software: Multiprogramming System\n| institution = Regnecentralen\n| date = April 1969\n| url = http://brinch-hansen.net/papers/1969a.pdf\n| accessdate = 13 September 2016\n}}\n</ref><ref>{{cite journal\n | author = Brinch Hansen, Per\n | year = 1970\n | volume = 13\n | title = The Nucleus of a Multiprogramming Operating System\n | journal = Communications of the ACM\n | pages = 238–250\n | url = http://www.brinch-hansen.net/papers/1970a.pdf\n | doi = 10.1145/362258.362278\n | issue = 4\n}}\n</ref>\n\nFollowing Brinch Hansen's work, microkernels have been developed since the 1970s<ref name=\"Wulf_74\">.{{cite journal\n | last1 = Wulf\n | first1 = William\n | last2 = Cohen\n | first2 = Ellis\n | last3 = Corwin\n | first3 = William\n | last4 = Jones\n | first4 = Anita\n | last5 = Levin\n | first5 = Roy\n | last6 = Pierson\n | first6 = C.\n | last7 = Pollack\n | first7 = Fred\n | date = June 1974\n | title = HYDRA: The Kernel of a Multiprocessor Operating System\n | journal = Communications of the ACM\n | volume = 17\n | issue = 6\n | pages = 337-345\n | pmid =\n | doi = 10.1145/355616.364017\n | id =\n | url =\n | laysummary =\n | laysource =\n | laydate =\n | quote =\n }}</ref> The term microkernel itself appeared no later than 1981.<ref name=\"Rashid_81\">{{cite conference\n | last1 = Rashid\n | first1 = Richard\n | last2 = Robertson\n | first2 = George\n | title = Accent: A communication oriented network operating system kernel\n | doi = 10.1145/800216.806593\n | booktitle = SOSP '81 Proceedings of the eighth ACM symposium on Operating systems principles\n | pages = 64-75\n | date = December 1981\n | location = Pacific Grove, California, USA\n }}</ref> Microkernels were meant as a response to changes in the computer world, and to several challenges adapting existing \"[[mono-kernel]]s\" to these new systems. New device drivers, protocol stacks, file systems and other low-level systems were being developed all the time. This code was normally located in the monolithic kernel, and thus required considerable work and careful code management to work on. Microkernels were developed with the idea that all of these services would be implemented as user-space programs, like any other, allowing them to be worked on monolithically and started and stopped like any other program. This would not only allow these services to be more easily worked on, but also separated the kernel code to allow it to be finely tuned without worrying about unintended side effects. Moreover, it would allow entirely new operating systems to be \"built up\" on a common core, aiding OS research.\n\nMicrokernels were a very hot topic in the 1980s when the first usable [[local area network]]s were being introduced.{{Citation needed|date=November 2012}} The same mechanisms that allowed the kernel to be distributed into user space also allowed the system to be distributed across network links. The first microkernels, notably [[Mach (kernel)|Mach]], proved to have disappointing performance, but the inherent advantages appeared so great that it was a major line of research into the late 1990s.{{Citation needed|date=November 2012}} However, during this time the speed of computers grew greatly in relation to networking systems, and the disadvantages in performance came to overwhelm the advantages in development terms.{{citation needed|date = June 2015}} Many attempts were made to adapt the existing systems to have better performance, but the overhead was always considerable and most of these efforts required the user-space programs to be moved back into the kernel. By 2000, most large-scale (Mach-like) efforts had ended, although Apple's [[macOS]], released in 2001, uses a [[hybrid kernel]] called [[XNU]], which combines a heavily modified (hybrid) [[OSFMK]] 7.3 kernel with code from BSD UNIX,<ref>{{cite av media|url=https://www.youtube.com/watch?v=ggnFoDqzGMU|author=Jim Magee|title=WWDC 2000 Session 106 - Mac OS X: Kernel|minutes=14}}</ref><ref>{{cite web|title=Porting UNIX/Linux Applications to Mac OS X|url=https://developer.apple.com/library/mac/#documentation/Porting/Conceptual/PortingUnix/glossary/glossary.html#//apple_ref/doc/uid/TP40002859-TPXREF101|publisher=Apple|accessdate=26 April 2011}}</ref> and this kernel is also used in [[iOS]], [[tvOS]], and [[watchOS]]. {{As of|2012}}, the Mach-based [[GNU Hurd]] is also functional and included in testing versions of [[Arch Linux]] and [[Debian]].\n\nAlthough major work on microkernels had largely ended, experimenters continued development.{{Citation needed|date=November 2012}} It has since been shown that many of the performance problems of earlier designs were not a fundamental limitation of the concept, but instead due to the designer's desire to use single-purpose systems to implement as many of these services as possible.{{Citation needed|date=November 2012}} Using a more pragmatic approach to the problem, including [[assembly code]] and relying on the processor to enforce concepts normally supported in software led to a new series of microkernels with dramatically improved performance.\n\nMicrokernels are closely related to [[exokernel]]s.<ref name=\"Liedtke_96\">{{cite journal\n | last = Liedtke\n | first = Jochen\n | date = September 1996\n | title = Towards Real Microkernels\n | journal = Communications of the ACM\n | volume = 39\n | issue = 9\n | pages = 70–77\n | pmid =\n | doi = 10.1145/234215.234473\n | id =\n | url =\n | laysummary =\n | laysource =\n | laydate =\n | quote =\n }}</ref>\nThey also have much in common with [[hypervisor]]s,<ref name=\"Heiser_UL_06\">{{cite journal\n | title=Are Virtual-Machine Monitors Microkernels Done Right?\n | authorlink1=Gernot Heiser|last1=Heiser|first1=Gernot|last2= Uhlig|first2= Volkmar |last3= LeVasseur|first3= Joshua\n | journal=ACM SIGOPS Operating Systems Review\n | volume=40\n | issue=1\n | pages=95–99\n |date=January 2006\n | url=http://os.ibds.kit.edu/65_747.php\n | publisher=ACM\n | doi = 10.1145/1113361.1113363\n | format=PDF}}</ref>\nbut the latter make no claim to minimality and are specialized to supporting [[virtual machine]]s; indeed, the [[L4 microkernel]] frequently finds use in a hypervisor capacity.\n\n==Introduction==\nEarly operating system kernels were rather small, partly because computer memory was limited. As the capability of computers grew, the number of devices the kernel had to control also grew. Throughout the early history of [[Unix]], kernels were generally small, even though they contained various [[device driver]]s and [[file system]] implementations. When address spaces increased from 16 to 32 bits, kernel design was no longer constrained by the hardware architecture, and kernels began to grow larger.\n\nThe [[Berkeley Software Distribution]] (BSD) of [[Unix]] began the era of larger kernels. In addition to operating a basic system consisting of the CPU, disks and printers, BSD added a complete [[protocol stack|TCP/IP networking system]] and a number of \"virtual\" devices that allowed the existing programs to work 'invisibly' over the network. This growth continued for many years, resulting in kernels with millions of lines of [[source code]]. As a result of this growth, kernels were prone to bugs and became increasingly difficult to maintain.\n\nThe microkernel was intended to address this growth of kernels and the difficulties that resulted. In theory, the microkernel design allows for easier management of code due to its division into [[user space]] services. This also allows for increased security and stability resulting from the reduced amount of code running in [[kernel mode]]. For example, if a networking service crashed due to [[buffer overflow]], only the networking service's memory would be corrupted, leaving the rest of the system still functional.\n\n==Inter-process communication==\n[[Inter-process communication]] (IPC) is any mechanism which allows separate processes to communicate with each other, usually by sending [[message passing|messages]]. [[Shared memory (interprocess communication)|Shared memory]] is strictly speaking also an inter-process communication mechanism, but the abbreviation IPC usually only refers to message passing, and it is the latter that is particularly relevant to microkernels. IPC allows the operating system to be built from a number of small programs called servers, which are used by other programs on the system, invoked via IPC. Most or all support for peripheral  hardware is handled in this fashion, with servers for device drivers, [[network protocol stack]]s, file systems, graphics, etc.\n\nIPC can be synchronous or asynchronous. Asynchronous IPC is analogous to network communication: the sender dispatches a message and continues executing. The receiver checks (polls) for the availability of the message by attempting a receive, or is alerted to it via some notification mechanism. Asynchronous IPC requires that the kernel maintains buffers and queues for messages, and deals with buffer overflows; it also requires double copying of messages (sender to kernel and kernel to receiver). In synchronous IPC, the first party (sender or receiver) blocks until the other party is ready to perform the IPC. It does not require buffering or multiple copies, but the implicit rendezvous can make programming tricky. Most programmers prefer asynchronous send and synchronous receive.\n\nFirst-generation microkernels typically supported synchronous as well as asynchronous IPC, and suffered from poor IPC performance. [[Jochen Liedtke]] assumed the design and implementation of the IPC mechanisms to be the underlying reason for this poor performance. In his [[L4 microkernel family|L4 microkernel]] he pioneered methods that lowered IPC costs by an [[order of magnitude]].<ref name=\"Liedtke_93\">{{cite conference\n | first = Jochen\n | last = Liedtke\n | authorlink = Jochen Liedtke\n | title = Improving IPC by kernel design\n | booktitle = 14th ACM Symposium on Operating System Principles\n | pages = 175–88\n |date=December 1993\n | location = Asheville, NC, USA\n | citeseerx = 10.1.1.40.1293\n }}</ref> These include an IPC system call that supports a send as well as a receive operation, making all IPC synchronous, and passing as much data as possible in registers. Furthermore, Liedtke introduced the concept of the ''direct process switch'', where during an IPC execution an (incomplete) [[context switch]] is performed from the sender directly to the receiver. If, as in L4, part or all of the message is passed in registers, this transfers the in-register part of the message without any copying at all. Furthermore, the overhead of invoking the scheduler is avoided; this is especially beneficial in the common case where IPC is used in an [[remote procedure call|RPC]]-type fashion by a client invoking a server. Another optimization, called ''lazy scheduling'', avoids traversing scheduling queues during IPC by leaving threads that block during IPC in the ready queue. Once the scheduler is invoked, it moves such threads to the appropriate waiting queue. As in many cases a thread gets unblocked before the next scheduler invocation, this approach saves significant work. Similar approaches have since been adopted by [[QNX]] and [[MINIX 3]].{{Citation needed|date=August 2010}}\n\nIn a series of experiments, Chen and Bershad compared memory [[cycles per instruction]] (MCPI) of monolithic [[Ultrix]] with those of microkernel [[Mach (kernel)|Mach]] combined with a [[4.3BSD]] [[Unix]] server running in [[user space]]. Their results explained Mach's poorer performance by higher MCPI and demonstrated that IPC alone is not responsible for much of the system overhead, suggesting that optimizations focused exclusively on IPC will have limited impact.<ref name=\"Chen_Bershad_93\">{{cite conference\n | first1 = J. Bradley\n | last1 = Chen\n | first2 = Brian N.\n | last2 = Bershad\n | title = The Impact of Operating System Structure on Memory System Performance\n | booktitle = SOSP '93 Proceedings of the fourteenth ACM symposium on Operating systems principles\n | pages = 120–133\n | date= December 1993\n | location = Asheville, NC, USA\n | doi = 10.1145/168619.168629\n | url = https://people.eecs.berkeley.edu/~prabal/resources/osprelim/CB93.pdf\n }}</ref> Liedtke later refined Chen and Bershad's results by making an observation that the bulk of the difference between Ultrix and Mach MCPI was caused by capacity [[CPU cache#Cache-miss|cache-misses]] and concluding that drastically reducing the cache working set of a microkernel will solve the problem.<ref name=\"Liedtke_95\">{{cite conference\n | first = Jochen\n | last = Liedtke\n | authorlink = Jochen Liedtke\n | title = On µ-Kernel Construction\n | booktitle = SOSP '95 Proceedings of the fifteenth ACM symposium on Operating systems principles\n | pages = 237–250\n | date= December 1995\n | location = Copper Mountain Resort, CO, USA \n | doi = 10.1145/224056.224075\n }}</ref>\n\nIn a client-server system, most communication is essentially synchronous, even if using asynchronous primitives, as the typical operation is a client invoking a server and then waiting for a reply. As it also lends itself to more efficient implementation, most microkernels generally followed L4's lead and only provided a synchronous IPC primitive. Asynchronous IPC could be implemented on top by using helper threads. However, experience has shown that the utility of synchronous IPC is dubious: synchronous IPC forces a multi-threaded design onto otherwise simple systems, with the resulting synchronization complexities. Moreover, an RPC-like server invocation sequentializes client and server, which should be avoided if they are running on separate cores. Versions of L4 deployed in commercial products have therefore found it necessary to add an asynchronous notification mechanism to better support asynchronous communication. This [[signal (computing)|signal]]-like mechanism does not carry data and therefore does not require buffering by the kernel. By having two forms of IPC, they have nonetheless violated the principle of minimality. Other versions of L4 have switched to asynchronous IPC completely.<ref name=\"elphinstone_2013\">{{cite conference\n | first1 = Kevin\n | last1 = Elphinstone\n | first2 = Gernot\n | last2 = Heiser\n | title = From L3 to seL4: What Have We Learnt in 20 Years of L4 Microkernels?\n | booktitle = SOSP '13 Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles\n | pages = 133–150\n | date = November 2013\n | location = Farmington, PA, USA \n | doi = 10.1145/2517349.2522720\n}}\n</ref>\n\nAs synchronous IPC blocks the first party until the other is ready, unrestricted use could easily lead to deadlocks. Furthermore, a client could easily mount a [[denial-of-service]] attack on a server by sending a request and never attempting to receive the reply. Therefore, synchronous IPC must provide a means to prevent indefinite blocking. Many microkernels provide [[timeout (telecommunication)|timeouts]] on IPC calls, which limit the blocking time. In practice, choosing sensible timeout values is difficult, and systems almost inevitably use infinite timeouts for clients and zero timeouts for servers. As a consequence, the trend is towards not providing arbitrary timeouts, but only a flag which indicates that the IPC should fail immediately if the partner is not ready. This approach effectively provides a choice of the two timeout values of zero and infinity. Recent versions of L4 and MINIX have gone down this path (older versions of L4 used timeouts, as does QNX).\n\n==Servers==\nMicrokernel servers are essentially [[daemon (computer software)|daemon]] programs like any others, except that the kernel grants some of them privileges to interact with parts of physical memory that are otherwise off limits to most programs. This allows some servers, particularly device drivers, to interact directly with hardware.\n\nA basic set of servers for a general-purpose microkernel includes file system servers, device driver servers, networking servers, [[display server]]s, and user interface device servers. This set of servers (drawn from [[QNX]]) provides roughly the set of services offered by a Unix [[monolithic kernel]]. The necessary servers are started at system startup and provide services, such as file, network, and device access, to ordinary application programs. With such servers running in the environment of a user application, server development is similar to ordinary application development, rather than the build-and-boot process needed for kernel development.\n\nAdditionally, many \"crashes\" can be corrected by simply [[Crash-only software|stopping and restarting the server]]. However, part of the system state is lost with the failing server, hence this approach requires applications to cope with failure. A good example is a server responsible for [[Internet protocol suite|TCP/IP]] connections: If this server is restarted, applications will experience a \"lost\" connection, a normal occurrence in a networked system. For other services, failure is less expected and may require changes to application code. For QNX, restart capability is offered as the QNX High Availability Toolkit.<ref>{{cite web|url=http://www.qnx.com/download/download/8107/QNX_High_Availability_Toolkit.pdf|title=The QNX High Availability Toolkit|archive-url=https://web.archive.org/web/20050824015422/http://www.qnx.com/download/download/8107/QNX_High_Availability_Toolkit.pdf|archive-date=24 August 2005 }}</ref>\n\nTo make all servers restartable, some microkernels have concentrated on adding various [[database]]-like methods such as [[database transaction|transaction]]s, [[replication (computer science)|replication]] and [[checkpointing]] to preserve essential state across single server restarts. An example is [[ChorusOS]], which was made for high-availability applications in the telecommunications world. Chorus included features to allow any \"properly written\" server to be restarted at any time, with clients using those servers being paused while the server brought itself back into its original state.{{Citation needed|date=February 2007}} However, such kernel features are incompatible with the minimality principle, and are thus not provided in modern microkernels, which instead rely on appropriate user-level protocols.\n\n==Device drivers==\n[[Device driver]]s frequently perform [[direct memory access]] (DMA), and therefore can write to arbitrary locations of physical memory, including various kernel data structures. Such drivers must therefore be trusted. It is a common misconception that this means that they must be part of the kernel. In fact, a driver is not inherently more or less trustworthy by being part of the kernel.\n\nWhile running a device driver in user space does not necessarily reduce the damage a misbehaving driver can cause, in practice it is beneficial for system stability in the presence of buggy (rather than malicious) drivers: memory-access violations by the driver code itself (as opposed to the device) may still be caught by the memory-management hardware. Furthermore, many devices are not DMA-capable, their drivers can be made untrusted by running them in user space. Recently, an increasing number of computers feature [[IOMMU]]s, many of which can be used to restrict a device's access to physical memory.<ref name=\"Wong_07\">{{cite journal |title=I/O, I/O, It's Off to Virtual Work We Go |url=http://www.electronicdesign.com/embedded/io-io-its-virtual-work-we-go |last=Wong |first=William |journal=[[Electronic Design (magazine)|Electronic Design]] |date=27 April 2007 |accessdate=8 June 2009 }}</ref> (IBM mainframes have had IO MMUs since the [[IBM System/360 Model 67]] and [[System/370]].) This also allows user-mode drivers to become untrusted.\n\nUser-mode drivers actually predate microkernels. The [[Michigan Terminal System]] (MTS), in 1967, supported user space drivers (including its file system support), the first operating system to be designed with that capability.<ref>{{cite journal |title=Organization and Features of the Michigan Terminal System |first=Michael T. |last=Alexander |journal=Proceedings of the November 16–18, 1971, fall joint computer conference |volume=40 |year=1971 |pages=589–591 |doi=10.1145/1478873.1478951}}</ref>\nHistorically, drivers were less of a problem, as the number of devices was small and trusted anyway, so having them in the kernel simplified the design and avoided potential performance problems. This led to the traditional driver-in-the-kernel style of Unix,<ref name=\"Lions book\">{{cite book |title=[[Lions' Commentary on UNIX 6th Edition, with Source Code]] |last=Lions |first=John |date=1 August 1977 |isbn=978-1-57398-013-5 |publisher=Peer-To-Peer Communications}}</ref> Linux, and Windows before [[Windows XP]].\nWith the proliferation of various kinds of peripherals, the amount of driver code escalated and in modern operating systems dominates the kernel in code size.\n\n==Essential components and minimality==\nAs a microkernel must allow building arbitrary operating system services on top, it must provide some core functionality. At a minimum, this includes:\n* some mechanisms for dealing with [[address space]]s, required for managing memory protection\n* some execution abstraction to manage CPU allocation, typically [[thread (computing)|threads]] or [[scheduler activations]]\n* [[inter-process communication]], required to invoke servers running in their own address spaces\n\nThis minimal design was pioneered by [[Brinch Hansen]]'s [[RC 4000 Multiprogramming System|Nucleus]] and the hypervisor of IBM's [[VM (operating system)|VM]]. It has since been formalised in Liedtke's ''minimality principle'':\n<blockquote>A concept is tolerated inside the microkernel only if moving it outside the kernel, i.e., permitting competing implementations, would prevent the implementation of the system's required functionality.<ref name=\"Liedtke_95\" /></blockquote>\nEverything else can be done in a usermode program, although device drivers implemented as user programs may on some processor architectures require special privileges to access I/O hardware.\n\nRelated to the minimality principle, and equally important for microkernel design, is the [[separation of mechanism and policy]], it is what enables the construction of arbitrary systems on top of a minimal kernel. Any policy built into the kernel cannot be overwritten at user level and therefore limits the generality of the microkernel.<ref name=\"Liedtke_96\"/>\nPolicy implemented in user-level servers can be changed by replacing the servers (or letting the application choose between competing servers offering similar services).\n\nFor efficiency, most microkernels contain schedulers and manage timers, in violation of the minimality principle and the principle of policy-mechanism separation.\n\nStart up ([[booting]]) of a microkernel-based system requires [[device driver]]s, which are not part of the kernel. Typically this means that they are packaged with the kernel in the boot image, and the kernel supports a bootstrap protocol that defines how the drivers are located and started; this is the traditional bootstrap procedure of [[L4 microkernel family|L4 microkernels]]. Some microkernels simplify this by placing some key drivers inside the kernel (in violation of the minimality principle), [[LynxOS]] and the original [[Minix]] are examples. Some even include a [[file system]] in the kernel to simplify booting. A <!-- In other cases,  [[GNU GRUB]] for example, (This is NOT according to GRUB wiki) --> microkernel-based system may boot via multiboot compatible boot loader. Such systems usually load statically-linked servers to make an initial bootstrap or mount an OS image to continue bootstrapping.\n\nA key component of a microkernel is a good [[Inter-process communication|IPC]] system and virtual-memory-manager design that allows implementing page-fault handling and swapping in usermode servers in a safe way. Since all services are performed by usermode programs, efficient means of communication between programs are essential, far more so than in monolithic kernels. The design of the IPC system makes or breaks a microkernel. To be effective, the IPC system must not only have low overhead, but also interact well with CPU scheduling.\n\n==Performance==\nOn most mainstream processors, obtaining a service is inherently more expensive in a microkernel-based system than a monolithic system.<ref name=\"Liedtke_96\"/> In the monolithic system, the service is obtained by a single system call, which requires two ''mode switches'' (changes of the processor's [[ring (computer security)|ring]] or [[CPU modes|CPU mode]]). In the microkernel-based system, the service is obtained by sending an IPC message to a server, and obtaining the result in another IPC message from the server. This requires a [[context switch]] if the drivers are implemented as processes, or a function call if they are implemented as procedures. In addition, passing actual data to the server and back may incur extra copying overhead, while in a monolithic system the kernel can directly access the data in the client's buffers.\n\nPerformance is therefore a potential issue in microkernel systems. Indeed, the experience of first-generation microkernels such as [[Mach (kernel)|Mach]] and [[ChorusOS]] showed that systems based on them performed very poorly.<ref name=\"Chen_Bershad_93\" /> However, [[Jochen Liedtke]] showed that Mach's performance problems were the result of poor design and implementation, specifically Mach's excessive [[CPU cache|cache]] footprint.<ref name=\"Liedtke_95\"/>\nLiedtke demonstrated with his own [[L4 microkernel]] that through careful design and implementation, and especially by following the minimality principle, IPC costs could be reduced by more than an order of magnitude compared to Mach. L4's IPC performance is still unbeaten across a range of architectures.<ref name=\"Liedtke_ESHHIJ_97\">{{cite conference\n | first1 = Jochen\n | last1 = Liedtke\n | authorlink1 = Jochen Liedtke\n | last2 = Elphinstone | first2 = Kevin | last3 = Schönberg | first3 = Sebastian | last4 = Härtig | first4 = Hermann | authorlink5 = Gernot Heiser | last5 = Heiser | first5 = Gernot | last6 = Islam | first6 = Nayeem | last7 = Jaeger | first7 = Trent\n | title = Achieved IPC performance (still the foundation for extensibility)\n | booktitle = 6th Workshop on Hot Topics in Operating Systems\n | pages = 28–31\n | publisher = IEEE\n | date = May 1997\n | location = Cape Cod, MA, USA\n | url = http://ieeexplore.ieee.org/xpl/RecentCon.jsp?punumber=4643\n | id =\n}}</ref><ref name=\"Gray_CCMH_05\">{{cite conference\n |first=Charles |last=Gray |author2=Chapman, Matthew |author3=Chubb, Peter |author4=Mosberger-Tang, David |author5=[[Gernot Heiser|Heiser, Gernot]] |title=Itanium—a system implementor's tale |booktitle=USENIX Annual Technical Conference |pages=264–278 |date=April 2005|location=Annaheim, CA, USA |url=http://www.usenix.org/publications/library/proceedings/usenix05/tech/general/gray.html\n}}</ref><ref name=\"vanSchaik_Heiser_07\">\n{{cite conference\n | first1 = Carl\n | last1 = van Schaik\n | authorlink2 = Gernot Heiser | last2 = Heiser | first2 = Gernot\n | title = High-performance microkernels and virtualisation on ARM and segmented architectures\n | booktitle = 1st International Workshop on Microkernels for Embedded Systems\n | pages = 11–21\n | publisher = NICTA\n | date = January 2007\n | location = Sydney, Australia\n | url = http://ertos.nicta.com.au/publications\n | accessdate = 1 April 2007\n | id =\n}}</ref>\n\nWhile these results demonstrate that the poor performance of systems based on first-generation microkernels is not representative for second-generation kernels such as L4, this constitutes no proof that microkernel-based systems can be built with good performance. It has been shown that a monolithic Linux server ported to L4 exhibits only a few percent overhead over native Linux.<ref name=\"Hartig_97\">{{cite journal | first1 = Hermann | last1 = Härtig |\nlast2 = Hohmuth | first2 = Michael | authorlink3 = Jochen Liedtke | last3 = Liedtke | first3 = Jochen | last4 = Schönberg | first4 = Sebastian | title=The performance of µ-kernel-based systems | journal = Proceedings of the sixteenth ACM symposium on Operating systems principles  | date = October 1997 | url = http://portal.acm.org/citation.cfm?id=266660&dl=ACM&coll=&CFID=15151515&CFTOKEN=6184618 | pages=66–77|doi=10.1145/268998.266660 | isbn = 0-89791-916-5 }}</ref>\nHowever, such a single-server system exhibits few, if any, of the advantages microkernels are supposed to provide by structuring operating system functionality into separate servers.\n\nA number of commercial multi-server systems exist, in particular the [[Real-time operating system|real-time systems]] [[QNX]] and [[Integrity (operating system)|Integrity]]. No comprehensive comparison of performance relative to monolithic systems has been published for those multiserver systems. Furthermore, performance does not seem to be the overriding concern for those commercial systems, which instead emphasize reliably quick interrupt handling response times (QNX) and simplicity for the sake of robustness. An attempt to build a high-performance multiserver operating system was the IBM Sawmill Linux project.<ref name=\"Gefflaut_JPLEUTDR_00\">\n{{cite conference\n | first1 = Alain\n | last1 = Gefflaut\n | last2 = Jaeger | first2 = Trent | last3 = Park | first3 = Yoonho | authorlink4 = Jochen Liedtke | last4 = Liedtke | first4 = Jochen | last5 = Elphinstone | first5 = Kevin J. | last6 = Uhlig | first6 = Volkmar | last7 = Tidswell | first7 = Jonathon E. | last8 = Deller | first8 = Luke | last9 = Reuther | first9 = Lars | displayauthors=8\n | title = The Sawmill multiserver approach\n | booktitle = 9th ACM SIGOPS European Worshop\n | location = Kolding, Denmark\n | pages = 109–114\n | year = 2000\n| citeseerx = 10.1.1.25.8376}}</ref>\nHowever, this project was never completed.\n\nIt has been shown in the meantime that user-level device drivers can come close to the performance of in-kernel drivers even for such high-throughput, high-interrupt devices as Gigabit Ethernet.<ref name=\"Leslie_CFGGMPSEH_05\">{{cite journal |last1=Leslie |first1=Ben |last2=Chubb|first2= Peter|last3 = FitzRoy-Dale|first3= Nicholas|last4= Götz|first4 =Stefan|last5= Gray|first5= Charles|last6= Macpherson|first6= Luke|last7= Potts|first7= Daniel|last8= Shen|first8= Yueting|last9= Elphinstone|first9= Kevin| authorlink10=Gernot Heiser|last10=Heiser|first10= Gernot | date=September 2005 |title=User-level device drivers: achieved performance |journal=Journal of Computer Science and Technology |volume=20 |issue=5 |pages=654–664 |doi=10.1007/s11390-005-0654-4}}</ref> This seems to imply that high-performance multi-server systems are possible.\n\n== Security ==\nThe security benefits of microkernels have been frequently discussed.<ref>{{cite web | authorlink = Andrew S. Tanenbaum | last = Tanenbaum | first = Andrew S. | url = http://www.cs.vu.nl/~ast/reliable-os/ | title = Tanenbaum-Torvalds debate, part II }}</ref><ref>Tanenbaum, A., Herder, J. and Bos, H. (May 2006).</ref> In the context of security the minimality principle of microkernels is, some have argued, a direct consequence of the [[principle of least privilege]], according to which all code should have only the privileges needed to provide required functionality. Minimality requires that a system's [[trusted computing base]] (TCB) should be kept minimal. As the kernel (the code that executes in the privileged mode of the hardware) has unvetted access to any data and can thus violate its integrity or confidentiality, the kernel is always part of the TCB. Minimizing it is natural in a security-driven design.\n\nConsequently, microkernel designs have been used for systems designed for high-security applications, including [[KeyKOS]], [[Extremely Reliable Operating System|EROS]] and military systems. In fact [[common criteria]] (CC) at the highest assurance level ([[Evaluation Assurance Level]] (EAL) 7) has an explicit requirement that the target of evaluation be \"simple\", an acknowledgment of the practical impossibility of establishing true trustworthiness for a complex system. Unfortunately, again, the term \"simple\" is misleading and ill-defined. At least the Department of Defense Trusted Computer System Evaluation Criteria introduced somewhat more precise verbiage at the B3/A1 classes:\n\n{{Quote|text=\"The TCB shall [implement] complete, conceptually simple protection mechanisms with precisely defined semantics. Significant system engineering shall be directed toward minimizing the complexity of the TCB, as well as excluding from the TCB those modules that are not protection-critical.\"|sign=|source=Department of Defense Trusted Computer System Evaluation Criteria}}\n\n==Third generation==\nRecent work on microkernels has been focusing on formal specifications of the kernel API, and formal proofs of the API's security properties and implementation correctness. The first example of this is a mathematical proof of the confinement mechanisms in EROS, based on a simplified model of the EROS API.<ref>{{cite conference\n |first1      = Jonathan S.\n |last1       = Shapiro\n |last2       = Weber\n |first2      = Samuel\n |title       = Verifying the EROS Confinement Mechanism\n |booktitle   = IEEE Conference on Security and Privacy\n |url         = http://www.eros-os.org/papers/oakland2000.ps\n |id          = \n |deadurl     = yes\n |archiveurl  = https://web.archive.org/web/20160303174121/http://www.eros-os.org/papers/oakland2000.ps\n |archivedate = 3 March 2016\n |df          = dmy-all\n}}</ref> More recently, a comprehensive set of machine-checked proofs has been performed of the properties of the protection model of [[L4 microkernel family#High assurance: seL4|seL4]], a version of L4.<ref>{{Cite book\n  | first = Dhammika\n  | last = Elkaduwe\n  | author-link =\n  | first2 =  Gerwin\n  | last2 = Klein\n  | first3 = Kevin\n  | last3 = Elphinstone\n  | author2-link =\n  | editor-last =\n  | editor-first =\n  | editor2-last =\n  | editor2-first =\n  | contribution =\n  | contribution-url =\n  | title =Verified Protection Model of the seL4 Microkernel\n  | year = 2007\n  | place =\n  | publisher = submitted for publication\n  | url = http://ertos.org/publications/papers/Elkaduwe_GE_07.abstract\n  | id =  }}</ref>\n\nThis has led to what is referred to as ''third-generation microkernels'',<ref Name=\"Klein_EHACDEEKNSTW_09\">\n{{cite conference\n | first1 = Gerwin\n | last1 = Klein\n | last2 = Elphinstone | first2 = Kevin | last3 = Heiser | first3 = Gernot | last4 = Andronick | first4 = June | last5 = Cock | first5 = David | last6 = Derrin | first6 = Philip | last7 = Elkaduwe | first7 = Dhammika | last8 = Engelhardt | first8 = Kai | last9 = Kolanski | first9 = Rafal | last10 = Norrish | first10 = Michael | last11 = Sewell | first11 = Thomas | last12 = Tuch | first12 = Harvey | last13 = Winwood | first13 = Simon\n | title = seL4: Formal verification of an OS kernel\n | booktitle = 22nd ACM Symposium on Operating System Principles\n | date = October 2009\n | location = Big Sky, MT, USA\n | url = http://www.sigops.org/sosp/sosp09/papers/klein-sosp09.pdf\n}}</ref>\ncharacterised by a security-oriented API with resource access controlled by [[capability-based security|capabilities]], [[virtual machines#System virtual machines|virtualization]] as a first-class concern, novel approaches to kernel resource management,<ref Name=\"Elkaduwe_DE_08\">\n{{cite conference\n | first1 = Dhammika\n | last1 = Elkaduwe\n | last2 = Derrin | first2 = Philip | last3 = Elphinstone | first3 = Kevin\n | title = Kernel design for isolation and assurance of physical memory\n | booktitle = 1st Workshop on Isolation and Integration in Embedded Systems\n | date = April 2008\n | location = Glasgow, UK\n | doi = 10.1145/1435458\n | url = http://ertos.nicta.com.au/publications/papers/Elkaduwe_DE_08.abstract\n}}</ref>\nand a design goal of suitability for [[formal methods|formal analysis]], besides the usual goal of high performance. Examples are [[Coyotos]], [[L4 microkernel family#High assurance: seL4|seL4]], Nova,<ref name=\"TUD\">{{cite web |url=http://www.inf.tu-dresden.de/index.php?node_id=2697 |date=12 August 2010 |title=TUD Home: Operating Systems: Research: Microkernel & Hypervisor |work=Faculty of Computer Science |publisher=Technische Universität Dresden |accessdate=5 November 2011}}</ref><ref Name=\"Steinberg_Kauer_EuroSys_2010\">\n{{cite conference\n | first = Udo\n | last = Steinberg\n | first2 = Bernhard\n | last2 = Kauer\n | title = NOVA: A Microhypervisor-Based Secure Virtualization Architecture\n | booktitle = Eurosys 2010\n | date = April 2010\n | location = Paris, France\n | pages=209–222\n | url = http://doi.acm.org/10.1145/1755913.1755935\n}}</ref>\n[[Redox (operating system)|Redox]] and Fiasco.OC.<ref name=\"TUD\"/><ref name=Lackor_Warg_IIES_09>{{cite conference\n | first = Adam\n | last = Lackorzynski\n | first2 = Alexander\n | last2 = Warg\n | title = Taming Subsystems – Capabilities as Universal Resource Access Control in L4\n | booktitle = IIES'09: Second Workshop on Isolation and Integration in Embedded Systems\n | date = March 2009\n | location = [[Nuremberg]], Germany\n | url = http://portal.acm.org/citation.cfm?id=1519135&dl=ACM\n | citeseerx = 10.1.1.629.9845\n }}</ref>\n\nIn the case of seL4, complete formal verification of the implementation has been achieved,<ref Name=\"Klein_EHACDEEKNSTW_09\"/> i.e. a mathematical proof that the kernel's implementation is consistent with its formal specification. This provides a guarantee that the properties proved about the API actually hold for the real kernel, a degree of assurance which goes beyond even CC EAL7. It was followed by proofs of security-enforcement properties of the API, and a proof demonstrating that the executable binary code is a correct translation of the C implementation, taking the compiler out of the TCB. Taken together, these proofs establish an end-to-end proof of security properties of the kernel.<ref name=\"Klein_AEMSKH_14\">{{cite journal\n | last1 = Klein\n | first1 = Gerwin\n | last2 = Andronick\n | first2 = June\n | last3 = Elphinstone\n | first3= Kevin \n | last4 = Murray\n | first4 = Toby \n | last5 = Sewell\n | first5 = Thomas \n | last6 = Kolanski\n | first6 = Rafal \n | last7 = Heiser\n | first7 = Gernot\n | date = February 2014\n | title = Comprehensive Formal Verification of an OS Microkernel\n | journal = ACM Transactions on Computer Systems\n | volume = 32\n | issue = 1\n | pages = 2:1–2:70\n | doi = 10.1145/2560537\n }}</ref>\n\n== Nanokernel ==\nThe term ''nanokernel'' or ''picokernel'' historically referred to:\n* A kernel where the total amount of kernel code, i.e. code executing in the privileged mode of the hardware, is very small. The term ''picokernel'' was sometimes used to further emphasize small size. The term ''nanokernel'' was coined by Jonathan S. Shapiro in the paper [https://web.archive.org/web/20110621235229/http://www.cis.upenn.edu/~KeyKOS/NanoKernel/NanoKernel.html ''The KeyKOS NanoKernel Architecture'']. It was a sardonic response to [[Mach (kernel)|Mach]], which claimed to be a microkernel while Shapiro considered it monolithic, essentially unstructured, and slower than the systems it sought to replace. Subsequent reuse of and response to the term, including the picokernel coinage, suggest that the point was largely missed. Both ''nanokernel'' and ''picokernel'' have subsequently come to have the same meaning expressed by the term microkernel.\n* A virtualization layer underneath an operating system, which is more correctly referred to as a [[hypervisor]].\n* A [[hardware abstraction layer]] that forms the lowest-level part of a kernel, sometimes used to provide [[Real-time computing|real-time]] functionality to normal operating systems, like [[Adaptive Domain Environment for Operating Systems|Adeos]].\n\nThere is also at least one case where the term nanokernel is used to refer not to a small kernel, but one that supports a [[nanosecond]] clock resolution.<ref name=\"udel\">{{cite web|url=http://www.eecis.udel.edu/~mills/database/papers/nano/nano2.pdf|date=28 November 2000|title=The Nanokernel|author=David L. Mills and Poul-Henning Kamp |accessdate=28 August 2017}}</ref>\n\n==See also==\n*[[Kernel (computer science)]]\n**[[Exokernel]]\n**[[Hybrid kernel]]\n**[[Loadable kernel module]]\n**[[Monolithic kernel]]\n*[[Tanenbaum–Torvalds debate]]\n*[[Trusted computing base]]\n*[[Unikernel]]\n\n== References ==\n{{Reflist|30em}}\n\n==Further reading==\n* [http://citeseerx.ist.psu.edu/search?q=microkernel Scientific articles about microkernels] (on [[CiteSeerX]]), including:\n** {{cite journal | author=   Dan Hildebrand|title=An Architectural Overview of QNX|journal=Proceedings of the Workshop on Micro-kernels and Other Kernel Architectures  | year=1992 |   pages=113–126 | isbn=   1-880446-42-1 |citeseerx=10.1.1.459.4481}} – the basic QNX reference.\n** {{cite journal | title=Can We Make Operating Systems Reliable and Secure? | author=Tanenbaum, A., Herder, J. and Bos, H.| journal = Computer|date=May 2006 | url = http://www.computer.org/portal/site/computer/menuitem.eb7d70008ce52e4b0ef1bd108bcd45f3/index.jsp?&pName=computer_level1&path=computer/homepage/0506&file=cover1.xml&xsl=article.xsl |pages = 44–51 | doi=10.1109/MC.2006.156 | volume=39 | issue=5}} -the basic reliable reference.\n** {{cite journal |title=Microkernel Operating System Architecture and Mach | author=Black, D.L., Golub, D.B., Julin, D.P., Rashid, R.F., Draves, R.P., Dean, R.W., Forin, A., Barrera, J., Tokuda, H., Malan, G., and Bohman, D. |journal=Journal of Information Processing|volume=14 |date=March 1992 | issue=4}} – the basic Mach reference.\n* *{{cite journal | magazine=Byte | date=January 1994 | title=Small Kernels Hit It Big | first=Peter D. | last=Varhol | url=http://www.byte.com:80/art/9401/sec8/art2.htm | deadurl=yes | archiveurl=https://web.archive.org/web/20060307075538/http://www.byte.com/art/9401/sec8/art2.htm | archivedate=7 March 2006 | accessdate=September 20, 2017 | df=dmy-all }} An assessment of the present and future state of microkernel based OSes as of January 1994\n* [http://c2.com/cgi/wiki?MicroKernel MicroKernel page] from the [[Portland Pattern Repository]]\n* The [[Tanenbaum–Torvalds debate]]\n** [http://www.oreilly.com/catalog/opensources/book/appa.html The Tanenbaum-Torvalds Debate, 1992.01.29]\n** Tanenbaum, A. S. \"[http://www.computer.org/csdl/mags/co/2006/05/r5044-abs.html Can We Make Operating Systems Reliable and Secure?]\".\n** Torvalds, L. [http://www.realworldtech.com/forums/index.cfm?action=detail&id=66630&threadid=66595&roomid=11 Linus Torvalds about the microkernels again, 2006.05.09]\n** Shapiro, J. \"[https://web.archive.org/web/20160922022726/http://www.coyotos.org/docs/misc/linus-rebuttal.html Debunking Linus's Latest]\".\n** Tanenbaum, A. S. \"[http://www.cs.vu.nl/~ast/reliable-os/ Tanenbaum-Torvalds Debate: Part II]\".\n\n{{Microkernel}}\n{{Operating system}}\n{{Use dmy dates|date=October 2012}}\n\n{{Authority control}}\n\n[[Category:Microkernels]]\n\n[[fr:Noyau de système d'exploitation#Systèmes à micro-noyaux]]\n[[it:Kernel#Microkernel]]\n[[fi:Käyttöjärjestelmän ydin#Mikroydin]]",
            "slug": "microkernel",
            "date_updated": 1519557674215,
            "imported": "https://en.wikipedia.org/wiki/Microkernel"
        }
    ]
}