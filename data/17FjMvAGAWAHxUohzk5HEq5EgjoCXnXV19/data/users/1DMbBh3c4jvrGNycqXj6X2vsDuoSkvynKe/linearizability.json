{
    "article": [
        {
            "title": "Linearizability",
            "text": "{{more footnotes|date=December 2010}}\n\nIn [[concurrent programming]], an operation (or set of operations) is '''atomic''', '''linearizable''', '''indivisible''' or '''uninterruptible''' if it appears to the rest of the system to occur at once without being interrupted. Atomicity is a guarantee of [[Isolation (computer science)|isolation]] from [[interrupt]]s, [[Signal (IPC)|signals]], [[Concurrency (computer science)|concurrent]] [[Process (computing)|processes]] and [[Thread (computing)|threads]].  It is relevant for [[thread safety]] and [[Reentrancy (computing)|reentrancy]]. Additionally, atomic operations commonly have a [[Atomicity (database systems)|succeed-or-fail]] definition—they either successfully change the state of the system, or have no apparent effect.\n\nIn a concurrent system, processes can access a shared object at the same time. Because multiple processes are accessing a single object, there may arise a situation in which while one process is accessing the object, another process changes its contents. This example demonstrates the need for linearizability. In a linearizable system although operations overlap on a shared object, each operation appears to take place instantaneously. Linearizability is a strong correctness condition, which constrains what  outputs are possible when an object is accessed by multiple processes concurrently. It is a safety property which ensures that operations do not complete in an unexpected or unpredictable manner. If a system is linearizable it allows a programmer to reason about the system.<ref>{{Cite journal|last=Shavit, Nir and Taubenfel,Gadi|year=2016|title=The Computability of Relaxed Data Structures: Queues and Stacks as Examples|url=http://www.faculty.idc.ac.il/gadi/MyPapers/2015ST-RelaxedDataStructures.pdf|journal=Distributed Computing|volume=29|pages=396–407|via=}}</ref>\n\nAtomicity is often enforced by [[mutual exclusion]], whether at the hardware level building on a [[cache coherency]] protocol, or the software level using [[Semaphore (programming)|semaphores]] or [[Lock (computer science)|locks]]. Thus, an atomic operation does not necessarily ''actually'' occur instantaneously. The benefit comes from the ''appearance'': the system behaves ''as if'' each operation occurred instantly, separated by pauses. This makes the system consistent. Because of this, implementation details may be ignored by the user, except insofar as they affect performance. If an operation is not atomic, the user will also need to understand and cope with sporadic extraneous behaviour caused by interactions between concurrent operations, which by their nature are likely to be hard to reproduce and debug.\n\n== History of linearizability ==\nLinearizability was first introduced as a [[consistency model]] by [[Maurice Herlihy|Herlihy]] and [[Jeannette Wing|Wing]] in 1987. It encompassed more restrictive definitions of atomic, such as \"an atomic operation is one which cannot be (or is not) interrupted by concurrent operations\", which are usually vague about when an operation is considered to begin and end.\n\nAn atomic object can be understood immediately and completely from its sequential definition, as a set of operations run in parallel which always appear to occur one after the other; no inconsistencies may emerge. Specifically, linearizability guarantees that the [[Invariant (computer science)|invariants]] of a system are ''observed'' and ''preserved'' by all operations: if all operations individually preserve an invariant, the system as a whole will.\n\n== Definition of linearizability ==\nA concurrent system consists of a collection of processes communicating through shared data structures or objects. Linearizability is important in these concurrent systems where objects may be accessed by multiple processes at the same time and a programmer needs to be able to reason about the expected results. An execution of a concurrent system results in a ''history'', an ordered sequence of completed operations.\n\nA ''history'' is a sequence of ''invocations'' and ''responses'' made of an object by a set of [[Thread (computer science)|threads]] or processes. An invocation can be thought of as the start of an operation, and the response being the signaled end of that operation. Each invocation of a function will have a subsequent response. This can be used to model any use of an object. Suppose, for example, that two threads, A and B, both attempt to grab a lock, backing off if it's already taken. This would be modeled as both threads invoking the lock operation, then both threads receiving a response, one successful, one not.\n\n{| border=\"1\" cellspacing=\"0\"\n| A invokes ''lock''\n| B invokes ''lock''\n| A gets \"failed\" response\n| B gets \"successful\" response\n|}\n\nA ''sequential'' history is one in which all invocations have immediate responses, that is the invocation and response are considered to take place instantaneously. A sequential history should be trivial to reason about, as it has no real concurrency; the previous example was not sequential, and thus is hard to reason about. This is where linearizability comes in.\n\nA history σ is ''linearizable'' if there is a linear order of the completed operations such that:\n# For every completed operation in σ, the operation returns the same result in the execution as the operation would return if every operation was completed one by one in order σ.\n# If an operation op<small>1</small> completes (gets a response) before op2 begins (invokes), then op<small>1</small> precedes op<small>2</small> in σ.<ref name=\":0\">{{Cite journal|author1=Herlihy, Maurice P.  |author2=Wing, Jeannette M.|year=1990|title=Linearizability: A Correctness Condition for Concurrent Objects|url=|journal=ACM Transactions on Programming Languages and Systems (TOPLAS)|volume=12| issue = 3|pages=463–492|via=}}</ref>\nIn other words:\n* its invocations and responses can be reordered to yield a sequential history;\n* that sequential history is correct according to the sequential definition of the object;\n* if a response preceded an invocation in the original history, it must still precede it in the sequential reordering.\n\n(Note that the first two bullet points here match [[serializability]]: the operations appear to happen in some order. It is the last point which is unique to linearizability, and is thus the major contribution of Herlihy and Wing.)<ref name=\":0\" />\n\nLet us look at two ways of reordering the locking example above.\n\n{| border=\"1\" cellspacing=\"0\"\n| A invokes ''lock''\n| A gets \"failed\" response\n| B invokes ''lock''\n| B gets \"successful\" response\n|}\n\nReordering B's invocation below A's response yields a sequential history. This is easy to reason about, as all operations now happen in an obvious order. Unfortunately, it doesn't match the sequential definition of the object (it doesn't match the semantics of the program): A should have successfully obtained the lock, and B should have subsequently aborted.\n\n{| border=\"1\" cellspacing=\"0\"\n| B invokes ''lock''\n| B gets \"successful\" response\n| A invokes ''lock''\n| A gets \"failed\" response\n|}\n\nThis is another correct sequential history. It is also a linearization! Note that the definition of linearizability only precludes responses that precede invocations from being reordered; since the original history had no responses before invocations, we can reorder it as we wish. Hence the original history is indeed linearizable.\n\nAn object (as opposed to a history) is linearizable if all valid histories of its use can be linearized. Note that this is a much harder assertion to prove.\n\n=== Linearizability versus serializability ===\nConsider the following history, again of two objects interacting with a lock:\n\n{| border=\"1\" cellspacing=\"0\"\n| A invokes lock\n| A successfully locks\n| B invokes unlock\n| B successfully unlocks\n| A invokes unlock\n| A successfully unlocks\n|}\n\nThis history is not valid because there is a point at which both A and B hold the lock; moreover, it cannot be reordered to a valid sequential history without violating the ordering rule. Therefore, it is not linearizable. However, under serializability, B's unlock operation may be moved to ''before'' A's original lock, which is a valid history (assuming the object begins the history in a locked state):\n\n{| border=\"1\" cellspacing=\"0\"\n| B invokes unlock\n| B successfully unlocks\n| A invokes lock\n| A successfully locks\n| A invokes unlock\n| A successfully unlocks\n|}\n\nWhile weird, this reordering is sensible provided there is no alternative means of communicating between A and B. Linearizability is better when considering individual objects separately, as the reordering restrictions ensure that multiple linearizable objects are, considered as a whole, still linearizable.\n\n=== Linearization points ===\nThis definition of linearizability is equivalent to the following:\n* All function calls have a ''linearization point'' at some instant between their invocation and their response.\n* All functions appear to occur instantly at their linearization point, behaving as specified by the sequential definition.\n\nThis alternative is usually much easier to prove. It is also much easier to reason about as a user, largely due to its intuitiveness. This property of occurring instantaneously, or indivisibly, leads to the use of the term ''atomic'' as an alternative to the longer \"linearizable\".<ref name=\":0\" />\n\nIn the examples above, the linearization point of the counter built on compare-and-swap is the linearization point of the first (and only) successful compare-and-swap update. The counter built using locking can be considered to linearize at any moment while the locks are held, since any potentially conflicting operations are excluded from running during that period.\n\n== Primitive atomic instructions ==\nProcessors have [[Instruction (computer science)|instructions]] that can be used to implement [[Lock (computer science)|locking]] and [[lock-free and wait-free algorithms]]. The ability to temporarily inhibit [[interrupt]]s, ensuring that the currently running [[Process (computing)|process]] cannot be [[context switch]]ed, also suffices on a [[uniprocessor]]. These instructions are used directly by compiler and operating system writers but are also abstracted and exposed as bytecodes and library functions in higher-level languages:\n* atomic read-write;\n* [[atomic swap]] (the RDLK instruction in some [[Burroughs large systems#Multiple processors|Burroughs mainframes]], and the XCHG [[x86 instruction listings|x86 instruction]]);\n* [[test-and-set]];\n* [[fetch-and-add]];\n* [[compare-and-swap]];\n* [[load-link/store-conditional]].\n\nMost{{citation needed|date=December 2015}} [[central processing unit|processors]] include  store operations that are not atomic with respect to memory. These include multiple-word stores and string operations. Should a high priority interrupt occur when a portion of the store is complete, the operation must be completed when the interrupt level is returned. The routine that processes the interrupt must not access the memory being changed. It is important to take this into account when writing interrupt routines.\n\nWhen there are multiple instructions which must be completed without interruption, a CPU instruction which temporarily disables interrupts is used. This must be kept to only a few instructions and the interrupts must be re-enabled to avoid unacceptable response time to interrupts or even losing interrupts. This mechanism is not sufficient in a multi-processor environment since each CPU can interfere with the process regardless of whether interrupts occur or not. Further, in the presence of an [[instruction pipeline]], uninterruptible operations present a security risk, as they can potentially be chained in an [[infinite loop]] to create a [[denial of service attack]], as in the [[Cyrix coma bug]].\n\nThe [[C programming language|C standard]] and [[SUSv3]] provide <code>sig_atomic_t</code> for simple atomic reads and writes; incrementing or decrementing is not guaranteed to be atomic<ref>https://books.google.de/books?id=2SAQAQAAQBAJ&pg=PA428</ref>. More complex atomic operations are available in [[C11 (C standard revision)|C11]], which provides <code>stdatomic.h</code>.\n\nThe [[ARM architecture|ARM instruction set]] provides <code>LDREX</code> and <code>STREX</code> instructions which can be used to implement atomic memory access by using [[Monitor (synchronization)|exclusive monitors]] implemented in the processor to track memory accesses for a specific address.<ref>{{cite web|title=ARM Synchronization Primitives Development Article|url=https://developer.arm.com/products/architecture/a-profile/docs/dht0008/latest/1-arm-synchronization-primitives}}</ref>  However, if a context switch occurs between calls to <code>LDREX</code> and <code>STREX</code>, the documentation notes that <code>STREX</code> will fail, indicating the operation should be retried.\n\n== High-level atomic operations ==\nThe easiest way to achieve linearizability is running groups of primitive operations in a [[critical section]]. Strictly, independent operations can then be carefully permitted to overlap their critical sections, provided this does not violate linearizability. Such an approach must balance the cost of large numbers of [[lock (computer science)|locks]] against the benefits of increased parallelism.\n\nAnother approach, favoured by researchers (but not yet widely used in the software industry), is to design a linearizable object using the native atomic primitives provided by the hardware. This has the potential to maximise available parallelism and minimise synchronisation costs, but requires mathematical proofs which show that the objects behave correctly.\n\nA promising hybrid of these two is to provide a [[transactional memory]] abstraction. As with critical sections, the user marks sequential code that must be run in isolation from other threads. The implementation then ensures the code executes atomically. This style of abstraction is common when interacting with databases; for instance, when using the [[Spring Framework]], annotating a method with @Transactional will ensure all enclosed database interactions occur in a single [[database transaction]]. Transactional memory goes a step further, ensuring that all memory interactions occur atomically. As with database transactions, issues arise regarding composition of transactions, especially database and in-memory transactions.\n\nA common theme when designing linearizable objects is to provide an all-or-nothing interface: either an operation succeeds completely, or it fails and does nothing. ([[ACID]] databases refer to this principle as [[Atomicity (database systems)|atomicity]].) If the operation fails (usually due to concurrent operations), the user must retry, usually performing a different operation. For example:\n* [[Compare-and-swap]] writes a new value into a location only if the latter's contents matches a supplied old value. This is commonly used in a read-modify-CAS sequence: the user reads the location, computes a new value to write, and writes it with a CAS (compare-and-swap); if the value changes concurrently, the CAS will fail and the user tries again.\n* [[Load-link/store-conditional]] encodes this pattern more directly: the user reads the location with load-link, computes a new value to write, and writes it with store-conditional; if the value has changed concurrently, the SC (store-conditional) will fail and the user tries again.\n* In a [[database transaction]], if the transaction cannot be completed due to a concurrent operation (e.g. in a [[deadlock]]), the transaction will be aborted and the user must try again.\n\n== Examples of Linearizability ==\n\n=== Counters ===\nTo demonstrate the power and necessity of Linearizability we will consider a simple counter which different processes can increment.\n\nWe would like to implement a counter object which multiple processes can access. Many common systems make use of counters to keep track of the number of times an event has occurred.\n\nThe counter object can be accessed by multiple processes and has two available operations.\n# Increment - adds 1 to the value stored in the counter, return acknowledgement\n# Read - returns the current value stored in the counter without changing it.\nWe will attempt to implement this counter object using [[Shared register]]<nowiki/>s\n\nOur first attempt which we will see is non-linearizable has the following implementation using one Shared Register among the processes.\n\n==== Non-atomic ====\nThe naive, non-atomic implementation:\n\n'''Increment:'''\n# read the value in the register R\n# add one to the value\n# writes the new value back into register R\n'''Read:'''\n\nread Register R\n\nThis simple implementation is not linearizable, as is demonstrated by the following example.\n\nImagine two processes are running accessing the single counter object initialized to have value 0:\n# the first process reads the value in the register as 0\n# the first process adds one to the value, the counter's value should be 1\nbut before it has finished writing the new value back to the register it may become suspended, meanwhile the second process is running:\n# the second process reads the value in the register, which is still equal to 0;\n# the second process adds one to the value;\n# the second process writes the new value into the register, the register now has value 1.\nThe second process is finished running and the first process continues running from where it left off:\n# the first process writes 1 into the register, unaware that the other process has already updated the value in the register to 1.\nIn the above example, two processes invoked an increment command, however the value of the object only increased from 0 to 1, instead of 2 as it should have. One of the increment operations was lost as a result of the system not being linearizable.\n\nThe above example shows the need for carefully thinking through implementations of data structures and how Linearizability can have an effect on the correctness of the system.\n\n==== Atomic ====\nTo implement a Linearizable or Atomic Counter object we will modify our previous implementation so each Process P<small>i</small> will use its own Register R<small>i</small>\n\nEach process Increments and Reads according to the following algorithm:\n\n'''Increment:'''\n# read value in Register R<small>i</small>\n# add one to the value\n# write new value back into R<small>i</small>\n'''Read:'''\n# read Registers R<small>1,</small> R<small>2, ...</small> R<small>n</small>\n# return sum of all registers\nThis implementation solves the problem with our original implementation. In this system the increment operations are linearized at the write step. The Linearization point of an increment operation is when that operation writes the new value in its Register R<small>i.</small> The Read operations are linearized to a point in the system when the value returned by the Read is equal to the sum of all the values stored in each Register R<small>i .</small>\n\nThis is a trivial example. In a real system, the operations can be more complex and the errors introduced extremely subtle. For example, reading a [[64-bit]] value from memory may actually be implemented as two [[sequence|sequential]] reads of two [[32-bit]] memory locations. If a process has only read the first 32&nbsp;bits, and before it reads the second 32&nbsp;bits the value in memory gets changed, it will have neither the original value nor the new value but a mixed-up value.\n\nFurthermore, the specific order in which the processes run can change the results, making such an error difficult to detect, reproduce and [[debug]].\n\n=== Compare-and-swap ===\n{{Main|Compare-and-swap}}\nMost systems provide an atomic compare-and-swap instruction that reads from a memory location, compares the value with an \"expected\" one provided by the user, and writes out a \"new\" value if the two match, returning whether the update succeeded. We can use this to fix the non-atomic counter algorithm as follows:\n\n:# read the value in the memory location;\n:# add one to the value;\n:# use compare-and-swap to write the incremented value back;\n:# retry if the value read in by the compare-and-swap did not match the value we originally read.\n\nSince the compare-and-swap occurs (or appears to occur) instantaneously, if another process updates the location while we are in-progress, the compare-and-swap is guaranteed to fail.\n\n=== Fetch-and-increment ===\n{{Main|Fetch-and-increment}}\nMany systems provide an atomic fetch-and-increment instruction that reads from a memory location, unconditionally writes a new value (the old value plus one), and returns the old value.\nWe can use this to fix the non-atomic counter algorithm as follows:\n\n:# Use fetch-and-increment to read the old value and write the incremented value back.\n\nUsing fetch-and increment is always better (requires fewer memory references) for some algorithms—such as the one shown here—than compare-and-swap,<ref name=\"cond-sync\">{{cite book| last1=Fich | first1=Faith | title=Proceedings of the twenty-third annual ACM symposium on Principles of distributed computing – PODC '04 | last2=Hendler | first2=Danny | last3=Shavit | first3=Nir | year=2004 | publisher=ACM | location=New York, NY | pages=80–87 | isbn=1-58113-802-4 | url=http://doi.acm.org/10.1145/1011767.1011780|doi=10.1145/1011767.1011780| chapter=On the inherent weakness of conditional synchronization primitives }}</ref> even though Herlihy earlier proved that compare-and-swap is better for certain other algorithms that can't be implemented at all using only fetch-and-increment.\nSo [[CPU design]]s with both fetch-and-increment and compare-and-swap (or equivalent instructions) may be a better choice than ones with only one or the other.<ref name=\"cond-sync\" />\n\n=== Locking ===\n{{Main|Lock (computer science)}}\nAnother approach is to turn the naive algorithm into a [[critical section]], preventing other threads from disrupting it, using a [[lock (computer science)|lock]]. Once again fixing the non-atomic counter algorithm:\n\n:# acquire a lock, excluding other threads from running the critical section (steps 2-4) at the same time;\n:# read the value in the memory location;\n:# add one to the value;\n:# write the incremented value back to the memory location;\n:# release the lock.\n\nThis strategy works as expected; the lock prevents other threads from updating the value until it is released. However, when compared with direct use of atomic operations, it can suffer from significant overhead due to lock contention. To improve program performance, it may therefore be a good idea to replace simple critical sections with atomic operations for [[non-blocking synchronization]] (as we have just done for the counter with compare-and-swap and fetch-and-increment), instead of the other way around, but unfortunately a significant improvement is not guaranteed and lock-free algorithms can easily become too complicated to be worth the effort.\n\n== See also ==\n* [[Atomicity (database systems)|Atomic transaction]]\n* [[Consistency model]]\n* [[ACID]]\n* [[Read-copy-update]] (RCU)\n* [[Read-modify-write]]\n* [[Time of check to time of use]]\n\n== References ==\n{{reflist}}\n\n== Further reading ==\n* {{cite journal | doi=10.1145/41625.41627 | title=Axioms for Concurrent Objects | year=1987 | last1=Herlihy | first1=Maurice P. | last2=Wing | first2=Jeannette M. | journal=Proceedings of the 14th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, POPL '87 | pages=13 | isbn=0-89791-215-2}}\n* {{cite journal | doi=10.1145/99164.99185 | title=A Methodology for Implementing Highly Concurrent Data Structures | year=1990 | last1=Herlihy | first1=Maurice P. | journal=ACM SIGPLAN Notices | volume=25 | issue=3 | pages=197–206 | isbn=0-89791-350-7}}\n* {{cite journal | doi=10.1145/78969.78972 | title=Linearizability: A Correctness Condition for Concurrent Objects | year=1990 | last1=Herlihy | first1=Maurice P. | last2=Wing | first2=Jeannette M. | journal=ACM Transactions on Programming Languages and Systems | volume=12 | issue=3 | pages=463–492}}\n\n[[Category:Consistency models]]\n[[Category:Transaction processing]]\n[[Category:Concurrency control]]",
            "slug": "linearizability",
            "date_updated": 1520462766462,
            "imported": "https://en.wikipedia.org/wiki/Linearizability"
        }
    ]
}