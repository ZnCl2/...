<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2F138ZnY9PP55pxgiaxGfdCaW7AKeVmj1TmM%2F2017%2F12%2F18%2Flinux%2Fnginx%2F</url>
    <content type="text"><![CDATA[Nginx 安装ubuntu 系统安装 nginx1sudo apt-get install nginx 编译安装123./configuremakesudo make install 编译参数12345678910111213141516171819./configure \--user=nginx \--group=nginx \--prefix=/etc/nginx \--sbin-path=/usr/sbin/nginx \--conf-path=/etc/nginx/nginx.conf \--pid-path=/var/run/nginx.pid \--lock-path=/var/run/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--with-http_stub_status_module \--with-http_ssl_module \--with-pcre \--with-file-aio \--with-http_realip_module \--without-http_scgi_module \--without-http_uwsgi_module \--without-http_fastcgi_module more 基本操作启动(start)、重启(restart)，停止(stop) nginx1234567sudo /etc/init.d/nginx restart# orsudo service nginx restart# reloadsudo nginx -s reload 配置文件语法nginx 是模块化的系统 通过configure的参数编译可以配置模块 http_gzip_static_module负责压缩，http_ssl_module负责加密 …… 整个配置文件都是由指令来控制, events, http, server, 和 location等 配置文件 /etc/nginx/nginx.conf ， nginx -t 显示 主配置文件:12345678910111213141516171819202122232425262728user www-data;worker_processes 1;pid /run/nginx.pid;events &#123; worker_connections 768;&#125;http &#123; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; gzip on; gzip_disable &quot;msie6&quot;; include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;&#125; 指令和指令之间是有层级和继承关系的, 如 http 内的指令会影响到 server 的 假如要部署一个web服务, 在/etc/nginx/conf.d/目录下新增一个文件即可 http 和 events 还有 mail 是同级 一个简单的配置：12345678server &#123; listen 80; root /home/yinsigan/foo; server_name foo.bar.com; location / &#123; &#125;&#125; listen 监听的端口root 网站根目录server_name 指定域名 稍微详细的配置：1234567891011121314151617181920server &#123; listen 80; server_name example.org www.example.org; root /data/www; location / &#123; index index.html index.php; &#125; location ~* \.(gif|jpg|png)$ &#123; expires 30d; &#125; location ~ \.php$ &#123; fastcgi_pass localhost:9000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 访问 http://example.org , 读取/var/root/index.html , 找不到就会读取index.php , 转发到 fastcgi_pass 里面的逻辑 访问 http://example.org/about.gif , 读取/var/root/about.gif ，缓存30天。 反向代理最简单的反向代理反向代理依赖于ngx_http_proxy_module这个module 反向代理服务器能代理的请求的协议包括http(s)，FastCGI，SCGI，uwsgi，memcached等 把 https 协议的图片请求反向代理到 http 协议的真实图片上https协议的图片是不存在，而它有一个地址实际指向的内容是 http 协议中的图片。 12345678# httpsserver &#123; server_name www.example.com; listen 443; location /newchart/hollow/small/nsh000001.gif &#123; proxy_pass http://image.sinajs.cn/newchart/hollow/small/nsh000001.gif; &#125;&#125; 动态转发…… gzip压缩需要nginx已经有编译过ngx_http_gzip_module 压缩是需要消耗CPU，但能提高传缩的速度 使用是否编译了ngx_http_gzip_module sudo nginx -V 输出 --with-ngx_http_gzip_module ok 配置nginx的gzip: 123456789101112131415161718http &#123; gzip on; gzip_disable &quot;msie6&quot;; gzip_vary on; gzip_proxied any; gzip_comp_level 6; gzip_buffers 16 8k; gzip_http_version 1.1; gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; server &#123; location ~ ^/assets/ &#123; gzip_static on; expires max; add_header Cache-Control public; &#125; &#125;&#125; 最重要的是 http 中 gzip on 、gzip_types gzip_vary 等都是一些配置 在需要压缩的静态资源那里加上 gzip_static on; expires max; add_header Cache-Control public; sudo nginx -s reload 重新加载生效 Content-Encoding: gzip 成功 搭建Google镜像]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker and ownCloud]]></title>
    <url>%2F138ZnY9PP55pxgiaxGfdCaW7AKeVmj1TmM%2F2017%2F12%2F17%2Flinux%2Fdocker_owncloud%2F</url>
    <content type="text"><![CDATA[Docker ownCloud 安装Docker安装内核模块包12345$ sudo apt-get update$ sudo apt-get install \ linux-image-extra-$(uname -r) \ linux-image-extra-virtual 使用 APT 镜像源 安装添加使用 HTTPS 传输的软件包以及 CA 证书1234567$ sudo apt-get update$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 添加软件源的 GPG 密钥1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 向 source.list 中添加 Docker 软件源1234$ sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" 安装 Docker CE更新 apt 软件包缓存，并安装 docker-ce：123$ sudo apt-get update$ sudo apt-get install docker-ce 启动 Docker CE12$ sudo systemctl enable docker$ sudo systemctl start docker 测试 Docker 是否安装正确12345$ docker run hello-worldUnable to find image 'hello-world:latest' locally......Hello from Docker! ...... 有如上输入则代表安装成功 配置 docker-compose下载最新版本的Docker Compose1$ sudo curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 检查最新版本，版本号自行更改 对二进制文件应用可执行权限1$ sudo chmod +x /usr/local/bin/docker-compose 测试12$ docker-compose --versiondocker-compose version 1.17.0, build 1719ceb 编写配置 docker-compose.yml123456789101112131415161718192021version: '2'services: owncloud: image: owncloud links: - mysql:mysql volumes: - "/data/db/owncloud/data:/var/www/html/data" - "/data/db/owncloud/config:/var/www/html/config" - "/data/db/owncloud/apps:/var/www/html/apps" ports: - 8000:80 mysql: image: mysql volumes: - "/data/db/mysql:/var/lib/mysql" ports: - 3306:3306 environment: MYSQL_ROOT_PASSWORD: "password" MYSQL_DATABASE: ownCloud docker-compose 运行和停止docker-compose 必须在 docker-compose.yml 文件所在目录中执行 123456789101112docker-compose 后台启动$ docker-compose up -ddocker-compose 查看状态$ docker-compose psdocker-compose 停止和删除$ docker-compose stop$ dcoker-compose rm相当上面两条命令$ dcoker-compose down 启动并配置 owncloud1$ docker-compose up -d 数据库用户：root数据库密码：password数据库名：owncloud数据库主机：mysql]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javascript Object]]></title>
    <url>%2F138ZnY9PP55pxgiaxGfdCaW7AKeVmj1TmM%2F2017%2F12%2F16%2Fjavascript_obj%2F</url>
    <content type="text"><![CDATA[Javascript Object Object属性类型ECMAScript中有两种属性：数据属性和访问器属性。 数据属性 [[Configurable]]：表示能否通过 delete 删除属性从，能否修改属性的特性，能否把属性修改为访问器属性，默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性，默认值为 true。 [[Writable]]：表示能否修改属性的值，默认值为 true。 [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候， 把新值保存在这个位置。默认值为 undefined。 直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]] 和[[Writable]]特性都被设置为 true，而[[Value]]特性被设置为指定的值。 修改属性默认的特性，必须使用 ECMAScript 5的 [Object.defineProperty()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)方法。 访问器属性访问器属性不包含数据值；它们包含一对 getter和 setter函数 [[Configurable]]：表示能否通过 delete 删除属性，能否修改属性的特性，能否把属性修改为数据属性。直接在对象上定义的属性默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。直接在对象上定义的属性默认值为 true。 [[Get]]：在读取属性时调用的函数。默认值为 undefined。 [[Set]]：在写入属性时调用的函数。默认值为 undefined 访问器属性不能直接定义，必须使用 Object.defineProperty()来定义。 定义多个属性Object.defineProperties()方法。可以通过描述符一次定义多个属性。 读取属性特性Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。 Object.defineProperty() Object.defineProperty(obj, prop, descriptor) 在调用 Object.defineProperty()方法时，如果不指定，configurable、enumerable 和 writable 特性的默认值都是 false。 参数 obj 要在其上定义属性的对象。Object prop 要定义或修改的属性的名称。String descriptor 将被定义或修改的属性描述符。Object 返回被传递给函数的对象。 描述描述符必须是数据属性和访问器属性之一，不能同时是两者。 选项不一定是自身属性，如果是继承来的也要考虑。为了确认保留这些默认值，可能要在这之前冻结 Object.prototype，明确指定所有的选项，或者将__proto__属性指向null。 Object.assign() Object.assign(target, …sources) 参数 target 目标对象。 sources 源对象。 返回值目标对象 描述目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。 针对深拷贝，Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。 继承属性和不可枚举属性是不能拷贝的。 拷贝访问器12345678910111213141516171819// 下面这个函数会拷贝所有自有属性的属性描述符function completeAssign(target, ...sources) &#123; sources.forEach(source =&gt; &#123; let descriptors = Object.keys(source).reduce((descriptors, key) =&gt; &#123; descriptors[key] = Object.getOwnPropertyDescriptor(source, key); return descriptors; &#125;, &#123;&#125;); // Object.assign 默认也会拷贝可枚举的Symbols Object.getOwnPropertySymbols(source).forEach(sym =&gt; &#123; let descriptor = Object.getOwnPropertyDescriptor(source, sym); if (descriptor.enumerable) &#123; descriptors[sym] = descriptor; &#125; &#125;); Object.defineProperties(target, descriptors); &#125;); return target;&#125; Object.create()1234Object.create(null)// &#123;&#125;// 返回一个没有原型的空对象]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javascript five chess]]></title>
    <url>%2F138ZnY9PP55pxgiaxGfdCaW7AKeVmj1TmM%2F2017%2F09%2F22%2Fjavascript_five_chess%2F</url>
    <content type="text"><![CDATA[简单的 Javascript 五子棋 Demo. Dome: gk5.me/javascript-five-chess/index.htmlGithub repository: github.com/helloAwei/javascript-five-chess 简介 实现胜负判断，并给出赢棋提示。 界面用 DOM 实现 实现悔棋 前端用的是 Knockout 做双向绑定。 思路：用一个二维数组生成棋盘，对格子添加点击事件，用一个布尔值进行切换黑白轮流落子，落子后对当前棋子进行胜负判断 … 生成二维数组12345678910111213141516function GeneratorList() &#123; let array = new Array(ROW).fill(null); //生成二维数组 let result = array.map((value, y) =&gt; &#123; return array.map((value, x) =&gt; &#123; return &#123; hasChess: ko.observable(false), value: ko.observable(null), x: x, y: y &#125; &#125;); &#125;); return result;&#125; 生成一个 15*15 的二维数组，List[y][x]能取到对应格子的状态。初始的状态为：123456&#123; hasChess: ko.observable(false), //是否有棋子 value: ko.observable(null), //棋子的值（黑或白） x: x, //坐标 y: y&#125; 这里没有单独去定义一个棋子类，直接用的字面量形式。 落子12345678910111213141516171819ViewModel.prototype.down = function (data) &#123; if (data.hasChess()) return; if (this.winer()) this.rePlay(); // change data.hasChess(true); data.value(this.isBlack() ? 'X' : 'O'); // add history this.history.push(&#123; x: data.x, y: data.y &#125;); //判断输赢 this.referee(data); //换手 this.isBlack(!this.isBlack());&#125; 落子前进行判断，落子，然后添加一条历史记录，判断输赢，换手。。。 判断输赢的算法1234567891011121314151617181920ViewModel.prototype.referee = function (item) &#123; //四个方向 let change = [[0, -1], [-1, 0], [-1, -1], [1, -1]]; change.forEach(c =&gt; &#123; //朝某个方向递归 this.test(item, c); //不足五连珠朝反方向递归 if (this.lineTotal &lt;= 4) &#123; //反方向 let reveis = c.map(x =&gt; &#123; return x * -1; &#125;); this.test(item, reveis) this.lineTotal = 0 &#125;; &#125;)&#125; 判断胜负需要检查一个棋子的八个方向上有无五连珠的情况。 change是一个保存了四个检查方向的二维数组。在朝某个方向检查完之后然后反向的检查，这样能够将八个方向缩减为四个。例： 1、2、3、4 反向后对应 5、6、7、8 如果某个方向不满足五连珠的情况（代码中为&lt;=4，因为检查不包括本身），则向反向的方向进行检查。 下面是一个递归检查的方法：1234567891011121314151617181920212223242526//判断连子ViewModel.prototype.test = function (item, change, total = 0) &#123; let cx = item.x + change[0]; let cy = item.y + change[1]; let isInBoard = (cx &gt;= 0 &amp;&amp; cx &lt;= ROW - 1) &amp;&amp; (cy &gt;= 0 &amp;&amp; cy &lt;= ROW - 1); let cItem = isInBoard &amp;&amp; this.allBoxs()[cy][cx]; let isNull = cItem !== null; if (isNull &amp;&amp; isInBoard &amp;&amp; item.value() === cItem.value() ) &#123; total += 1; //递归 this.test(cItem, change, total); &#125; else &#123; //跳出 this.lineTotal += total; &#125; //win if (this.lineTotal &gt;= 4) &#123; this.win(); &#125;;&#125; 直到下一个棋子不是与本身同类型的棋子便跳出递归，同时将total 返回。 完。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[About Js]]></title>
    <url>%2F138ZnY9PP55pxgiaxGfdCaW7AKeVmj1TmM%2F2017%2F08%2F16%2Fjavascript_trap%2F</url>
    <content type="text"><![CDATA[About Js. NumberNumber.toString()在js中，直接对数值类型调用 toString() 方法可能会报SyntaxError：1123.toString(); // SyntaxError 因为在js解析器中，会默认认为数值后面的第一个点是小数点 。。。 解决的办法：12345678123..toString();//'123'123.0.toString();//'123'(123).toString();//'123' ArrayArray 与 if()!![] 等于 true12if(!![])console.log('I\'m true');// I'm true 在 if() 判断中，会判断 () 的值是否为真值JavaScript 中假值总共只有6个：false 、 undefined 、 null 、 0、 NaN 、 &quot;&quot;（空字符串）除此之外的所有值，都是真值[] 为真值，所以 !![] 为真值。 延伸if([]) 与 if([] == true) 是不等价的if([])的含义：[] 是否为“真值”if([] == true) 的含义：[] 与 true 是否相等。 真值与 true不一定相等126 == true// false 因为在js中 true 是以数值 1 的形式存在的,6 虽然是真值但并不等于 true123451 == true// true'1' == true// true &#39;1&#39; 会被转换成 1 所以 &#39;1&#39; 也是等于 true forEach()forEach() 时无法退出循环：12345[1, 2, 3, 4, 5, 6, 7, 8, 9].forEach((el)=&gt;&#123; console.log(el); if (el &gt; 2) return;&#125;);// 1,2,3,4 ... 解决： 使用 some() 方法。 1234[1, 2, 3].some(function(el) &#123; console.log(el); return el === 2;&#125;); 抛出异常 12345678910var BreakException = &#123;&#125;;try &#123; [1, 2, 3].forEach(function(el) &#123; console.log(el); if (el === 2) throw BreakException; &#125;);&#125; catch (e) &#123; if (e !== BreakException) throw e;&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Js FP]]></title>
    <url>%2F138ZnY9PP55pxgiaxGfdCaW7AKeVmj1TmM%2F2017%2F08%2F15%2Fjavascript_fp%2F</url>
    <content type="text"><![CDATA[Js fp 代码的组合 Compose函数组合12345var compose = function(f,g) &#123; return function(x) &#123; return f(g(x)); &#125;;&#125;; f 和 g 都是函数，x 是在它们之间通过“管道”传输的值。在 compose 的定义中，g 将先于 f 执行，因此就创建了一个从右到左的数据流，称之为“左倾”。 组合的概念直接来自于结合律。123// 结合律（associativity）var associative = compose(f, compose(g, h)) == compose(compose(f, g), h);// true 组合的最佳实践是可重用。 pointfreepointfree 模式指的是：定义函数时不使用所要处理的值，只合成运算过程。1234567// 非 pointfree，因为提到了数据：wordvar snakeCase = function (word) &#123; return word.toLowerCase().replace(/\s+/ig, '_');&#125;;// pointfreevar snakeCase = compose(replace(/\s+/ig, '_'), toLowerCase); 范畴论有着以下这些组件（component）的搜集（collection）就构成了一个范畴： 对象 态射 态射的组合 identity 这个独特的态射 对象对象就是数据类型，例如 String、Boolean、Number 和 Object 等等。通常把数据类型视作所有可能的值的一个集合（set），然后可以利用集合论（set theory）处理类型。 态射态射是标准的、普通的纯函数。 态射的组合compose 函数是符合结合律的，结合律是在范畴学中对任何组合都适用的一个特性。 identity 的态射12345var id = function(x)&#123; return x; &#125;;// identitycompose(id, f) == compose(f, id) == f;// true 类型签名1234// capitalize :: String -&gt; Stringvar capitalize = function(s)&#123; return toUpperCase(head(s)) + toLowerCase(tail(s));&#125; capitalize 接受一个 String 并返回了一个 String。 1234// match :: Regex -&gt; String -&gt; [String]var match = curry(function(reg, s)&#123; return s.match(reg);&#125;); match 函数接受一个 Regex 和一个 String，返回一个 [String]。 函子 Functor函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。123456789class Functor &#123; constructor(x) &#123; this.__value = x; &#125;; map(f) &#123; return new Functor(f(this.__value)); &#125;;&#125; 函数式编程一般约定，函子有一个 of 方法，用来生成新的容器。123Functor.of = function(x) &#123; return new Functor(x)&#125;; 用法的示例。1234567891011const A = Functor.of(2);A.map(function (x) &#123; return x + 2;&#125;);// 4const B = Functor.of("flamethrowers");B.map(function (s) &#123; return s.toUpperCase();&#125;)//FLAMETHROWERS Maybe 函子函子接受各种函数，处理容器内部的值,外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。它的 map 方法里面设置了空值检查。12345class Maybe extends Functor &#123; map(f) &#123; return this.__value ? Maybe.of(f(this.__value)) : Maybe.of(null); &#125;&#125; Either 函子Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。1234567891011121314class Either extends Functor &#123; constructor(left, right) &#123; this.left = left; this.right = right; &#125; map(f) &#123; return this.right ? Either.of(f(this.right)) : Either.of(f(this.left)); &#125;&#125;Either.of = function (left, right) &#123; return new Either(left, right)&#125; 提供默认值。12345Either .of(&#123; address: 'xxx' &#125;, currentUser.address) .map(updateField); 代替try...catch。1234567function parseJSON(json) &#123; try &#123; return Either.of(null, JSON.parse(json)); &#125; catch (e: Error) &#123; return Either.of(e, null); &#125;&#125; ap 函子函子 A 内部的值是 2 ，函子 B 内部的值是函数addTwo。我们想让函子 B 内部的函数，可以使用函子 A 内部的值进行运算。这时就需要用到 ap 函子。凡是部署了 ap 方法的函子，就是 ap 函子。12345class Ap extends Functor&#123; ap(F)&#123; return Ap.of(this.__value(F.__value)) &#125;&#125; ap 方法的参数不是函数，而是另一个函子。 使用123456789101112Ap.of(addTwo).ap(Functor.of(2))// Ap(4)function add(x) &#123; return function (y) &#123; return x + y; &#125;;&#125;Ap.of(add).ap(Maybe.of(2)).ap(Maybe.of(3));// Ap(5)]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
</search>
