{
	"next_topic_id": 2,
	"topic": [
		{
			"topic_id": 1,
			"title": "Metodología -- Obtener passwords de redes WiFi",
			"body": "# 0: requirements\nTener `GNU/Linux` con drivers de placa de red _patcheados_ para poder inyectar paquetes. Mi recomendación es correr `Kali Linux`, una distribución que ya posee esto y las aplicaciones de la suite `aircrack-ng` además de otro montón de herramientas de _pentest_. Hasta donde entiendo, el asunto de _drivers patcheados_ depende de si queremos ejecutar la metodología 'activa' (aparece en el final del segundo paso y es optativa para ganar tiempo).\nSalvo el último paso, el primero y el segundo hay que hacerlos estando cerca del _target_ y para eso recomiendo usar cualquier netbook vieja (x86) o incluso una tablet (ARM) ya que si se opta por la metodología pasiva puede demorar horas/días y lo mejor es dejar todo ahí y olvidarse durante ese tiempo hasta que aparece en la pantalla `HANDSHAKE CAPTURED`. Eso es la información de la clave que básicamente circula encriptada por el aire y es lo que después pasaremos a _crackear_ (romper).\n\n# 1: airmon-ng\nHay que terminar todos los procesos que tengan en uso la placa de red (por ej. _NetworkManager_). Para eso corremos `airmon-ng check kill`. Luego, es necesario identificar el nombre de la interfaz con `ifconfig` (normalmente aparecen loopback y **wlan0**).\nPara cerrar estos primeros pasos, cabe mencionar que podemos utilizar `macchanger -r wlan0` para _spoofear_ la dirección MAC de nuestra placa y evitar ser identificados si elegimos algun método activo (es decir, enviamos paquetes hacia el _target_) hacia el final del segundo paso con el fin de acelerarlo.\nIniciamos la interfaz de placa de red en modo monitor con `airmon-ng start wlan0`. Se va a crear una nueva interfaz con el mismo nombre y el sufijo **mon** de monitor. Empezamos el scaneo de redes ahora con `airodump-ng --wps wlan0mon`. Idealmente vamos a buscar una red que tenga señal (PWR) mínima de **-75**. Una vez que hayamos elegido una fila lo mejor es parar el scaneo con `CTRL+C` para evitar que sigan moviéndose ya que están constantemente siendo ordenadas según su señal. Pueden probar distintos lugares para obtener mayor señal con cierto _target_. Entre los datos que proporciona cada columna lo que necesitamos es el _channel_ y la _BSSID del AP_, recomiendo anotarlos en algún papel. Elijan un _target_ fácil para empezar, el grado de vulnerabilidad en forma decreciente sería WPS > WEP >> WPA.\n\n# 2: airodump-ng\nPara terminar esta primera etapa, hay que ejecutar `airodump-ng -c $channel -w $nombre --bssid $APbssid wlan0mon` dónde las _$variables_ son estos datos que anotamos y $nombre es el prefijo usado para los archivos con info de _captura_ que se generarán (en el directorio de trabajo actual). Ahora queda esperar a juntar suficientes _beacons_, normalmente alcanza con un fin de semana entero y es algo que depende de muchas cosas pero principalmente será la señal (PWR) y el uso de la red por parte de los clientes que se autentifican correctamente en ella. Cuando haya finalizado, arriba a la derecha aparecerá un mensaje que indica _handshake_ capturado.\n\n## aireplay-ng\nSirve para acelerar este proceso que puede demorar horas/días. Acceder a otra shell. Si se trata de una red con encriptación WEP, basta usar `aireplay-ng -1 0 -a $APbssid wlan0mon` y `aireplay-ng -3 -b $APbssid wlan0mon`. Si se trata de una WPA 1 o 2, `aireplay-ng -0 3 -a $APbssid -c $clientMAC wlan0mon`. Lo que hacen estos porgramas y parámetros es enviar señales para desconectar los clientes. En el ultimo caso, hay que indicar específicamente la MAC del cliente que podemos ver conectado a dicha red (aparece en el listado de _airodump-ng_)\n\n## WPS\nDe haber encontrado un router con WPS encendido lo primero que diría es que no sea una impresora, pero asumo que ya lo han chequeado, asique `reaver -i wlan0mon -b $APbssid -vv`.\n\n\n# 3: aircrack-ng\nAcá varía según que método de encriptación use nuestra red _target_. En estos comandos vuelvo a usar la nomenclatura de _$variables_ que ya deberían haber entendido del paso anterior. Pero se suma el diccionario para los casos de encriptación más fuerte (WPA).\n### WEP\n`aircrack-ng $file.cap`\n### WPA 1 y 2\n`aircrack-ng -w $diccionario.txt $file.cap`\n\nEl punto del diccionario es toda una historia aparte. Por mi parte me ha resultado provechoso entender que las compañias (_ISP_) utilizan un formato para las claves, que puede ser algo así como `nombreCompañia-#` con algún numero variable de dígitos. Para conocer estos patrones basta mirar un rato alguno de sos **mapas de WiFi** que proporcionan las aplicaciones de _Play Store_. Algunas incluso no usan números al azar sino que utilizan el ID nacional del dueño de la red, con lo cual se identifica un patrón o se acota desde qué nro. hasta cuál ir dentro de esas _N_ cifras. Normalmente me han resultado diccionarios de 10-30 mb que en una laptop moderna se consume en ~20 minutos. Para generar los diccionarios alcanza con un _loop_ en tu lenguaje de programación de preferencia y no voy a decir cómo porque son una decena de carácteres que a cualquier ser humano alfabetizado informáticamente debería resultarle obvio. Learn to code.\n\n## [REPOST DE MI BLOG](http://127.0.0.1:43110/17TKQQZw9UatwxxwmUo2TVe1aEdWMmknwp/)",
			"added": 1469235124
		}
	],
	"topic_vote": {},
	"next_comment_id": 3,
	"comment": {
		"2_1HK5C3Uf8zvbbSb92ZP6EsfHKC59MXDcK9": [
			{
				"comment_id": 1,
				"body": "Well, it's not a big deal. I mean, of course you can see all my comments, blog posts, etc. That's why I wrote them in the first place... right? Anyway, I find it amusing that you call \"hacking\" looking for a string with grep :P",
				"added": 1468978778
			}
		],
		"1_18PjrZ3wRnWFAF5MQzb19YoRFZ5Zkw8CAy": [
			{
				"comment_id": 2,
				"body": "I want them!",
				"added": 1468978903
			}
		]
	},
	"comment_vote": {}
}